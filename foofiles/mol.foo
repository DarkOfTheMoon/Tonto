!-------------------------------------------------------------------------------
!
! MOL: An object representation of a molecule.
!
! $Id$
!-------------------------------------------------------------------------------
module MOL

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL

   use IVEC
   use VEC
   use MAT
   use MAT3, ONLY:create_,destroy_
   use MAT4, ONLY:create_,destroy_

   use CVEC
   use CMAT
   use CMAT3, ONLY:create_,destroy_
   use CMAT4, ONLY:create_,destroy_
   use CMAT5, ONLY:create_,destroy_

   use OPVEC
   use OPMAT

   use TEXTFILE
   use ARCHIVE

   use VECDIIS

   use SHELL
   use SHELL1
   use SHELL2
   use SHELL4
   use SHELLVEC
   use BASIS
   use BASISVEC
   use ATOM
   use ATOMVEC

   use POINTGROUP
   use CRYSTAL

   use PLOTGRID
   use DFTGRID
   use SCFDATA

   implicit none

#  include "macros"
#  include "mol.int"

!   type mol_type
!
!   STR :: name
!   ! Name of molecule
!
!   INT :: charge
!   ! Electric charge of the molecule
!
!   INT :: mult
!   ! Spin multiplicity of the molecule
!
!   VEC(3) :: E_field
!   ! Applied electric field in atomic units
!
!   VEC(3) :: B_field
!   ! Applied magnetic field in atomic units
!
!   VEC(3) :: gauge_origin
!   ! Global gauge origin for magnetic field
!
!   ATOMVEC* :: atom
!   ! List of atoms in molecule
!
!   BASISVEC* :: basis
!   ! List of basis sets used
!
!   PLOTGRID* :: grid
!   ! Rectangular grid data, for plots
!
!   DFTGRID* :: dftgrid
!   ! DFT integration grid data
!
!   CRYSTAL* :: crystal
!   ! Crystal data for the enclosing crystal
!
!   POINTGROUP* :: pointgroup
!   ! Pointgroup symmetry of the molecule
!
!   INT :: n_e
!   ! No of electrons
!
!   INT :: n_a
!   ! No of alpha electrons
!
!   INT :: n_b
!   ! No of beta electrons
!
!   INT :: n_atom
!   ! No of atoms
!
!   INT :: n_atom_kind
!   ! No of atoms of a different kind
!
!   INT :: n_basis
!   ! No of basis sets
!
!   INT :: n_shell
!   ! Total number of shells in the molecular basis set
!
!   INT :: n_shell_pairs
!   ! Total number of shell pairs in the molecular basis set
!
!   INT :: n_bf
!   ! Total number of basis functions in the molecular basis set
!
!   INT :: n_prim
!   ! Total number of primitives in the molecular basis set
!
!   IVEC* :: atom_for_shell
!   ! Atom index for molecular shell index array
!
!   IVEC* :: atom_shell_for_shell
!   ! Atom shell index for molecular shell index array
!
!   IVEC* :: first_shell_for_atom
!   ! First molecule shell index for an atom
!
!   IVEC* :: first_basis_fn_for_shell
!   ! First basis function for a given shell
!
!   IVEC* :: last_basis_fn_for_shell
!   ! Last basis function for a given shell
!
!   IVEC* :: atom_kind
!   ! The unique kind of each atom in .atom
!
!   IVEC* :: unique_atom
!   ! List of the unique atoms (of different kind)
!
!   IVEC* :: first_basis_fn_for_atom
!   ! For the atom basis function limits
!
!   IVEC* :: last_basis_fn_for_atom
!   ! For the atom basis function limits
!
!   SCFDATA* :: scfdata
!   ! SCF data object
!
!   OPVEC* :: orbital_energies
!   ! The orbital energies
!
!   OPMAT* :: molecular_orbitals
!   ! The (real) molecular orbitals
!
!   OPMAT* :: density_matrix
!   ! The real density matrix
!
!   OPMAT* :: natural_orbitals
!   ! The natural orbitals
!
!   OPVEC* :: occupation
!   ! The associated occupation numbers
!
!   OPMAT* :: fock_matrix
!   ! The real fock matrix
!
!   MAT4VEC* :: ab_ab_ERI
!   ! The two electron integrals of the form ab|ab
!
!   BIN :: optimise_thermals
!   ! Whether to optimise the thermal parameters
!
!   end

   MOL* :: saved_self

contains

!  **************************
!  Create and destroy methods
!  **************************

   create
   ! Create a molecule object
      PTR :: self
      allocate(self)
      .nullify_ptr_part
      .set_defaults
      ADD_MEM(MOL_SIZE)
   end

   destroy
   ! Destroy a molecule object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      deallocate(self)
      DELETE_MEM(MOL_SIZE)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the molecule
      nullify(.crystal)
      nullify(.pointgroup)
      nullify(.atom)
      nullify(.basis)
      nullify(.grid)
      nullify(.dftgrid)
      nullify(.atom_for_shell)
      nullify(.atom_shell_for_shell)
      nullify(.first_shell_for_atom)
      nullify(.first_basis_fn_for_shell)
      nullify(.last_basis_fn_for_shell)
      nullify(.first_basis_fn_for_atom)
      nullify(.last_basis_fn_for_atom)
      nullify(.atom_kind)
      nullify(.unique_atom)
      nullify(.scfdata)
      nullify(.orbital_energies)
      nullify(.molecular_orbitals)
      nullify(.density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation)
      nullify(.fock_matrix)
      nullify(.atom_group)
      nullify(.ab_ab_ERI)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of a molecule object
      .crystal.destroy
      .pointgroup.destroy
      if (.atom.created) .atom.nullify_basis_part ! nullify this !
      .atom.destroy
      .basis.destroy
      .grid.destroy
      .dftgrid.destroy
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .atom_kind.destroy
      .unique_atom.destroy
      .scfdata.destroy
      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation.destroy
      .fock_matrix.destroy
      .atom_group.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has not been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_defaults [leaky]
   ! Set up a default molecule
      .E_field = ZERO
      .B_field = ZERO
      .gauge_origin = ZERO
      .charge = 0
      .mult = 1
      .optimise_thermals = FALSE
      if (.atom.created) then
        .mult = .atom.default_multiplicity
        .set_atom_info
      end
   end

   set_atom_info [leaky]
   ! Set the associated atom information
      .n_atom = .no_of_atoms
      .n_e = .no_of_electrons
      .n_a = .no_of_alpha_electrons
      .n_b = .no_of_beta_electrons
      .atom_kind.create(.n_atom)
      .atom.make_atom_kind_list(.atom_kind,.n_atom_kind)
      .unique_atom.create(.n_atom_kind)
      .atom.make_unique_atom_list(.unique_atom)
   end

   resolve_basis_labels [leaky]
   ! Match the basis set labels for every atom with the actual atomic basis set.
   ! Also perform any initialization procedures to finalise all data objects
      if (.basis.destroyed) return
      if (.atom.destroyed) return
      if (NOT .atom.bases_are_all_labeled) return
      .atom.resolve_basis_labels(.basis)
      .n_basis = .no_of_basis_sets
      .set_basis_info
    ! .delete_scf_integrals
   end

   resolve_axis_system
   ! Change the axis system to crystal coordinates, if required.
      if (.crystal.destroyed) return
      if (.atom.destroyed) return
      .atom.resolve_axis_system(.crystal)
   end

   set_basis_info [leaky]
   ! Set the associated basis set information
      .n_basis = .no_of_basis_sets
      .n_bf = .atom.n_bf
      .n_prim = .atom.n_prim
      .n_shell = .atom.n_shell
      .n_shell_pairs = .no_of_shell_pairs
      .molecular_orbitals.create(.n_bf)
      .orbital_energies.create(.n_bf)
      .density_matrix.create(.n_bf)
      .natural_orbitals.create(.n_bf)
      .occupation.create(.n_bf)
      .fock_matrix.create(.n_bf)
      .make_shell_info
   end

   delete_scf_integrals
   ! Delete all integral files. This is required whenever the geometry is
   ! changed.
      ARCHIVE :: archive
      archive.set(.name,"overlap_matrix"); archive.delete
      archive.set(.name,"kinetic_matrix"); archive.delete
      archive.set(.name,"nuclear_matrix"); archive.delete
      archive.set(.name,"core_matrix");    archive.delete
      archive.set(.name,"fock_matrix");    archive.delete
      archive.set(.name,"eri_integrals");  archive.delete
      archive.set(.name,"eri_index");      archive.delete
      archive.set(.name,"ft_ints");        archive.delete
   end

   assign_natural_orbitals [leaky]
   ! Assign the natural orbitals to be the molecular_orbitals
      STR :: kind
      .natural_orbitals.destroy
      .natural_orbitals.create_copy(.molecular_orbitals)
      kind = .natural_orbitals.spinorbital_kind
      .occupation.create(kind)
      .occupation.zero
      .set_scf_occupations(kind)
   end

   assign_MOs_to_NOs [leaky]
   ! Assign the MOs to be the same as the natural orbitals
      STR :: kind
      .molecular_orbitals.destroy
      .molecular_orbitals.create_copy(.natural_orbitals)
      kind = .natural_orbitals.spinorbital_kind
      .occupation.create(kind)
      .occupation.zero
      .set_scf_occupations(kind)
   end

   set_scf_occupations(kind)
   ! Set the SCF occupation numbers for the natural orbitals
      STR :: kind
      select case (kind)
         case ("restricted")
            .occupation.restricted(1:.n_a) = TWO
         case ("unrestricted")
            .occupation.alpha(1:.n_a) = ONE
            .occupation.beta(1:.n_b) = ONE
         case ("general")
            .occupation.general(1:.n_e) = ONE
         case ("restricted_complex")
            .occupation.restricted(1:.n_a) = TWO
         case ("unrestricted_complex")
            .occupation.alpha(1:.n_a) = ONE
            .occupation.beta(1:.n_b) = ONE
         case ("general_complex")
            .occupation.general(1:.n_e) = ONE
      end
   end

!!  ***************************
!!  ATOMVEC information methods
!!  ***************************
!
!   nuclear_energy result(res)
!   ! Return the nuclear repulsion energy
!      DBL :: res
!      ENSURE(.atom.created,"atom list required")
!      res = .atom.nuclear_energy
!   end
!
!   chemical_formula result(res)
!   ! Return the chemical formula for the molecule, as a string, in alphabetical
!   ! order of elements
!      STR :: res
!      ENSURE(.atom.created,"atom list required")
!      res = .atom.chemical_formula
!   end
!
!   centre_of_mass result(centre)
!   ! Return the centre of mass
!      VEC(3) :: centre
!      ENSURE(.atom.created,"atom list required")
!      centre = .atom.centre_of_mass
!   end
!
!   move_origin_to_centre_of_mass
!   ! Move the origin to the centre of mass
!      VEC(3) :: com
!      INT :: a
!      ENSURE(.atom.created,"atom list required")
!      com = .atom.centre_of_mass
!      .atom.translate(-com)
!   end
!
!   molecular_weight result(res)
!   ! Return the molceular weight
!      DBL:: res
!      ENSURE(.atom.created,"atom list required")
!      res = .atom.molecular_weight
!   end
!
!   reduced_mass result(res)
!   ! Return the reduced mass
!      DBL:: res
!      ENSURE(.atom.created,"atom list required")
!      res = .atom.reduced_mass
!   end
!
!   centre_of_atoms result(centre)
!   ! Return the centroid of the atom positions
!      VEC(3) :: centre
!      ENSURE(.atom.created,"atom list required")
!      centre = .atom.centre_of_atoms
!   end
!
!   atom_index_from_pos(pos) result(res)
!   ! Return the index of atom from its position "pos"
!      VEC(3) :: pos
!      INT :: res
!      ENSURE(.atom.created,"atom list required")
!      res = .atom.atom_index_from_pos(pos)
!   end
!
!   get_geometry(g)
!   ! Return the geometry "g" in a matrix
!      MAT :: g
!      ENSURE(.atom.created,"no atom list")
!      .atom.get_geometry(g)
!   end
!
   get_crystal_geometry(g)
   ! Return the crystal (fractional coordinate) geometry "g" in a matrix
      MAT :: g
      INT :: n
      .atom.get_geometry(g)
      if (size(g,1)==3) then
         do n = 1,.n_atom
            .crystal.inverse_cell_matrix.rotate(g(:,n))
         end
      else if (size(g,2)==3) then
         do n = 1,.n_atom
            .crystal.inverse_cell_matrix.rotate(g(n,:))
         end
      end
   end

!  ********************************
!  ATOMVEC shell extraction methods
!  ********************************

   get_shell(shell,index) [leaky]
   ! Get basis set "shell" corresponding to "index"
      INT, IN :: index
      SHELL, OUT :: shell
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy(.atom(aa).basis.shell(sa) )
   end

   get_shell(shell,index) [leaky]
   ! Update the shell1 "shell".
      INT, IN :: index
      SHELL1, OUT :: shell
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy(shell=.atom(aa).basis.shell(sa),pos=.atom(aa).pos)
   end

   get_shell(shell,index,fa,la) [leaky]
   ! Update the shell1 "shell".
      INT, IN :: index
      SHELL1, OUT :: shell
      INT, OUT :: fa,la
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)
      shell.copy(shell=.atom(aa).basis.shell(sa),pos=.atom(aa).pos)
   end

   get_shell_pair_indices(index,a,b)
   ! Return the actual shell indicies "a" and "b" which map to "index"
     INT, IN :: index
     INT, OUT :: a,b
     a  = (1+sqrt(8.0d0*index-7.0d0))/2
     b  = index - a*(a-1)/2
   end

   get_shell_pair_indices(index,a,b,fa,la,fb,lb)
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      INT, OUT :: a,b,fa,la,fb,lb
      a  = (1+sqrt(8.0d0*index-7.0d0))/2
      b  = index - a*(a-1)/2
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end

   get_shell_pair(shell,index,a,b) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: a,b
      INT :: aa,sa,bb,sb
      a  = (1+sqrt(8.0d0*index-7.0d0))/2
      b  = index - a*(a-1)/2
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(aa).pos, .atom(bb).pos )
   end

   get_shell_pair(shell,index,fa,la,fb,lb) [leaky]
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: fa,la,fb,lb
      INT :: a,b,aa,sa,bb,sb
      a  = (1+sqrt(8.0d0*index-7.0d0))/2
      b  = index - a*(a-1)/2
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(aa).pos, .atom(bb).pos )
   end

   get_shell_pair(shell,index,a,b,fa,la,fb,lb) [leaky]
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: a,b,fa,la,fb,lb
      INT :: aa,sa,bb,sb
      a  = (1+sqrt(8.0d0*index-7.0d0))/2
      b  = index - a*(a-1)/2
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(aa).pos, .atom(bb).pos )
   end

   get_shell_pair(shell,index,a,b,fa,la,fb,lb,atom_a,atom_b) [leaky]
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Plus the atoms the shells are located on, "atom_a" and "atom_b".
     INT, IN :: index
     SHELL2, OUT :: shell
     INT, OUT :: a,b,fa,la,fb,lb,atom_a,atom_b
     INT :: sa,sb
     a  = (1+sqrt(8.0d0*index-7.0d0))/2
     b  = index - a*(a-1)/2
     fa = .first_basis_fn_for_shell(a)
     fb = .first_basis_fn_for_shell(b)
     la = .last_basis_fn_for_shell(a)
     lb = .last_basis_fn_for_shell(b)
     atom_a = .atom_for_shell(a)
     atom_b = .atom_for_shell(b)
     sa = .atom_shell_for_shell(a)
     sb = .atom_shell_for_shell(b)
     shell.copy(.atom(atom_a).basis.shell(sa), .atom(atom_b).basis.shell(sb), &
                 .atom(atom_a).pos, .atom(atom_b).pos )
   end

   get_shell_quartet_indices(index,a,b,c,d)
   ! Get the indexes a,b,c,d of the quartet from the "index".
   ! Note that "index" will die at 361 shells for integer(4).
     INT, IN :: index
     INT, OUT :: a,b,c,d
     INT :: ab,cd
     ab = (1+sqrt(8.0d0*index-7.0d0))/2
     cd = index - ab*(ab-1)/2
     a  = (1+sqrt(8.0d0*ab-7.0d0))/2
     b  = ab - a*(a-1)/2
     c  = (1+sqrt(8.0d0*cd-7.0d0))/2
     d  = cd - c*(c-1)/2
   end

   get_shell_quartet_indices(index,fa,la,fb,lb,fc,lc,fd,ld) [leaky]
   ! For the quartet index "index" return the shell indicies "a", "b",
   ! "c" and "d" which map to "index". Also return the basis function
   ! start indices "fa", "la", etc ...
      INT, IN :: index
      INT, OUT :: fa,la,fb,lb,fc,lc,fd,ld
      INT :: a,b,c,d
      INT :: ab,cd
      ab = (1+sqrt(8.0d0*index-7.0d0))/2
      cd = index - ab*(ab-1)/2
      a  = (1+sqrt(8.0d0*ab-7.0d0))/2
      b  = ab - a*(a-1)/2
      c  = (1+sqrt(8.0d0*cd-7.0d0))/2
      d  = cd - c*(c-1)/2
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)
   end

   get_shell_quartet_indexes(index,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
   ! For the quartet index "index" return the shell indicies "a", "b", "c" and
   ! "d" which map to "index" and the corresponding atom centers. Note different
   ! spelling for this routine and the one above to avoid overload problems.
      INT, IN :: index
      INT, OUT :: a,b,c,d,atom_a,atom_b,atom_c,atom_d
      INT :: ab,cd
      ab = (1+sqrt(8.0d0*index-7.0d0))/2
      cd = index - ab*(ab-1)/2
      a  = (1+sqrt(8.0d0*ab-7.0d0))/2
      b  = ab - a*(a-1)/2
      c  = (1+sqrt(8.0d0*cd-7.0d0))/2
      d  = cd - c*(c-1)/2
      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
      atom_c = .atom_for_shell(c)
      atom_d = .atom_for_shell(d)
   end

   get_shell_quartet(shell,a,b,c,d) [leaky]
   ! Get the SHELL4 object "shell" correponding to the indicies "a", "b", "c"
   ! and "d".
      SHELL4, OUT :: shell
      INT, IN :: a,b,c,d
      INT :: aa,sa,bb,sb,cc,sc,dd,sd
      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                  .atom(aa).pos, .atom(bb).pos, .atom(cc).pos, .atom(dd).pos )
   end

   get_shell_quartet(shell,index,a,b,c,d) [leaky]
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d
      INT :: ab,cd,aa,sa,bb,sb,cc,sc,dd,sd
      ab = (1+sqrt(8.0d0*index-7.0d0))/2
      cd = index - ab*(ab-1)/2
      a  = (1+sqrt(8.0d0*ab-7.0d0))/2
      b  = ab - a*(a-1)/2
      c  = (1+sqrt(8.0d0*cd-7.0d0))/2
      d  = cd - c*(c-1)/2
      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                  .atom(aa).pos, .atom(bb).pos, .atom(cc).pos, .atom(dd).pos )
   end

   get_shell_quartet(shell,index,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld) [leaky]
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld
      INT :: ab,cd,aa,sa,bb,sb,cc,sc,dd,sd
      ab = (1+sqrt(8.0d0*index-7.0d0))/2
      cd = index - ab*(ab-1)/2
      a  = (1+sqrt(8.0d0*ab-7.0d0))/2
      b  = ab - a*(a-1)/2
      c  = (1+sqrt(8.0d0*cd-7.0d0))/2
      d  = cd - c*(c-1)/2
      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                  .atom(aa).pos, .atom(bb).pos, .atom(cc).pos, .atom(dd).pos )
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)
   end

   get_shell_quartet(shell,index,a,b,c,d,atom_a,atom_b,atom_c,atom_d) [leaky]
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Plus the atoms which the shells are on.
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d,atom_a,atom_b,atom_c,atom_d
      INT :: ab,cd,sa,sb,sc,sd
      ab = (1+sqrt(8.0d0*index-7.0d0))/2
      cd = index - ab*(ab-1)/2
      a  = (1+sqrt(8.0d0*ab-7.0d0))/2
      b  = ab - a*(a-1)/2
      c  = (1+sqrt(8.0d0*cd-7.0d0))/2
      d  = cd - c*(c-1)/2
      atom_a = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      atom_b = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      atom_c = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      atom_d = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy(.atom(atom_a).basis.shell(sa), .atom(atom_b).basis.shell(sb), &
                 .atom(atom_c).basis.shell(sc), .atom(atom_d).basis.shell(sd), &
                 .atom(atom_a).pos, .atom(atom_b).pos, &
                 .atom(atom_c).pos, .atom(atom_d).pos )
   end

   set_shell_quartet_ab(shell,a,b) [leaky]
   ! Set the a and b parts of the "shell" SHELL4 object.
     SHELL4, INOUT :: shell
     INT, IN :: a,b
     INT :: aa,sa,bb,sb
     aa = .atom_for_shell(a)
     sa = .atom_shell_for_shell(a)
     bb = .atom_for_shell(b)
     sb = .atom_shell_for_shell(b)
     shell.copy_ab(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(aa).pos, .atom(bb).pos)
   end

   set_shell_quartet_cd(shell,c,d) [leaky]
   ! Set the c and d parts of the "shell" SHELL4 object.
     SHELL4, INOUT :: shell
     INT, IN :: c,d
     INT :: cc,sc,dd,sd
     cc = .atom_for_shell(c)
     sc = .atom_shell_for_shell(c)
     dd = .atom_for_shell(d)
     sd = .atom_shell_for_shell(d)
     shell.copy_cd(.atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(cc).pos, .atom(dd).pos)
   end

   make_contraction_matrix(cc_mat)
   ! Returns the matrix of complete contraction coefficients for each basis set
   ! Size of cc_mat is [.n_prim,.n_bf].
      MAT, OUT :: cc_mat
      INT :: a, bf_count, prim_count,a_prim,a_bf
      STR :: error_string
      error_string = "contraction matrix has incorrect shape"
      ENSURE(size(cc_mat,1)== .n_prim,error_string)
      ENSURE(size(cc_mat,2)== .n_bf,error_string)
      bf_count = 1
      prim_count = 1
      cc_mat = ZERO
      do a = 1, .n_atom
         a_prim = .atom(a).basis.n_prim
         a_bf = .atom(a).basis.n_bf
         cc_mat(prim_count : prim_count + a_prim - 1, bf_count : bf_count + a_bf - 1) &
                  = .atom(a).basis.contraction_matrix
         prim_count = prim_count + a_prim
         bf_count = bf_count + a_bf
      end
   end


!  **********************
!  Make shell information
!  **********************

   make_shell_info [leaky]
   ! Define a vector of atom numbers corresponding to the molecule
   ! basis set shell numbers; also define a vector of atom shell numbers
   ! corresponding to the molecule basis set shell number
     .atom_for_shell       => .atom.atom_for_shell
     .atom_shell_for_shell => .atom.atom_shell_for_shell
     .first_shell_for_atom => .atom.first_shell_for_atom
     .atom.get_shell_limits(.first_basis_fn_for_shell, .last_basis_fn_for_shell)
     .atom.make_atom_basis_fn_limits(.first_basis_fn_for_atom,.last_basis_fn_for_atom)
   end

!  **********************
!  Density matrix methods
!  **********************

  make_scf_density_matrix(damp,scf_kind) [leaky]
  ! Make the density matrix from the molecular orbitals. If "damp" is present
  ! use it to damp the updated density matrix.
    BIN, optional :: damp
    STR(*), optional :: scf_kind
    BIN :: damping
    OPMAT* :: D_old
    MAT* :: MO,D,MOa,MOb,Da,Db
    CMAT* :: CMO,CD,CMOa,CMOb,CDa,CDb
    ARCHIVE :: archive
    STR :: kind
    DBL :: mix
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    ENSURE(.molecular_orbitals.created, "no molecular orbitals")
    if (.scfdata.destroyed) then;                 damping = FALSE
    else if (.density_matrix.all_destroyed) then; damping = FALSE
    else
      damping = .scfdata.apply_damping
      if (present(damp)) damping = damp
    end
    if (damping) D_old.create_copy(.density_matrix)
    if (.scfdata.destroyed) then; kind = .molecular_orbitals.spinorbital_kind
    else;                          kind = .scfdata.spinorbital_kind
    end
    .density_matrix.destroy(kind)
    .density_matrix.create(kind)
    archive.set(.name,"density_matrix",kind)
    if (present(scf_kind)) then;        kind = scf_kind
    else if (.scfdata.destroyed) then; kind = .molecular_orbitals.guess_scf_kind
    else;                               kind = .scfdata.kind
    end
    select case (kind)
      case ("rhf","restricted_hartree_fock", &
            "xray_rhf","xray_constrained","xray_rks")
        ENSURE(.molecular_orbitals.created("restricted"), "no molecular orbitals")
        DIE_IF(.mult/=1,"this is not a singlet state")
        MO => .molecular_orbitals.restricted(:,1:.n_a)
        D  => .density_matrix.restricted
        D.to_scaled_product(TWO,MO,MO,transpose_b=TRUE)
      case ("rohf","restricted_open_shell_hartree_fock")
        ENSURE(.molecular_orbitals.created("restricted"), "no molecular orbitals")
        MOa => .molecular_orbitals.restricted(:,1:.n_a)
        MOb => .molecular_orbitals.restricted(:,1:.n_b)
        Da => .density_matrix.alpha
        Db => .density_matrix.beta
        Da.to_product(MOa,MOa,transpose_b=TRUE)
        Db.to_product(MOb,MOb,transpose_b=TRUE)
      case ("uhf","unrestricted_hartree_fock")
        ENSURE(.molecular_orbitals.created("unrestricted"), "no molecular orbitals")
        MOa => .molecular_orbitals.alpha(:,1:.n_a)
        MOb => .molecular_orbitals.beta(:,1:.n_b)
        Da => .density_matrix.alpha
        Db => .density_matrix.beta
        Da.to_product(MOa,MOa,transpose_b=TRUE)
        Db.to_product(MOb,MOb,transpose_b=TRUE)
      case ("ghf","general_hartree_fock")
        ENSURE(.molecular_orbitals.created("general"), "no molecular orbitals")
        DIE_IF(.mult/=1,"this is not a singlet state")
        MO => .molecular_orbitals.general(:,1:.n_e)
        D =>  .density_matrix.general
        D.to_product(MO,MO,transpose_b=TRUE)
      case ("rchf","restricted_complex_hartree_fock")
        ENSURE(.molecular_orbitals.created("restricted_complex"), "no molecular orbitals")
        CMO => .molecular_orbitals.restricted_complex(:,1:.n_a)
        CD  => .density_matrix.restricted_complex
        CD.to_product(CMO,CMO,dagger_b=TRUE)
        CD = TWO*CD
      case ("uchf","unrestricted_complex_hartree_fock")
        ENSURE(.molecular_orbitals.created("unrestricted_complex"), "no molecular orbitals")
        CMOa => .molecular_orbitals.alpha_complex(:,1:.n_a)
        CMOb => .molecular_orbitals.beta_complex(:,1:.n_b)
        CDa => .density_matrix.alpha_complex
        CDb => .density_matrix.beta_complex
        CDa.to_product(CMOa,CMOa,dagger_b=TRUE)
        CDb.to_product(CMOb,CMOb,dagger_b=TRUE)
      case ("gchf","general_complex_hartree_fock")
        ENSURE(.molecular_orbitals.created("general_complex"), "no molecular orbitals")
        CMO => .molecular_orbitals.general_complex(:,1:.n_e)
        CD =>  .density_matrix.general_complex
        CD.to_product(CMO,CMO,dagger_b=TRUE)
    end
    if (damping) then
      mix = .scfdata.damp_factor
      select case (kind)
        case ("rhf","restricted_hartree_fock","xray_rhf","xray_rks")
          D = (1-mix)*D + mix*D_old.restricted
        case ("rohf","restricted_open_shell_hartree_fock")
          Da = (1-mix)*Da + mix*D_old.alpha
          Db = (1-mix)*Db + mix*D_old.beta
        case ("uhf","unrestricted_hartree_fock")
          Da = (1-mix)*Da + mix*D_old.alpha
          Db = (1-mix)*Db + mix*D_old.beta
        case ("ghf","general_hartree_fock")
          D = (1-mix)*D + mix*D_old.general
        case ("rchf","restricted_complex_hartree_fock")
          CD = (1-mix)*CD + mix*D_old.restricted_complex
        case ("uchf","unrestricted_complex_hartree_fock")
          CDa = (1-mix)*CDa + mix*D_old.alpha_complex
          CDb = (1-mix)*CDb + mix*D_old.beta_complex
        case ("gchf","general_complex_hartree_fock")
          CD = (1-mix)*CD + mix*D_old.general_complex
      end
      D_old.destroy
    end
    archive.write(.density_matrix)
  end

   make_ao_density_matrix [leaky]
   ! Make the AO (spin independent) density matrix from the existing density
   ! matrix.
   ! The result is placed in the "restricted" part of the density matrix
      STR :: kind
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      ENSURE(.density_matrix.created, "no density matrix")
      ENSURE(.density_matrix.any_created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if (kind=="restricted") return
      if (kind=="restricted_complex") return
      if (kind.includes("complex")) then
         .density_matrix.destroy("restricted_complex")
         .density_matrix.create("restricted_complex")
      else
         .density_matrix.destroy("restricted")
         .density_matrix.create("restricted")
      end
      select case (kind)
         case ("unrestricted")
            .density_matrix.restricted = .density_matrix.alpha + .density_matrix.beta
         case ("general")
            .density_matrix.restricted = .density_matrix.general.alpha_alpha &
                                       + .density_matrix.general.beta_beta
         case ("unrestricted_complex")
            .density_matrix.restricted_complex = .density_matrix.alpha_complex &
                                               + .density_matrix.beta_complex
         case ("general_complex")
            .density_matrix.restricted_complex = .density_matrix.general_complex.alpha_alpha &
                                               + .density_matrix.general_complex.beta_beta
         case default; DIE("unknown spinorbital kind, " // trim(kind))
      end
   end

   make_ao_sz_density_matrix
   ! Make the AO (spin independent) density matrix from the existing density
   ! matrix.
   ! The result is placed in the "restricted" part of the density matrix
      STR :: kind
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      ENSURE(.density_matrix.created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if (kind=="restricted") return
      if (kind.includes("complex")) then
         .density_matrix.destroy("restricted_complex")
         .density_matrix.create("restricted_complex")
      else
         .density_matrix.destroy("restricted")
         .density_matrix.create("restricted")
      end
      select case (kind)
         case ("unrestricted")
            .density_matrix.restricted = .density_matrix.alpha - .density_matrix.beta
         case ("general")
            .density_matrix.restricted = .density_matrix.general.alpha_alpha &
                                       - .density_matrix.general.beta_beta
         case ("unrestricted_complex")
            .density_matrix.restricted_complex = .density_matrix.alpha_complex &
                                               - .density_matrix.beta_complex
         case ("general_complex")
            .density_matrix.restricted_complex = .density_matrix.general_complex.alpha_alpha &
                                               - .density_matrix.general_complex.beta_beta
         case default; DIE("unknown spinorbital kind, " // trim(kind))
      end
   end

   make_scf_density_matrix(n,nb)
   ! Make the density matrix from orbital "n" of the molecular orbitals.
   ! If present, orbital "nb" of the beta molecular orbitals is used.
   ! If either index is not an occupied MO, the density is set to zero.
      INT :: n
      INT, optional :: nb
      MAT* :: MO,D,MOa,MOb,Da,Db
      CMAT* :: CMO,CD,CMOa,CMOb,CDa,CDb
      STR :: kind
      ARCHIVE :: archive
      INT :: m
      BIN :: uhf
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      ENSURE(.molecular_orbitals.created, "no molecular orbitals")
      uhf = .scfdata.kind.includes("unrestricted")
      WARN_IF(present(nb) AND (NOT uhf), "nb ignored")
      m = n
      if (present(nb)) m = nb
      kind = .scfdata.spinorbital_kind
      .density_matrix.destroy(kind)
      .density_matrix.create(kind)
      archive.set(.name,"density_matrix",kind)
      kind = .scfdata.kind
      select case (kind)
         case ("rhf","restricted_hartree_fock","xray_rhf","xray_rks")
            DIE_IF(.mult/=1,"this is not a singlet state")
            D  => .density_matrix.restricted
            if (n>0 AND n<=.n_a) then
               MO => .molecular_orbitals.restricted(:,n:n)
               D.to_scaled_product(TWO,MO,MO,transpose_b=TRUE)
            else
               D = ZERO
            end
         case ("rohf","restricted_open_shell_hartree_fock")
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            if (n>0 AND n<=.n_b) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               MOb => .molecular_orbitals.restricted(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
               Db.to_product(MOb,MOb,transpose_b=TRUE)
            else if (n>nb AND n<=.n_a) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
               Db = ZERO
            else
               Da = ZERO
               Db = ZERO
            end
         case ("uhf","unrestricted_hartree_fock")
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            if (n>0 AND n<=.n_a) then
               MOa => .molecular_orbitals.alpha(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
            else
               Da = ZERO
            end
            if (m>0 AND m<=.n_b) then
               MOb => .molecular_orbitals.beta(:,m:m)
               Db.to_product(MOb,MOb,transpose_b=TRUE)
            else
               Db = ZERO
            end
         case ("ghf","general_hartree_fock")
            DIE_IF(.mult/=1,"this is not a singlet state")
            D =>  .density_matrix.general
            if (n>0 AND n<=.n_e) then
               MO => .molecular_orbitals.general(:,n:n)
               D.to_product(MO,MO,transpose_b=TRUE)
            else
               D = ZERO
            end
         case ("rchf","restricted_complex_hartree_fock")
            CD  => .density_matrix.restricted_complex
            if (n>0 AND n<=.n_a) then
               CMO => .molecular_orbitals.restricted_complex(:,n:n)
               CD.to_scaled_product(TWO,CMO,CMO,dagger_b=TRUE)
            else
               CD = ZERO
            end
         case ("uchf","unrestricted_complex_hartree_fock")
            CDa => .density_matrix.alpha_complex
            CDb => .density_matrix.beta_complex
            if (n>0 AND n<=.n_a) then
               CMOa => .molecular_orbitals.alpha_complex(:,n:n)
               CDa.to_product(CMOa,CMOa,dagger_b=TRUE)
            else
               CDa = ZERO
            end
            if (m>0 AND m<=.n_b) then
               CMOb => .molecular_orbitals.beta_complex(:,m:m)
               CDb.to_product(CMOb,CMOb,dagger_b=TRUE)
            else
               CDb = ZERO
            end
         case ("gchf","general_complex_hartree_fock")
            CD =>  .density_matrix.general_complex
            if (n>0 AND n<=.n_e) then
               CMO => .molecular_orbitals.general_complex(:,n:n)
               CD.to_product(CMO,CMO,dagger_b=TRUE)
            else
               CD = ZERO
            end
      end
      archive.write(.density_matrix)
   end


!****************************
!* Overlap Matrix formation *
!****************************


  get_overlap_matrix(S)
  ! Set "S" to the overlap matrix.
  ! If the archive file exists, read it; otherwise make it.
     MAT :: S
     ARCHIVE :: archive
     archive.set(.name,"overlap_matrix")
     if (archive.exists) then; archive.read(S)
     else;                      .make_overlap_matrix(S)
     end
  end

  make_overlap_matrix(S)
  ! Calculate the overlap matrix "S"
    MAT, target :: S
    INT :: q,fa,la,fb,lb
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    S = ZERO
    do q=1,.n_shell_pairs
      .get_shell_pair(shell,q,fa,la,fb,lb)
      shell.make_overlap(S(fa:la,fb:lb))
      shell.destroy_ptr_part
    end
    S.symmetric_reflect
    archive.set(.name,"overlap_matrix")
    archive.write(S)
  end

!  ***************
!  Inquiry methods
!  ***************

   no_of_electrons result(res)
   ! Work out and return the number of electrons in the molecule
      INT :: res
      INT :: a
      ENSURE(.atom.created,  "no atom list")
      res = .atom.n_e - .charge
   end

   no_of_alpha_electrons result(res)
   ! Work out and return the number of alpha electrons in the molecule
      INT :: res
      res = (.no_of_electrons+.mult-1)/2
   end

   no_of_beta_electrons result(res)
   ! Work out and return the number of beta electrons in the molecule
      INT :: res
      res = (.no_of_electrons-.mult+1)/2
   end

   no_of_atoms result(res)
   ! Return the number of atoms in the molecule
      INT :: res
      ENSURE(.atom.created,  "no atom list")
      res = size(.atom)
   end

   no_of_basis_sets result(res)
   ! Return the number of distinct atomic basis sets for the molecule
      INT :: res
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      res = size(.basis)
   end

   no_of_shells result(res)
   ! Work out and return the number of gaussian shells in the basis set for the
   ! molecule
      IN :: self
      INT :: res
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      res = .atom.n_shell
   end

   no_of_shell_pairs result(res)
   ! Return the number of shell pairs in the basis set for the molecule
      INT :: res
      INT :: n_shell
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_shell = .no_of_shells
      res = n_shell*(n_shell+1)/2
   end

   n_shell_quartets result (res)
   ! Return the number of shell quartets in the basis set for the molecule
   ! Note, "res" will die at 22 shells for integer(2).
   !       "res" will die at 361 shells for integer(4).
   !       "res" will die at 92681 shells for integer(8).
      INT :: res
      INT :: n_shell_pair
      n_shell_pair = .no_of_shell_pairs
      if (n_shell_pair/sqrt(TWO) <= (huge(n_shell_pair))**HALF) then
         res = n_shell_pair*(n_shell_pair+1)/2
      else
         WARN("too many shells")
         res = 0
      end
   end

!   no_of_basis_functions result (res)
!   ! Work out and return the number of basis functions in the basis set for the
!   ! molecule
!      INT :: res
!      INT :: a
!      ENSURE(.atom.created,  "no atom list")
!      ENSURE(.atom.bases_are_all_resolved, "no basis set")
!      res = .atom.n_bf
!   end
!
!   no_of_primitives result (res)
!   ! Work out and return the number of primitives in the basis set for the
!   ! molecule
!      INT :: res
!      INT :: a
!      ENSURE(.atom.created,  "no atom list")
!      ENSURE(.atom.bases_are_all_resolved, "no basis set")
!      res = .atom.n_prim
!   end

   no_of_occupied_NOs(kind,tol) result (res)
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      STR, optional :: kind
      DBL, optional :: tol
      INT :: res
      STR :: itemkind
      DBL :: eps
      INT :: n,n_bf
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      ENSURE(.occupation.created, "no occupation numbers")
      itemkind = .occupation.spinorbital_kind
      if (present(kind)) itemkind=kind
      eps = TOL(7)
      if (present(tol)) eps = tol
      select case (itemkind)
         case ("restricted")
            n_bf = .occupation.n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation.restricted(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case ("unrestricted")
            n_bf = .occupation.n_bf
            res = 2*n_bf
            do n = 1,n_bf
               if (.occupation.alpha(n)<eps) then
                  res = n-1
                  exit
               end
            end
            do n = 1,n_bf
               if (.occupation.beta(n)<eps) then
                  res = res + n-1
                  exit
               end
            end
         case ("general")
            n_bf = 2*.occupation.n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation.general(n)<eps) then
                  res = n-1
                  exit
               end
            end
      end
   end

!  ****************
!  Natural orbitals
!  ****************

   make_natural_orbitals [leaky]
   ! Make the natural orbitals from the density matrix
     STR :: kind
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      ENSURE(.density_matrix.created, "no density matrix")
      ENSURE(.density_matrix.any_created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if (.natural_orbitals.created) .natural_orbitals.destroy_ptr_part
      select case (kind)
         case ("restricted");         .make_restricted_NOs
         case ("unrestricted");       .make_unrestricted_NOs
!        case ("general");            .make_general_NOs
         case ("restricted_complex"); .make_restricted_complex_NOs
         case ("general_complex");    .make_general_complex_NOs
         case default;                DIE("unknown kind" // trim(kind))
      end
   end

   make_restricted_NOs [leaky]
   ! Make the restricted natural orbitals from the density matrix
      ENSURE(.density_matrix.restricted.created, "no density matrix")
      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"restricted")
      .occupation.destroy
      .occupation.create(.n_bf,"restricted")
      .make_r_NOs(.natural_orbitals.restricted,.occupation.restricted,.density_matrix.restricted)
   end

   make_unrestricted_NOs [leaky]
   ! Make the unrestricted natural orbitals from the density matrix
      ENSURE(.density_matrix.alpha.created, "no density matrix")
      ENSURE(.density_matrix.beta.created, "no density matrix")
      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"unrestricted")
      .occupation.destroy
      .occupation.create(.n_bf,"unrestricted")
      .make_r_NOs(.natural_orbitals.alpha,.occupation.alpha,.density_matrix.alpha)
      .make_r_NOs(.natural_orbitals.beta, .occupation.beta, .density_matrix.beta)
   end

   make_r_NOs(NO,occupation,P)
   ! Make the real natural orbitals "NO" and "occupation" numbers from the
   ! density matrix "P"
      MAT :: NO,P
      VEC :: occupation
      MAT* :: V,X,S
      V.create(.n_bf,.n_bf)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      V.to_sqrt(S)
      S.destroy
      X.create(.n_bf,.n_bf)
      X = P
      X.change_basis(V)
      X.solve_eigenproblem(occupation,V)
      S.create(.n_bf, .n_bf); .get_overlap_matrix(S)
      X.to_inverse_sqrt(S)
      S.destroy
      NO.to_product(X,V)
      X.destroy
      V.destroy
      occupation = occupation(.n_bf:1:-1)
      occupation.zero_small_values(TOL(10))
      NO = NO(:,.n_bf:1:-1)
   end

  make_restricted_complex_NOs [leaky]
  ! Make the restricted complex natural orbitals from the density matrix
    CMAT* :: V,X
    MAT*  :: S,O
    CMAT* :: D
    D => .density_matrix.restricted_complex
    ENSURE(D.created, "no density matrix")
    .natural_orbitals.destroy
    .natural_orbitals.create(.n_bf,"restricted_complex")
    .occupation.destroy
    .occupation.create(.n_bf,"restricted")
    V.create(.n_bf,.n_bf)
    X.create(.n_bf,.n_bf)
    O.create(.n_bf,.n_bf)
    S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
    O.to_sqrt(S)
    S.destroy
    V = O
    X = D
    X.change_basis(V)
    X.solve_eigenproblem(.occupation.restricted,V)
    S.create(.n_bf, .n_bf); .get_overlap_matrix(S)
    O.to_inverse_sqrt(S)
    S.destroy
    X = O
    O.destroy
    .natural_orbitals.restricted_complex.to_product(X,V)
    X.destroy
    V.destroy
    .occupation.restricted = .occupation.restricted(.n_bf:1:-1)
    .occupation.restricted.zero_small_values(TOL(10))
    .natural_orbitals.restricted_complex = .natural_orbitals.restricted_complex(:,.n_bf:1:-1)
  end

   make_general_complex_NOs [leaky]
   ! Make the general natural orbitals and occupations from the complex density
   ! matrix.
      MAT* :: S,R
      CMAT* :: V,X
      BIN :: dens_created
      dens_created = .density_matrix.general_complex.created
      ENSURE(dens_created,"no density matrix")
      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"general_complex")
      .occupation.destroy
      .occupation.create(.n_bf,"general")
      V.create(2*.n_bf,2*.n_bf)
      R.create(.n_bf,.n_bf)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      R.to_sqrt(S)
      S.destroy
      V.alpha_alpha_set_to(R)
      V.beta_beta_set_to(R)
      R.destroy
      X.create(2*.n_bf,2*.n_bf)
      X = .density_matrix.general_complex
      X.change_basis(V)
      X.solve_eigenproblem(.occupation.general,V)
      R.create(.n_bf,.n_bf)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      R.to_inverse_sqrt(S)
      S.destroy
      X.alpha_alpha_set_to(R)
      X.beta_beta_set_to(R)
      R.destroy
      .natural_orbitals.general_complex.to_product(X,V)
      .occupation.general = .occupation.general(2*.n_bf:1:-1)
      .occupation.general.zero_small_values(TOL(10))
      .natural_orbitals.general = .natural_orbitals.general(:,2*.n_bf:1:-1)
      X.destroy
      V.destroy
   end

!  ***************************
!  Population Analysis Methods
!  ***************************

   make_mulliken_matrix
   ! sets the mulliken population matrix and the outputs it.
      MAT* :: mulliken_matrix, S
      VEC* :: diagonals
      S.create(.n_bf, .n_bf)
      mulliken_matrix.create(.n_bf, .n_bf)
      diagonals.create(.n_bf)
      .get_overlap_matrix(S)
      mulliken_matrix = matmul(.density_matrix.restricted, S)
      mulliken_matrix.get_diagonal(diagonals)
      .put_mulliken_populations(mulliken_matrix, diagonals)
      S.destroy
      mulliken_matrix.destroy
      diagonals.destroy
   end

   put_mulliken_populations(mulliken_matrix, diagonals)
   ! outputs the mulliken populations to the output file
      MAT :: mulliken_matrix
      VEC :: diagonals
      DBL :: sum
      INT :: o_count, a, b, c
      stdout.flush
      stdout.text("Mulliken population analysis: ")
      stdout.dash(int_fields=2,dbl_fields=1)
      stdout.put("Atom", int_width = TRUE)
      stdout.put("Type", int_width = TRUE)
      stdout.put("Population")
      stdout.flush
      stdout.dash(int_fields=2,dbl_fields=1)
      o_count = 1
      do a = 1, .n_atom
         do b = 1, .atom.n_shell_for_atom(a)
            do c = 1, .atom(a).basis.shell(b).n_comp
               stdout.put(.atom(a).label, int_width = TRUE)
               stdout.put(.atom(a).basis.shell(b).l_chr, int_width = TRUE)
               stdout.put(diagonals(c + o_count - 1))
               stdout.flush
            end
            o_count = o_count + .atom(a).basis.shell(b).n_comp
         end
      end
      stdout.flush
      stdout.text("Trace of the matrix: ")
      stdout.put(mulliken_matrix.trace )
      stdout.flush
      stdout.text("Atomic Populations: ")
      stdout.dash(int_fields=1, dbl_fields=1)
      stdout.put("Atom", int_width = TRUE)
      stdout.put("Population")
      stdout.flush
      stdout.dash(int_fields=1, dbl_fields=1)
      o_count = 1
      do a = 1, .n_atom
         stdout.put(.atom(a).label, int_width = TRUE)
         sum = 0
         do b = 1, .atom.n_shell_for_atom(a)
            sum = sum + diagonals(b - 1 + o_count)
         end
         stdout.put(sum)
         stdout.flush
         o_count = o_count + .atom.n_bf_for_atom(a)
      end
   end

  get_kinetic_matrix(T)
  ! Set "T" to the kinetic matrix
  ! If the archive file exists, read it; otherwise make it.
     MAT :: T
     ARCHIVE :: archive
     archive.set(.name,"kinetic_matrix")
     if (archive.exists) then; archive.read(T)
     else;                      .make_kinetic_matrix(T)
     end
  end

  make_kinetic_matrix(T,output)
  ! Calculate the kinetic energy matrix "T"
  ! if PRESENT and FALSE the matrix is not archived
    MAT :: T
    BIN, OPTIONAL :: output
    INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
    SHELL2 :: shell
    BIN :: do_archive
    ARCHIVE :: archive
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    do_archive = TRUE
    if (present(output)) do_archive=output
    if (.scfdata.nddo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (atom_a==atom_b) then; shell.get_kei(T(fa:la,fb:lb))
        else;                     T(fa:la,fb:lb) = ZERO
        end
        shell.destroy_ptr_part
      end
    else if (.scfdata.nudo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (.atom.bonded(atom_a,atom_b)) then; shell.get_kei(T(fa:la,fb:lb))
        else;                                  T(fa:la,fb:lb) = ZERO
        end
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,fa,la,fb,lb)
        shell.get_kei(T(fa:la,fb:lb))
        shell.destroy_ptr_part
      end
    end
    T.symmetric_reflect
    if (do_archive) then
      archive.set(.name,"kinetic_matrix")
      archive.write(T)
    end
  end

  get_kinetic_overlap(T,S)
  ! Set "S" to the overlap matrix and "T" to the kinetic matrix
  ! If both archives exists, read them; otherwise make them both!
     MAT :: T,S
     ARCHIVE :: T_archive,S_archive
     S_archive.set(.name,"overlap_matrix")
     T_archive.set(.name,"kinetic_matrix")
     if ((S_archive.exists) AND (T_archive.exists)) then
        S_archive.read(S)
        T_archive.read(T)
     else
        .make_kinetic_overlap(T,S)
     end
  end

  make_kinetic_overlap(T,S)
  ! Calculate the kinetic energy matrix "T" and overlap integral matrix "S"
    MAT :: T,S
    INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    if (.scfdata.nddo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (atom_a==atom_b) then; shell.get_kei(T(fa:la,fb:lb),S(fa:la,fb:lb))
        else;                     T(fa:la,fb:lb) = ZERO; S(fa:la,fb:lb) = ZERO
        end
        shell.destroy_ptr_part
      end
    else if (.scfdata.nudo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (.atom.bonded(atom_a,atom_b)) then; shell.get_kei(T(fa:la,fb:lb),S(fa:la,fb:lb))
        else;                                  T(fa:la,fb:lb) = ZERO; S(fa:la,fb:lb) = ZERO
        end
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,fa,la,fb,lb)
        shell.get_kei(T(fa:la,fb:lb), S(fa:la,fb:lb))
        shell.destroy_ptr_part
      end
    end
    S.symmetric_reflect
    T.symmetric_reflect
    archive.set(.name,"kinetic_matrix")
    archive.write(T)
    archive.set(.name,"overlap_matrix")
    archive.write(S)
  end

  get_nuclear_matrix(Z)
  ! Set "Z" to the nuclear attraction matrix.
  ! If the archive file exists, read it; otherwise make it.
     MAT :: Z
     ARCHIVE :: archive
     archive.set(.name,"nuclear_matrix")
     if (archive.exists) then; archive.read(Z)
     else;                      .make_nuclear_matrix(Z)
     end
  end

  make_nuclear_matrix(Z,output)
  ! Calculate the nuclear attraction matrix "Z"
  ! if output is present and FALSE then do not make output archive
    MAT :: Z
    BIN, OPTIONAL :: output
    BIN :: do_output
    ATOM* :: atom
    MAT* :: Z_c
    INT :: q,c,a,b,fa,la,fb,lb,atom_a,atom_b
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    do_output=TRUE
    if (present(output)) do_output=output
    Z = ZERO
    if (.scfdata.nddo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (atom_a==atom_b) then
          Z_c.create(shell.a.n_comp,shell.b.n_comp)
          do c=1,.n_atom
            atom=>.atom(c)
            shell.get_nuc(Z_c, atom.mass,atom.pos)
          ! shell.make_nuclear_attraction_ints(Z_c, atom.pos)
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
          end
          Z_c.destroy
        end
        shell.destroy_ptr_part
      end
    else if (.scfdata.nudo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (.atom.bonded(atom_a,atom_b)) then
          Z_c.create(shell.a.n_comp,shell.b.n_comp)
          do c=1,.n_atom
            atom=>.atom(c)
            shell.get_nuc(Z_c, atom.mass,atom.pos)
          ! shell.make_nuclear_attraction_ints(Z_c, atom.pos)
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
          end
          Z_c.destroy
        end
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,fa,la,fb,lb)
        Z_c.create(shell.a.n_comp,shell.b.n_comp)
        do c=1,.n_atom
          atom=>.atom(c)
          shell.get_nuc(Z_c, atom.mass,atom.pos)
        ! shell.make_nuclear_attraction_ints(Z_c, atom.pos)
          Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
        end
        Z_c.destroy
        shell.destroy_ptr_part
      end
    end
    Z.symmetric_reflect
    if (do_output) then
      archive.set(.name,"nuclear_matrix")
      archive.write(Z)
    end
  end

  make_nuclear_matrix(Z,nuclei)
  ! Using the nuclei specified in "nuclei"
  ! Calculate the nuclear attraction matrix "Z"
    MAT :: Z
    IVEC :: nuclei
    ATOM* :: atom
    MAT* :: Z_c
    INT :: q,c,a,b,fa,la,fb,lb,n_atom,atom_a,atom_b
    SHELL2 :: shell
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    Z = ZERO
    n_atom = size(nuclei)
    if (.scfdata.nddo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (atom_a==atom_b) then
          Z_c.create(shell.a.n_comp,shell.b.n_comp)
          do c=1,n_atom
            atom=>.atom(nuclei(c))
            shell.get_nuc(Z_c, atom.mass,atom.pos)
          ! shell.make_nuclear_attraction_ints(Z_c, atom.pos)
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
          end
          Z_c.destroy
        end
        shell.destroy_ptr_part
      end
    else if (.scfdata.nudo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (.atom.bonded(atom_a,atom_b)) then
          Z_c.create(shell.a.n_comp,shell.b.n_comp)
          do c=1,n_atom
            atom=>.atom(nuclei(c))
            shell.get_nuc(Z_c, atom.mass,atom.pos)
          ! shell.make_nuclear_attraction_ints(Z_c, atom.pos)
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
          end
          Z_c.destroy
        end
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,fa,la,fb,lb)
        Z_c.create(shell.a.n_comp,shell.b.n_comp)
        do c=1,n_atom
          atom=>.atom(nuclei(c))
        ! shell.get_nuc(Z_c, atom.mass,atom.pos)
          shell.make_nuclear_attraction_ints(Z_c, atom.pos)
          Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
        end
        Z_c.destroy
        shell.destroy_ptr_part
      end
    end
    Z.symmetric_reflect
  end

  get_core_matrix(H,nuclei)
  ! Get the core hamiltonian matrix. If already in memory, do nothing. Else if
  ! the archive file exists, read it. Otherwise make it.
  ! If the nuclei are given make it regardless, since the stored one is
  ! likely to be different
     MAT :: H
     IVEC, optional :: nuclei
     ARCHIVE :: archive
     if (present(nuclei)) then
      .make_core_matrix(H,nuclei)
     else
      archive.set(.name,"core_matrix")
      if (archive.exists) then; archive.read(H)
       else; .make_core_matrix(H)
      end
     end
  end

  make_core_matrix(H)
  ! Get the core hamiltonian matrix "H".
     MAT :: H
     MAT* :: Z
     ARCHIVE :: archive
     .get_kinetic_matrix(H)
     Z.create(.n_bf, .n_bf)
     .get_nuclear_matrix(Z)
     H = H + Z
     Z.destroy
     archive.set(.name,"core_matrix")
     archive.write(H)
  end

  make_core_matrix(H,nuclei)
  ! Get the core hamiltonian matrix "H".
     MAT :: H
     IVEC :: nuclei
     MAT* :: Z
     .make_kinetic_matrix(H,output=FALSE)
     Z.create(.n_bf, .n_bf)
     .make_nuclear_matrix(Z,nuclei)
     H = H + Z
     Z.destroy
  end

  get_dipole_matrices(Dx,Dy,Dz)
  ! Set "Di" to the dipole moment integral matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Dx,Dy,Dz
     ARCHIVE :: x_archive,y_archive,z_archive
     x_archive.set(.name,"dipole_x_matrix")
     y_archive.set(.name,"dipole_y_matrix")
     z_archive.set(.name,"dipole_z_matrix")
     if (x_archive.exists) then
        x_archive.read(Dx); y_archive.read(Dy); z_archive.read(Dz)
     else
        .make_dipole_matrices(Dx,Dy,Dz)
     end
  end

  make_dipole_matrices(Dx,Dy,Dz)
  ! Make "Di", the dipole moment integral matrices.
     MAT :: Dx,Dy,Dz
     MAT* :: DDx,DDy,DDz
     INT :: q,fa,la,fb,lb
     SHELL2 :: shell
     ARCHIVE :: archive
     INT :: n_a,n_b
     ENSURE(.atom.created,  "no atom list")
     ENSURE(.atom.bases_are_all_resolved, "no basis set")
     Dx = ZERO; Dy = ZERO; Dz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,fa,la,fb,lb)
        n_a = shell.a.n_comp; n_b = shell.b.n_comp
        DDx.create(n_a,n_b); DDy.create(n_a,n_b); DDz.create(n_a,n_b)
        shell.make_dipole_ints(DDx,DDy,DDz, .gauge_origin)
        Dx(fa:la,fb:lb) = Dx(fa:la,fb:lb) + DDx
        Dy(fa:la,fb:lb) = Dy(fa:la,fb:lb) + DDy
        Dz(fa:la,fb:lb) = Dz(fa:la,fb:lb) + DDz
        shell.destroy_ptr_part
        DDz.destroy; DDy.destroy; DDx.destroy
     end
     Dx.symmetric_reflect; Dy.symmetric_reflect; Dz.symmetric_reflect
     archive.set(.name,"dipole_x_matrix"); archive.write(Dx)
     archive.set(.name,"dipole_y_matrix"); archive.write(Dy)
     archive.set(.name,"dipole_z_matrix"); archive.write(Dz)
  end

  get_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
  ! Set "Qij" to the quadrupole moment integral matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Qxx,Qyy,Qzz,Qxy,Qxz,Qyz
     ARCHIVE :: xx_archive,yy_archive,zz_archive
     ARCHIVE :: xy_archive,xz_archive,yz_archive
     xx_archive.set(.name,"quadrupole_xx_matrix")
     yy_archive.set(.name,"quadrupole_yy_matrix")
     zz_archive.set(.name,"quadrupole_zz_matrix")
     xy_archive.set(.name,"quadrupole_xy_matrix")
     xz_archive.set(.name,"quadrupole_xz_matrix")
     yz_archive.set(.name,"quadrupole_yz_matrix")
     if (xx_archive.exists) then
        xx_archive.read(Qxx); yy_archive.read(Qyy); zz_archive.read(Qzz)
        xy_archive.read(Qxy); xz_archive.read(Qxz); yz_archive.read(Qyz)
     else
        .make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
     end
  end

  make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
  ! Make "Qij", the quadrupole moment integral matrices.
     MAT :: Qxx,Qyy,Qzz,Qxy,Qxz,Qyz
     MAT* :: QQxx,QQyy,QQzz,QQxy,QQxz,QQyz
     INT :: q,fa,la,fb,lb
     SHELL2 :: shell
     ARCHIVE :: archive
     INT :: n_a,n_b
     ENSURE(.atom.created,  "no atom list")
     ENSURE(.atom.bases_are_all_resolved, "no basis set")
     Qxx = ZERO; Qyy = ZERO; Qzz = ZERO
     Qxy = ZERO; Qxz = ZERO; Qyz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,fa,la,fb,lb)
        n_a = shell.a.n_comp; n_b = shell.b.n_comp
        QQxx.create(n_a,n_b); QQyy.create(n_a,n_b); QQzz.create(n_a,n_b)
        QQxy.create(n_a,n_b); QQxz.create(n_a,n_b); QQyz.create(n_a,n_b)
        shell.make_quadrupole_ints(QQxx,QQyy,QQzz,QQxy,QQxz,QQyz, .gauge_origin)
        Qxx(fa:la,fb:lb) = Qxx(fa:la,fb:lb) + QQxx
        Qyy(fa:la,fb:lb) = Qyy(fa:la,fb:lb) + QQyy
        Qzz(fa:la,fb:lb) = Qzz(fa:la,fb:lb) + QQzz
        Qxy(fa:la,fb:lb) = Qxy(fa:la,fb:lb) + QQxy
        Qxz(fa:la,fb:lb) = Qxz(fa:la,fb:lb) + QQxz
        Qyz(fa:la,fb:lb) = Qyz(fa:la,fb:lb) + QQyz
        shell.destroy_ptr_part
        QQyz.destroy; QQxz.destroy; QQxy.destroy
        QQzz.destroy; QQyy.destroy; QQxx.destroy
     end
     Qxx.symmetric_reflect; Qyy.symmetric_reflect; Qzz.symmetric_reflect
     Qxy.symmetric_reflect; Qxz.symmetric_reflect; Qyz.symmetric_reflect
     archive.set(.name,"quadrupole_xx_matrix"); archive.write(Qxx)
     archive.set(.name,"quadrupole_yy_matrix"); archive.write(Qyy)
     archive.set(.name,"quadrupole_zz_matrix"); archive.write(Qzz)
     archive.set(.name,"quadrupole_xy_matrix"); archive.write(Qxy)
     archive.set(.name,"quadrupole_xz_matrix"); archive.write(Qxz)
     archive.set(.name,"quadrupole_yz_matrix"); archive.write(Qyz)
  end

  get_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
  ! Set "Oijk" to the quadrupole moment integral matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz
     ARCHIVE :: xxx,yyy,zzz,xxy,xxz,yyx,yyz,zzx,zzy,xyz
     ARCHIVE :: xy_archive,xz_archive,yz_archive
     xxx.set(.name,"octupole_xxx_matrix")
     yyy.set(.name,"octupole_yyy_matrix")
     zzz.set(.name,"octupole_zzz_matrix")
     xxy.set(.name,"octupole_xxy_matrix")
     xxz.set(.name,"octupole_xxz_matrix")
     yyx.set(.name,"octupole_yyx_matrix")
     yyz.set(.name,"octupole_yyz_matrix")
     zzx.set(.name,"octupole_zzx_matrix")
     zzy.set(.name,"octupole_zzy_matrix")
     xyz.set(.name,"octupole_xyz_matrix")
     if (xxx.exists) then
        xxx.read(Oxxx); yyy.read(Oyyy); zzz.read(Ozzz)
        xxy.read(Oxxy); xxz.read(Oxxz)
        yyx.read(Oyyx); yyz.read(Oyyz)
        zzx.read(Ozzx); zzy.read(Ozzy)
        xyz.read(Oxyz)
     else
        .make_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
     end
  end

  make_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
  ! Make "Oijk", the octupole moment integral matrices.
     MAT :: Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz
     MAT* :: OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz
     INT :: q,fa,la,fb,lb
     SHELL2 :: shell
     ARCHIVE :: archive
     INT :: n_a,n_b
     ENSURE(.atom.created,  "no atom list")
     ENSURE(.atom.bases_are_all_resolved, "no basis set")
     Oxxx = ZERO; Oyyy = ZERO; Ozzz = ZERO
     Oxxy = ZERO; Oxxz = ZERO
     Oyyx = ZERO; Oyyz = ZERO
     Ozzx = ZERO; Ozzy = ZERO
     Oxyz = ZERO
     do q = 1,.n_shell_pairs
        .get_shell_pair(shell,q,fa,la,fb,lb)
        n_a = shell.a.n_comp; n_b = shell.b.n_comp
        OOxxx.create(n_a,n_b); OOyyy.create(n_a,n_b); OOzzz.create(n_a,n_b)
        OOxxy.create(n_a,n_b); OOxxz.create(n_a,n_b)
        OOyyx.create(n_a,n_b); OOyyz.create(n_a,n_b)
        OOzzx.create(n_a,n_b); OOzzy.create(n_a,n_b)
        OOxyz.create(n_a,n_b)
        shell.make_octupole_ints(OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz,.gauge_origin)
        Oxxx(fa:la,fb:lb) = Oxxx(fa:la,fb:lb) + OOxxx
        Oyyy(fa:la,fb:lb) = Oyyy(fa:la,fb:lb) + OOyyy
        Ozzz(fa:la,fb:lb) = Ozzz(fa:la,fb:lb) + OOzzz
        Oxxy(fa:la,fb:lb) = Oxxy(fa:la,fb:lb) + OOxxy
        Oxxz(fa:la,fb:lb) = Oxxz(fa:la,fb:lb) + OOxxz
        Oyyx(fa:la,fb:lb) = Oyyx(fa:la,fb:lb) + OOyyx
        Oyyz(fa:la,fb:lb) = Oyyz(fa:la,fb:lb) + OOyyz
        Ozzx(fa:la,fb:lb) = Ozzx(fa:la,fb:lb) + OOzzx
        Ozzy(fa:la,fb:lb) = Ozzy(fa:la,fb:lb) + OOzzy
        Oxyz(fa:la,fb:lb) = Oxyz(fa:la,fb:lb) + OOxyz
        shell.destroy_ptr_part
        OOxyz.destroy
        OOzzy.destroy; OOzzx.destroy
        OOyyz.destroy; OOyyx.destroy
        OOxxz.destroy; OOxxy.destroy
        OOzzz.destroy; OOyyy.destroy; OOxxx.destroy
     end
     Oxxx.symmetric_reflect; Oyyy.symmetric_reflect; Ozzz.symmetric_reflect
     Oxxy.symmetric_reflect; Oxxz.symmetric_reflect
     Oyyx.symmetric_reflect; Oyyz.symmetric_reflect
     Ozzx.symmetric_reflect; Ozzy.symmetric_reflect
     Oxyz.symmetric_reflect
     archive.set(.name,"octupole_xxx_matrix"); archive.write(Oxxx)
     archive.set(.name,"octupole_yyy_matrix"); archive.write(Oyyy)
     archive.set(.name,"octupole_zzz_matrix"); archive.write(Ozzz)
     archive.set(.name,"octupole_xxy_matrix"); archive.write(Oxxy)
     archive.set(.name,"octupole_xxz_matrix"); archive.write(Oxxz)
     archive.set(.name,"octupole_yyx_matrix"); archive.write(Oyyx)
     archive.set(.name,"octupole_yyz_matrix"); archive.write(Oyyz)
     archive.set(.name,"octupole_zzx_matrix"); archive.write(Ozzx)
     archive.set(.name,"octupole_zzy_matrix"); archive.write(Ozzy)
     archive.set(.name,"octupole_xyz_matrix"); archive.write(Oxyz)
  end

  get_spin_orbit_matrices(SOx,SOy,SOz)
  ! Set "SOx", "SOy", and "SOz" to the one electron spin orbit matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: SOx,SOy,SOz
     ARCHIVE :: SOx_archive,SOy_archive,SOz_archive
     SOx_archive.set(.name,"SOx_matrix")
     SOy_archive.set(.name,"SOy_matrix")
     SOz_archive.set(.name,"SOz_matrix")
     if (SOx_archive.exists AND SOy_archive.exists AND SOz_archive.exists) then
        SOx_archive.read(SOx)
        SOy_archive.read(SOy)
        SOz_archive.read(SOz)
     else
        .make_spin_orbit_matrices(SOx,SOy,SOz)
     end
  end

  make_spin_orbit_matrices(SOx,SOy,SOz)
  ! Calculate the spin orbit matrices "SOx" "SOy" and "SOz"
     MAT :: SOx,SOy,SOz
     MAT* :: SOx_c,SOy_c,SOz_c
     INT :: q,c,fa,la,fb,lb
     DBL :: Z
     SHELL2 :: shell
     ARCHIVE :: archive
     ENSURE(.atom.created,  "no atom list")
     ENSURE(.atom.bases_are_all_resolved, "no basis set")
     SOx = ZERO; SOy = ZERO; SOz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,fa,la,fb,lb)
        SOx_c.create(shell.a.n_comp,shell.b.n_comp)
        SOy_c.create(shell.a.n_comp,shell.b.n_comp)
        SOz_c.create(shell.a.n_comp,shell.b.n_comp)
        do c = 1,.n_atom
           Z = .atom(c).atomic_number
           shell.make_spin_orbit_ints(SOx_c,SOy_c,SOz_c, .atom(c).pos)
           SOx(fa:la,fb:lb) = SOx(fa:la,fb:lb) + Z*SOx_c
           SOy(fa:la,fb:lb) = SOy(fa:la,fb:lb) + Z*SOy_c
           SOz(fa:la,fb:lb) = SOz(fa:la,fb:lb) + Z*SOz_c
        end
        shell.destroy_ptr_part
        SOz_c.destroy; SOy_c.destroy; SOx_c.destroy
     end
     SOx.antisymmetric_reflect
     SOy.antisymmetric_reflect
     SOz.antisymmetric_reflect
     archive.set(.name,"SOx_matrix"); archive.write(SOx)
     archive.set(.name,"SOy_matrix"); archive.write(SOy)
     archive.set(.name,"SOz_matrix"); archive.write(SOz)
  end

  get_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
  ! Set "SOBi" to the gauge modified (B field) one electron spin orbit matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: SOBx,SOBy,SOBz
     ARCHIVE :: x_archive,y_archive,z_archive
     x_archive.set(.name,"SOBx_matrix")
     y_archive.set(.name,"SOBy_matrix")
     z_archive.set(.name,"SOBz_matrix")
     if (x_archive.exists) then
        x_archive.read(SOBx); y_archive.read(SOBy); z_archive.read(SOBz)
     else
        .make_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
     end
  end

  make_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
  ! Calculate the gauge modified (B field) spin orbit matrices "SOBx" "SOBy"
  ! and "SOBz"
     MAT :: SOBx,SOBy,SOBz
     MAT* :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
     INT :: n_bf
     ARCHIVE :: archive
     ENSURE(.atom.created,  "no atom list")
     ENSURE(.atom.bases_are_all_resolved, "no basis set")
     n_bf = .n_bf
     Qxx.create(n_bf,n_bf); Qxy.create(n_bf,n_bf); Qxz.create(n_bf,n_bf)
     Qyx.create(n_bf,n_bf); Qyy.create(n_bf,n_bf); Qyz.create(n_bf,n_bf)
     Qzx.create(n_bf,n_bf); Qzy.create(n_bf,n_bf); Qzz.create(n_bf,n_bf)
     .get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
     SOBx = (Qyy + Qzz)*.B_field(1) - Qxy*.B_field(2) - Qxz*.B_field(3)
     SOBy = (Qxx + Qzz)*.B_field(2) - Qyx*.B_field(1) - Qyz*.B_field(3)
     SOBz = (Qxx + Qyy)*.B_field(3) - Qzx*.B_field(1) - Qzy*.B_field(2)
     Qzz.destroy; Qzy.destroy; Qzx.destroy
     Qyz.destroy; Qyy.destroy; Qyx.destroy
     Qxz.destroy; Qxy.destroy; Qxx.destroy
     SOBx.symmetric_reflect
     SOBy.symmetric_reflect
     SOBz.symmetric_reflect
     archive.set(.name,"SOBx_matrix"); archive.write(SOBx)
     archive.set(.name,"SOBy_matrix"); archive.write(SOBy)
     archive.set(.name,"SOBz_matrix"); archive.write(SOBz)
  end

  get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
  ! Set "Qij" the gauge modified (B field) spin orbit quadrupole matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
     ARCHIVE :: xx_archive,xy_archive,xz_archive
     ARCHIVE :: yx_archive,yy_archive,yz_archive
     ARCHIVE :: zx_archive,zy_archive,zz_archive
     xx_archive.set(.name,"SO_Qxx_matrix")
     xy_archive.set(.name,"SO_Qxy_matrix")
     xz_archive.set(.name,"SO_Qxz_matrix")
     yx_archive.set(.name,"SO_Qyx_matrix")
     yy_archive.set(.name,"SO_Qyy_matrix")
     yz_archive.set(.name,"SO_Qyz_matrix")
     zx_archive.set(.name,"SO_Qzx_matrix")
     zy_archive.set(.name,"SO_Qzy_matrix")
     zz_archive.set(.name,"SO_Qzz_matrix")
     if (xx_archive.exists ) then
        xx_archive.read(Qxx); xy_archive.read(Qxy); xz_archive.read(Qxz)
        yx_archive.read(Qyx); yy_archive.read(Qyy); yz_archive.read(Qyz)
        zx_archive.read(Qzx); zy_archive.read(Qzy); zz_archive.read(Qzz)
     else
        .make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
     end
  end

  make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
  ! Calculate the gauge modified (B field) spin orbit quadrupole matrices "Qij".
     MAT :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
     MAT* :: xx,xy,xz,yx,yy,yz,zx,zy,zz
     INT :: q,c,fa,la,fb,lb
     DBL :: Z
     SHELL2 :: shell
     ARCHIVE :: archive
     INT :: n_a,n_b
     ENSURE(.atom.created,  "no atom list")
     ENSURE(.atom.bases_are_all_resolved, "no basis set")
     Qxx = ZERO; Qxy = ZERO; Qxz = ZERO
     Qyx = ZERO; Qyy = ZERO; Qyz = ZERO
     Qzx = ZERO; Qzy = ZERO; Qzz = ZERO
     do q = 1,.n_shell_pairs
        .get_shell_pair(shell,q,fa,la,fb,lb)
        n_a = shell.a.n_comp; n_b = shell.b.n_comp
        xx.create(n_a,n_b); xy.create(n_a,n_b); xz.create(n_a,n_b)
        yx.create(n_a,n_b); yy.create(n_a,n_b); yz.create(n_a,n_b)
        zx.create(n_a,n_b); zy.create(n_a,n_b); zz.create(n_a,n_b)
        do c = 1,.n_atom
           Z = .atom(c).atomic_number
           shell.make_spin_orbit_B_ints(xx,xy,xz,yx,yy,yz,zx,zy,zz,.atom(c).pos, .gauge_origin)
           ! minus due to r-c, not c-r in the electric field part
           ! this comment should go in gaussian2?
           Qxx(fa:la,fb:lb) = Qxx(fa:la,fb:lb) - Z*xx
           Qxy(fa:la,fb:lb) = Qxy(fa:la,fb:lb) - Z*xy
           Qxz(fa:la,fb:lb) = Qxz(fa:la,fb:lb) - Z*xz
           Qyx(fa:la,fb:lb) = Qyx(fa:la,fb:lb) - Z*yx
           Qyy(fa:la,fb:lb) = Qyy(fa:la,fb:lb) - Z*yy
           Qyz(fa:la,fb:lb) = Qyz(fa:la,fb:lb) - Z*yz
           Qzx(fa:la,fb:lb) = Qzx(fa:la,fb:lb) - Z*zx
           Qzy(fa:la,fb:lb) = Qzy(fa:la,fb:lb) - Z*zy
           Qzz(fa:la,fb:lb) = Qzz(fa:la,fb:lb) - Z*zz
        end
        shell.destroy_ptr_part
        zz.destroy; zy.destroy; zx.destroy
        yz.destroy; yy.destroy; yx.destroy
        xz.destroy; xy.destroy; xx.destroy
     end
     Qxx.symmetric_reflect; Qxy.symmetric_reflect; Qxz.symmetric_reflect
     Qyx.symmetric_reflect; Qyy.symmetric_reflect; Qyz.symmetric_reflect
     Qzx.symmetric_reflect; Qzy.symmetric_reflect; Qzz.symmetric_reflect
     archive.set(.name,"SO_Qxx_matrix"); archive.write(Qxx)
     archive.set(.name,"SO_Qxy_matrix"); archive.write(Qxy)
     archive.set(.name,"SO_Qxz_matrix"); archive.write(Qxz)
     archive.set(.name,"SO_Qyx_matrix"); archive.write(Qyx)
     archive.set(.name,"SO_Qyy_matrix"); archive.write(Qyy)
     archive.set(.name,"SO_Qyz_matrix"); archive.write(Qyz)
     archive.set(.name,"SO_Qzx_matrix"); archive.write(Qzx)
     archive.set(.name,"SO_Qzy_matrix"); archive.write(Qzy)
     archive.set(.name,"SO_Qzz_matrix"); archive.write(Qzz)
  end

   nuclear_potential(values,pts)
   ! Calculate the nuclear potential "values" of a given set of "pts".
   ! This is usefule for numerical integration of nuclear attraction integrals.
      VEC :: values
      MAT :: pts
      INT :: n_pts,n,i
      DBL :: Z_n,r_ni
      VEC(3) :: pos
      n_pts = size(pts,1)
      values = ZERO
      do n = 1,.n_atom
         Z_n = .atom(n).atomic_number
         pos = .atom(n).pos
         do i = 1,n_pts
            r_ni = pos.distance_to(pts(i,:))
            values(i) = values(i) + Z_n/r_ni
         end
      end
   end

   ZORA_potential(values,pts)
   ! Calculate the one electron ZORA potential "values" of a given set of "pts".
   ! This is useful for numerical integration.
      VEC :: values
      MAT :: pts
      DBL :: fac
      .nuclear_potential(values,pts)
      fac    = ONE/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      values = ONE/(TWO + fac*values)
   end

  get_1e_ZORA_matrices(T,SOx,SOy,SOz)
  ! Set "SOx", "SOy", and "SOz" to the one electron ZORA spin orbit matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: T,SOx,SOy,SOz
     ARCHIVE :: T_archive,SOx_archive,SOy_archive,SOz_archive
     T_archive.set(.name,"ZORA_kinetic_matrix")
     SOx_archive.set(.name,"ZORA_SOx_matrix")
     SOy_archive.set(.name,"ZORA_SOy_matrix")
     SOz_archive.set(.name,"ZORA_SOz_matrix")
     if (SOx_archive.exists AND SOy_archive.exists AND SOz_archive.exists) then
        T_archive.read(T)
        SOx_archive.read(SOx)
        SOy_archive.read(SOy)
        SOz_archive.read(SOz)
     else
        .make_1e_ZORA_matrices(T,SOx,SOy,SOz)
     end
  end

  make_1e_ZORA_matrices(T,Zx,Zy,Zz)
  ! Calculate the one-electron ZORA spin orbit matrices numerically.
  ! This includes the relativitically modified kinetic energy integrals.
    MAT  :: T, Zx,Zy,Zz
    MAT4* :: ZORA,SO
    INT :: q,fa,la,fb,lb,k,l,a,b
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.dftgrid.created, "need to specify dftgrid for ZORA")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    ZORA.create(.n_bf,.n_bf,3,3)
    ! Make the lower half of the ZORA spin orbit integrals
    ZORA = ZERO
    do q = 1,.n_shell_pairs
       .get_shell_pair(shell,q,fa,la,fb,lb)
       SO.create(shell.a.n_comp,shell.b.n_comp,3,3)
       .dftgrid.make_SO_matrix_elements_of(ZORA_potential,self,shell,SO)
       ZORA(fa:la,fb:lb,:,:) = ZORA(fa:la,fb:lb,:,:) + SO
       SO.destroy
       shell.destroy_ptr_part
    end
    ! Make the upper half of the ZORA spin orbit integrals
    do k = 1,3
    do l = 1,3
    do a = 1,.n_bf
    do b = 1,a-1
       ZORA(b,a,l,k) = ZORA(a,b,k,l)
    end
    end
    end
    end
    ! Assemble the ZORA contribution to the 1 electron hamiltonian
    ! Scalar kinetic energy contribution
    T = ZORA(:,:,1,1) + ZORA(:,:,2,2) + ZORA(:,:,3,3)
    ! Spin-dependent spin-orbit contribution
    Zx = ZORA(:,:,2,3) - ZORA(:,:,3,2)
    Zy = ZORA(:,:,3,1) - ZORA(:,:,1,3)
    Zz = ZORA(:,:,1,2) - ZORA(:,:,2,1)
    ZORA.destroy
     archive.set(.name,"ZORA_kinetic_matrix"); archive.write(T)
     archive.set(.name,"ZORA_SOx_matrix");     archive.write(Zx)
     archive.set(.name,"ZORA_SOy_matrix");     archive.write(Zy)
     archive.set(.name,"ZORA_SOz_matrix");     archive.write(Zz)
  end

  make_ENA_matrix(Z)
  ! Calculate the one-electron electron nuclear attractio matrix numerically.
    MAT  :: Z
    MAT* :: ZZ
    INT :: q,fa,la,fb,lb
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.dftgrid.created, "need to specify dftgrid for ZORA")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    Z = ZERO
    do q = 1,.n_shell_pairs
       .get_shell_pair(shell,q,fa,la,fb,lb)
       ZZ.create(shell.a.n_comp,shell.b.n_comp)
       .dftgrid.make_matrix_elements_of(nuclear_potential,self,shell,ZZ)
       Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - ZZ
       ZZ.destroy
       shell.destroy_ptr_part
    end
    Z.symmetric_reflect
     archive.set(.name,"ENA_matrix"); archive.write(Z)
  end

  get_L_matrices(Lx,Ly,Lz)
  ! Set "Lx", "Ly", and "Lz" to the angular momentum matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Lx,Ly,Lz
     ARCHIVE :: Lx_archive,Ly_archive,Lz_archive
     Lx_archive.set(.name,"Lx_matrix")
     Ly_archive.set(.name,"Ly_matrix")
     Lz_archive.set(.name,"Lz_matrix")
     if (Lx_archive.exists AND Ly_archive.exists AND Lz_archive.exists) then
        Lx_archive.read(Lx)
        Ly_archive.read(Ly)
        Lz_archive.read(Lz)
     else
        .make_L_matrices(Lx,Ly,Lz)
     end
  end

  make_L_matrices(Lx,Ly,Lz)
  ! Make the angular momentum matrices  "Lx", "Ly", and "Lz".
     MAT :: Lx,Ly,Lz
     INT :: q,fa,la,fb,lb
     SHELL2 :: shell
     ARCHIVE :: archive
     ENSURE(.atom.created,  "no atom list")
     ENSURE(.atom.bases_are_all_resolved, "no basis set")
     do q=1,.n_shell_pairs
        .get_shell_pair(shell,q,fa,la,fb,lb)
        shell.make_L_ints(Lx(fa:la,fb:lb),Ly(fa:la,fb:lb),Lz(fa:la,fb:lb), .gauge_origin)
        shell.destroy_ptr_part
     end
     Lx.antisymmetric_reflect
     Ly.antisymmetric_reflect
     Lz.antisymmetric_reflect
     archive.set(.name,"Lx_matrix"); archive.write(Lx)
     archive.set(.name,"Ly_matrix"); archive.write(Ly)
     archive.set(.name,"Lz_matrix"); archive.write(Lz)
  end

  get_ERI_integrals
  ! Get the electron repulsion integrals on disk. If the integral
  ! file is already there, do nothing.
    ARCHIVE :: eri_archive,ind_archive
    eri_archive.set(.name,"eri_integrals")
    ind_archive.set(.name,"eri_index")
    if ((NOT eri_archive.exists) OR (NOT ind_archive.exists)) then
       eri_archive.open(for="write-only",buffered=TRUE,type="dbl")
       ind_archive.open(for="write-only",buffered=TRUE,type="int")
       .make_eri_integrals(eri_archive,ind_archive)
       ind_archive.close
       eri_archive.close
    end
  end

  make_eri_integrals(eri_archive,eri_index)
  ! Calculate the electron repulsion integrals (ERI's) over all basis functions
  ! Outputs to archive "eri_archive".  Note that index coincidence factors are
  ! included.
    ARCHIVE :: eri_archive,eri_index
    SHELL4 :: shell4
    MAT4*   :: ERI
    INT :: q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d
    DBL :: factor
    STR :: cutoff
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    cutoff.from_dbl(SHELL4_ERI_CUTOFF)
    skipped = 0
    if (.scfdata.output) then
       stdout.text("Skipping electron repulsion integrals less than " // trim(cutoff) // ".")
    end
    if (.scfdata.nddo) then
       do q = 1, .n_shell_quartets
         .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
         if (atom_a==atom_b AND atom_c==atom_d) then
           .get_shell_quartet(shell4,q,a,b,c,d)
         else
           skipped = skipped + 1
           cycle
         end
         if (shell4.skip_ERI) then
           skipped = skipped + 1
           shell4.destroy_ptr_part
           cycle
         end
         ERI.create(shell4.a.n_comp,shell4.b.n_comp,shell4.c.n_comp,shell4.d.n_comp)
         shell4.get_ERI(ERI)
         factor = ONE
         if (a==b) factor = HALF                    ! Coincidence factors
         if (c==d) factor = HALF * factor
         if (a==c AND b==d) factor = HALF * factor
         ERI = factor * ERI
         eri_archive.file.write(ERI)
         eri_index.file.write(q)
         ERI.destroy
         shell4.destroy_ptr_part
       end
    else if (.scfdata.nudo) then
       do q = 1, .n_shell_quartets
         .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
         if (.atom.bonded(atom_a,atom_b) AND .atom.bonded(atom_c,atom_d)) then
           .get_shell_quartet(shell4,q,a,b,c,d)
         else
           skipped = skipped + 1
           cycle
         end
         if (shell4.skip_ERI) then
           skipped = skipped + 1
           shell4.destroy_ptr_part
           cycle
         end
         ERI.create(shell4.a.n_comp,shell4.b.n_comp,shell4.c.n_comp,shell4.d.n_comp)
         shell4.get_ERI(ERI)
         factor = ONE
         if (a==b) factor = HALF                    ! Coincidence factors
         if (c==d) factor = HALF * factor
         if (a==c AND b==d) factor = HALF * factor
         ERI = factor * ERI
         eri_archive.file.write(ERI)
         eri_index.file.write(q)
         ERI.destroy
         shell4.destroy_ptr_part
       end
    else
       do q = 1, .n_shell_quartets
         .get_shell_quartet(shell4,q,a,b,c,d)
         if (shell4.skip_ERI) then
           skipped = skipped + 1
           shell4.destroy_ptr_part
           cycle
         end
         ERI.create(shell4.a.n_comp,shell4.b.n_comp,shell4.c.n_comp,shell4.d.n_comp)
         shell4.get_ERI(ERI)
         factor=ONE
         if (a==b) factor = HALF                    ! Coincidence factors
         if (c==d) factor = HALF * factor
         if (a==c AND b==d) factor = HALF * factor
         ERI = factor * ERI
         eri_archive.file.write(ERI)
         eri_index.file.write(q)
         ERI.destroy
         shell4.destroy_ptr_part
       end
    end
    if (.scfdata.output) then
      stdout.put_text("Skipped " // trim(skipped.to_str ) //  " out of " // &
          trim(.n_shell_quartets.to_str ) // " blocks.",flush=1)
    end
    eri_index.file.write(.n_shell_quartets + 1 )
  end

  get_spin_orbit_integrals
  ! Get the spin orbit integrals on disk. If the integral files are
  ! file is already there, do nothing.
    ARCHIVE :: SOx_archive,SOy_archive,SOz_archive,ind_archive
    SOx_archive.set(.name,"SOx_integrals")
    SOy_archive.set(.name,"SOy_integrals")
    SOz_archive.set(.name,"SOz_integrals")
    ind_archive.set(.name,"SO_indices")
    if (NOT SOx_archive.exists) then
       SOx_archive.open(for="write-only",buffered=TRUE,type="dbl")
       SOy_archive.open(for="write-only",buffered=TRUE,type="dbl")
       SOz_archive.open(for="write-only",buffered=TRUE,type="dbl")
       ind_archive.open(for="write-only",buffered=TRUE,type="int")
       .make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)
       SOx_archive.close
       SOy_archive.close
       SOz_archive.close
       ind_archive.close
    end
  end

  make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)
  ! Calculate the spin orbit integrals. Outputs the spin same-orbit integrals
  ! to for each component i to "SOi_archive". The shell quartet index for
  ! these integrals are put in "ind_archive". Note that index coincidence
  ! factors are included.
    ARCHIVE :: SOx_archive,SOy_archive,SOz_archive,ind_archive
    SHELL4 :: shell4
    MAT4*   :: Sx,Sy,Sz,Ox,Oy,Oz
    INT :: q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d,na,nb,nc,nd
    DBL :: factor
    STR :: cutoff
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    cutoff.from_dbl(SHELL4_ERI_CUTOFF)
    skipped = 0
    if (.scfdata.output) then
      stdout.text("Skipping electron repulsion integrals less than " // trim(cutoff) // ".")
    end
    do q = 1, .n_shell_quartets
      if (.scfdata.nddo) then
        .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
        if (atom_a==atom_b AND atom_c==atom_d) then
          .get_shell_quartet(shell4,q,a,b,c,d)
        else
          skipped = skipped + 1
          cycle
        end
      else if (.scfdata.nudo) then
        .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
        if (.atom.bonded(atom_a,atom_b) AND .atom.bonded(atom_c,atom_d)) then
          .get_shell_quartet(shell4,q,a,b,c,d)
        else
          skipped = skipped + 1
          cycle
        end
      else
        .get_shell_quartet(shell4,q,a,b,c,d)
      end
      if (shell4.skip_ERI) then
        skipped = skipped + 1
        shell4.destroy_ptr_part
        cycle
      end
      na = shell4.a.n_comp; nb = shell4.b.n_comp
      nc = shell4.c.n_comp; nd = shell4.d.n_comp
      Sx.create(na,nb,nc,nd); Sy.create(na,nb,nc,nd); Sz.create(na,nb,nc,nd)
      Ox.create(na,nb,nc,nd); Oy.create(na,nb,nc,nd); Oz.create(na,nb,nc,nd)
      shell4.make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
      factor = ONE
      if (a==b) factor = HALF                    ! Coincidence factors
      if (c==d) factor = HALF * factor
      if (a==c AND b==d) factor = HALF * factor
      Sx = factor*Sx; Sy = factor*Sy; Sz = factor*Sz
      Ox = factor*Ox; Oy = factor*Oy; Oz = factor*Oz
      SOx_archive.file.write(Sx); SOx_archive.file.write(Ox)
      SOy_archive.file.write(Sy); SOy_archive.file.write(Oy)
      SOz_archive.file.write(Sz); SOz_archive.file.write(Oz)
      ind_archive.file.write(q)
      Oz.destroy; Oy.destroy; Ox.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      shell4.destroy_ptr_part
    end
    if (.scfdata.output) then
      stdout.put_text("Skipped " // trim(skipped.to_str ) //  " out of " // &
          trim(.n_shell_quartets.to_str ) // " blocks.",flush=1)
    end
    ind_archive.file.write(.n_shell_quartets + 1 )
  end

!  **************************
!  Crystal structure routines
!  **************************

   make_ft(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [size(k_pts,1)]
      MAT, target :: dens
      MAT, IN :: k_pts
      CVEC :: res
      INT :: k_max,k,fa,fb,la,lb,q,a,b,atom_a,atom_b
      SHELL2 :: shell
      CMAT3* :: ft_ab
      MAT* :: dens_ba
      DBL :: cutoff
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      k_max = size(k_pts,1)
      res = ZERO
      cutoff = TOL(10) / .n_shell_pairs
      do q = 1, .n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
         if (shell.skip_ft(cutoff)) then
           shell.destroy_ptr_part
           cycle
         end
         ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp)
         .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
         dens_ba => dens(fb:lb,fa:la)
         if (a/=b) ft_ab = TWO * ft_ab ! count off-diagonals twice.
         do k = 1,k_max
            res(k) = res(k) + ft_ab(k,:,:).trace_of_product(dens_ba)
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
   end

   make_ft(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [size(k_pts,1)].
      CMAT, target :: dens
      MAT :: k_pts
      CVEC :: res
      INT :: k_max,q,k,a,b,fa,la,fb,lb,atom_a,atom_b
      SHELL2 :: shell
      CMAT3* :: ft_ab
      CMAT* :: dens_ba
      DBL :: cutoff
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      k_max = size(k_pts,1)
      res = ZERO
      cutoff = TOL(10) / .n_shell_pairs
      do q = 1,.n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
         if (shell.skip_ft(cutoff)) then
           shell.destroy_ptr_part
           cycle
         end
         ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp)
         .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
         dens_ba => dens(fb:lb,fa:la)
         if (a/=b) ft_ab = TWO * ft_ab ! count off-diagonals twice.
         do k = 1,k_max
            res(k) = res(k) + ft_ab(k,:,:).trace_of_product(dens_ba)
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
   end

  make_ft_deriv_U(res,dens,k_pts)
  ! Fourier transform of a density described by AO density matrix dens
  ! evaluated at a series of reciprocal space points k_pts
  ! Size of res is [k_max,n_atom*6]
    MAT, target :: dens
    MAT, IN :: k_pts
    CMAT, target :: res
    CDBL :: ft_ab2,tmp1,tmp2
    INT :: k_max,k,fa,fb,la,lb,q,a,b,atom_a,atom_b,basea,baseb
    DBL :: delta,g,separation,x,y,z
    SHELL2 :: shell
    CMAT3* :: ft_ab
    MAT* :: dens_ba
    DBL :: cutoff
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    k_max = size(k_pts,1)
    res = ZERO
    cutoff = TOL(10) / .n_shell_pairs
    do q = 1, .n_shell_pairs
      .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
      if (shell.skip_ft(cutoff)) then
        shell.destroy_ptr_part
        cycle
      end
      ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp)
      .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
      dens_ba => dens(fb:lb,fa:la)
      if (a/=b) ft_ab = TWO * ft_ab ! count off-diagonals twice.

      separation = (.atom(atom_a).pos-.atom(atom_b).pos).norm
      g=HALF
      if (separation > 2.5d0) g=QUARTER
      g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

      basea = (atom_a-1) * 6
      if (atom_a == atom_b) then
        delta = TWO * g
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba) * delta
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          tmp1 = ft_ab2 * x
          tmp2 = ft_ab2 * y
          res(basea+1,k) = res(basea+1,k) + tmp1 * x
          res(basea+2,k) = res(basea+2,k) + tmp1 * y * TWO
          res(basea+3,k) = res(basea+3,k) + tmp1 * z * TWO
          res(basea+4,k) = res(basea+4,k) + tmp2 * y
          res(basea+5,k) = res(basea+5,k) + tmp2 * z * TWO
          res(basea+6,k) = res(basea+6,k) + ft_ab2 * z * z
        end
      else
        baseb = (atom_b-1) * 6
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba) * g
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          tmp1 = ft_ab2 * x
          tmp2 = ft_ab2 * y
          res(basea+1,k) = res(basea+1,k) + tmp1 * x
          res(basea+2,k) = res(basea+2,k) + tmp1 * y * TWO
          res(basea+3,k) = res(basea+3,k) + tmp1 * z * TWO
          res(basea+4,k) = res(basea+4,k) + tmp2 * y
          res(basea+5,k) = res(basea+5,k) + tmp2 * z * TWO
          res(basea+6,k) = res(basea+6,k) + ft_ab2 * z * z
          res(baseb+1,k) = res(baseb+1,k) + tmp1 * x
          res(baseb+2,k) = res(baseb+2,k) + tmp1 * y * TWO
          res(baseb+3,k) = res(baseb+3,k) + tmp1 * z * TWO
          res(baseb+4,k) = res(baseb+4,k) + tmp2 * y
          res(baseb+5,k) = res(baseb+5,k) + tmp2 * z * TWO
          res(baseb+6,k) = res(baseb+6,k) + ft_ab2 * z * z
        end
      end
      ft_ab.destroy
      shell.destroy_ptr_part
    end
  end

  make_ft_deriv_U(res,dens,k_pts)
  ! Fourier transform of a density described by AO density matrix dens
  ! evaluated at a series of reciprocal space points k_pts
  ! Size of res is [k_max,n_atom*6]
    CMAT, target :: dens
    MAT, IN :: k_pts
    CMAT, target :: res
    CDBL :: ft_ab2,tmp1,tmp2
    INT :: k_max,k,fa,fb,la,lb,q,a,b,atom_a,atom_b,basea,baseb
    DBL :: delta,g,separation,x,y,z
    SHELL2 :: shell
    CMAT3* :: ft_ab
    CMAT* :: dens_ba
    DBL :: cutoff
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    k_max = size(k_pts,1)
    res = ZERO
    cutoff = TOL(10) / .n_shell_pairs
    do q = 1, .n_shell_pairs
      .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
      if (shell.skip_ft(cutoff)) then
        shell.destroy_ptr_part
        cycle
      end
      ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp)
      .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
      dens_ba => dens(fb:lb,fa:la)
      if (a/=b) ft_ab = TWO * ft_ab ! count off-diagonals twice.

      separation = (.atom(atom_a).pos-.atom(atom_b).pos).norm
      g=HALF
      if (separation > 2.5d0) g=QUARTER
      g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

      basea = (atom_a-1) * 6
      if (atom_a == atom_b) then
        delta = TWO * g
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba) * delta
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          tmp1 = ft_ab2 * x
          tmp2 = ft_ab2 * y
          res(basea+1,k) = res(basea+1,k) + tmp1 * x
          res(basea+2,k) = res(basea+2,k) + tmp1 * y
          res(basea+3,k) = res(basea+3,k) + tmp1 * z
          res(basea+4,k) = res(basea+4,k) + tmp2 * y
          res(basea+5,k) = res(basea+5,k) + tmp2 * z
          res(basea+6,k) = res(basea+6,k) + ft_ab2 * z * z
        end
      else
        baseb = (atom_b-1) * 6
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba) * g
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          tmp1 = ft_ab2 * x
          tmp2 = ft_ab2 * y
          res(basea+1,k) = res(basea+1,k) + tmp1 * x
          res(basea+2,k) = res(basea+2,k) + tmp1 * y
          res(basea+3,k) = res(basea+3,k) + tmp1 * z
          res(basea+4,k) = res(basea+4,k) + tmp2 * y
          res(basea+5,k) = res(basea+5,k) + tmp2 * z
          res(basea+6,k) = res(basea+6,k) + ft_ab2 * z * z
          res(baseb+1,k) = res(baseb+1,k) + tmp1 * x
          res(baseb+2,k) = res(baseb+2,k) + tmp1 * y
          res(baseb+3,k) = res(baseb+3,k) + tmp1 * z
          res(baseb+4,k) = res(baseb+4,k) + tmp2 * y
          res(baseb+5,k) = res(baseb+5,k) + tmp2 * z
          res(baseb+6,k) = res(baseb+6,k) + ft_ab2 * z * z
        end
      end
      ft_ab.destroy
      shell.destroy_ptr_part
    end
  end

  make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
  ! Make_ft for one pair of gaussians.
  ! Includes partitioning, dispersion and thermal smearing.
     CMAT3 :: ft_ab
     MAT, IN :: k_pts
     SHELL2, IN :: shell
     INT, IN :: atom_a,atom_b
     MAT3* :: t
     MAT* :: p
     INT :: k_max
     ENSURE(.crystal.created,"no crystal data")
     k_max = size(k_pts,1)
     t.create(k_max,shell.a.n_cc,shell.b.n_cc)
     .thermal_smearing_correction(t,k_pts,atom_a,atom_b,shell)
     p.create(shell.a.n_cc,shell.b.n_cc)
     .make_partition_factors(p,shell,atom_a,atom_b)
     shell.make_ft(ft_ab,k_pts,t,p)
     p.destroy
     t.destroy
  end

  make_partition_factors(p,shell,atom_a,atom_b)
  ! Make the partitition factors "p" for a particular thermal smearing "model",
  ! for a given "shell" pair with atom centres "atom_a" and "atom_b".
     MAT :: p
     SHELL2, IN :: shell
     INT, IN :: atom_a,atom_b
     DBL :: ra,rb,fa,fb
     ENSURE(.crystal.created,"no crystal data")
     ra = .crystal.repetition_factor(atom_a)
     rb = .crystal.repetition_factor(atom_b)
     if (ra<1) then; fa = ZERO
     else;           fa = ONE/ra
     end
     if (rb<1) then; fb = ZERO
     else;           fb = ONE/rb
     end
     select case (trim(.crystal.partition_model))
        case ("","none")
           p = ONE
        case ("mulliken")
           p = HALF * (fa + fb)
        case ("gaussian")
           shell.make_gaussian_partition(p,fa,fb)
        case default
           DIE("Unknown partition method : " // trim(.crystal.partition_model))
     end
  end

  thermal_smearing_correction(res,k_pts,a,b,shell)
  ! Makes the thermal smearing correction term.  Note that res
  ! is done over the contraction coefficients.
  ! Dimensions of "res" are [k_max,.a.n_cc,.b.n_cc].
    MAT3, OUT :: res
    MAT, IN :: k_pts
    INT, IN :: a,b
    SHELL2, IN :: shell
    MAT(3,3) :: Ua,Ub,Uab
    VEC(3) :: S,US
    INT :: k_max,k
    DBL :: separation,bondlength,Ta,Tb,g

    k_max = size(k_pts,1)
    select case (trim(.crystal.thermal_smearing_model))
      case ("","none")
        res = ONE
      case ("coppens") ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
        Ua = -HALF * .atom(a).thermal_tensor
        Ub = -HALF * .atom(b).thermal_tensor
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Ua,S)
           Ta = dot_product(S,US)
           US = matmul(Ub,S)
           Tb = dot_product(S,US)
           res(k,:,:) = HALF*(exp(Ta)+exp(Tb))
        end
      case ("stewart") ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4
        bondlength=2.5
        Ua = .atom(a).thermal_tensor
        Ub = .atom(b).thermal_tensor
        Uab = Ua + Ub
        separation = (.atom(a).pos-.atom(b).pos).norm
        g=HALF
        if (separation > bondlength) g=QUARTER
        Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Uab,S)
           Ta = dot_product(S,US)
           res(k,:,:) = exp(Ta)
        end
      case ("tanaka") ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
        Ua = .atom(a).thermal_tensor
        Ub = .atom(b).thermal_tensor
        shell.make_tanaka_thermal_smearing(res,k_pts,Ua,Ub)
      case default
        DIE("unknown thermal smearing model.")
    end
  end

  ft_thermally_smear(ft_ab,k_pts,a,b)
  ! Thermally smear the fourier transform integrals "ft_ab" evaluated
  ! on "k_pts" for shell pair (ab) centered on atoms "a" and "b" .
    INT :: a,b
    MAT :: k_pts
    CMAT3 :: ft_ab
    MAT(3,3) :: Ua,Ub,Uab
    VEC(3) :: S,US
    DBL :: separation,bondlength,Ta,Tb,g
    INT :: k,k_max
    k_max = size(k_pts,1)
    select case (trim(.crystal.thermal_smearing_model))
      case ("")
      case ("coppens") ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
        Ua = -HALF * .atom(a).thermal_tensor
        Ub = -HALF * .atom(b).thermal_tensor
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Ua,S)
           Ta = dot_product(S,US)
           US = matmul(Ub,S)
           Tb = dot_product(S,US)
           ft_ab(k,:,:) = ft_ab(k,:,:) * HALF*(exp(Ta)+exp(Tb))
        end
      case ("stewart") ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4
        bondlength=2.5
        Ua = .atom(a).thermal_tensor
        Ub = .atom(b).thermal_tensor
        Uab = Ua + Ub
        separation = (.atom(a).pos-.atom(b).pos).norm
        g=HALF
        if (separation > bondlength) g=QUARTER
        Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Uab,S)
           Ta = dot_product(S,US)
           ft_ab(k,:,:) = exp(Ta)*ft_ab(k,:,:)
        end
      case ("tanaka") ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
        DIE("cannot thermally smear at contracted level.")
      case default
        DIE("unknown thermal smearing model.")
    end
  end

  add_dispersion_correction(ft,k_pts)
  ! Adds the dispersion correction.
    MAT :: k_pts
    CVEC :: ft
    CDBL :: disp,phase
    VEC(3) :: pos
    MAT(3,3) :: U
    VEC(3) :: S,US
    DBL :: x,y,z,T
    INT :: n,k,k_max

    if (.crystal.correct_dispersion) then
      select case (trim(.crystal.thermal_smearing_model))
        case ("")
          do n=1,.n_atom
            pos = .atom(n).pos
            x = pos(1); y = pos(2); z = pos(3)
            disp = .atom(n).dispersion_correction(.crystal.wavelength)
            ft(:) = ft(:) + disp * exp(cmplx(ZERO,(k_pts(:,1)*x + k_pts(:,2)*y + k_pts(:,3)*z)))
          end
        case default ! thermal smearing methods collapse to be the same
                     ! when dealing with one atom.
          k_max = size(k_pts,1)
          do n=1,.n_atom
            U = -HALF * self.atom(n).thermal_tensor
            pos = .atom(n).pos
            x = pos(1); y = pos(2); z = pos(3)
            disp = .atom(n).dispersion_correction(.crystal.wavelength)
            do k = 1,k_max
              S = k_pts(k,:)
              US = matmul(U,S)
              T = (dot_product(S,US))
              phase = exp(cmplx(T,(k_pts(k,1)*x + k_pts(k,2)*y + k_pts(k,3)*z)))
              ft(k) = ft(k) + disp * phase
            end
          end
      end
    end
  end

  get_ft_ints
  ! Get the fourier transform of the overlap integrals.
  ! If the archive file exists, read it; otherwise make it.
     ARCHIVE :: archive
     archive.set(.name,"ft_ints")
     if (NOT archive.exists) .make_ft_ints
  end

   make_ft_ints
   ! Make the fourier transform of the overlap integrals on an archive file
      ARCHIVE :: archive
      MAT* :: k_pts
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
      SHELL2* :: shell
      CMAT3* :: ft_ab_eq,ft_ab

      ENSURE(.crystal.created, "no crystal")
      archive.set(.name,"ft_ints")
      archive.open(for="write-only",buffered=TRUE,type="cdbl")
      k_pts.create(.crystal.n_unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell.a.n_comp,shell.b.n_comp)
         ft_ab.create(.crystal.n_refl,shell.a.n_comp,shell.b.n_comp)
         .make_ft_pair(ft_ab_eq,k_pts,shell,atom_a,atom_b)
         .crystal.sum_ft_ints(ft_ab,ft_ab_eq)
         archive.file.write(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

   make_structure_factors
   ! Make the structure factors for this molecule.
      CVEC* :: sf_eq,Fc
      MAT* :: k_pts
      ARCHIVE :: archive
      BIN :: complex
      ENSURE(.crystal.created, "no crystal")
      ENSURE(.crystal.reflection_data_exists, "no reflection data")
      ENSURE(.density_matrix.created, "no density matrix")
      Fc.create(.crystal.n_refl)
      k_pts.create(.crystal.n_unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      sf_eq.create(size(k_pts,1))
      .make_ao_density_matrix
      complex = .density_matrix.spinorbital_kind.includes("complex")
      if (complex) then
        .make_ft(sf_eq,.density_matrix.restricted_complex,k_pts)
      else
        .make_ft(sf_eq,.density_matrix.restricted,k_pts)
      end
!     .add_dispersion_correction(sf_eq,k_pts)
      .crystal.sum_unique_sf(Fc,sf_eq)
      sf_eq.destroy
      k_pts.destroy
      .crystal.set_F_calc(Fc)
      .crystal.make_F_predicted
      archive.set(.name,"structure_factors")
      archive.write(Fc)
      Fc.destroy
   end

   get_structure_factors
   ! Get the structure factors on disk or remake if they don't already exist
     ARCHIVE :: archive
     CVEC, PTR :: Fc
     archive.set(.name,"structure_factors")
     if (archive.exists) then
        ENSURE(.crystal.created, "no crystal")
        ENSURE(.crystal.reflection_data_exists, "no reflection data")
        Fc.create(.crystal.n_refl)
        archive.read(Fc)
        .crystal.set_F_calc(Fc)
        Fc.destroy
     else
        .make_structure_factors
     end
   end

   make_sz_structure_factors
   ! Make the structure factors for this molecule.
      CVEC* :: sf_eq,Fc
      MAT* :: k_pts
      ARCHIVE :: archive
      BIN :: complex
      ENSURE(.crystal.created, "no crystal")
      ENSURE(.crystal.reflection_data_exists, "no reflection data")
      Fc.create(.crystal.n_refl)
      k_pts.create(.crystal.n_unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      sf_eq.create(size(k_pts,1))
      .make_ao_sz_density_matrix
      complex = .density_matrix.spinorbital_kind.includes("complex")
      if (complex) then
        .make_ft(sf_eq,.density_matrix.restricted_complex,k_pts)
      else
        .make_ft(sf_eq,.density_matrix.restricted,k_pts)
      end
      .crystal.sum_unique_sf(Fc,sf_eq)
      .crystal.set_F_calc(Fc)
      sf_eq.destroy
      k_pts.destroy
      .crystal.make_F_predicted
      archive.set(.name,"sz_structure_factors")
      archive.write(Fc)
      Fc.destroy
   end

   make_PND_scalar_magnetic_sf
   ! Make the PND scalar magnetic structure factors and assign them
   ! To the crystal objects structure factors for analysis
      CVEC* :: FM_s, FM_l, FM_r, Fc
      INT :: n_refl
      ARCHIVE :: archive
      ENSURE(.crystal.created, "no crystal")
      ENSURE(.crystal.reflection_data_exists, "no reflection data")
      n_refl = .crystal.n_refl
      Fc.create(n_refl)
      ! Spin contribution
      .make_PND_spin_sf
      FM_s.create(n_refl)
      archive.set(.name,"PND_spin_sf")
      archive.read(FM_s)
      ! Orbital contribution
      .make_PND_nabla_sf
      FM_l.create(n_refl)
      archive.set(.name,"PND_nabla_sf")
      archive.read(FM_l)
      ! Diamagnetic contribution
    ! .make_PND_r_sf
    ! FM_r.create(n_refl)
    ! archive.set(.name,"PND_r_sf")
    ! archive.read(FM_r)
      ! Make F_calc
      Fc = FM_s + FM_l ! + FM_r
      archive.set(.name,"PND_scalar_magnetic_sf")
      archive.write(Fc)
      .crystal.set_F_calc(Fc)
      .crystal.make_F_predicted
      FM_r.destroy
      FM_l.destroy
      FM_s.destroy
      Fc.destroy
   end

   make_PND_spin_sf
   ! Make the scalar spin magnetic structure factors assuming an applied field
   ! in the z direction
      ARCHIVE :: archive
      DBL :: fac,ans
      CMAT* :: d_aa,d_bb,d_ba
      CMAT4* :: ft_ab
      CVEC* :: FM
      CDBL :: ci
      SHELL2* :: shell
      INT :: k_max,i,q,a,b,fa,la,fb,lb
      ENSURE(.crystal.created, "no crystal")
      archive.set(.name,"PND_ft_spin_ints")
      if (NOT archive.exists) .make_PND_ft_spin_ints
      archive.open(for="read-only",type="dbl")
      ci = (ZERO,ONE)
      k_max = .crystal.n_refl
      FM.create(k_max)
      FM = ZERO
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb)
         ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp,3)
         archive.file.read(ft_ab)
         d_aa => .density_matrix.general_complex(      fb:      lb,      fa:      la)
         d_bb => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         d_ba => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,      fa:      la)
         fac = TWO
         if (a==b) fac=ONE
         do i = 1,k_max
            ans =          ft_ab(i,:,:,1).trace_of_product(d_ba)
            ans = ans - ci*ft_ab(i,:,:,2).trace_of_product(d_ba)
            ans = ans +    ft_ab(i,:,:,3).trace_of_product(d_aa)
            ans = ans -    ft_ab(i,:,:,3).trace_of_product(d_bb)
            FM(i) = FM(i) + fac*ans
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close
      archive.set(.name,"PND_spin_sf")
      archive.write(FM)
      FM.destroy
   end

   get_PND_ft_spin_ints
   ! Get the PND ft spin integrals on disk if they don't already exist
      ARCHIVE :: archive
      archive.set(.name,"PND_ft_spin_ints")
      if (NOT archive.exists) .make_PND_ft_spin_ints
   end

   make_PND_ft_spin_ints
   ! Make the fourier transform of the PND spin integrals on the archive
      ARCHIVE :: archive
      MAT* :: k_pts
      SHELL2* :: shell
      CMAT3* :: ft_ab_eq
      CMAT4* :: ft_ab
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
      ENSURE(.crystal.created, "no crystal")
      archive.set(.name,"PND_ft_spin_ints")
      archive.open(for="write-only",type="cdbl")
      k_pts.create(.crystal.n_unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell.a.n_comp,shell.b.n_comp)
         .make_ft_pair(ft_ab_eq,k_pts,shell,atom_a,atom_b)
         ft_ab.create(.crystal.n_refl,shell.a.n_comp,shell.b.n_comp,3)
         .crystal.sum_PND_spin_ints(ft_ab,ft_ab_eq)
         archive.file.write(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

   make_PND_nabla_sf
   ! Make the scalar nabla magnetic structure factors assuming an applied field
   ! in the z direction
      ARCHIVE :: archive
      DBL :: fac
      CMAT* :: dens
      CMAT3* :: ft_ab_z
      CVEC* :: FM
      SHELL2* :: shell
      INT :: k_max,i,q,a,b,fa,la,fb,lb
      ENSURE(.crystal.created, "no crystal")
      archive.set(.name,"PND_ft_nabla_ints")
      if (NOT archive.exists) .make_PND_ft_nabla_ints
      archive.open(for="read-only",type="dbl")
      k_max = .crystal.n_refl
      FM.create(k_max)
      FM = ZERO
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb)
         ft_ab_z.create(k_max,shell.a.n_comp,shell.b.n_comp)
         archive.file.read(ft_ab_z)
         dens.create(shell.b.n_comp,shell.a.n_comp)
         dens =        .density_matrix.general_complex(      fb:      lb,      fa:      la)
         dens = dens + .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         fac = TWO
         if (a==b) fac=ONE
         do i = 1,k_max
            FM(i) = FM(i) + fac*ft_ab_z(i,:,:).trace_of_product(dens)
         end
         dens.destroy
         ft_ab_z.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close
      archive.set(.name,"PND_nabla_sf")
      archive.write(FM)
      FM.destroy
   end

   get_PND_ft_nabla_ints
   ! Get the PND ft nabla integrals on disk if they don't already exist
      ARCHIVE :: archive
      archive.set(.name,"PND_ft_nabla_ints")
      if (NOT archive.exists) .make_PND_ft_nabla_ints
   end

   make_PND_ft_nabla_ints
   ! Make the fourier transform of the nabla integrals on the archive
      ARCHIVE :: archive
      MAT* :: k_pts
      SHELL2* :: shell
      CMAT4* :: ft_ab_eq
      CMAT3* :: ft_ab_z
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
      ENSURE(.crystal.created, "no crystal")
      archive.set(.name,"PND_ft_nabla_ints")
      archive.open(for="write-only",type="cdbl")
      k_pts.create(.crystal.n_unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell.a.n_comp,shell.b.n_comp,3)
         .make_ft_nabla_pair(ft_ab_eq,k_pts,shell,atom_a,atom_b)
       ! shell.make_ft_nabla(ft_ab_eq,k_pts)
       ! .ft_thermally_smear(ft_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
       ! .ft_thermally_smear(ft_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
       ! .ft_thermally_smear(ft_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
         ft_ab_z.create(.crystal.n_refl,shell.a.n_comp,shell.b.n_comp)
         .crystal.sum_PND_nabla_ints(ft_ab_z,ft_ab_eq)
         archive.file.write(ft_ab_z)
         ft_ab_z.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

  make_ft_nabla_pair(ft_ab,k_pts,shell,atom_a,atom_b)
  ! Make_ft for one pair of gaussians.
  ! Includes partitioning, dispersion and thermal smearing.
     CMAT4 :: ft_ab
     MAT, IN :: k_pts
     SHELL2, IN :: shell
     INT, IN :: atom_a,atom_b
     MAT3* :: t
     MAT* :: p
     INT :: k_max
     ENSURE(.crystal.created,"no crystal data")
     k_max = size(k_pts,1)
     t.create(k_max,shell.a.n_cc,shell.b.n_cc)
     .thermal_smearing_correction(t,k_pts,atom_a,atom_b,shell)
     p.create(shell.a.n_cc,shell.b.n_cc)
     .make_partition_factors(p,shell,atom_a,atom_b)
     shell.make_ft_nabla(ft_ab,k_pts,t,p)
     p.destroy
     t.destroy
  end

   make_PND_r_sf
   ! Make the scalar dipole magnetic structure factors assuming an applied field
   ! in the z direction
      ARCHIVE :: archive
      DBL :: fac,ans
      CMAT* :: d_aa,d_bb
      CMAT4* :: ft_ab
      CVEC* :: FM
      SHELL2* :: shell
      INT :: k_max,i,q,a,b,fa,la,fb,lb
      ENSURE(.crystal.created, "no crystal")
      archive.set(.name,"PND_ft_r_ints")
      if (NOT archive.exists) .make_PND_ft_r_ints
      archive.open(for="read-only",type="dbl")
      k_max = .crystal.n_refl
      FM.create(k_max)
      FM = ZERO
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb)
         ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp,3)
         archive.file.read(ft_ab)
         d_aa => .density_matrix.general_complex(      fb:      lb,      fa:      la)
         d_bb => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         fac = TWO
         if (a==b) fac=ONE
         do i = 1,k_max
            ans =       fac*ft_ab(i,:,:,3).trace_of_product(d_aa)
            ans = ans + fac*ft_ab(i,:,:,3).trace_of_product(d_bb)
            FM(i) = FM(i) + ans
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close
      archive.set(.name,"PND_r_sf")
      archive.write(FM)
      FM.destroy
   end

   get_PND_ft_r_ints
   ! Get the PND ft r integrals on disk if they don't already exist
      ARCHIVE :: archive
      archive.set(.name,"PND_ft_r_ints")
      if (NOT archive.exists) .make_PND_ft_r_ints
   end

   make_PND_ft_r_ints
   ! Make the fourier transform of the dipole "r" integrals on the archive
      ARCHIVE :: archive
      MAT* :: k_pts
      SHELL2* :: shell
      CMAT4* :: ft_ab_eq, ft_ab
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b,n_refl
      ENSURE(.crystal.created, "no crystal")
      ENSURE(.crystal.reflection_data_exists, "no structure factor data")
      n_refl = .crystal.n_refl
      archive.set(.name,"PND_ft_r_ints")
      archive.open(for="write-only",type="cdbl")
      k_pts.create(.crystal.n_unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell.a.n_comp,shell.b.n_comp,3)
         shell.make_ft_r(ft_ab_eq,k_pts)
         .ft_thermally_smear(ft_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
         ft_ab.create(n_refl,shell.a.n_comp,shell.b.n_comp,3)
         .crystal.sum_ft_r_ints(ft_ab,ft_ab_eq,.B_field)
         archive.file.write(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

   make_PND_fit_ints(ints,lambda)
   ! Make the PND constraint integrals on the archive
      CMAT, target :: ints
      DBL :: lambda
      ARCHIVE :: spin_archive,nabla_archive
      VEC* :: Fc,F_exp,F_sigma
      CMAT* :: ints_aa,ints_bb,ints_ba
      CMAT3* :: nabla_z
      CMAT4* :: spin
      SHELL2* :: shell
      CDBL :: ci
      DBL :: fac,fac1
      INT :: i,q,a,b,fa,la,fb,lb
      INT :: n_bf,n_refl
      .get_PND_ft_spin_ints
      .get_PND_ft_nabla_ints
      .get_PND_ft_r_ints
      spin_archive.set(.name,"PND_ft_spin_ints")
      nabla_archive.set(.name,"PND_ft_nabla_ints")
    ! r_archive.set(.name,"PND_ft_r_ints")
      spin_archive.open(for="read-only",type="dbl")
      nabla_archive.open(for="read-only",type="dbl")
    ! r_archive.open(for="read-only",type="dbl")
      ci = (ZERO,ONE)
      n_bf   =  .n_bf
      n_refl =  .crystal.n_refl
      Fc.create(n_refl)
      F_exp.create(n_refl)
      F_sigma.create(n_refl)
      Fc = abs(.crystal.F_calc)
      F_exp  = .crystal.F_exp
      F_sigma  = .crystal.F_sigma
      ints = ZERO
      shell.create
      fac1 = TWO*lambda/n_refl
      do q = 1,.n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb)
         spin.create(n_refl,shell.a.n_comp,shell.b.n_comp,3)
         spin_archive.file.read(spin)
         ints_aa => ints(     fa:     la,     fb:     lb)
         ints_bb => ints(n_bf+fa:n_bf+la,n_bf+fb:n_bf+lb)
         ints_ba => ints(n_bf+fa:n_bf+la,     fb:     lb)
         do i = 1,n_refl
            fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i))
            ints_ba = ints_ba +    fac*spin(i,:,:,1)
            ints_ba = ints_ba + ci*fac*spin(i,:,:,2)
            ints_aa = ints_aa +    fac*spin(i,:,:,3)
            ints_bb = ints_bb -    fac*spin(i,:,:,3)
         end
         spin.destroy
         nabla_z.create(n_refl,shell.a.n_comp,shell.b.n_comp)
         nabla_archive.file.read(nabla_z)
         do i = 1,n_refl
            fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i))
            ints_aa = ints_aa + fac*nabla_z(i,:,:)
            ints_bb = ints_bb + fac*nabla_z(i,:,:)
         end
         nabla_z.destroy
       ! r.create(n_refl,shell.a.n_comp,shell.b.n_comp,3)
       ! r_archive.file.read(r)
       ! do i = 1,n_refl
       !    fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i)*)
       !    ints_aa = ints_aa + fac*r(i,:,:,3)
       !    ints_bb = ints_bb + fac*r(i,:,:,3)
       ! end
       ! r.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      ints.make_hermitian
    ! r_archive.close
      nabla_archive.close
      spin_archive.close
      F_sigma.destroy
      F_exp.destroy
      Fc.destroy
   end

!  ****************
!  Symmetry methods
!  ****************

   symmetrise(mat,kind)
   ! Symmetrise an opmat matrix "mat" of spinorbital_kind "kind" (if specified)
      OPMAT :: mat
      STR, optional :: kind
      STR :: itemkind
      itemkind = mat.spinorbital_kind
      if (present(kind)) itemkind = kind
      select case (itemkind)
         case ("restricted");           .symmetrise_r(mat.restricted)
         case ("unrestricted");         .symmetrise_r(mat.alpha)
                                        .symmetrise_r(mat.beta)
         case ("general");              .symmetrise_r(mat.general.alpha_alpha)
                                        .symmetrise_r(mat.general.beta_beta)
                                        .symmetrise_r(mat.general.alpha_beta)
                                        .symmetrise_r(mat.general.beta_alpha)
         case ("restricted_complex");   .symmetrise_c(mat.restricted_complex)
         case ("unrestricted_complex"); .symmetrise_c(mat.alpha_complex)
                                        .symmetrise_c(mat.beta_complex)
         case ("general_complex");      .symmetrise_c(mat.general_complex.alpha_alpha)
                                        .symmetrise_c(mat.general_complex.beta_beta)
                                        .symmetrise_c(mat.general_complex.alpha_beta)
                                        .symmetrise_c(mat.general_complex.beta_alpha)
         case default; DIE("unknown spinorbital kind, " // trim(kind))
      end
   end

   symmetrise_r(mat)
   ! Symmetrise a real restricted basis kind matrix
      MAT :: mat
      MAT* :: sym,w
      MAT,  PTR :: tra,trb
      SHELL* :: sh
      INT :: n_bf,dim1,dim2,n,a,b,i,j,na,nb
      INT :: fa,fb,fi,fj,la,lb,li,lj
      IVEC* :: first,last
      IMAT* :: image
      dim1 = size(mat,1)
      dim2 = size(mat,2)
      n_bf = .n_bf
      ENSURE(.atom.created,"no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(dim1==n_bf,"incorrectly dimensioned matrix")
      first => .first_basis_fn_for_shell
      last  => .last_basis_fn_for_shell
      image.create(.n_shell, .pointgroup.order)
      .make_image_of_shell(image)
      sym.create(n_bf,n_bf)
      sym = ZERO
      sh.create
      do n = 1,.pointgroup.order
         do a = 1,.n_shell
            .get_shell(sh,a); na = sh.n_comp; la = sh.l; sh.destroy_ptr_part
            tra => .pointgroup.xyz_matrix(n,la)
            i = image(a,n)
            fa = first(a);  la = last(a); fi = first(i);  li = last(i)
            do b = 1,.n_shell
               .get_shell(sh,b); nb = sh.n_comp; lb = sh.l; sh.destroy_ptr_part
               trb => .pointgroup.xyz_matrix(n,lb)
               j = image(b,n)
               fb = first(b);  lb = last(b); fj = first(j);  lj = last(j)
               w.create(na,nb)
               w = matmul(tra, mat(fa:la,fb:lb) )
               sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + matmul(w,transpose(trb))
               w.destroy
               trb.destroy
            end
            tra.destroy
         end
      end
      sh.destroy
      mat = sym/.pointgroup.order
      sym.destroy
      image.destroy
   end

   symmetrise_c(mat)
   ! Symmetrise a complex restricted basis kind matrix
      CMAT :: mat
      CMAT* :: sym,w
      MAT,  PTR :: tra,trb
      SHELL* :: sh
      INT :: n_bf,dim1,dim2,n,a,b,i,j,na,nb
      INT :: fa,fb,fi,fj,la,lb,li,lj
      IVEC* :: first,last
      IMAT* :: image
      dim1 = size(mat,1)
      dim2 = size(mat,2)
      n_bf = .n_bf
      ENSURE(.atom.created,"no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(dim1==n_bf,"incorrectly dimensioned matrix")
      first => .first_basis_fn_for_shell
      last  => .last_basis_fn_for_shell
      image.create(.n_shell, .pointgroup.order)
      .make_image_of_shell(image)
      sym.create(n_bf,n_bf)
      sym = ZERO
      sh.create
      do n = 1,.pointgroup.order
         do a = 1,.n_shell
            .get_shell(sh,a); na = sh.n_comp; la = sh.l; sh.destroy_ptr_part
            tra => .pointgroup.xyz_matrix(n,la)
            i = image(a,n)
            fa = first(a);  la = last(a); fi = first(i);  li = last(i)
            do b = 1,.n_shell
               .get_shell(sh,b); nb = sh.n_comp; lb = sh.l; sh.destroy_ptr_part
               trb => .pointgroup.xyz_matrix(n,lb)
               j = image(b,n)
               fb = first(b);  lb = last(b); fj = first(j);  lj = last(j)
               w.create(na,nb)
               w = matmul(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + matmul(w,transpose(trb))
               w.destroy
               trb.destroy
            end
            tra.destroy
         end
      end
      sh.destroy
      mat = sym/.pointgroup.order
      sym.destroy
      image.destroy
   end

   make_image_of_shell(res)
   ! Return an array "res(a,n)" which is the image of shell "a" under pointgroup
   ! operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      IMAT, OUT :: res
      VEC(3) :: new_pos
      INT :: n,a,aa,as,new_atom,fs
      ENSURE(size(res,1) == .n_shell, "dimension of matrix incorrect")
      ENSURE(size(res,2) == .pointgroup.order, "dimension of matrix incorrect")
      do n = 1,.pointgroup.order
         do a = 1,.n_shell
            aa = .atom_for_shell(a)
            as = .atom_shell_for_shell(a)
            new_pos = matmul(.pointgroup.mat(:,:,n), .atom(aa).pos)
            new_atom = .atom.atom_index_from_pos(new_pos)
            fs = .first_shell_for_atom(new_atom)
            res(a,n) = fs+as-1
         end
      end
   end

!  ************
!  I/O routines
!  ************

  read_repetition_factors
  ! Useful to get structure factor contributions from a small portion of the
  ! cluster.
    INT :: n
    STR :: word
    ENSURE(.crystal.created,"no crystal information")
    ENSURE(.crystal.repetition_factor.created,"no repetition factors defined")
    do n=1,size(.crystal.repetition_factor)
      stdin.read(.crystal.repetition_factor(n))
    end
    stdin.read(word)
    word.to_lower_case
    ENSURE(word=='end','expecting "end" keyword')
  end

   read_multiplicity
   ! Read in the spin multiplicity
      stdin.read(.mult)
      ENSURE(.mult/=0,"cannot have zero multiplicity")
   end

   read_gauge_origin
   ! Read in the gauge origin vector for an applied external magnetic field
      stdin.read(.gauge_origin)
      .delete_gauge_integrals
   end

   delete_gauge_integrals
   ! Delete all integral files which depend on the gauge origin.
   ! This is required whenever the gauge origin is changed.
      ARCHIVE :: archive
      archive.set(.name,"Lx_matrix"); archive.delete
      archive.set(.name,"Ly_matrix"); archive.delete
      archive.set(.name,"Lz_matrix"); archive.delete
   end

   read_plotgrid [leaky]
   ! Read in the plot grid data
      if (.crystal.destroyed) then
        .grid.read(.atom)
      else if (.crystal.created) then
        .grid.read(.atom,.crystal)
      end
   end

   read_dftgrid [leaky]
   ! Read in the DFT grid data
      .dftgrid.destroy
      .dftgrid.create
      .dftgrid.read
      .dftgrid.archive.set_root_name(.name)
   end

   read_crystal [leaky]
   ! Read in the crystal data
      .crystal.destroy
      .crystal.create
      .crystal.read
      if (associated(.atom)) then
         .resolve_axis_system
         .crystal.make_reduced_group_data(.atom)
      end
   end

   read_pointgroup [leaky]
   ! Read in the pointgroup data
      .pointgroup.destroy
      .pointgroup.create
      .pointgroup.read
   end

   read_scfdata [leaky]
   ! Read in the scf data
      .scfdata.destroy
      .scfdata.create
      .scfdata.read
      if (.scfdata.using_diis) then
      .scfdata.diis.set_archive_root_name(.name)
      .scfdata.diis.set_archive_name("fock_matrix,DIIS")
      end
   end

   read_atoms [leaky]
   ! Read in the atom list information
      .atom.read
      DIE_IF(.atom.bases_are_part_labeled,"some empty basis labels exist")
      .resolve_basis_labels
      .set_atom_info
      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_reduced_group_data(.atom)
      end
   end

!  read_basis_labels
!  ! Read in a list of basis set labels for every atom in the molecule
!  ! If a basis set is defined, all atoms must have a resolved basis set
!     ENSURE(.atom.created,"no atoms in atom list")
!     .atom.read_basis_labels
!     .resolve_basis_labels
!  end

   read_basis_sets [leaky]
   ! Read in a list of atomic basis sets for the molecule
      .basis.read
      .resolve_basis_labels
   end

   read_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g.
   ! "restricted".
   ! For use with TONTO generated archives.
      STR :: name,kind
      ARCHIVE :: archive
      ENSURE(stdin.n_line_items==3, "must specify an archive and a kind")
      stdin.read(name)
      stdin.read(kind)
      stdout.text("reading archive : " // trim(name))
      archive.set(.name,name,kind)
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals)
         case ("density_matrix");     archive.read(.density_matrix)
         case ("orbital_energies");   archive.read(.orbital_energies)
         case ("natural_orbitals");   archive.read(.natural_orbitals)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("covalent_orbitals");  archive.read(.natural_orbitals)
         case ("ionic_orbitals");     archive.read(.natural_orbitals)
         case default;                DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_ascii_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g.
   ! "restricted".
   ! If required, the input order may be specified as "by_row" (default) or
   ! "by_column".
      STR :: name,kind,order
      ARCHIVE :: archive
      ENSURE(stdin.buffer.n_items==3, "must specify an archive and a kind")
      stdin.read(name)
      stdin.read(kind)
      order = "by_row"
      if (NOT stdin.buffer_exhausted) stdin.read(order)
      archive.set(.name,name,kind,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.read(.density_matrix,order=order)
         case ("orbital_energies");   archive.read(.orbital_energies)
         case ("natural_orbitals");   archive.read(.natural_orbitals,order=order)
         case ("occupation");         archive.read(.occupation)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("fock_matrix");        .fock_matrix.create("restricted")
                                      archive.read(.fock_matrix,order=order)
         case default; DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_g94_checkpoint_file [leaky]
   ! Read a g94 checkpoint file (after fchk conversion to ASCII) into TONTO
      STR :: name
      TEXTFILE* :: chkfile
      IVEC* :: shell_l, nps, shell_to_atom, e_atom
      IVEC* :: tmp_nps, tmp_sta, tmp_shells
      VEC* :: tmp_pe, tmp_cc
      VEC* :: pe, cc, extra_cc, temp_vec
      MAT* :: temp_mat
      OPMAT* :: temp_spin, temp_total
      BASIS* :: basis
      INT :: c, t, a, s, u, m1, m2, i,n_basis
      INT :: n_shell, n_comp, n_cc, nps_c
      BIN :: same
      ARCHIVE :: archive
      if (.basis.created) .basis.destroy
      if (.atom.created)  .atom.destroy
      name = trim(.name) // achar(46) // "FChk"        ! name.FChk or
      if (NOT stdin.buffer_exhausted) stdin.read(name) ! specified on stdin
      .scfdata.create

      ! Read in basic stuff.
      chkfile.create(name)
      chkfile.open_for_read
      chkfile.read_line
      chkfile.look_for("Number of atoms")
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)
      chkfile.look_for("Charge")
      chkfile.move_to_line_item(3); chkfile.read(.charge)
      chkfile.look_for("Multiplicity")
      chkfile.move_to_line_item(3); chkfile.read(.mult)
      chkfile.look_for("Number of electrons")
      chkfile.move_to_line_item(5); chkfile.read(.n_e)
      chkfile.look_for("Number of alpha electrons")
      chkfile.move_to_line_item(6); chkfile.read(.n_a)
      chkfile.look_for("Number of beta electrons")
      chkfile.move_to_line_item(6); chkfile.read(.n_b)
      chkfile.look_for("Number of basis functions")
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)
      chkfile.look_for("Number of contracted shells")
      chkfile.move_to_line_item(6); chkfile.read(.n_shell)
      chkfile.look_for("Number of primitive shells")
      chkfile.move_to_line_item(6); chkfile.read(.n_prim)
      chkfile.look_for("Total Energy")
      chkfile.move_to_line_item(4)
      chkfile.read_dbl(.scfdata.energy )
      chkfile.look_for("Atomic numbers"); chkfile.read_line
      .atom.create(.n_atom)
      do a = 1, .n_atom
         chkfile.read(.atom(a).atomic_number )
         .atom(a).label = trim(.atom(a).chemical_symbol) // trim(a.to_str)
      end
      chkfile.look_for("Current cartesian coordinates")
      chkfile.read_line
      do a = 1, .n_atom
         chkfile.read(.atom(a).pos)
      end

      ! Shell info.
      chkfile.look_for("Shell types"); chkfile.read_line
      tmp_shells.create(.n_shell); tmp_nps.create(.n_shell)
      tmp_sta.create(.n_shell); tmp_pe.create(.n_prim)
      tmp_cc.create(.n_prim)
      chkfile.read(tmp_shells)
      chkfile.look_for("Number of primitives per shell")
      chkfile.read_line; chkfile.read(tmp_nps)
      chkfile.look_for("Shell to atom map"); chkfile.read_line
      chkfile.read(tmp_sta)
      chkfile.look_for("Primitive exponents"); chkfile.read_line
      chkfile.read(tmp_pe)
      chkfile.look_for("Contraction coefficients"); chkfile.read_line
      chkfile.read(tmp_cc)
      e_atom.create(.n_atom); e_atom = ZERO
      extra_cc.create(.n_prim)
      if (any(tmp_shells == (-1) )) then
        do a = 1, .n_shell
           if (tmp_shells(a) == (-1)) then
              e_atom(tmp_sta(a)) = e_atom(tmp_sta(a)) + 1
              .n_prim = .n_prim + tmp_nps(a)
           end
        end
        chkfile.look_for("P(S=P)"); chkfile.read_line
        chkfile.read(extra_cc)
      end
      s = .n_shell + sum(e_atom)
      shell_l.create(s); nps.create(s)
      pe.create(.n_prim); cc.create(.n_prim)
      shell_to_atom.create(s)
      a = 0
      m1 = 1; m2 = 1
      do c = 1, .n_shell
        a = a + 1
        nps_c = tmp_nps(c)
        if (tmp_shells(c) == (-1)) then
           shell_l(a) = 0
           nps(a) = nps_c
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+nps_c-1) = tmp_pe(m2:m2+nps_c-1)
           cc(m1:m1+nps_c-1) = tmp_cc(m2:m2+nps_c-1)
           a = a+1; m1=m1+nps_c
           shell_l(a) = 1
           nps(a) = nps_c
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+nps_c-1) = tmp_pe(m2:m2+nps_c-1)
           cc(m1:m1+nps_c-1) = extra_cc(m2:m2+nps_c-1)
        else
           pe(m1:m1+nps_c-1) = tmp_pe(m2:m2+nps_c-1)
           cc(m1:m1+nps_c-1) = tmp_cc(m2:m2+nps_c-1)
           shell_l(a) = tmp_shells(c)
           nps(a) = nps_c
           shell_to_atom(a) = tmp_sta(c)
        end
        m1 = m1 + nps_c; m2 = m2 + nps_c
      end
      extra_cc.destroy
      tmp_shells.destroy; tmp_sta.destroy
      tmp_nps.destroy; tmp_pe.destroy; tmp_cc.destroy
      .n_shell = s
      c = 0      ! for recording number of primitives read
      t = 0      ! for recording number of shells read
      n_basis = 0
      .basis.create(n_basis)
      do a = 1, .n_atom
         basis.create
         basis.label = trim(.atom(a).label) // "_g94_basis"
         n_shell = count(shell_to_atom==a)
         basis.n_shell = n_shell
         basis.shell.create(n_shell)
         basis.shell.nullify_ptr_part
         do s = 1, n_shell
            n_comp = shell_l(t+s).n_comp
            n_cc = nps(t+s)
            basis.shell(s).l = shell_l(t+s)
            basis.shell(s).n_comp = n_comp
            basis.shell(s).n_cc = n_cc
            basis.shell(s).ex.create(n_cc )
            basis.shell(s).cc.create(n_cc )
            basis.shell(s).ex = pe(c+1 : c+n_cc )
            basis.shell(s).cc = cc(c+1 : c+n_cc )
            c = c + n_cc
         end
         basis.n_bf = basis.no_of_basis_functions
         basis.n_prim = basis.no_of_primitives
         basis.unnormalise
         t = t + n_shell
         same = FALSE
         do i = 1,n_basis
            if (.basis(i).same_as(basis)) then
               same = TRUE
               exit
            end
         end
         .atom(a).basis.create
         if (same) then
            .atom(a).basis.label = .basis(i).label
         else
            .atom(a).basis.label =  basis.label
            n_basis = n_basis + 1
            .basis.expand(n_basis)
            .basis(n_basis).copy(basis)
         end
         basis.destroy
      end
      pe.destroy; cc.destroy
      shell_to_atom.destroy; nps.destroy; e_atom.destroy
      shell_l.destroy
      .resolve_basis_labels
      .set_atom_info

      ! Read in orbital energies.
      temp_vec.create(.n_bf)
      chkfile.look_for("Alpha Orbital Energies")
      chkfile.read_line; chkfile.read(temp_vec)
      if (chkfile.next_str == "Beta") then
         u = 1
         .scfdata.kind = "uhf"
         .orbital_energies.create(.n_bf, "beta")
         chkfile.read_line; chkfile.read(.orbital_energies.beta)
         .orbital_energies.alpha => temp_vec
         nullify(temp_vec)
      else
         u = 0
         .scfdata.kind = "rhf"
         .orbital_energies.create(.n_bf)
         .orbital_energies.restricted => temp_vec
         nullify(temp_vec)
      end

      ! Read in molecular orbitals.
      temp_mat.create(.n_bf, .n_bf)
      chkfile.look_for("Alpha MO"); chkfile.read_line
      chkfile.read(temp_mat)
      temp_mat.to_transpose
      if (chkfile.next_str == "Beta") then
         .molecular_orbitals.create(.n_bf, "beta")
         chkfile.read_line; chkfile.read(.molecular_orbitals.beta)
         .molecular_orbitals.beta.to_transpose
         .molecular_orbitals.alpha => temp_mat
         nullify(temp_vec)
         .swap_g94_orbital_order(.molecular_orbitals.alpha,"row")
         .swap_g94_orbital_order(.molecular_orbitals.beta, "row")
      else
         .molecular_orbitals.create(.n_bf)
         .molecular_orbitals.restricted => temp_mat
         nullify(temp_vec)
         .swap_g94_orbital_order(.molecular_orbitals.restricted,"row")
      end

      ! Read in density matrix.
      if (u==0) then
         .density_matrix.create(.n_bf, "restricted")
         .density_matrix.triangle.create(.density_matrix.l_compress("restricted"))
         chkfile.look_for("Total SCF Density"); chkfile.read_line
         chkfile.read(.density_matrix.triangle)
         .density_matrix.uncompress
         .swap_g94_orbital_order(.density_matrix.restricted,"row")
         .swap_g94_orbital_order(.density_matrix.restricted,"column")
      else
         temp_total.create(.n_bf, "restricted")
         temp_spin.create(.n_bf, "restricted")
         temp_total.triangle.create(temp_total.l_compress("restricted"))
         chkfile.look_for("Total SCF Density"); chkfile.read_line
         chkfile.read(temp_total.triangle)
         temp_total.uncompress
         temp_spin.triangle.create(temp_spin.l_compress("restricted"))
         chkfile.look_for("Spin SCF Density"); chkfile.read_line
         chkfile.read(temp_spin.triangle)
         temp_spin.uncompress
         .density_matrix.create(.n_bf, "alpha")
         .density_matrix.create("beta")
         .density_matrix.beta = (temp_total.restricted - temp_spin.restricted)/2
         .density_matrix.alpha = (temp_spin.restricted + temp_total.restricted)/2
         temp_spin.destroy
         temp_total.destroy
         .swap_g94_orbital_order(.density_matrix.alpha,"row")
         .swap_g94_orbital_order(.density_matrix.alpha,"column")
         .swap_g94_orbital_order(.density_matrix.beta, "row")
         .swap_g94_orbital_order(.density_matrix.beta, "column")
         .make_unrestricted_NOs
      end

      chkfile.close; chkfile.destroy

      ! Save data in archive files
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_reduced_group_data(.atom)
      end
   end

   swap_g94_orbital_order(X,swap)
   ! Swap the order of f orbitals on matrix "X" after reading a g94 checkpoint
   ! file, for "swap" equal to "row" or "1", or "coloumn" or "2".
      MAT :: X
      STR(*) :: swap
      INT :: n,f,l
      IVEC(10) :: ff = (/ 1, 2, 3, 5, 6, 4, 9, 7, 8,10 /)
      select case (swap)
         case("row","1")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(f:l,:) = X(f-1+ff,:)
               end
            end
         case("column","2")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(:,f:l) = X(:,f-1+ff)
               end
            end
         case default
            DIE("unknown swap option")
      end
   end

   write_wfn_file [leaky]
   ! writes a .wfn file for input to morphy98
      STR :: name
      TEXTFILE* :: wfnfile
      IVEC* :: lvec
      VEC* :: evec
      MAT* :: dmatrix, cc
      SHELL* :: sh
      INT :: i, j, pcount, n_orbitals, a, l, atom, shell
      STR, parameter :: title_format = "(A80)"
      STR, parameter :: n_vars_format = "(A8, 10X, I5, 15X, I5, 15X, I5, 17X)"
      STR, parameter :: atom_format = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      STR, parameter :: c_assignment_format = "('CENTRE ASSIGNMENTS  ', 20I3)"
      STR, parameter :: t_assignment_format = "('TYPE ASSIGNMENTS    ', 20I3)"
      STR, parameter :: exponent_format = "('EXPONENTS ', 5E14.7)"
      STR, parameter :: mol_title_format = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      STR, parameter :: coefficient_format = "(5E16.8)"
      STR, parameter :: e_v_format = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"
      ENSURE(.occupation.restricted.created, "No occupation numbers")
      ENSURE(.orbital_energies.restricted.created, "No orbital energies")
      ENSURE(.molecular_orbitals.restricted.created, "No orbitals")
      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)
      wfnfile.create(name)
      wfnfile.open_for_write
      if (mod(.n_e, 2) == 0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end
      write(unit = wfnfile.unit, fmt = title_format) trim(name) // " computed by TONTO"
      write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
         .atom(i).pos, dble(.atom(i).atomic_number ) , i = 1, .n_atom)
      write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i = 1, .atom(j).n_prim ), j = 1, .n_atom )
      pcount = 1
      lvec.create(.n_prim)
      evec.create(.n_prim)
      do a = 1, .n_shell
        atom  = .atom_for_shell(a)
        shell = .atom_shell_for_shell(a)
        sh => .atom(atom).basis.shell(shell)
        l = sh.n_comp_sum - sh.n_comp
        do j = 1, sh.n_cc
          do i = 1, sh.n_comp
            evec(pcount ) = sh.ex(j)
            lvec(pcount ) = l + i
            pcount = pcount + 1
          end
        end
      end
      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write(unit = wfnfile.unit, fmt = exponent_format) evec
      lvec.destroy
      evec.destroy
      dmatrix.create(.n_prim, .n_bf)
      dmatrix = ZERO
      cc.create(.n_prim, .n_bf);    .make_contraction_matrix(cc)
      dmatrix.to_product(cc,.molecular_orbitals.restricted)
      do i = 1, n_orbitals
         write(unit = wfnfile.unit, fmt = mol_title_format) "MO  ", i, "OCC NO = ", &
            .occupation.restricted(i), " ORB. ENERGY = ", .orbital_energies.restricted(i)
         write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end
      write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
      write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy
   end

   write_archive
   ! Write the archive called "name". The kind is defined by the object to be
   ! written.
      STR :: name
      ARCHIVE :: archive
      stdin.read(name)
      archive.set(.name,name)
      select case (name)
         case ("molecular_orbitals"); archive.write(.molecular_orbitals)
         case ("density_matrix");     archive.write(.density_matrix)
         case ("natural_orbitals");   archive.write(.natural_orbitals)
         case ("occupation");         archive.write(.occupation)
         case ("fock_matrix");        archive.write(.fock_matrix)
         case ("orbital_energies");   archive.write(.orbital_energies)
         case default;     DIE("unknown archive name, " // trim(name))
      end
      archive.close
   end

   write_ascii_archive
   ! Write the archive called "name". The kind is defined by the object to be
   ! written. If required, the output order may be specified as
   ! "by_row" (default) or "by_column".
      STR :: name,order
      ARCHIVE :: archive
      stdin.read(name)
      order = "by_row"
      if (NOT stdin.buffer_exhausted) stdin.read(order)
      archive.set(.name,name,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.write(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.write(.density_matrix,order=order)
         case ("natural_orbitals");   archive.write(.natural_orbitals,order=order)
         case ("occupation");         archive.write(.occupation,order=order)
         case ("fock_matrix");        archive.write(.fock_matrix,order=order)
         case ("orbital_energies");   archive.write(.orbital_energies,order=order)
         case default;     DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

!  **************
!  Output methods
!  **************

   put
   ! Put all the available molecule information on file "out"
     stdout.flush
     stdout.text("Molecule information:")
     stdout.flush
     stdout.show("Name                   =",.name)
     stdout.show("Charge                 =",.charge)
     stdout.show("Multiplicity           =",.mult)
     stdout.show("Applied E Field        =",.E_field(1),.E_field(2),.E_field(3))
     stdout.show("Applied B Field        =",.B_field(1),.B_field(2),.B_field(3))
     stdout.show("B field Gauge origin   =",.gauge_origin)
     if (.atom.created)        .put_atoms
     if (.pointgroup.created)  .put_pointgroup
     if (.crystal.created)     .put_crystal
!    if (.grid.created)        .put_grid
     if (.dftgrid.created)     .put_dftgrid
   end

   put_atoms
   ! Output the atom coordinate and basis set information
      ENSURE(.atom.created,"no atom list")
      stdout.flush
      stdout.text("Molecule atom information:")
      stdout.flush
      stdout.show("Chemical Formula       =",trim(.atom.chemical_formula))
      stdout.show("No of atoms            =",.n_atom)
      stdout.show("No of electrons        =",.n_e)
      stdout.show("No of alpha electrons  =",.n_a)
      stdout.show("No of beta  electrons  =",.n_b)
      .atom.put_coord_info
      .put_bases
      .put_atom_thermal_tensors
   end

   put_bases
   ! Output the molecule basis set information, if the bases are all resolved.
      ENSURE(.atom.created,"no atom list")
      RETURN_IF(.atom.bases_are_unresolved)
      ENSURE(.basis.created,"no basis set list")
      stdout.flush
      stdout.text("Molecule atom basis set information:")
      stdout.flush
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.n_shell_pairs)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      .basis.renormalise
      .basis.put
      .basis.unnormalise
   end

  put_atom_thermal_tensors
  ! Output the thermal tensors if they exist.
    STR :: thermal_smearing_model
    RETURN_IF(.crystal.destroyed)
    thermal_smearing_model = .crystal.thermal_smearing_model
    if (thermal_smearing_model=="") then
      stdout.flush
      stdout.put("No thermal smearing.")
      stdout.flush
    else
      stdout.flush
      stdout.put("Thermal tensor information:")
      stdout.flush
      stdout.show("Thermal smearing model = ", trim(thermal_smearing_model))
      stdout.flush
      ENSURE(.atom.created,"no atom list data")
      .atom.put_thermal_tensors
    end
  end

   put_pointgroup
   ! Output the current pointgroup
      .pointgroup.put
   end

  put_plotgrid
  ! Output the current grid.
    ENSURE(.grid.created,"no plot grid to output")
    .grid.put
  end

  put_dftgrid
  ! Output the current DFT grid.
    ENSURE(.dftgrid.created,"no DFT grid to output")
    .dftgrid.put
  end

   put_crystal
   ! Output the current crystal
      if (.atom.created) then; .crystal.put(.atom)
      else;                    .crystal.put
      end
   end

   put_crystal_reflection_data
   ! Output the current crystal
      .crystal.put_reflection_data
   end

   put_molecular_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.molecular_orbitals)
   end

   put_mos_and_energies
   ! Output the current associated molecular orbitals and their energies
      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.orbital_energies, format="column")
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.molecular_orbitals)
   end

   put_natural_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Natural orbital occupations:")
      stdout.put(.occupation, format="column")
      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put(.natural_orbitals)
   end

   put_density_matrix
   ! Output the current associated density matrix
      ENSURE(.density_matrix.created,"no density matrix")
      stdout.flush
      stdout.text("Density matrix:")
      stdout.put(.density_matrix)
   end

   put_fock_matrix
   ! Output the current associated fock matrix
      ENSURE(.fock_matrix.created,"no fock matrix")
      stdout.flush
      stdout.text("Fock matrix:")
      stdout.put(.fock_matrix)
   end

  put_PND_sf
  ! Output the magnetic structure factors
    .crystal.put_PND_sf(.name)
  end

!  ***********
!  SCF methods
!  ***********

   set_scf_defaults [leaky]
   ! Set up scf defaults for molecule
      .scfdata.destroy
      .scfdata.create
      if (.mult==1) .scfdata.kind = "rhf"
      if (.mult/=1) .scfdata.kind = "uhf"
      .scfdata.using_diis = TRUE
      .scfdata.direct = FALSE
      .scfdata.diis.set_archive_root_name(.name)
      .scfdata.diis.set_archive_name("fock_matrix,DIIS")
   end

   make_molecule_from_atom(n,mol) [leaky]
   ! Make a fully fledged molecule "mol" from a single atom "n" in self
      INT :: n
      MOL :: mol
      ENSURE(n<=.n_atom,"atom number n too big")
      mol.atom.create(1)
      mol.atom = .atom(n) ! WARNING: dont destroy ptr parts of mol.atom !
      mol.atom(1).pos = (/ZERO,ZERO,ZERO/)
      mol.set_defaults
      mol.name  =  trim(.name) // "_" // trim(.atom(n).label)
      mol.basis => .basis ! WARNING: dont destroy basis of mol !
      mol.set_basis_info
      mol.set_scf_defaults
   end

! ************
! SCF routines
! ************

  scf    [recursive] [leaky]
  ! Do an SCF calculation. The following :
  !   .molecular_orbitals, .orbital_energies, .density_matrix
  ! are produced as results.
    ENSURE(.scfdata.created,"no scfdata provided")
    select case (.scfdata.kind)
      case ("xray_rhf","xray_rks")
        .constrained_scf_rhf
      case default;
        .hf_scf
    end
  end

  hf_scf [recursive] [leaky]
  ! Do a Hartree-Fock SCF calculation. The following :
  !   .molecular_orbitals, .orbital_energies, .density_matrix
  ! are produced as results.
    OPMAT* :: dP,dF,old_P,old_F,old_MO
    DBL :: E_HF,E_K,diis_error
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    ! Initialize cycles
    .get_initial_guess
    .make_fock_matrix(core=TRUE)
    dP.create(.n_bf); old_P.create_copy(.density_matrix)
    dF.create(.n_bf); old_F.create_copy(.fock_matrix)
    old_MO.create_copy(.molecular_orbitals)
    ! Zeroth iteration.
    E_HF = .scf_energy
    E_K = .kinetic_energy
    .make_diis_error(diis_error)
    .scfdata.reset(.atom.nuclear_energy,E_HF,E_K)
    .scfdata.set_diis_error(diis_error)
    .scfdata.put_banner
    .scfdata.put_results
    do
      if (.scfdata.scf_done) exit
      old_P.set_to(.density_matrix)
      old_F.set_to(.fock_matrix)
      old_MO.set_to(.molecular_orbitals)
      .extrapolate_scf
      .update_molecular_orbitals
      .schmidt_orthonormalise(.molecular_orbitals)
      .make_scf_density_matrix
      .save_scf_results
      dP.set_to(.density_matrix)
      dP.minus(old_P)
      .make_fock_matrix(dP,dF,core=FALSE)
      .fock_matrix.set_to(old_F)
      .fock_matrix.plus(dF)
      E_HF = .scf_energy
      E_K = .kinetic_energy
      if (.scfdata.apply_camp_king) .camp_king(old_MO,old_F,E_HF,E_K)
      .make_diis_error(diis_error)
      .scfdata.update(E_HF,E_K)
      .scfdata.set_diis_error(diis_error)
      .scfdata.put_results
    end
    dF.destroy
    dP.destroy
    old_MO.destroy
    old_F.destroy
    old_P.destroy
    .scfdata.cleanup_diis
    .fock_matrix.destroy("all")
  end

  schmidt_orthonormalise(MO)
  ! Schmidt orthonormalise the molecular orbitals, "MO"
     OPMAT :: MO
     MAT* :: S
     S.create(.n_bf,.n_bf)
     .get_overlap_matrix(S)
     MO.schmidt_orthonormalise(S)
     S.destroy
  end

  update_molecular_orbitals
  ! Solve for the molecular orbitals.  Requires a set of old molecular orbitals.
  ! The new molecular orbitals "cU" are found from the old MOs "c" by solving :
  ! (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
    STR :: kind
    BIN :: mos_exist
    VEC* :: e
    CMAT* :: MOc,Fc
    kind = .scfdata.kind
    mos_exist = .molecular_orbitals.created
    ENSURE(mos_exist, "need old MOs for initial guess")
    select case (kind)
       case ("rhf","restricted_hartree_fock", &
             "rohf","restricted_open_shell_hartree_fock", &
             "xray_rhf","xray_rks")
          .update_r_MO(.orbital_energies.restricted,.molecular_orbitals.restricted,.fock_matrix.restricted)
       case ("uhf","unrestricted_hartree_fock")
          .update_r_MO(.orbital_energies.alpha,.molecular_orbitals.alpha, .fock_matrix.alpha)
          .update_r_MO(.orbital_energies.beta ,.molecular_orbitals.beta , .fock_matrix.beta )
       case ("gchf","cghf","general_complex_hartree_fock","complex_general_hartree_fock")
          e   => .orbital_energies.general
          MOc => .molecular_orbitals.general_complex
          Fc  => .fock_matrix.general_complex
          .update_gc_MO(e,MOc,Fc)
    end
  end

  update_r_MO(MO_energies,MO,F)
  ! Solve for the new molecular orbital energies "MO_energies" and the new
  ! molecular orbitals "MO", given an initial old set (in "MO") and a fock
  ! matrix "F".  The new molecular orbitals "MO*U" are found from the old MOs
  ! "MO" by solving : (c^T F c)U = c^T S c U E ...... where U is an orthogonal
  ! matrix.
    VEC :: MO_energies
    MAT :: MO,F
    MAT* :: G,U
    INT :: i

    G.create(.n_bf,.n_bf)
    U.create(.n_bf,.n_bf)
    G = F
    G.change_basis(MO)

    ! Level shifting
    if (.scfdata.apply_level_shifting) then
      do i = .n_a + 1, .n_bf
        G(i,i) = .scfdata.level_shift + G(i,i)
      end
    end

    G.solve_eigenproblem(MO_energies,U)
    G.to_product(MO,U)
    MO = G
    U.destroy
    G.destroy
  end

  update_gc_MO(MO_energies,MO,F)
  ! Solve for the new molecular orbital energies "MO_energies" and the new
  ! molecular orbitals "MO", given an initial old set (in "MO") and a fock
  ! matrix "F".
  ! The new molecular orbitals "MO*U" are found from the old MOs "MO" by
  ! solving (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
    VEC :: MO_energies
    CMAT :: MO,F
    CMAT* :: G,U
    INT :: i
    G.create(2*.n_bf,2*.n_bf)
    U.create(2*.n_bf,2*.n_bf)
    G = F
    G.change_basis(MO)
    ! Level shifting
    if (.scfdata.apply_level_shifting) then
      do i = .n_e + 1, 2*.n_bf
        G(i,i) = .scfdata.level_shift + G(i,i)
      end
    end
    G.solve_eigenproblem(MO_energies,U)
    G.to_product(MO,U)
    MO = G
    U.destroy
    G.destroy
  end

  kinetic_energy result (res)
  ! Evaluates the SCF kinetic energy as a trace of ".density_matrix" with the
  ! ".kinetic matrix".
    DBL :: res
    STR :: kind
    MAT* :: H
    CMAT* :: HH
    kind = .scfdata.kind
    ENSURE(.density_matrix.any_created, "no density matrix")
    select case (kind)
       case ("rhf","restricted_hartree_fock","xray_rhf","xray_rks")
          H.create(.n_bf,.n_bf); .get_kinetic_matrix(H)
          res = .density_matrix.restricted.trace_of_product(H)
          H.destroy
       case ("uhf","unrestricted_hartree_fock","rohf","restricted_open_shell_hartree_fock")
          H.create(.n_bf,.n_bf); .get_kinetic_matrix(H)
          res = .density_matrix.alpha.trace_of_product(H)
          res = .density_matrix.beta.trace_of_product(H) + res
          H.destroy
       case ("cghf","gchf","general_complex_hartree_fock","complex_general_hartree_fock")
          HH.create(2*.n_bf,2*.n_bf); HH=ZERO
          H.create(.n_bf,.n_bf)
          .get_kinetic_matrix(H)
          HH.alpha_alpha_set_to(H)
          HH.beta_beta_set_to(H)
          H.destroy
          res = .density_matrix.general_complex.trace_of_product(HH)
          HH.destroy
       case default; DIE("don't know what to do with " // .scfdata.kind)
    end
  end

  scf_energy result (res)
  ! Evaluates the total SCF energy (including nuclear) as a trace of
  ! ".density_matrix" with the ".fock matrix".
    DBL :: res
    res = .scf_electronic_energy(.density_matrix) + .atom.nuclear_energy
  end

  put_scf_energy
  ! Out put the scf energy.
    DBL :: energy
    energy = .scf_energy
    stdout.show("The SCF energy is ", .scf_energy)
    stdout.show("The kinetic energy is ", .kinetic_energy)
  end

  scf_energy(P) result (res)
  ! Evaluates the total SCF energy (including nuclear) as a trace of
  ! "P" with the ".fock matrix".
    OPMAT, target :: P
    DBL :: res
    res = .scf_electronic_energy(P) + .atom.nuclear_energy
  end

  scf_electronic_energy(P,core) result (res)
  ! Evaluates the SCF electronic energy as a trace of "D" with the ".fock
  ! matrix".
  ! If "core" is present and FALSE, the core contribution is not added.
    OPMAT, target :: P
    BIN, optional :: core
    BIN :: add_core
    DBL :: res
    STR :: kind
    MAT* :: F
    CMAT* :: FF
    kind = .scfdata.kind
    ENSURE(.fock_matrix.any_created,    "no fock matrix")
    ENSURE(.density_matrix.any_created, "no density matrix")
    add_core = TRUE
    if (present(core)) add_core = core
    select case (kind)
       case ("rhf","restricted_hartree_fock","xray_rhf","xray_rks")
          F.create(.n_bf,.n_bf)
          F = .fock_matrix.restricted
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P.restricted.trace_of_product(F)
          F.destroy
       case ("uhf","unrestricted_hartree_fock","rohf","restricted_open_shell_hartree_fock")
          F.create(.n_bf,.n_bf);
          F = .fock_matrix.alpha
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P.alpha.trace_of_product(F)
          F = .fock_matrix.beta
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P.beta.trace_of_product(F) + res
          F.destroy
       case ("cghf","gchf","general_complex_hartree_fock","complex_general_hartree_fock")
          FF.create(2*.n_bf,2*.n_bf);
          FF = .fock_matrix.general_complex
          if (add_core) .add_core_hamiltonian(FF)
          res = HALF * P.general_complex.trace_of_product(FF)
          FF.destroy
       case default; DIE("not yet implemented, " // .scfdata.kind)
    end
  end

  scf_electronic_energy(P,nuclei) result (res)
  ! Evaluates the SCF electronic energy as a trace of "D" with the ".fock
  ! matrix".
  ! "nuclei" lists the nuclei to be used for obtaining n->e attractions.
    OPMAT, target :: P
    IVEC :: nuclei
    BIN :: add_core
    DBL :: res
    STR :: kind
    MAT* :: F
    CMAT* :: FF
    kind = .scfdata.kind
    ENSURE(.fock_matrix.any_created,    "no fock matrix")
    ENSURE(.density_matrix.any_created, "no density matrix")
    add_core = TRUE
    select case (kind)
       case ("rhf","restricted_hartree_fock","xray_rhf","xray_rks")
          F.create(.n_bf,.n_bf)
          F = .fock_matrix.restricted
          .add_core_hamiltonian(F,nuclei)
          res = HALF * P.restricted.trace_of_product(F)
          F.destroy
       case ("uhf","unrestricted_hartree_fock","rohf","restricted_open_shell_hartree_fock")
          F.create(.n_bf,.n_bf);
          F = .fock_matrix.alpha
          .add_core_hamiltonian(F,nuclei)
          res = HALF * P.alpha.trace_of_product(F)
          F = .fock_matrix.beta
          .add_core_hamiltonian(F,nuclei)
          res = HALF * P.beta.trace_of_product(F) + res
          F.destroy
       case ("cghf","gchf","general_complex_hartree_fock","complex_general_hartree_fock")
          FF.create(2*.n_bf,2*.n_bf);
          FF = .fock_matrix.general_complex
          .add_core_hamiltonian(FF,nuclei)
          res = HALF * P.general_complex.trace_of_product(FF)
          FF.destroy
       case default; DIE("not yet implemented, " // .scfdata.kind)
    end
  end

  get_scf_results [leaky]
  ! Get the SCF results in from archives. Do not get the density matrix, because
  ! it can/should be generated from the orbitals, depending on the kind of SCF.
    ARCHIVE :: archive
    STR :: k
    k = .scfdata.molecular_orbital_kind
    archive.set(.name,"molecular_orbitals",kind=k)
    archive.read(.molecular_orbitals,kind=k)
    k = .scfdata.orbital_energies_kind
    archive.set(.name,"orbital_energies",kind=k)
    archive.read(.orbital_energies,kind=k)
  end

  save_scf_results
  ! Save the SCF results in various archives
    ARCHIVE :: archive
    archive.set(.name,"density_matrix")
    archive.write(.density_matrix)
    archive.set(.name,"molecular_orbitals")
    archive.write(.molecular_orbitals)
    archive.set(.name,"orbital_energies")
    archive.write(.orbital_energies)
  end

  destroy_scf_results [leaky]
  ! Destroy the SCF results
    .density_matrix.destroy
    .density_matrix.create(.n_bf)
    .molecular_orbitals.destroy
    .molecular_orbitals.create(.n_bf)
    .orbital_energies.destroy
    .orbital_energies.create(.n_bf)
  end

  delete_integrals
  ! Delete all integral files.
  ! This is required whenever the geometry is changed.
     ARCHIVE :: archive
     archive.set(.name,"overlap_matrix")
     archive.delete
     archive.set(.name,"kinetic_matrix")
     archive.delete
     archive.set(.name,"nuclear_matrix")
     archive.delete
     archive.set(.name,"core_matrix")
     archive.delete
     archive.set(.name,"fock_matrix")
     archive.delete
     archive.set(.name,"eri_integrals")
     archive.delete
     archive.set(.name,"eri_index")
     archive.delete
     archive.set(.name,"ft_ints")
     archive.delete
  end

  delete_matrices
  ! Delete any matrices stored on disk.
     ARCHIVE :: archive
     archive.set(.name,"density_matrix")
     archive.delete_all
     archive.set(.name,"molecular_orbitals")
     archive.delete_all
     archive.set(.name,"orbital_energies")
     archive.delete_all
  end

  canonicalize_MOs
  ! Generate the Fock matrix from the molecular orbitals and diagonalise it
  ! on the occupied-occupied block to get the canonical molecular orbitals.
    STR :: kind
    ENSURE(.molecular_orbitals.created,"need old MOs!")
    ENSURE(.orbital_energies.created,"need old energies")
    .make_scf_density_matrix
    .make_fock_matrix
    kind = .scfdata.kind
    select case (kind)
       case ("rhf","restricted_hartree_fock", &
             "rohf","restricted_open_shell_hartree_fock", &
             "xray_rhf","xray_rks")
          .orbital_energies.destroy
          .orbital_energies.create(.n_bf,"restricted")
          .canonicalize_r_MO(.orbital_energies.restricted, &
                             .molecular_orbitals.restricted, &
                             .fock_matrix.restricted)
          stdout.flush
          stdout.text("Canonicalized molecular orbital energies:")
          stdout.put(.orbital_energies.restricted(1:.n_e/2), format="column")
       case default; DIE("unknown or unimplemented code")
    end
  end

  canonicalize_r_MO(MO_energies,MO,F)
  ! Digaonalise the Fock matrix "F" in the occupied-occupied block of the
  ! molecular orbitals "MO", and reset the occupied "MO_energies".
    VEC :: MO_energies
    MAT :: MO,F
    MAT* :: G,U,MO_old
    INT :: n
    n = .n_e/2
    G.create(n,n)
    U.create(n,n)
    MO_old.create(.n_bf,n)
    MO_old = MO(:,1:n)
    F.change_basis(G,MO_old)
    MO_energies = ZERO
    G.solve_eigenproblem(MO_energies,U)
    MO(:,1:n).to_product(MO_old,U)
    MO_old.destroy
    U.destroy
    G.destroy
  end

!*******************************
! Initial orbital guess routines
!*******************************

  get_initial_guess [leaky]
  ! Get the initial guess for the ".density_matrix" and ".molecular_orbitals"
  ! If .scfdata.initial_mos is set, it overides .initial_density.
     STR :: initial_mos
     initial_mos = .scfdata.initial_mos
     if (initial_mos/=" ") then; .get_initial_MOs
     else;                       .get_initial_density
     end
  end

  get_initial_MOs [leaky]
  ! Get the initial guess for the .molecular_orbitals
  ! Convert the .molecular_orbitals, if neccesary.
     STR :: initial_mos
     initial_mos = .scfdata.initial_mos
     select case (initial_mos)
      ! case ("atom")
      !    .make_atom_MOs_guess
        case("restricted","unrestricted","general", &
             "restricted_complex","unrestricted_complex","general_complex", &
             "complex_restricted","complex_unrestricted","complex_general")
           .read_old_MOs_guess
        case default
           DIE("unknown initial MO's, "// trim(initial_mos))
     end
  end

  read_old_MOs_guess [leaky]
  ! Get the initial guess for the .molecular_orbitals by reading an old archive of
  ! .molecular_orbitals, and then make the SCF density matrix as well.
  ! Convert the .molecular_orbitals, if neccesary.
     ARCHIVE :: archive
     archive.set(.name,"molecular_orbitals",kind=.scfdata.initial_mos)
     archive.read(.molecular_orbitals)
     .molecular_orbitals.convert_to(.scfdata.molecular_orbital_kind,.n_a,.n_b, &
                                    .scfdata.quantization_axis)
     .make_scf_density_matrix
     .orbital_energies.create(kind=.scfdata.orbital_energies_kind)
  end

  make_atom_MOs_guess [leaky]
  ! Get the initial guess for the .molecular_orbitals by getting the highest
  ! occupied restricted natural orbitals from the sum of atomic densities guess
  ! for the density matrix. Convert these .molecular_orbitals, if neccesary.
  ! Also make the SCF .density_matrix from these .molecular_orbitals.
     STR :: kind
     ARCHIVE :: archive
     .get_atom_density
     if (.density_matrix.spinorbital_kind/="restricted") then
        archive.set(.name,"atom_density_matrix", kind="restricted")
        .density_matrix.destroy("restricted")
        archive.read(.density_matrix)
     end
     .make_natural_orbitals
     .put_natural_orbitals
     .assign_MOs_to_NOs
     kind = .scfdata.molecular_orbital_kind
     .molecular_orbitals.convert_to(kind,.n_a,.n_b,.scfdata.quantization_axis)
     .make_scf_density_matrix
     .orbital_energies.create(kind=.scfdata.orbital_energies_kind)
  end

  get_initial_density [leaky]
  ! Get the initial guess for the ".density_matrix"
     STR :: initial_density
     initial_density = .scfdata.initial_density
     select case (initial_density)
        case ("core"); .make_core_guess
        case ("fock"); .make_fock_guess
        case ("atom"); .make_atom_guess
        case("restricted","unrestricted","general", &
             "restricted_complex","unrestricted_complex","general_complex", &
             "complex_restricted","complex_unrestricted","complex_general")
           .make_density_guess
        case default
           DIE("unknown initial guess density, "// trim(initial_density))
     end
  end

  make_density_guess [leaky]
  ! Read an old .density_matrix of type "initial_guess" and use it to
  ! make initial .molecular_orbitals to start an scf calculation.
  ! Convert the .density_matrix, if neccesary.
     STR :: initial_density
     ARCHIVE :: archive
     initial_density = .scfdata.initial_density
     archive.set(.name,"density_matrix")
     archive.read(.density_matrix,kind=initial_density)
     .density_matrix.convert_to(newkind = .scfdata.spinorbital_kind)
     .make_fock_matrix  ! Make a fock matrix
     .make_fock_guess   ! Get a reasonable set of starting MO's
  end

  make_core_guess [leaky]
  ! Do a core scf for the ".density_matrix", ".molecular_orbitals" and
  ! ".orbital_energies"
    STR :: kind
    .destroy_scf_results
    .orbital_energies.destroy("restricted")
    .orbital_energies.create("restricted")
    .molecular_orbitals.destroy("restricted")
    .molecular_orbitals.create("restricted")
    .make_r_core_guess(.orbital_energies.restricted,.molecular_orbitals.restricted)
    kind = .scfdata.orbital_energies_kind
    .orbital_energies.convert_to(kind)
    kind = .scfdata.molecular_orbital_kind
    .molecular_orbitals.convert_to(kind,.n_a,.n_b,.scfdata.quantization_axis)
    .make_scf_density_matrix
    .make_fock_matrix  ! Make a fock matrix (only to get MO's)
    .make_fock_guess   ! Get a reasonable set of starting MO's
  end

  make_r_core_guess(MO_energies,MO)
  ! Do a real core scf for the molecular orbital energies  "MO_energies"
  ! and the molecular_orbitals "MO"
    VEC :: MO_energies
    MAT :: MO
    MAT* :: S,R,H
    !  H~ = S^-1/2 H S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
    R.create(.n_bf,.n_bf); R.to_inverse_sqrt(S)
    H.create(.n_bf,.n_bf); .get_core_matrix(H)
    S.to_product(R,H)
    H.to_product(S,R)
    H.solve_eigenproblem(MO_energies,MO)
    H.to_product(R,MO)
    MO = H
    H.destroy
    R.destroy
    S.destroy
  end

  make_atom_guess [leaky]
  ! Make a ".density matrix" and fock matrix from the sum of atomic densities.
  ! Then get initial orbitals from this fock matrix, and make the density
  ! corresponding to these initial orbitals.
     ENSURE(.scfdata.kind/="rohf","atom guess not available for ROHF")
     .get_atom_density
     .make_fock_matrix       ! Make a fock matrix (only to get MO's)
     .make_fock_guess        ! Get a reasonable set of starting MO's
  end

  get_atom_density [leaky]
  ! Reads ".density_matrix" from the archive, otherwise makes it and
  ! writes to the archive.
    ARCHIVE :: archive
    archive.set(.name,"atom_density_matrix", kind="restricted")
    if (archive.exists) then
       .density_matrix.destroy
       .density_matrix.create(.n_bf,"restricted")
       archive.read(.density_matrix)
       .density_matrix.convert_to(.scfdata.spinorbital_kind,factor=HALF)
    else
       .make_atom_density
    end
  end

  make_atom_density(output) [leaky]
  ! Make a ".density matrix" from the sum of atomic densities
  ! if output is present and FALSE the density matrix is not archived
    BIN, OPTIONAL :: output
    BIN :: do_output
    INT :: k,n_k,l,kl,a,b
    MOL* :: mol
    IVEC* :: first,last
    IVECVEC* :: atom_kind
    ARCHIVE :: archive
    ENSURE(.scfdata.created, "no scf data present.")
    do_output=TRUE
    if (present(output)) do_output=output
    .density_matrix.destroy
    .density_matrix.create(.n_bf,"restricted")
    .density_matrix.restricted = ZERO
    .atom.make_atom_basis_fn_limits(first,last)
    .atom.make_atom_kind_list(atom_kind)
    n_k = size(atom_kind)
    do k = 1,n_k ! Do an SCF for every different kind of atom
      mol.create
      l = atom_kind(k).vec(1)
      .make_molecule_from_atom(l,mol)
      if (mol.no_of_electrons >= 1) then
        mol.scfdata.convergence = 0.0001
        mol.scfdata.output = FALSE
        mol.scf
        mol.make_ao_density_matrix
        mol.pointgroup.create("oh")
        mol.symmetrise(mol.density_matrix)
        do l = 1,size(atom_kind(k).vec) ! Copy this atom density
          kl = atom_kind(k).vec(l)
          a = first(kl); b = last(kl)
         .density_matrix.restricted(a:b,a:b) = &
         .density_matrix.restricted(a:b,a:b) &
         + mol.density_matrix.restricted
        end
      end
      mol.atom.nullify_ptr_part ! do not destroy these
      nullify(mol.basis)        ! do not destroy this
      mol.delete_integrals
      mol.delete_matrices
      mol.destroy
    end
    if (do_output) then
     archive.set(.name,"atom_density_matrix", kind="restricted")
     archive.write(.density_matrix, kind="restricted")
    end
    .density_matrix.convert_to(.scfdata.spinorbital_kind,factor=HALF)
    atom_kind.destroy
    last.destroy
    first.destroy
  end

  make_fock_guess [leaky]
  ! From an initial .fock_matrix make the .molecular_orbitals, and .orbital_energies.
  ! Then make the .density_matrix from these orbitals. Destroy .fock_matrix afterwards
    STR :: kind
    VEC* :: e
    MAT* :: MO,F
    CMAT* :: MOc,Fc
    kind = .scfdata.spinorbital_kind
    ENSURE(.fock_matrix.created(kind),"need an initial fock matrix")
    .destroy_scf_results
    kind = .scfdata.kind
    select case (kind)
    !  F~ = S^-1/2 F S^-1/2
    !  c  = S^-1/2 c~
       case ("rhf","restricted_hartree_fock", &
             "rohf","restricted_open_shell_hartree_fock", &
             "xray_rhf","xray_rks")
          .orbital_energies.destroy("restricted")
          .orbital_energies.create("restricted")
          .molecular_orbitals.destroy("restricted")
          .molecular_orbitals.create("restricted")
          e  => .orbital_energies.restricted
          MO => .molecular_orbitals.restricted
          F  => .fock_matrix.restricted
          .make_r_fock_guess(e,MO,F)
       case ("uhf","unrestricted_hartree_fock")
          .orbital_energies.destroy("unrestricted")
          .orbital_energies.create("unrestricted")
          .molecular_orbitals.destroy("unrestricted")
          .molecular_orbitals.create("unrestricted")
          e  => .orbital_energies.alpha
          MO => .molecular_orbitals.alpha
          F  => .fock_matrix.alpha
          .make_r_fock_guess(e,MO,F)
          e  => .orbital_energies.beta
          MO => .molecular_orbitals.beta
          F  => .fock_matrix.beta
          .make_r_fock_guess(e,MO,F)
       case ("cghf","gchf","general_complex_hartree_fock","complex_general_hartree_fock")
          .orbital_energies.destroy("general")
          .orbital_energies.create("general")
          .molecular_orbitals.destroy("general_complex")
          .molecular_orbitals.create("general_complex")
          e   => .orbital_energies.general
          MOc => .molecular_orbitals.general_complex
          Fc  => .fock_matrix.general_complex
          .make_gc_fock_guess(e,MOc,Fc)
       case default; DIE("unknown spinorbital kind, " // trim(kind))
    end
    kind = .scfdata.spinorbital_kind
    .fock_matrix.destroy(kind)
    .make_scf_density_matrix
    .save_scf_results
  end

  make_r_fock_guess(MO_energies,MO,fock_matrix)
  ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
  ! a given real restricted "fock_matrix".
    VEC :: MO_energies
    MAT :: MO, fock_matrix
    MAT* :: S,R,H
    !  F~ = S^-1/2 F S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
    R.create(.n_bf,.n_bf); R.to_inverse_sqrt(S)
    H.create(.n_bf,.n_bf); H = fock_matrix
    S.to_product(R,H)
    H.to_product(S,R)
    H.solve_eigenproblem(MO_energies,MO)
    H.to_product(R,MO)
    MO = H
    H.destroy
    R.destroy
    S.destroy
  end

  make_gc_fock_guess(MO_energies,MO,fock_matrix)
  ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
  ! a given complex general "fock_matrix".
    VEC :: MO_energies
    CMAT :: MO, fock_matrix
    MAT* :: S,R
    CMAT* :: H,W
    !  F~ = S^-1/2 F S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf)
    R.create(.n_bf,.n_bf)
    .get_overlap_matrix(R)
    S.to_inverse_sqrt(R)
    R.destroy
    R.create(2*.n_bf,2*.n_bf); R=ZERO
    R.alpha_alpha_set_to(S)
    R.beta_beta_set_to(S)
    S.destroy
    H.create(2*.n_bf,2*.n_bf); H = fock_matrix
    W.create(2*.n_bf,2*.n_bf)
    W = matmul(R,H)
    H = matmul(W,R)
    W.destroy
    H.solve_eigenproblem(MO_energies,MO)
    H = matmul(R,MO)
    MO = H
    H.destroy
    R.destroy
  end

! ******************
! DIIS extrapolation
! ******************

   make_diis_error(length)
   ! Make the SCF "error" vector from the current fock_matrix and
   ! density_matrix, and return the error length.  Useful for reporting the
   ! error length.
      OPMAT* :: error
      STR :: kind
      CMAT* :: err,F,P
      DBL :: length
      kind = .scfdata.kind
      select case (kind)
         case ("rhf","restricted_hartree_fock","xray_rhf","xray_rks")
            error.create(.n_bf,"restricted")
            .make_r_diis_error(error.restricted,.fock_matrix.restricted,.density_matrix.restricted)
            error.compress
            length = sqrt(dot_product(error.triangle,error.triangle)) / .n_bf
            error.destroy
         case ("rohf","restricted_open_shell_hartree_fock")
            error.create(.n_bf,"restricted")
            .make_r_diis_error(error.restricted,.fock_matrix.restricted,.density_matrix.alpha)
            error.compress
            length = sqrt(dot_product(error.triangle,error.triangle)) / .n_bf
            error.destroy
         case ("uhf","unrestricted_hartree_fock")
            error.create(.n_bf,"unrestricted")
            .make_r_diis_error(error.alpha,.fock_matrix.alpha,.density_matrix.alpha)
           .make_r_diis_error(error.beta, .fock_matrix.beta, .density_matrix.beta)
            error.compress
            length = sqrt(dot_product(error.triangle,error.triangle)) / .n_bf
            error.destroy
         case ("gchf","cghf","complex_general_hartree_fock","general_complex_hartree_fock")
            error.create(.n_bf,"general_complex")
            err => error.general_complex
            F   => .fock_matrix.general_complex
            P   => .density_matrix.general_complex
            .make_gc_diis_error(err,F,P)
            error.compress
            length = sqrt(dot_product(error.square,error.square)) / .n_bf
            error.destroy
         case default;          DIE("unknown SCF kind, "//trim(kind))
      end
   end

  extrapolate_scf
  ! Extrapolate the scf fock matrix.
    OPMAT* :: error
    STR :: kind
    CMAT* :: F,P
    DBL :: err_len
    kind = .scfdata.kind
    select case (kind)
      case ("rhf","restricted_hartree_fock","xray_rhf","xray_rks")
        error.create(.n_bf,"restricted")
        .make_r_diis_error(error.restricted,.fock_matrix.restricted,.density_matrix.restricted)
        error.compress
        err_len = sqrt(dot_product(error.triangle,error.triangle)) / .n_bf
        if (.scfdata.apply_diis) then
          .fock_matrix.compress
          .scfdata.diis.extrapolate(.fock_matrix.triangle,error.triangle)
        end
        error.destroy
      case ("rohf","restricted_open_shell_hartree_fock")
        error.create(.n_bf,"restricted")
        .make_r_diis_error(error.restricted,.fock_matrix.restricted,.density_matrix.alpha)
        error.compress
        err_len = sqrt(dot_product(error.triangle,error.triangle)) / .n_bf
        if (.scfdata.apply_diis) then
          .fock_matrix.compress("restricted")
          .scfdata.diis.extrapolate(.fock_matrix.triangle,error.triangle)
        end
        error.destroy
      case ("uhf","unrestricted_hartree_fock")
         error.create(.n_bf,"unrestricted")
         .make_r_diis_error(error.alpha,.fock_matrix.alpha,.density_matrix.alpha)
         .make_r_diis_error(error.beta, .fock_matrix.beta, .density_matrix.beta)
         error.compress
         err_len = sqrt(dot_product(error.triangle,error.triangle)) / .n_bf
         if (.scfdata.apply_diis) then
           .fock_matrix.compress
           .scfdata.diis.extrapolate(.fock_matrix.triangle,error.triangle)
         end
         error.destroy
      case ("gchf","cghf","complex_general_hartree_fock","general_complex_hartree_fock")
         error.create(.n_bf,"general_complex")
         F   => .fock_matrix.general_complex
         P   => .density_matrix.general_complex
         .make_gc_diis_error(error.general_complex,F,P)
         error.compress
         err_len = sqrt(dot_product(error.square,error.square)) / .n_bf
         if (.scfdata.apply_diis) then
           .fock_matrix.compress
           .scfdata.diis.extrapolate(.fock_matrix.square,error.square)
         end
         error.destroy
      case default;          DIE("unknown SCF kind, "//trim(kind))
    end
    .scfdata.set_diis_error(err_len)
    .fock_matrix.uncompress
    error.destroy
  end

   make_r_diis_error(error,F,P) [private]
   ! Make the real DIIS error matrix, error = FPS - SPF
      MAT :: error,F,P
      MAT* :: S,W
      W.create(.n_bf, .n_bf)
      S.create(.n_bf, .n_bf); .get_overlap_matrix(S)
      W.to_product(P,S)
      S.destroy
      error.to_product(F,W)
      W.destroy
      error.antisymmetric_fold
      error.antisymmetric_reflect
   end

   make_gc_diis_error(error,F,P) [private]
   ! Make the complex general DIIS error matrix, error = FPS - SPF
      CMAT :: error,F,P
      MAT* :: R
      CMAT* :: S,W
      W.create(2*.n_bf, 2*.n_bf)
      S.create(2*.n_bf,2*.n_bf); S=ZERO
      R.create(.n_bf,.n_bf)
      .get_overlap_matrix(R)
      S.alpha_alpha_set_to(R)
      S.beta_beta_set_to(R)
      R.destroy
      W.to_product(P,S)
      S.destroy
      error.to_product(F,W)
      W.destroy
      error.antihermitian_fold
      error.make_antihermitian
   end

! *******************
! Pairwise SCF energy
! *******************

   put_scf_energy_in_mo_pairs
   ! Analyse the SCF energy into MO pairs
      OPMAT* :: Di
      VEC* :: core_energy
      MAT* :: pair_energy
      INT :: i,j
      DBL :: energy,fac
      BIN :: direct
      core_energy.create(.n_a)
      pair_energy.create(.n_a,.n_a)
      core_energy = ZERO
      pair_energy = ZERO
      Di.create(.n_bf)
      direct = .scfdata.direct
      .scfdata.direct = TRUE
      do i = 1,.n_a
         .make_scf_density_matrix(i)
         Di.set_to(.density_matrix)
         .make_fock_matrix(core=TRUE,r12=FALSE)
         core_energy(i) = .scf_electronic_energy(Di,core=TRUE)
         do j = 1,i
            .make_scf_density_matrix(j)
            .make_fock_matrix(core=FALSE,r12=TRUE)
            fac = TWO
            if (i==j) fac = ONE
            pair_energy(i,j) = fac*.scf_electronic_energy(Di,core=FALSE)
         end
      end
      Di.destroy
      .scfdata.direct = direct
      stdout.flush
      stdout.text("SCF MO pair energy decomposition:",flush=1)
      energy = sum(core_energy)+sum(transfer(pair_energy,(/ONE/)))+.atom.nuclear_energy
      stdout.show("SCF energy =",energy)
      stdout.text("Core energies:",flush=1)
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=1)
      stdout.put("MO_i",int_width=TRUE)
      stdout.put("Core energy")
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=1)
      do i = 1,.n_a
         stdout.put(i)
         stdout.put(core_energy(i),flush=1)
      end
      stdout.dash(int_fields=1,dbl_fields=1)
      stdout.flush
      stdout.text("Orbital pair energies:",flush=1)
      stdout.dash(int_fields=2,dbl_fields=1)
      stdout.put("MO_i",int_width=TRUE)
      stdout.put("MO_j",int_width=TRUE)
      stdout.put("Pair energy",flush=1)
      stdout.dash(int_fields=2,dbl_fields=1)
      do i = 1,.n_a
      do j = 1,i
         stdout.put(i)
         stdout.put(j)
         stdout.put(pair_energy(i,j),flush=1)
      end
      end
      stdout.dash(int_fields=2,dbl_fields=1)
      stdout.flush
  end

!*********************
! Fock matrix routines
!*********************

  get_fock_matrix [leaky]
  ! Get the Fock matrix. If already in memory, do nothing. Else if
  ! the archive file exists, read it. Otherwise make it.
     ARCHIVE :: archive
     STR :: kind
     kind = .scfdata.spinorbital_kind
     archive.set(.name,"fock_matrix",kind)
     if (archive.exists) then; archive.read(.fock_matrix)
     else;                      .make_fock_matrix
     end
  end

  make_fock_matrix(core,r12) [leaky]
  ! If core is present and FALSE, the core hamiltonian is not added
  ! If r12  is present and FALSE, the r12 part is not computed
    BIN, optional :: core,r12
    .make_fock_matrix(.density_matrix,.fock_matrix,core,r12)
  end

  make_fock_matrix(P,F,core,r12) [leaky]
  ! For the quicker ERI method.
    OPMAT* :: P,F
    BIN, optional :: core,r12
    STR :: scf_kind
    BIN :: direct,test
    scf_kind = .scfdata.kind
    direct = .scfdata.direct
    test   = .scfdata.test
    if (NOT direct) .get_ERI_integrals
    select case (scf_kind)
       case ("rhf","restricted_hartree_fock","xray_rhf")
          .make_r_fock(P,F,direct,core,r12,test)
       case ("xray_rks")
          F.destroy("restricted")
          F.create("restricted")
          if (present(core)) then
             if (core) then; .get_kinetic_matrix(F.restricted)
             else;           F.restricted = ZERO
             end
          else
                             .get_kinetic_matrix(F.restricted)
          end
       case ("rohf","restricted_open_shell_hartree_fock")
          .make_ro_fock(P,F,direct,core,r12)
       case ("uhf","unrestricted_hartree_fock")
          .make_u_fock(P,F,direct,core,r12)
       case ("gchf","cghf", &
             "general_complex_hartree_fock","complex_general_hartree_fock")
          .make_gc_fock(P,F,direct,core,r12)
          .add_gc_so_fock(P,F)
       case default; DIE("unknown scf kind, "// trim(scf_kind))
    end
  end

  add_core_hamiltonian(F,nuclei)
  ! Add the core hamiltonain to "F"
  ! if "nuclei" is present then the core_matrix is calculated using
  ! only the nuclei specified
     MAT :: F
     IVEC, optional :: nuclei
     MAT* :: H
     H.create(.n_bf, .n_bf)
     .get_core_matrix(H,nuclei)
     F = F + H
     H.destroy
  end

  add_core_hamiltonian(F,nuclei)
  ! Add the core hamiltonain to a general complex "F"
     CMAT :: F
     IVEC, optional :: nuclei
     CMAT,PTR :: HH
     MAT* :: H,S,T,xx,yy,zz,xy,xz,yz,Lx,Ly,Lz
     MAT(3,3) :: BB
     INT :: k,l
     DBL :: fac
     CDBL :: I
     HH.create(2*.n_bf, 2*.n_bf); HH = ZERO
     H.create(.n_bf, .n_bf)
     .get_core_matrix(H,nuclei)
     HH.alpha_alpha_plus(H)
     HH.beta_beta_plus(H)
     H.destroy
     I = (ZERO,ONE)
     if (.scfdata.using_1e_sl_term) then
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_spin_orbit_matrices(Lx,Ly,Lz)
           fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
           fac = fac * .scfdata.sl_1e_factor
           HH.beta_alpha_plus(Lx,factor=-fac*I)
           HH.beta_alpha_plus(Ly,factor=fac)
           HH.alpha_alpha_plus(Lz,factor=-fac*I)
           HH.beta_beta_plus(Lz,factor=fac*I)
           Lz.destroy; Ly.destroy; Lx.destroy
     else if (.scfdata.using_1e_zora_term) then
           T.create(.n_bf,.n_bf)
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_1e_ZORA_matrices(T,Lx,Ly,Lz)
           HH.alpha_alpha_plus(T)
           HH.beta_beta_plus(T)
           .get_kinetic_matrix(T) ! remove normal kinetic energy
           HH.alpha_alpha_plus(T,factor=-ONE)
           HH.beta_beta_plus(T,factor=-ONE)
           fac = G_FACTOR/TWO
           fac = fac * .scfdata.sl_1e_factor
           HH.beta_alpha_plus(Lx,factor=-fac*I)
           HH.beta_alpha_plus(Ly,factor=fac)
           HH.alpha_alpha_plus(Lz,factor=-fac*I)
           HH.beta_beta_plus(Lz,factor=fac*I)
           T.destroy
           Lz.destroy; Ly.destroy; Lx.destroy
     end
     if (.B_field.is_not_zero) then
        if (.scfdata.using_bs_term) then
           S.create(.n_bf,.n_bf)
           .get_overlap_matrix(S)
           fac = G_FACTOR/FOUR
           HH.alpha_alpha_plus(S,factor=fac*.B_field(3))
           HH.beta_beta_plus(S,factor=-fac*.B_field(3))
           HH.beta_alpha_plus(S,factor=fac*.B_field(1))
           HH.beta_alpha_plus(S,factor=fac*.B_field(2)*I)
           S.destroy
        end
        if (.scfdata.using_bs_t_term) then
           T.create(.n_bf,.n_bf)
           .get_kinetic_matrix(T)
           fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU**2)
           HH.alpha_alpha_plus(T,factor=fac*.B_field(3))
           HH.beta_beta_plus(T,factor=-fac*.B_field(3))
           HH.beta_alpha_plus(T,factor=fac*.B_field(1))
           HH.beta_alpha_plus(T,factor=fac*.B_field(2)*I)
           T.destroy
        end
        if (.scfdata.using_bl_term) then
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_L_matrices(Lx,Ly,Lz)
           Lx = Lx*.B_field(1) + Ly*.B_field(2) + Lz*.B_field(3)
           fac = HALF
           HH.alpha_alpha_plus(Lx,factor=fac*I)
           HH.beta_beta_plus(Lx,factor=fac*I)
           Lz.destroy; Ly.destroy; Lx.destroy
        end
        if (.scfdata.using_aa_term) then
          xx.create(.n_bf,.n_bf); yy.create(.n_bf,.n_bf); zz.create(.n_bf,.n_bf)
          xy.create(.n_bf,.n_bf); xz.create(.n_bf,.n_bf); yz.create(.n_bf,.n_bf)
          .get_quadrupole_matrices(xx,yy,zz,xy,xz,yz)
          fac = ONE/EIGHT
          do k = 1,3
             BB(k,k) = fac*(sum(.B_field*.B_field) - .B_field(k)*.B_field(k))
          end
          do k = 1,3
          do l = k+1,3
             BB(k,l) = -TWO*fac*.B_field(k)*.B_field(l)
          end
          end
          xx =      BB(1,1)*xx; xx = xx + BB(2,2)*yy; xx = xx + BB(3,3)*zz
          xx = xx + BB(1,2)*xy; xx = xx + BB(1,3)*xz; xx = xx + BB(2,3)*yz
          HH.alpha_alpha_plus(xx)
          HH.beta_beta_plus(xx)
          yz.destroy; xz.destroy; xy.destroy
          zz.destroy; yy.destroy; xx.destroy
        end
        if (.scfdata.using_1e_srxa_term) then
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_spin_orbit_B_matrices(Lx,Ly,Lz)
           fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
           HH.beta_alpha_plus(Lx,factor=fac)
           HH.beta_alpha_plus(Ly,factor=fac*I)
           HH.alpha_alpha_plus(Lz,factor=fac)
           HH.beta_beta_plus(Lz,factor=-fac)
           Lz.destroy; Ly.destroy; Lx.destroy
        end
     end
     HH.make_hermitian
     F = HH + F
     HH.destroy
  end

  make_r_fock(direct,core,r12,test) [leaky]
  ! Make a new restricted Fock matrix.
    BIN, optional :: direct,core,r12,test
    .make_r_fock(.density_matrix,.fock_matrix,direct,core,r12,test)
  end

  make_u_fock(direct,core,r12) [leaky]
  ! Make a new unrestricted Fock matrix.
    BIN, optional :: direct,core,r12
    .make_u_fock(.density_matrix,.fock_matrix,direct,core,r12)
  end

  make_ro_fock(direct,core,r12) [leaky]
  ! Make a new restricted open shell Fock matrix.
    BIN, optional :: direct,core,r12
    .make_ro_fock(.density_matrix,.fock_matrix,direct,core,r12)
  end

  make_gc_fock(direct,core,r12) [leaky]
  ! Make a new complex general Fock matrix.
    BIN, optional :: direct,core,r12
    .make_gc_fock(.density_matrix,.fock_matrix,direct,core,r12)
  end

  add_gc_so_fock(direct) [leaky]
  ! Add the general complex two electron spin orbit contribution to the
  ! .fock_matrix.
    BIN, optional :: direct
    .add_gc_so_fock(.density_matrix,.fock_matrix,direct)
  end

  make_r_fock(P,F,direct,core,r12,test) [leaky]
  ! Make a new restricted Fock matrix "F" from the density matrix "P".
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12,test
    OPMAT* :: P,F
    MAT* :: J,K
    BIN :: do_direct,add_core,add_r12,do_test
    ENSURE(P.created,"no density matrix")
    ENSURE(F.created,"no fock matrix")
    ENSURE(F.n_bf == .n_bf, "Fock matrix dimensions wrong")
    ENSURE(P.n_bf == .n_bf, "Density matrix dimensions wrong")
    ENSURE(P.restricted.created, "no density matrix")
    F.destroy("restricted")
    F.create("restricted")
    do_direct= FALSE
    do_test= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(test))   do_test  = test
    if (present(core))   add_core = core
    if (present(r12))    add_r12  = r12
    if (add_r12) then
       J.create(.n_bf,.n_bf)
       K.create(.n_bf,.n_bf)
!       if (do_test) then;        .make_r_JK_test(J,K,P.restricted)
       if (do_direct) then; .make_r_JK_direct(J,K,P.restricted)
       else;                     .make_r_JK_disk(J,K,P.restricted)
       end
       F.restricted = J - HALF*K
       K.destroy
       J.destroy
    else
       F.restricted = ZERO
    end
    if (add_core) .add_core_hamiltonian(F.restricted)
  end

  make_u_fock(P,F,direct,core,r12) [leaky]
  ! Make a new unrestricted Fock matrix.
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    OPMAT* :: P,F
    BIN, optional :: direct,core,r12
    MAT* :: J,Ka,Kb,Pab
    BIN :: do_direct,add_core,add_r12
    ENSURE(P.created,"no density matrix")
    ENSURE(F.created,"no fock matrix")
    ENSURE(P.alpha.created,"no density matrix")
    ENSURE(P.beta.created, "no density matrix")
    ENSURE(F.n_bf == .n_bf, "Fock matrix dimensions wrong")
    ENSURE(P.n_bf == .n_bf, "Density matrix dimensions wrong")
    F.destroy("unrestricted")
    F.create("unrestricted")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core))   add_core = core
    if (present(r12))    add_r12  = r12
    if (add_r12) then
       J.create(.n_bf,.n_bf)
       Ka.create(.n_bf,.n_bf)
       Kb.create(.n_bf,.n_bf)
       Pab.create(.n_bf,.n_bf)
       Pab  = P.alpha + P.beta
       if (do_direct) then; .make_u_JK_direct(J,Ka,Kb,Pab,P.alpha,P.beta)
       else;                .make_u_JK_disk(J,Ka,Kb,Pab,P.alpha,P.beta)
       end
       Pab.destroy
       F.alpha = J - Ka
       F.beta = J - Kb
       Kb.destroy
       Ka.destroy
       J.destroy
    else
       F.alpha = ZERO
       F.beta  = ZERO
    end
    if (add_core) .add_core_hamiltonian(F.alpha)
    if (add_core) .add_core_hamiltonian(F.beta)
  end

  make_ro_fock(P,F,direct,core,r12) [leaky]
  ! Make a new restricted open shell Fock matrix.
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    OPMAT* :: F,P
    BIN, optional :: direct,core,r12
    MAT* :: Fr,Fa,Fb,S,W
    ENSURE(.molecular_orbitals.restricted.created,"no orbitals")
    F.destroy("restricted")
    F.create("restricted")
    .make_u_fock(P,F,direct,core,r12)
    Fr => F.restricted
    Fa.create(.n_bf,.n_bf); Fa = F.alpha
    Fb.create(.n_bf,.n_bf); Fb = F.beta
    Fa.change_basis(.molecular_orbitals.restricted)
    Fb.change_basis(.molecular_orbitals.restricted)
    Fr = HALF*(Fa+Fb)
    Fr(.n_b+1:.n_a,     1:.n_b) = Fb(.n_b+1:.n_a,     1:.n_b)
    Fr(     1:.n_b,.n_b+1:.n_a) = Fb(     1:.n_b,.n_b+1:.n_a)
    Fr(.n_a+1:    ,.n_b+1:.n_a) = Fa(.n_a+1:    ,.n_b+1:.n_a)
    Fr(.n_b+1:.n_a,.n_a+1:    ) = Fa(.n_b+1:.n_a,.n_a+1:    )
    S => Fb; .get_overlap_matrix(S)
    W => Fa; W.to_product(.molecular_orbitals.restricted,S,transpose_a=TRUE)
    Fr.change_basis(W) ! change to AO basis
    Fb.destroy
    Fa.destroy
  end

  make_gc_fock(P,F,direct,core,r12) [leaky]
  ! Make a new complex general Fock matrix.
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    OPMAT* :: P,F
    CMAT* :: Ka,Kb,Kba,Pa,Pb,Pba,Fgc
    MAT* :: J, Pab
    BIN :: do_direct,add_core,add_r12
    ENSURE(P.created,"no density matrix")
    ENSURE(F.created,"no fock matrix")
    ENSURE(P.general_complex.created, "no density matrix")
    ENSURE(F.n_bf == .n_bf, "Fock matrix dimensions wrong")
    ENSURE(P.n_bf == .n_bf, "Density matrix dimensions wrong")
    F.destroy("general_complex")
    F.create("general_complex")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core)) add_core = core
    if (present(r12))  add_r12  = r12
    Fgc => F.general_complex
    if (add_r12) then
       J.create(.n_bf,.n_bf)
       Ka.create(.n_bf,.n_bf)
       Kb.create(.n_bf,.n_bf)
       Kba.create(.n_bf,.n_bf)
       Pa.create(.n_bf,.n_bf);  P.general_complex.alpha_alpha_put_to(Pa)
       Pb.create(.n_bf,.n_bf);  P.general_complex.beta_beta_put_to(Pb)
       Pba.create(.n_bf,.n_bf); P.general_complex.beta_alpha_put_to(Pba)
       Pab.create(.n_bf,.n_bf)
       Pab  = Pa + Pb
       if (do_direct) then; .make_gc_JK_direct(J,Ka,Kb,Kba,Pab,Pa,Pb,Pba)
       else;                .make_gc_JK_disk(J,Ka,Kb,Kba,Pab,Pa,Pb,Pba)
       end
       Pab.destroy
       Pba.destroy
       Pb.destroy
       Pa.destroy
       Ka = J - Ka; Fgc.alpha_alpha_set_to(Ka)
       Kb = J - Kb; Fgc.beta_beta_set_to(Kb)
       Kba = -Kba;  Fgc.beta_alpha_set_to(Kba)
       Kba.destroy
       Kb.destroy
       Ka.destroy
       J.destroy
    else
       Fgc = ZERO
    end
    Fgc.make_hermitian
    if (add_core) .add_core_hamiltonian(Fgc)
  end

  add_gc_so_fock(P,F,direct) [leaky]
  ! Make the general complex two electron spin orbit contribution to the Fock
  ! matrix.
    OPMAT* :: P,F
    BIN, optional :: direct
    CMAT5* :: JS,KS,JO,KO
    CMAT4* :: Pgc
    CMAT*  :: Faa,Fbb,Fba
    CDBL :: I
    DBL :: fac
    INT :: a,b,x,y,z
    BIN :: do_direct
    ENSURE(P.created,"no density matrix")
    ENSURE(F.created,"no fock matrix")
    ENSURE(P.general_complex.created, "no density matrix")
    ENSURE(F.general_complex.created, "no fock matrix")
    ENSURE(F.n_bf == .n_bf, "Fock matrix dimensions wrong")
    ENSURE(P.n_bf == .n_bf, "Density matrix dimensions wrong")
    do_direct= FALSE
    if (present(direct)) do_direct = direct
    if (.scfdata.using_2e_sl_term) then
      .get_spin_orbit_integrals
      Faa.create(.n_bf,.n_bf)
      Fbb.create(.n_bf,.n_bf)
      Fba.create(.n_bf,.n_bf)
      JS.create(.n_bf,.n_bf,2,2,3); KS.create(.n_bf,.n_bf,2,2,3)
      JO.create(.n_bf,.n_bf,2,2,3); KO.create(.n_bf,.n_bf,2,2,3)
      Pgc.create(.n_bf,.n_bf,2,2)
      P.general_complex.alpha_alpha_put_to(Pgc(:,:,1,1))
      P.general_complex.beta_alpha_put_to(Pgc(:,:,2,1))
      P.general_complex.alpha_beta_put_to(Pgc(:,:,1,2))
      P.general_complex.beta_beta_put_to(Pgc(:,:,2,2))
      if (do_direct) then
      .make_gc_so_JK_direct(JS,KS,JO,KO,Pgc)
      else
      .make_gc_so_JK_disk(JS(:,:,:,:,1),KS(:,:,:,:,1),JO(:,:,:,:,1),KO(:,:,:,:,1),Pgc,"x")
      .make_gc_so_JK_disk(JS(:,:,:,:,2),KS(:,:,:,:,2),JO(:,:,:,:,2),KO(:,:,:,:,2),Pgc,"y")
      .make_gc_so_JK_disk(JS(:,:,:,:,3),KS(:,:,:,:,3),JO(:,:,:,:,3),KO(:,:,:,:,3),Pgc,"z")
      end
      Pgc.destroy
      I = (ZERO,ONE)
      a = 1; b = 2; x = 1; y = 2; z = 3
      Faa =  THREE*JO(:,:,a,a,z) +       JO(:,:,b,b,z) + THREE*JS(:,:,a,a,z) -   JS(:,:,b,b,z) &
          +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
          +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
          -    TWO*KO(:,:,b,a,x) -       KO(:,:,a,b,x) -   TWO*KS(:,:,a,b,x) -   KS(:,:,b,a,x) &
          +  I*TWO*KO(:,:,b,a,y) -     I*KO(:,:,a,b,y) - I*TWO*KS(:,:,a,b,y) + I*KS(:,:,b,a,y) &
          -  THREE*KO(:,:,a,a,z) - THREE*KS(:,:,a,a,z)
      Fbb = -THREE*JO(:,:,b,b,z) -       JO(:,:,a,a,z) - THREE*JS(:,:,b,b,z) +   JS(:,:,a,a,z) &
          +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
          +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
          -    TWO*KO(:,:,a,b,x) -       KO(:,:,b,a,x) -   TWO*KS(:,:,b,a,x) -   KS(:,:,a,b,x) &
          -  I*TWO*KO(:,:,a,b,y) + I*KO(:,:,b,a,y)     + I*TWO*KS(:,:,b,a,y) - I*KS(:,:,a,b,y) &
          +  THREE*KO(:,:,b,b,z) + THREE*KS(:,:,b,b,z)
      Fba =    TWO*JO(:,:,a,a,x) +   TWO*JO(:,:,b,b,x) +       JS(:,:,a,a,x) +   JS(:,:,b,b,x) &
          +  I*TWO*JO(:,:,a,a,y) + I*TWO*JO(:,:,b,b,y) +     I*JS(:,:,a,a,y) + I*JS(:,:,b,b,y) &
          -    TWO*KO(:,:,a,a,x) -       KO(:,:,b,b,x) -   TWO*KS(:,:,b,b,x) -   KS(:,:,a,a,x) &
          -  I*TWO*KO(:,:,a,a,y) -     I*KO(:,:,b,b,y) - I*TWO*KS(:,:,b,b,y) - I*KS(:,:,a,a,y) &
          +        KO(:,:,b,a,z) -       KS(:,:,b,a,z)
      KO.destroy; JO.destroy; KS.destroy; JS.destroy

      fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
      fac = fac * .scfdata.sl_2e_factor
      F.general_complex.alpha_alpha_plus(Faa,factor=I*fac)
      F.general_complex.beta_beta_plus(Fbb,factor=I*fac)
      F.general_complex.beta_alpha_plus(Fba,factor=I*fac)
      Fbb = conjg(transpose(Fba))
      F.general_complex.alpha_beta_plus(Fbb,factor=-I*fac)
      Fba.destroy; Fbb.destroy; Faa.destroy
    end
  end

!**********************
! J & K matrix routines
!**********************

!  make_shellpair_vector(shellpair) [leaky]
!    SHELLPAIRVEC :: shellpair
!    INT :: ab,a,b, aa,sa,bb,sb
!    do ab = 1, .n_shell_pairs
!      .get_shell_pair_indices(ab,a,b)
!      aa = .atom_for_shell(a)
!      sa = .atom_shell_for_shell(a)
!      shellpair(ab).copy_a(.atom(aa).basis.shell(sa),.atom(aa).pos)
!      bb = .atom_for_shell(b)
!      sb = .atom_shell_for_shell(b)
!      shellpair(ab).copy_b(.atom(bb).basis.shell(sb),.atom(bb).pos)
!      shellpair(ab).make_precalculated_data
!    end
!  end

  schwarz_inequality_test(cutoff,ab,cd,a,b,c,d,P_max,I_max) result(skip)
  ! Return "skip", a logical variable which is TRUE if the maximum contribution
  ! to the restricted Fock matrix (based on the schwarz inequality test) from a
  ! shell of ERI integrals (ab|cd) with shell pair indices "ab" and "cd" is
  ! smaller than a preset "cutoff". "P_max" is the maximum density matrix
  ! elements for each shell pair "ab", and "I_max(ab)" is maximum value of the
  ! square root of the integral (ab|ab) for the shell pair with index "ab".
    BIN :: skip
    DBL :: cutoff
    INT :: ab,cd, a,b,c,d
    VEC :: P_max,I_max
    DBL :: Pmax
    INT :: ac,ad,bc,bd,k,l
    Pmax = ZERO                    ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
    ac = HALF*(a-1)*a + c
    ad = HALF*(a-1)*a + d
    k = max(b,c); l = min(b,c)
    bc = HALF*(k-1)*k + l
    k = max(b,d); l = min(b,d)
    bd = HALF*(k-1)*k + l
    Pmax = max(P_max(ab),P_max(cd),P_max(ac),P_max(ad),P_max(bc),P_max(bd))
    if (Pmax*I_max(ab)*I_max(cd) > cutoff) then; skip = FALSE
    else;                                        skip = TRUE
    end
  end

  make_max_density_elements(P_max,P)
  ! Make "P_max", the maximum of the (a,b) density elements of "P" over each
  ! shell pair, for use in the schwarz test.
    VEC :: P_max
    MAT :: P
    INT :: ab,fa,fb,la,lb,aa,bb, a,b
    DBL :: Pmax
    ENSURE(size(P_max)==.n_shell_pairs,"wrong size, P_max")
    ENSURE(size(P,1)==.n_bf,"wrong size, P")
    ENSURE(size(P,2)==.n_bf,"wrong size, P")
    ! Store the largest integral for each shell pair ab|ab
    do ab = 1, .n_shell_pairs
      .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb)
      Pmax = ZERO
      do a = fa,la
      do b = fb,lb
         Pmax = max(abs(P(a,b)),Pmax)
      end
      end
      P_max(ab) = Pmax
    end
  end

  make_max_abab_integrals(I_max)
  ! Make "I_max", the square root of the maximum of the (ab|ab) ERI integrals.
    VEC :: I_max
    INT :: ab,fa,fb,la,lb,sa,sb,na,nb, a,b
    SHELL4 :: shell4
    MAT4* :: Iabab
    DBL :: Imax
    ENSURE(size(I_max)==.n_shell_pairs,"wrong size, I_max")
    ! Store the largest integral for each shell pair ab|ab
    do ab = 1, .n_shell_pairs
      .get_shell_pair_indices(ab,sa,sb,fa,la,fb,lb)
      na = la-fa+1
      nb = lb-fb+1
      .set_shell_quartet_ab(shell4,sa,sb)  ! Set (ab|ab) shell
      .set_shell_quartet_cd(shell4,sa,sb)
      Iabab.create(na,nb,na,nb)
      shell4.get_ERI(Iabab)
      shell4.destroy_ptr_part
      Imax = ZERO
      do a=1,na
      do b=1,nb
         Imax = max(abs(Iabab(a,b,a,b)),Imax)
      end
      end
      I_max(ab) = sqrt(Imax)
      Iabab.destroy
    end
  end

  make_max_abab_so_integrals(I_max)
  ! Make "I_max", the square root of the maximum of the all (ab|ab) spin orbit integrals.
    VEC :: I_max
    INT :: ab,fa,fb,la,lb,sa,sb,na,nb, a,b
    SHELL4 :: shell4
    MAT5* :: S,O
    DBL :: Imax
    ENSURE(size(I_max)==.n_shell_pairs,"wrong size, I_max")
    ! Store the largest integral for each shell pair ab|ab
    do ab = 1, .n_shell_pairs              ! Store the largest integral for each
      .get_shell_pair_indices(ab,sa,sb,fa,la,fb,lb)
      na = la-fa+1
      nb = lb-fb+1
      .set_shell_quartet_ab(shell4,sa,sb)
      .set_shell_quartet_cd(shell4,sa,sb)
      S.create(na,nb,na,nb,3)
      O.create(na,nb,na,nb,3)
      shell4.make_spin_orbit_ints(S,O)
      shell4.destroy_ptr_part
      Imax = ZERO
      do a=1,na
      do b=1,nb
         Imax = max(abs(S(a,b,a,b,1)),abs(S(a,b,a,b,2)),abs(S(a,b,a,b,3)), &
                    abs(O(a,b,a,b,1)),abs(O(a,b,a,b,2)),abs(O(a,b,a,b,3)),Imax)
      end
      end
      I_max(ab) = sqrt(Imax)
      O.destroy
      S.destroy
    end
  end

  make_r_JK_direct(J,K,P)
  ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a
  ! symmetric density matrix "P" directly.
    MAT :: J,K,P
    VEC* :: max_I,max_P
    SHELL4 :: shell4
    INT :: ab,cd,i_a,i_b,i_c,i_d
    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd,factor,P_dc,P_db,P_cb,cutoff
    DBL :: Jcd,Kbc,Kbd,Kdb,Kad,Jab,Kac,P_ca,P_ba,P_da
    BIN :: skip

    J = ZERO
    K = ZERO
    cutoff = .scfdata.eri_cutoff

    max_I.create(.n_shell_pairs)
    max_P.create(.n_shell_pairs)
    .make_max_abab_integrals(max_I)
    .make_max_density_elements(max_P,P)
    do ab = 1, .n_shell_pairs
      .get_shell_pair_indices(ab,i_a,i_b)    ! a & b shell indices.
      fa = .first_basis_fn_for_shell(i_a)
      fb = .first_basis_fn_for_shell(i_b)
      la = .last_basis_fn_for_shell(i_a)
      lb = .last_basis_fn_for_shell(i_b)
      .set_shell_quartet_ab(shell4,i_a,i_b)
      do cd = 1,ab
        .get_shell_pair_indices(cd,i_c,i_d)  ! c & d shell indices.
        fc = .first_basis_fn_for_shell(i_c)
        fd = .first_basis_fn_for_shell(i_d)
        lc = .last_basis_fn_for_shell(i_c)
        ld = .last_basis_fn_for_shell(i_d)
                                       ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
        skip = .schwarz_inequality_test(cutoff,ab,cd,i_a,i_b,i_c,i_d,max_P,max_I)
        if (skip) cycle

        .set_shell_quartet_cd(shell4,i_c,i_d)
        if (i_a==i_b) then                   ! Evaluate the integrals'
          factor = HALF                      ! coincidence factors
        else
          factor = ONE
        end
        if (i_c==i_d) factor = HALF * factor
        if (i_a==i_c AND i_b==i_d) factor = HALF * factor

        shell4.make_r_JK(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
        shell4.destroy_cd
      end
      shell4.destroy_ab
    end
    max_P.destroy
    max_I.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(K)
    J.symmetric_reflect
    K.symmetric_reflect
    J = TWO*J
  end

  make_r_JK_disk(J,K,P)
  ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a
  ! symmetric density matrix "P" from disk integral archive "eri_integrals"
    MAT :: J,K,P
    ARCHIVE :: eri_archive,ind_archive
    MAT4* :: I
    INT :: q,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,n_quartets
    DBL :: I_abcd,P_dc,P_db,P_cb
    eri_archive.set(.name,"eri_integrals")
    ind_archive.set(.name,"eri_index")
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    ENSURE(eri_archive.exists, "no integral file")
    ENSURE(ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J = ZERO
    K = ZERO
    n_quartets = .n_shell_quartets
    do
      ind_archive.file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)
      I.create(fa,la,fb,lb,fc,lc,fd,ld)
      eri_archive.file.read(I)
      do d = fd,ld
        do c = fc,lc
          P_dc = P(d,c)
          do b = fb,lb
            P_db = P(d,b)
            P_cb = P(c,b)
            do a = fa,la
               I_abcd = I(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               J(c,d) = J(c,d) + I_abcd*P(b,a)
               K(a,c) = K(a,c) + I_abcd*P_db
               K(a,d) = K(a,d) + I_abcd*P_cb
               K(b,c) = K(b,c) + I_abcd*P(d,a)
               K(b,d) = K(b,d) + I_abcd*P(c,a)
            end
          end
        end
      end
      I.destroy
    end
    ind_archive.close
    eri_archive.close
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(K)
    J.symmetric_reflect
    K.symmetric_reflect
    J = TWO*J
  end

  make_u_JK_direct(J,Ka,Kb,P,Pa,Pb)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
  ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly.
    MAT,target :: J,Ka,Kb,P,Pa,Pb
    MAT4*   :: I
    VEC* :: max_P,max_I
    SHELL4 :: shell4
    INT :: ab,cd, aa,bb,cc,dd
    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd,factor,Pa_db,Pa_cb,Pb_db,Pb_cb,cutoff
    DBL :: P_dc,Jcd,Ka_bc,Ka_bd,Kb_bc,Kb_bd
    BIN :: skip
    J  = ZERO
    Ka = ZERO
    Kb = ZERO
    cutoff = .scfdata.eri_cutoff
    max_P.create(.n_shell_pairs)
    .make_max_density_elements(max_P,P)
    max_I.create(.n_shell_pairs )            ! Store the largest integral for each
    .make_max_abab_integrals(max_I)          ! shell pair ab|ab
    do ab = 1, .n_shell_pairs
      .get_shell_pair_indices(ab,aa,bb)      ! a & b shell indices.
      .set_shell_quartet_ab(shell4,aa,bb)
      fa = .first_basis_fn_for_shell(aa)
      fb = .first_basis_fn_for_shell(bb)
      la = .last_basis_fn_for_shell(aa)
      lb = .last_basis_fn_for_shell(bb)

      do cd = 1,ab
        .get_shell_pair_indices(cd,cc,dd)    ! c & d shell indices.

        fc = .first_basis_fn_for_shell(cc)
        fd = .first_basis_fn_for_shell(dd)
        lc = .last_basis_fn_for_shell(cc)
        ld = .last_basis_fn_for_shell(dd)
                                             ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
        skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,max_I)
        if (skip) cycle
                                             ! calculate ab|cd
        .set_shell_quartet_cd(shell4,cc,dd)
        factor = ONE                         ! Evaluate the integrals'
        if (aa==bb) factor = HALF            ! coincidence factors
        if (cc==dd) factor = HALF * factor
        if (aa==cc AND bb==dd) factor = HALF * factor

        I.create(fa,la,fb,lb,fc,lc,fd,ld)
        shell4.get_ERI(I)
        do d = fd,ld
          do c = fc,lc
            P_dc = P(d,c)
            Jcd = ZERO
            do b = fb,lb
              Pa_db = Pa(d,b)
              Pb_db = Pb(d,b)
              Pa_cb = Pa(c,b)
              Pb_cb = Pb(c,b)
              Ka_bc = ZERO
              Kb_bc = ZERO
              Ka_bd = ZERO
              Kb_bd = ZERO
              do a = fa,la
                I_abcd  = factor  * I(a,b,c,d)
                J(a,b)  = J(a,b)  + I_abcd*P_dc
                Jcd     = Jcd     + I_abcd*P(b,a)
                Ka(a,c) = Ka(a,c) + I_abcd*Pa_db
                Ka(a,d) = Ka(a,d) + I_abcd*Pa_cb
                Ka_bc   = Ka_bc   + I_abcd*Pa(d,a)
                Ka_bd   = Ka_bd   + I_abcd*Pa(c,a)
                Kb(a,c) = Kb(a,c) + I_abcd*Pb_db
                Kb(a,d) = Kb(a,d) + I_abcd*Pb_cb
                Kb_bc   = Kb_bc   + I_abcd*Pb(d,a)
                Kb_bd   = Kb_bd   + I_abcd*Pb(c,a)
              end
              Ka(b,c) = Ka(b,c) + Ka_bc
              Ka(b,d) = Ka(b,d) + Ka_bd
              Kb(b,c) = Kb(b,c) + Kb_bc
              Kb(b,d) = Kb(b,d) + Kb_bd
            end
            J(c,d) = J(c,d) + Jcd
          end
        end
        I.destroy
        shell4.destroy_cd
      end
      shell4.destroy_ab
    end
    max_I.destroy
    max_P.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(Ka)
    .blockwise_symmetric_fold(Kb)
    J.symmetric_reflect
    Ka.symmetric_reflect
    Kb.symmetric_reflect
    J = TWO*J
  end

  make_u_JK_disk(J,Ka,Kb,P,Pa,Pb)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
  ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly.
    MAT :: J,Ka,Kb,P,Pa,Pb
    ARCHIVE* :: eri_archive,ind_archive
    MAT4*   :: I
    INT :: q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd,P_dc,Pa_db,Pa_cb,Pb_db,Pb_cb
    eri_archive.create(.name,"eri_integrals")
    ind_archive.create(.name,"eri_index")
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    ENSURE(eri_archive.exists, "no integral file")
    ENSURE(ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J  = ZERO
    Ka = ZERO
    Kb = ZERO
    n_quartets = .n_shell_quartets
    do
      ind_archive.file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)
      I.create(fa,la,fb,lb,fc,lc,fd,ld)
      eri_archive.file.read(I)
      do d = fd,ld
        do c = fc,lc
          P_dc = P(d,c)
          do b = fb,lb
            Pa_db = Pa(d,b)
            Pb_db = Pb(d,b)
            Pa_cb = Pa(c,b)
            Pb_cb = Pb(c,b)
            do a = fa,la
               I_abcd = I(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               J(c,d) = J(c,d) + I_abcd*P(b,a)
               Ka(a,c) = Ka(a,c) + I_abcd*Pa_db
               Ka(a,d) = Ka(a,d) + I_abcd*Pa_cb
               Ka(b,c) = Ka(b,c) + I_abcd*Pa(d,a)
               Ka(b,d) = Ka(b,d) + I_abcd*Pa(c,a)
               Kb(a,c) = Kb(a,c) + I_abcd*Pb_db
               Kb(a,d) = Kb(a,d) + I_abcd*Pb_cb
               Kb(b,c) = Kb(b,c) + I_abcd*Pb(d,a)
               Kb(b,d) = Kb(b,d) + I_abcd*Pb(c,a)
            end
          end
        end
      end
      I.destroy
    end
    ind_archive.destroy
    eri_archive.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(Ka)
    .blockwise_symmetric_fold(Kb)
    J.symmetric_reflect
    Ka.symmetric_reflect
    Kb.symmetric_reflect
    J = TWO*J
  end

  make_gc_JK_direct(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
  ! Make the general complex matrices "J" and exchange matrices
  ! "Ka", "Kb" and "Kba" from a density matrices "P", "Pa", "Pb" and "Pba"
  ! directly from the integrals.
    MAT :: J,P
    CMAT :: Ka,Kb,Kba,Pa,Pb,Pba
    MAT4*   :: I
    MAT* :: abs_P
    VEC* :: max_I,max_P
    SHELL4 :: shell4
    INT :: ab,cd,aa,bb,cc,dd
    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd,factor,cutoff
    BIN :: skip
    J   = ZERO
    Ka  = ZERO
    Kb  = ZERO
    Kba = ZERO
    cutoff = .scfdata.eri_cutoff
    abs_P.create(.n_bf,.n_bf)
    abs_P = max(abs(P),abs(Pa),abs(Pb),abs(Pb))
    max_P.create(.n_shell_pairs)
    .make_max_density_elements(max_P,abs_P)
    max_I.create(.n_shell_pairs)             ! Store the largest integral for each
    .make_max_abab_integrals(max_I)          ! shell pair ab|ab
    do ab = 1,.n_shell_pairs
      .get_shell_pair_indices(ab,aa,bb)
      .set_shell_quartet_ab(shell4,aa,bb)
      fa = .first_basis_fn_for_shell(aa)
      fb = .first_basis_fn_for_shell(bb)
      la = .last_basis_fn_for_shell(aa)
      lb = .last_basis_fn_for_shell(bb)
      do cd = 1,ab
        .get_shell_pair_indices(cd,cc,dd)
        fc = .first_basis_fn_for_shell(cc)
        fd = .first_basis_fn_for_shell(dd)
        lc = .last_basis_fn_for_shell(cc)
        ld = .last_basis_fn_for_shell(dd)
                                             ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
        skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,max_I)
        if (skip) cycle
                                             ! calculate ab|cd
        .set_shell_quartet_cd(shell4,cc,dd)
        I.create(fa,la,fb,lb,fc,lc,fd,ld)
        shell4.get_ERI(I)
        factor = ONE                             ! Evaluate the integrals
        if (aa==bb) factor = HALF                ! Coincidence factors
        if (cc==dd) factor = HALF * factor
        if (aa==cc AND bb==dd) factor = HALF * factor
        I = factor * I
        do d = fd,ld
        do c = fc,lc
        do b = fb,lb
        do a = fa,la
           I_abcd = I(a,b,c,d)
           J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
           J(c,d)   = J(c,d)   + I_abcd*P(b,a)
           Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric
           Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)  ! but must be folded
           Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
           Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
           Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric
           Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)  ! but must be folded
           Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
           Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
           Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
           Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d)
           Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
           Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
           Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
           Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
           Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
           Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
        end
        end
        end
        end
        I.destroy
        shell4.destroy_cd
      end
      shell4.destroy_ab
    end
    max_I.destroy
    max_P.destroy
    abs_P.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_hermitian_fold(Ka)
    .blockwise_hermitian_fold(Kb)
    J.symmetric_reflect
    Ka.make_hermitian
    Kb.make_hermitian
    J = TWO*J
  end

  make_gc_JK_disk(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
  ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly.
    MAT :: J,P
    CMAT :: Ka,Kb,Kba,Pa,Pb,Pba
    ARCHIVE* :: eri_archive,ind_archive
    MAT4*   :: I
    INT :: q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd
    eri_archive.create(.name,"eri_integrals")
    ind_archive.create(.name,"eri_index")
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    ENSURE(eri_archive.exists, "no integral file")
    ENSURE(ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J   = ZERO
    Ka  = ZERO
    Kb  = ZERO
    Kba = ZERO
    n_quartets = .n_shell_quartets
    do
      ind_archive.file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)
    ! I.create(fa,la,fb,lb,fc,lc,fd,ld)
      allocate(I(fa:la,fb:lb,fc:lc,fd:ld))
      eri_archive.file.read(I)
      do d = fd,ld
      do c = fc,lc
      do b = fb,lb
      do a = fa,la
          I_abcd = I(a,b,c,d)
          J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
          J(c,d)   = J(c,d)   + I_abcd*P(b,a)
          Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric but must be folded
          Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)
          Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
          Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
          Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric but must be folded
          Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)
          Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
          Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
          Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
          Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d)
          Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
          Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
          Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
          Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
          Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
          Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
      end
      end
      end
      end
    ! I.destroy
      deallocate(I)
    end
    ind_archive.destroy
    eri_archive.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_hermitian_fold(Ka)
    .blockwise_hermitian_fold(Kb)
    J.symmetric_reflect
    Ka.make_hermitian
    Kb.make_hermitian
    J = TWO*J
  end

  make_gc_so_JK_direct(JS,KS,JO,KO,P)
  ! Make the general complex spin orbit Classical and Exchange matrices.
  ! Make them directly from integrals on the fly.
    CMAT5 :: JS,KS,JO,KO
    CMAT4 :: P
    MAT5* :: S,O
    INT :: ab,cd,aa,bb,cc,dd
    INT :: a,b,c,d,k,fa,fb,fc,fd,la,lb,lc,ld,m,n
    DBL :: S_abcd,O_abcd,factor
    SHELL4* :: shell4
    CDBL :: I
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    JS = ZERO; KS = ZERO; JO = ZERO; KO = ZERO
    I = (ZERO,ONE)
    shell4.create
    do ab = 1,.n_shell_pairs
      .get_shell_pair_indices(ab,aa,bb)
      fa = .first_basis_fn_for_shell(aa)
      fb = .first_basis_fn_for_shell(bb)
      la = .last_basis_fn_for_shell(aa)
      lb = .last_basis_fn_for_shell(bb)
      do cd = 1,ab
        .get_shell_pair_indices(cd,cc,dd)
        fc = .first_basis_fn_for_shell(cc)
        fd = .first_basis_fn_for_shell(dd)
        lc = .last_basis_fn_for_shell(cc)
        ld = .last_basis_fn_for_shell(dd)
        .get_shell_quartet(shell4,aa,bb,cc,dd)
        if (shell4.skip_ERI) then ! ??????
          shell4.destroy_ptr_part
          cycle
        end
        allocate(S(fa:la,fb:lb,fc:lc,fd:ld,3))
        allocate(O(fa:la,fb:lb,fc:lc,fd:ld,3))
        shell4.make_spin_orbit_ints(S,O)
        factor = ONE                                   ! Evaluate the integrals
        if (aa==bb) factor = HALF                      ! Coincidence factors
        if (cc==dd) factor = HALF * factor
        if (aa==cc AND bb==dd) factor = HALF * factor
        S = factor * S
        O = factor * O
        do k = 1,3
        do a = fa,la
        do b = fb,lb
        do c = fc,lc
        do d = fd,ld
           S_abcd = S(a,b,c,d,k)
           O_abcd = O(a,b,c,d,k)
           do m = 1,2
           do n = 1,2
              !
              JS(a,b, m,n,k) = JS(a,b, m,n,k) + S_abcd*P(d,c, m,n)
              JS(a,b, m,n,k) = JS(a,b, m,n,k) + S_abcd*P(c,d, m,n)
              JS(b,a, m,n,k) = JS(b,a, m,n,k) - S_abcd*P(d,c, m,n)
              JS(b,a, m,n,k) = JS(b,a, m,n,k) - S_abcd*P(c,d, m,n)
              JS(c,d, m,n,k) = JS(c,d, m,n,k) + O_abcd*P(b,a, m,n)
              JS(c,d, m,n,k) = JS(c,d, m,n,k) + O_abcd*P(a,b, m,n)
              JS(d,c, m,n,k) = JS(d,c, m,n,k) - O_abcd*P(b,a, m,n)
              JS(d,c, m,n,k) = JS(d,c, m,n,k) - O_abcd*P(a,b, m,n)
              !
              JO(a,b, m,n,k) = JO(a,b, m,n,k) + O_abcd*P(d,c, m,n)
              JO(a,b, m,n,k) = JO(a,b, m,n,k) - O_abcd*P(c,d, m,n)
              JO(b,a, m,n,k) = JO(b,a, m,n,k) + O_abcd*P(d,c, m,n)
              JO(b,a, m,n,k) = JO(b,a, m,n,k) - O_abcd*P(c,d, m,n)
              JO(c,d, m,n,k) = JO(c,d, m,n,k) + S_abcd*P(b,a, m,n)
              JO(c,d, m,n,k) = JO(c,d, m,n,k) - S_abcd*P(a,b, m,n)
              JO(d,c, m,n,k) = JO(d,c, m,n,k) + S_abcd*P(b,a, m,n)
              JO(d,c, m,n,k) = JO(d,c, m,n,k) - S_abcd*P(a,b, m,n)
              !
              KS(a,d, m,n,k) = KS(a,d, m,n,k) + S_abcd*P(b,c, m,n)
              KS(a,c, m,n,k) = KS(a,c, m,n,k) + S_abcd*P(b,d, m,n)
              KS(b,d, m,n,k) = KS(b,d, m,n,k) - S_abcd*P(a,c, m,n)
              KS(b,c, m,n,k) = KS(b,c, m,n,k) - S_abcd*P(a,d, m,n)
              KS(c,b, m,n,k) = KS(c,b, m,n,k) + O_abcd*P(d,a, m,n)
              KS(c,a, m,n,k) = KS(c,a, m,n,k) + O_abcd*P(d,b, m,n)
              KS(d,b, m,n,k) = KS(d,b, m,n,k) - O_abcd*P(c,a, m,n)
              KS(d,a, m,n,k) = KS(d,a, m,n,k) - O_abcd*P(c,b, m,n)
              !
              KO(a,d, m,n,k) = KO(a,d, m,n,k) + O_abcd*P(b,c, m,n)
              KO(a,c, m,n,k) = KO(a,c, m,n,k) - O_abcd*P(b,d, m,n)
              KO(b,d, m,n,k) = KO(b,d, m,n,k) + O_abcd*P(a,c, m,n)
              KO(b,c, m,n,k) = KO(b,c, m,n,k) - O_abcd*P(a,d, m,n)
              KO(c,b, m,n,k) = KO(c,b, m,n,k) + S_abcd*P(d,a, m,n)
              KO(c,a, m,n,k) = KO(c,a, m,n,k) - S_abcd*P(d,b, m,n)
              KO(d,b, m,n,k) = KO(d,b, m,n,k) + S_abcd*P(c,a, m,n)
              KO(d,a, m,n,k) = KO(d,a, m,n,k) - S_abcd*P(c,b, m,n)
           end
           end
        end
        end
        end
        end
        end
        deallocate(O)
        deallocate(S)
        shell4.destroy_ptr_part
      end
    end
    shell4.destroy
  end

  make_gc_so_JK_disk(JS,KS,JO,KO,P,component)
  ! Make the general complex spin orbit Classical and Exchange matrices
  ! for a particular "component", either "x", "y" or "z".
    CMAT4 :: JS,KS,JO,KO,P
    CHR :: component
    ARCHIVE :: SO_archive,ind_archive
    MAT4*   :: S,O
    INT :: q,n_quartets
    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,m,n
    DBL :: S_abcd,O_abcd
    CDBL :: I
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    SO_archive.set(.name,"SO"//component//"_integrals")
    ind_archive.set(.name,"SO_indices")
    ENSURE(SO_archive.exists,  "no spin orbit integral file!")
    ENSURE(ind_archive.exists, "no spin orbit integral index file")
    SO_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    JS = ZERO; KS = ZERO; JO = ZERO; KO = ZERO
    I = (ZERO,ONE)
    n_quartets = .n_shell_quartets
    do
       ind_archive.file.read(q)
       if (q > n_quartets) exit
       .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)
       S.create(fa,la,fb,lb,fc,lc,fd,ld)
       O.create(fa,la,fb,lb,fc,lc,fd,ld)
       SO_archive.file.read(S)
       SO_archive.file.read(O)
       do a = fa,la
       do b = fb,lb
       do c = fc,lc
       do d = fd,ld
          S_abcd = S(a,b,c,d)
          O_abcd = O(a,b,c,d)
          do m = 1,2
          do n = 1,2
             !
             JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(d,c, m,n)
             JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(c,d, m,n)
             JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(d,c, m,n)
             JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(c,d, m,n)
             JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(b,a, m,n)
             JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(a,b, m,n)
             JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(b,a, m,n)
             JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(a,b, m,n)
             !
             JO(a,b, m,n) = JO(a,b, m,n) + O_abcd*P(d,c, m,n)
             JO(a,b, m,n) = JO(a,b, m,n) - O_abcd*P(c,d, m,n)
             JO(b,a, m,n) = JO(b,a, m,n) + O_abcd*P(d,c, m,n)
             JO(b,a, m,n) = JO(b,a, m,n) - O_abcd*P(c,d, m,n)
             JO(c,d, m,n) = JO(c,d, m,n) + S_abcd*P(b,a, m,n)
             JO(c,d, m,n) = JO(c,d, m,n) - S_abcd*P(a,b, m,n)
             JO(d,c, m,n) = JO(d,c, m,n) + S_abcd*P(b,a, m,n)
             JO(d,c, m,n) = JO(d,c, m,n) - S_abcd*P(a,b, m,n)
             !
             KS(a,d, m,n) = KS(a,d, m,n) + S_abcd*P(b,c, m,n)
             KS(a,c, m,n) = KS(a,c, m,n) + S_abcd*P(b,d, m,n)
             KS(b,d, m,n) = KS(b,d, m,n) - S_abcd*P(a,c, m,n)
             KS(b,c, m,n) = KS(b,c, m,n) - S_abcd*P(a,d, m,n)
             KS(c,b, m,n) = KS(c,b, m,n) + O_abcd*P(d,a, m,n)
             KS(c,a, m,n) = KS(c,a, m,n) + O_abcd*P(d,b, m,n)
             KS(d,b, m,n) = KS(d,b, m,n) - O_abcd*P(c,a, m,n)
             KS(d,a, m,n) = KS(d,a, m,n) - O_abcd*P(c,b, m,n)
             !
             KO(a,d, m,n) = KO(a,d, m,n) + O_abcd*P(b,c, m,n)
             KO(a,c, m,n) = KO(a,c, m,n) - O_abcd*P(b,d, m,n)
             KO(b,d, m,n) = KO(b,d, m,n) + O_abcd*P(a,c, m,n)
             KO(b,c, m,n) = KO(b,c, m,n) - O_abcd*P(a,d, m,n)
             KO(c,b, m,n) = KO(c,b, m,n) + S_abcd*P(d,a, m,n)
             KO(c,a, m,n) = KO(c,a, m,n) - S_abcd*P(d,b, m,n)
             KO(d,b, m,n) = KO(d,b, m,n) + S_abcd*P(c,a, m,n)
             KO(d,a, m,n) = KO(d,a, m,n) - S_abcd*P(c,b, m,n)
          end
          end
       end
       end
       end
       end
       O.destroy; S.destroy
    end
    SO_archive.close
    ind_archive.close
  end

  weight_diagonal_blocks(X,fac) [pure]
  ! Weight the diagonal blocks of matrix "X" by "fac"
     IN :: self
     MAT, INOUT :: X
     DBL, IN :: fac
     INT :: n,f,l
     do n = 1,.n_shell
        f = .first_basis_fn_for_shell(n)
        l = .last_basis_fn_for_shell(n)
        X(f:l,f:l) = fac*X(f:l,f:l)
     end
  end

  weight_diagonal_blocks(X,fac) [pure]
  ! Weight the diagonal blocks of matrix "X" by "fac"
     IN :: self
     CMAT, INOUT :: X
     DBL, IN :: fac
     INT :: n,f,l
     do n = 1,.n_shell
        f = .first_basis_fn_for_shell(n)
        l = .last_basis_fn_for_shell(n)
        X(f:l,f:l) = fac*X(f:l,f:l)
     end
  end

  set_diagonal_blocks(X,fac) [pure]
  ! Set the diagonal blocks of matrix "X" to "fac"
     IN :: self
     MAT, INOUT :: X
     DBL, IN :: fac
     INT :: n,f,l
     do n = 1,.n_shell
        f = .first_basis_fn_for_shell(n)
        l = .last_basis_fn_for_shell(n)
        X(f:l,f:l) = fac
     end
  end

  blockwise_symmetric_fold(X)
  ! Symmetrically fold the matrix "X" blockwise
     MAT :: X
     INT :: a,fa,la,b,fb,lb
     do a = 1,.n_shell
     do b = 1,a
        fa = .first_basis_fn_for_shell(a)
        la = .last_basis_fn_for_shell(a)
        fb = .first_basis_fn_for_shell(b)
        lb = .last_basis_fn_for_shell(b)
        X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(X(fb:lb,fa:la))
     end
     end
  end

  blockwise_hermitian_fold(X)
  ! Hermitian fold the matrix "X" blockwise
     CMAT :: X
     INT :: a,fa,la,b,fb,lb
     do a = 1,.n_shell
     do b = 1,a
        fa = .first_basis_fn_for_shell(a)
        la = .last_basis_fn_for_shell(a)
        fb = .first_basis_fn_for_shell(b)
        lb = .last_basis_fn_for_shell(b)
        X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(conjg(X(fb:lb,fa:la)))
     end
     end
  end


! ******************
! Constraint methods
! ******************

  constrained_scf_rhf [leaky]
  ! Do a restricted Hartree-Fock calculation. The following objects
  ! are destroyed and made new:
  !   .overlap_matrix, .core_matrix, .fock_matrix,
  ! The following objects are produced as results:
  !   .molecular_orbitals, .orbital_energies, .density_matrix
  ! The following objects are deleted from memory after execution:
  !   .overlap_matrix, .core_matrix, .fock_matrix
    OPMAT* :: dP,dF,old_P,old_F,constraint,old_MO
    DBL :: E_HF,E_K,diis_error

    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    DIE_IF(.mult/=1,"this is not a singlet state")

    .get_initial_guess
    .make_fock_matrix
    dP.create(.n_bf); old_P.create_copy(.density_matrix)
    dF.create(.n_bf); old_F.create_copy(.fock_matrix)
    old_MO.create_copy(.molecular_orbitals)
    constraint.create(.n_bf,"restricted")

    .make_structure_factors
    E_HF = .scf_energy
    E_K = .kinetic_energy

    .make_constraint(constraint, .scfdata.lambda )
    .add_constraint(constraint)
    .make_diis_error(diis_error)

    .scfdata.reset(.atom.nuclear_energy,E_HF,E_K,.crystal)
    .scfdata.set_diis_error(diis_error)
    .scfdata.put_banner
    .crystal.put_correction_data(stdout)

    do
      .scfdata.put_results                     ! Zeroth iteration (important!)
      .scfdata.diis.cleanup
      do
        old_MO.set_to(.molecular_orbitals)
        old_P.set_to(.density_matrix)
        old_F.set_to(.fock_matrix)
        .extrapolate_scf
        .update_molecular_orbitals
        .schmidt_orthonormalise(.molecular_orbitals)
        .make_scf_density_matrix
        .save_scf_results
        .make_fock_matrix

        E_HF = .scf_energy
        E_K = .kinetic_energy
        .make_structure_factors

        .make_constraint(constraint, .scfdata.lambda )
        .add_constraint(constraint)

        if (.scfdata.apply_camp_king) .camp_king(old_MO,old_F,E_HF,E_K)

        .make_diis_error(diis_error)
        .scfdata.update(E_HF,E_K,.crystal)
        .scfdata.set_diis_error(diis_error)
        .scfdata.put_results
        if (.scfdata.scf_done) exit
      end
      .scfdata.update_lambda

      if (.scfdata.exceeded_lambda_max) exit
    end

    old_MO.destroy
    constraint.destroy
    .scfdata.cleanup_diis
    .fock_matrix.destroy("all")
    dF.destroy
    dP.destroy
    old_F.destroy
    old_P.destroy

    .crystal.put_reflection_data
  end

  add_constraint(constraint)
  ! Make the constraint matrix for wavefunction fitting and add it to the fock
  ! matrix.
    MAT* :: MO,temp,S
    OPMAT :: constraint
    STR :: kind
    kind = .scfdata.spinorbital_kind
    if (kind == "restricted") then
      if (.molecular_orbitals.destroyed(kind) ) .make_fock_guess
      MO => .molecular_orbitals.restricted
    else
      DIE("can only do restricted calculations.")
    end
    ! Add the constraint in the MO basis
!    constraint.restricted.change_basis(MO)          ! Zero out the occ-occ and vir-vir
!    constraint.restricted(:.n_a, :.n_a) = ZERO      ! blocks of the constraint matrix
!    constraint.restricted(.n_a+1:, .n_a+1:) = ZERO  ! to improve convergence.
!    .fock_matrix.restricted.change_basis(MO)
!    .fock_matrix.restricted(.n_a+1:,:.n_a).to_product(ONE/(.scfdata.lambda+1))
!    .fock_matrix.restricted(:.n_a,.n_a+1:).to_product(ONE/(.scfdata.lambda+1))

    .fock_matrix.plus(constraint)

!    ! Change .fock_matrix back to the AO basis
!    temp.create(.n_bf, .n_bf)
!    S.create(.n_bf, .n_bf)
!    .get_overlap_matrix(S)
!    temp.to_product(MO,S,transpose_a=TRUE)
!    S.destroy
!    .fock_matrix.restricted.change_basis(temp) ! Back to AO basis.
!    temp.destroy
  end

  make_constraint(constraint,lambda)
  ! Make the constraint matrix for wavefunction fitting.
    OPMAT :: constraint
    DBL, IN :: lambda
    MAT* :: k_pts,const
    CMAT3* :: ft_ab_eq,ft_ab
    CVEC* :: Fc,fac_times_alpha
    VEC* :: Fm,Fexp,Fsig,alpha
    SHELL2 :: shell
    DBL :: fac,cutoff
    INT :: q,a,b,fa,la,fb,lb,n,i,j,n_refl,n_unique,atom_a,atom_b
    ENSURE(.crystal.created,  "no crystal info")
    ENSURE(.crystal.reflection_data_exists, "no reflection data")
    ENSURE(.atom.created,  "no atom list")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    n_unique = .crystal.n_unique_k_pts
    n_refl = .crystal.n_refl
    fac = TWO*lambda/max(n_refl - .crystal.n_param,1)

    fac_times_alpha.create(n_refl)
    Fc.create(n_refl);    Fc = .crystal.F_calc

    alpha.create(n_refl)
    alpha = .crystal.extinction_correction
    Fexp.create(n_refl);  Fexp = .crystal.F_exp
    Fsig.create(n_refl);  Fsig = .crystal.F_sigma
    Fm.create(n_refl);    Fm = abs(Fc)
    fac_times_alpha = fac * alpha * (alpha * Fm - Fexp) / (Fsig * Fsig * Fm)
    Fm.destroy
    Fsig.destroy
    Fexp.destroy
    alpha.destroy

    k_pts.create(n_unique,3)
    .crystal.make_unique_k_pts(k_pts)
    cutoff = TOL(10) / .n_shell_pairs
    const => constraint.restricted
    do q=1, .n_shell_pairs
      .get_shell_pair(shell,q,a,b,fa,la,fb,lb,atom_a,atom_b)
      if (shell.skip_ft(cutoff)) then
        const(fa:la,fb:lb) = ZERO
        shell.destroy_ptr_part
        cycle
      end
      ft_ab.create((/1,n_refl/),(/fa,la/),(/fb,lb/))
      ft_ab_eq.create(n_unique,shell.a.n_comp,shell.b.n_comp)
      .make_ft_pair(ft_ab_eq,k_pts,shell,atom_a,atom_b)
      .crystal.sum_ft_ints(ft_ab,ft_ab_eq)
      ft_ab_eq.destroy
      do i = fa,la
        do j = fb,min(lb,i)
          const(i,j) = sum(fac_times_alpha(:) * &
           real(ft_ab(:,i,j) * conjg(Fc(:))))
        end
      end
      ft_ab.destroy
      shell.destroy_ptr_part
    end
    const.symmetric_reflect
    k_pts.destroy
    Fc.destroy
    fac_times_alpha.destroy
  end

! ****************
! Plotting methods
! ****************

  plot [leaky]
  ! Do one of the many kinds of plot calculations
    ENSURE(.grid.created, "no grid")
    .grid.put
    select case (.grid.kind)
       case("electron_density");     .make_electron_density_grid
       case("laplacian_density");    .make_laplacian_density_grid
       case("orbital_density");      .make_orbital_density_grid(.grid.orbital)
       case("orbital");              .make_orbital_grid(.grid.orbital)
       case("difference_density");   .make_difference_density_grid
       case("fermi_mobility");       .make_fermi_mobility_grid
       case("crystal_error_map");    .make_crystal_error_map
       case("qq_plot");              .crystal.put_qq_plot(.name)
       case("spin_density");         .make_spin_density_grid
       case("current_density");      .make_j_density_grid
       case("j_density");            .make_j_density_grid
       case("jp_density");           .make_jp_density_grid
       case("jd_density");           .make_jd_density_grid
       case("elf");                  .make_ELF_grid
       case("electric_potential");   .make_electric_potential_grid
       case("solenoidal_jp");        .make_solenoidal_jp_grid
       case default;                 DIE("unknown plot type")
    end
  end

   bounding_cube_width result(width)
   ! Return "width", the width of a cube in which the molecule nicely sits.
   ! Suitable for generating plot widths.
      DBL :: width
      width = .atom.bounding_cube_width
   end

   get_electron_density_grid(density_grid) [leaky]
   ! Set "density_grid" to the electron density grid.
   ! If the archive file exists, read it; otherwise make it.
      VEC :: density_grid
      ARCHIVE :: archive
      archive.set(.name,"electron_density_grid")
      if (NOT archive.exists) .make_electron_density_grid
      archive.read(density_grid)
   end

   make_electron_density_grid [leaky]
   ! Work out the density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC* :: density_grid
      ENSURE(.grid.created, "no grid")
      density_grid.create(.grid.n_pt)
      .make_density_grid(density_grid)
      archive.set(.name,"electron_density_grid")
      archive.write(density_grid)
      archive.set(.name,"electron_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(density_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      density_grid.destroy
   end

   get_laplacian_density_grid(laplacian_grid) [leaky]
   ! Set "laplacian_grid" to the Laplacian density grid.
   ! If the archive file exists, read it; otherwise make it.
      VEC :: laplacian_grid
      ARCHIVE :: archive
      archive.set(.name,"laplacian_density_grid")
      if (NOT archive.exists) .make_laplacian_density_grid
      archive.read(laplacian_grid)
   end

   make_laplacian_density_grid [leaky]
   ! Work out the laplacian density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC* :: laplacian_grid
      ENSURE(.grid.created, "no grid")
      laplacian_grid.create(.grid.n_pt)
      .make_laplacian_grid(laplacian_grid)
      archive.set(.name,"laplacian_density_grid")
      archive.write(laplacian_grid)
      archive.set(.name,"laplacian_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(laplacian_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      laplacian_grid.destroy
   end

  make_difference_density_grid
  ! Make a Gnuplot ascii file containing the difference density grid.
    ARCHIVE :: archive
    VEC* :: density_grid,atom_density_grid
    MAT* :: pts
    BIN :: old_dens,old_NOs
    STR :: kind
    ENSURE(.grid.created, "no grid")

    density_grid.create(.grid.n_pt)
    pts.create(.grid.n_pt,3); .grid.points(pts)

    ! Get NOs for the molecule
    old_NOs = FALSE;      old_dens = FALSE
    kind = .scfdata.molecular_orbital_kind
    if (.density_matrix.created)   old_dens = .density_matrix.any_created
    if (.natural_orbitals.created) old_NOs = .natural_orbitals.any_created
    if (old_NOs) then
      archive.set(.name,"temp_natural_orbitals")
      archive.write(.natural_orbitals)
      archive.set(.name,"temp_occupation")
      archive.write(.occupation)
    else
      .make_natural_orbitals
    end
    if (old_dens) then
      archive.set(.name,"temp_density_matrix")
      archive.write(.density_matrix)
    end

    ! Get density grid for the molecule
    .make_density_grid(density_grid)
    .natural_orbitals.destroy
    .occupation.destroy
    .density_matrix.destroy

    ! Get density grid for the promolecule
    .get_atom_density
    .make_natural_orbitals
    atom_density_grid.create(.grid.n_pt)
    .make_density_grid(atom_density_grid)
    density_grid = density_grid - atom_density_grid
    atom_density_grid.destroy

    ! Restore NOs for the molecule
    if (old_NOs) then
      archive.set(.name,"temp_natural_orbitals")
      archive.read(.natural_orbitals,kind)
      archive.delete_all
      archive.set(.name,"temp_occupation")
      archive.read(.occupation,kind)
      archive.delete_all
    else
      .natural_orbitals.destroy
      .occupation.destroy
    end

    ! Restore density matrix for the molecule
    if (old_dens) then
      archive.set(.name,"temp_density_matrix")
      archive.read(.density_matrix,kind)
      archive.delete_all
    else
      .density_matrix.destroy
    end

    archive.set(.name,"difference_density_grid,gnuplot",format="ascii")
    archive.write_gnuplot(density_grid, .grid.n_x, .grid.n_y, .grid.n_z)
    density_grid.destroy
  end

   get_spin_density_grid(density_grid) [leaky]
   ! Set "density_grid" to the electron spin density grid.
   ! If the archive file exists, read it; otherwise make it.
      VEC :: density_grid
      ARCHIVE :: archive
      archive.set(.name,"spin_density_grid")
      if (NOT archive.exists) .make_spin_density_grid
      archive.read(density_grid)
   end

   make_spin_density_grid [leaky]
   ! Work out the spin density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC* :: density_grid
      ENSURE(.grid.created, "no grid")
      .make_ao_sz_density_matrix
      density_grid.create(.grid.n_pt)
      .make_density_grid(density_grid)
      archive.set(.name,"spin_density_grid")
      archive.write(density_grid)
      archive.set(.name,"spin_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(density_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      density_grid.destroy
   end

   make_density_grid(density_grid)
   ! Work out the density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector.
      VEC :: density_grid
      BIN :: old_NOs
      if (.natural_orbitals.created) old_NOs = .natural_orbitals.any_created
      if (NOT old_NOs) .make_natural_orbitals
      if (.natural_orbitals.number_kind == "real") then
         .make_density_grid_r(density_grid)
      else
         .make_density_grid_c(density_grid)
      end
      if (NOT old_NOs) .natural_orbitals.destroy_ptr_part
   end

   make_density_grid_r(density_grid)
   ! Make the density grid from restricted real natural orbitals
      VEC :: density_grid
      MAT* :: pt
      INT :: n_pt
      ENSURE(.grid.created,  "no grid")
      density_grid = ZERO
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      .make_density_grid_r(density_grid,pt)
      pt.destroy
   end

   make_density_grid_c(density_grid)
   ! Make the density from restricted complex natural orbitals
      VEC :: density_grid
      MAT* :: pt
      INT :: n_pt
      ENSURE(.grid.created,  "no grid")
      density_grid = ZERO
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      .make_density_grid_c(density_grid,pt)
      pt.destroy
   end

   make_density_grid(density_grid,pts) [leaky]
   ! Work out the electron "density_grid" on "pts" using ".natural orbitals" and
   ! the ".occupation" number vector.
      VEC :: density_grid
      MAT :: pts
      if (.natural_orbitals.number_kind == "real") then
         .make_density_grid_r(density_grid,pts)
      else
         .make_density_grid_c(density_grid,pts)
      end
   end

   make_density_grid_r(density_grid,pts)
   ! Make the "density_grid" for the supplied points "pts" from restricted real
   ! natural orbitals
     VEC :: density_grid
     MAT :: pts
     VEC* :: NO
     INT :: n_occ,n,n_pts
     ENSURE(size(pts,2)==3,  "incorrect dimension for points array")
     ENSURE(.natural_orbitals.created("restricted"), "no natural orbitals")
     ENSURE(.occupation.restricted.created, "no occupation numbers")
     n_pts = size(pts,1)
     density_grid = ZERO
     NO.create(n_pts)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_orbital_grid(NO,.natural_orbitals.restricted(:,n), pts)
       density_grid(:) = density_grid(:) + .occupation.restricted(n)*NO(:)*NO(:)
     end
     NO.destroy
   end

   make_density_grid_c(density_grid,pts)
   ! Make the "density_grid" for the supplied points "pts" from restricted
   ! complex natural orbitals.
      VEC :: density_grid
      MAT :: pts
      CVEC* :: NO
      INT :: n_occ,n,n_pts
      ENSURE(size(pts,2)==3,  "incorrect dimension for points array")
      ENSURE(.natural_orbitals.created("restricted_complex"), "no natural orbitals")
      ENSURE(.occupation.restricted.created, "no occupation numbers")
      n_pts = size(pts,1)
      density_grid = ZERO
      NO.create(n_pts)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
         .make_orbital_grid(NO,.natural_orbitals.restricted_complex(:,n), pts)
         density_grid(:) = density_grid(:) + .occupation.restricted(n)*conjg(NO(:))*NO(:)
      end
      NO.destroy
   end

   make_laplacian_grid(laplacian_grid) [leaky]
   ! Work out the laplacian density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector.
      VEC :: laplacian_grid
      BIN :: old_NOs
      old_NOs = FALSE
      if (.natural_orbitals.created) old_NOs = .natural_orbitals.created("restricted")
      if (NOT old_NOs) .make_natural_orbitals
      .make_laplacian_grid_r(laplacian_grid)
   end

   make_laplacian_grid_r(laplacian_grid)
   ! Make the laplacian density grid from restricted real natural orbitals
      VEC :: laplacian_grid
      MAT* :: pt
      INT :: n_pt
      ENSURE(.grid.created,  "no grid")
      laplacian_grid = ZERO
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      .make_laplacian_grid_r(laplacian_grid,pt)
      pt.destroy
   end

   make_laplacian_grid(laplacian_grid,pts) [leaky]
   ! Work out the electron "laplacian_grid" on "pts" using ".natural orbitals"
   ! and  the ".occupation" number vector.
      VEC :: laplacian_grid
      MAT :: pts
      .make_laplacian_grid_r(laplacian_grid,pts)
   end

   make_laplacian_grid_r(laplacian_grid,pts)
   ! Make the "laplacian_grid" for the supplied points "pts" from restricted
   ! real natural orbitals
     VEC :: laplacian_grid
     MAT :: pts
     VEC* :: NO
     MAT* :: P,D
     INT :: n_occ,n,n_pts
     ENSURE(size(pts,2)==3,  "incorrect dimension for points array")
     ENSURE(.natural_orbitals.created, "no natural orbitals")
     ENSURE(.natural_orbitals.created("restricted"), "no natural orbitals")
     ENSURE(.occupation.created, "no occupation numbers")
     ENSURE(.occupation.created("restricted"), "no occupation numbers")
     n_pts = size(pts,1)
     laplacian_grid = ZERO
     NO.create(n_pts)
     P.create(n_pts,3)
     D.create(n_pts,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_laplacian_orbital_grid(D,P,NO,.natural_orbitals.restricted(:,n), pts)
       laplacian_grid(:) = laplacian_grid(:) + &
          .occupation.restricted(n)*NO(:)*(D(:,1) + D(:,2) + D(:,3)) + &
          .occupation.restricted(n)*(P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
     end
     laplacian_grid(:) = TWO*laplacian_grid(:)
     D.destroy
     P.destroy
     NO.destroy
   end

   get_crystal_error_map(map) [leaky]
   ! Set "map" to the crystal error map. If an archive file exists, read it;
   ! otherwise make it.
      VEC :: map
      ARCHIVE :: archive
      archive.set(.name,"crystal_error_map")
      if (NOT archive.exists) .make_crystal_error_map
      archive.read(map)
   end

   make_crystal_error_map [leaky]
   ! Work out the crystal_error map on ".grid". A Gnuplot ascii file is
   ! generated.
      ARCHIVE :: archive
      VEC* :: map
      ENSURE(.grid.created, "no grid")
      map.create(.grid.n_pt)
      .make_crystal_error_map(map)
      archive.set(.name,"crystal_error_map,gnuplot",format="ascii")
      archive.write_gnuplot(map, .grid.n_x, .grid.n_y, .grid.n_z)
      map.destroy
   end

   make_crystal_error_map(map)
   ! Make the crystal error "map".
      VEC :: map
      MAT, PTR :: pt
      INT :: n_pt
      ENSURE(.grid.created,  "no grid")
      map = ZERO
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      .make_crystal_error_map(map,pt)
      pt.destroy
   end

   make_crystal_error_map(map,pts)
   ! Make the crystal error "map" for the supplied points "pts" from the crystal
   ! structure factors
     VEC :: map
     MAT :: pts
     .crystal.make_crystal_error_map(map,pts)
   end

   get_orbital_density_grid(g,orb) [leaky]
   ! Set "g" to the orbital density grid for orbital "orb".
   ! If the archive file exists, read it; otherwise make it.
      VEC :: g
      INT :: orb
      ARCHIVE :: archive
      archive.set(.name,"orbital_density_grid"//trim(orb.to_str))
      if (NOT archive.exists) .make_orbital_density_grid(orb)
      archive.read(g)
   end

   make_orbital_density_grid(orb) [leaky]
   ! Work out the orbital on ".grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
      INT :: orb
      ARCHIVE :: archive
      VEC*  :: gr
      CVEC* :: gc
      ENSURE(.grid.created, "no grid")
      ENSURE(.natural_orbitals.created, "no natural orbitals")
      if (.natural_orbitals.number_kind == "real") then
        gr.create(.grid.n_pt)
        .make_orbital_grid(gr,orb,square=TRUE)
        archive.set(.name,"orbital_density_grid")
        archive.write(gr)
        archive.set(.name,"orbital_density_grid"//trim(orb.to_str)//",gnuplot",format="ascii")
        archive.write_gnuplot(gr, .grid.n_x, .grid.n_y, .grid.n_z)
        gr.destroy
      else
        gr.create(.grid.n_pt)
        gc.create(.grid.n_pt)
        .make_orbital_grid(gc,orb,square=TRUE)
        gr = gc
        archive.set(.name,"complex_orbital_density_grid")
        archive.write(gr)
        archive.set(.name,"complex_orbital_density_grid,gnuplot",format="ascii")
        archive.write_gnuplot(gr, .grid.n_x, .grid.n_y, .grid.n_z)
        gc.destroy
        gr.destroy
      end
   end

   make_orbital_grid(orb) [leaky]
   ! Work out the orbital on ".grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
      INT :: orb
      ARCHIVE :: archive
      VEC*  :: gr
      CVEC* :: gc
      ENSURE(.grid.created, "no grid")
      ENSURE(.natural_orbitals.created, "no natural orbitals")
      if (.natural_orbitals.number_kind == "real") then
         gr.create(.grid.n_pt)
         .make_orbital_grid(gr,orb)
         archive.set(.name,"orbital_grid")
         archive.write(gr)
         archive.set(.name,"orbital_grid"//trim(orb.to_str)//",gnuplot",format="ascii")
         archive.write_gnuplot(gr, .grid.n_x, .grid.n_y, .grid.n_z)
         gr.destroy
      else
         gc.create(.grid.n_pt)
         .make_orbital_grid(gc,orb)
         archive.set(.name,"complex_orbital_grid")
         archive.write(gc)
         archive.set(.name,"complex_orbital_grid,gnuplot",format="ascii")
         ! archive.write_gnuplot(gc, .grid.n_x, .grid.n_y, .grid.n_z)
         gc.destroy
      end
   end

   make_orbital_grid(g,orb,square) [leaky]
   ! Make the orbital density grid "g" for orbital
   ! no. "orb" of the restricted real natural orbitals.
   ! If present and TRUE, "square" will produce the square of the
   ! orbital density (i.e. probability density)
      VEC :: g
      INT :: orb,n_pt
      BIN, optional :: square
      VEC* :: NO
      MAT* :: pt
      BIN :: sq
      ENSURE(.grid.created,  "no grid")
      ENSURE(.natural_orbitals.created, "no natural orbitals")
      sq = FALSE
      if (present(square)) sq = square
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      NO.create(n_pt)
      .make_orbital_grid(NO,.natural_orbitals.restricted(:,orb), pt)
      if (sq) then; g(:) = NO(:)*NO(:)
      else;         g(:) = NO(:)
      end
      NO.destroy
      pt.destroy
   end

   make_orbital_grid(g,orb,square)
   ! Make the orbital density grid "g" for orbital
   ! no. "orb" of the restricted complex natural orbitals.
   ! If present and TRUE, "square" will produce the square of the
   ! orbital density (i.e. probability density)
      CVEC :: g
      INT :: orb,n_pt
      BIN, optional :: square
      CVEC* :: NO
      MAT* :: pt
      BIN :: sq
      ENSURE(.grid.created,  "no grid")
      ENSURE(.natural_orbitals.created, "no natural orbitals")
      sq = FALSE
      if (present(square)) sq = square
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      NO.create(n_pt)
      .make_orbital_grid(NO,.natural_orbitals.restricted_complex(:,orb), pt)
      if (sq) then; g(:) = conjg(NO(:))*NO(:)
      else;         g(:) = NO(:)
      end
      NO.destroy
      pt.destroy
   end

   make_orbital_grid(g,orb)
   ! Evaluate the orbital density grid "g" for *one* AO-basis orbital vector
   ! "orb" on a set of grid points defined by ".grid"
      VEC, OUT :: g
      VEC, IN :: orb
      MAT* :: pt
      SHELL1 :: sh
      MAT* :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_orbital_grid(g,orb)
   ! Evaluate the orbital density grid "g" for *one* AO-basis orbital vector
   ! "orb" on a set of grid points defined by ".grid"
      CVEC, OUT :: g
      CVEC, IN :: orb
      MAT* :: pt,sh_grid
      SHELL1 :: sh
      INT :: n_pt,fa,la,a
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_orbital_grid(g,orb,pt)
   ! Evaluate the orbital density grid "g" for *one* AO-basis orbital vector
   ! "orb" on a set of grid points "pt"
      VEC, OUT :: g
      VEC, IN :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT* :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      g = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_orbital_grid(g,orb,pt)
   ! Evaluate the orbital density for *one* AO-basis orbital vector "orb"
   ! on a set of grid points "pt"
      CVEC, OUT :: g
      CVEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1* :: sh
      MAT* :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
   end

   make_j_density_grid
   ! Make the current density on ".grid" using ".natural orbitals"
   ! and the ".occupation" number vector.
   !    J(r) = J_p(r) + J_d(r)
      ARCHIVE :: archive
      MAT* :: j,jp
      ENSURE(.grid.created, "no grid")
      j.create(.grid.n_pt,3);  .get_jd_density_grid(j)
      jp.create(.grid.n_pt,3); .get_jp_density_grid(jp)
      j = j + jp
      jp.destroy
      archive.set(.name,"current_density")
      archive.write(j)
      archive.set(.name,"current_density,gnuplot",format="ascii")
      archive.write_gnuplot(j, .grid.n_x, .grid.n_y, .grid.n_z)
      archive.set(.name,"current_norm_density,gnuplot",format="ascii")
      archive.write_gnuplot(j, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      archive.set(.name,"current_density,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(j, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      j.destroy
   end

   get_jd_density_grid(jd)
   ! Set "jd" to the diamagnetic current density grid.
   ! If the archive file exists, read it; otherwise make it.
      MAT :: jd
      ARCHIVE :: archive
      archive.set(.name,"jd_density_grid")
      if (NOT archive.exists) .make_jd_density_grid
      archive.read(jd)
   end

   make_jd_density_grid
   ! Work out the diamagnetic current density on ".grid" using ".natural
   ! orbitals" and the ".occupation" number vector.
   !    J_d(r) = - (e^2/2m) (B x r) rho(r)
      ARCHIVE :: archive
      MAT* :: jd,r
      VEC* :: rho
      ENSURE(.grid.created, "no grid")
      nullify(r)
      if (.B_field.norm<TOL(10)) return
      jd.create(.grid.n_pt,3)
      r.create(.grid.n_pt,3)
      .grid.make_points(r)
      jd(:,1) = .B_field(2)*r(:,3) - .B_field(3)*r(:,2)
      jd(:,2) = .B_field(3)*r(:,1) - .B_field(1)*r(:,3)
      jd(:,3) = .B_field(1)*r(:,2) - .B_field(2)*r(:,1)
      r.destroy
      rho.create(.grid.n_pt)
      .get_electron_density_grid(rho)
      jd(:,1) = -HALF*jd(:,1)*rho
      jd(:,2) = -HALF*jd(:,2)*rho
      jd(:,3) = -HALF*jd(:,3)*rho
      rho.destroy
      archive.set(.name,"jd_density")
      archive.write(jd)
      archive.set(.name,"jd_density,gnuplot",format="ascii")
      archive.write_gnuplot(jd, .grid.n_x, .grid.n_y, .grid.n_z)
      archive.set(.name,"jd_norm_density,gnuplot",format="ascii")
      archive.write_gnuplot(jd, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      archive.set(.name,"jd_density,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(jd, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      jd.destroy
   end

   get_jp_density_grid(jp)
   ! Set "jp" to the paramagnetic current density grid.
   ! If the archive file exists, read it; otherwise make it.
      MAT :: jp
      ARCHIVE :: archive
      archive.set(.name,"jp_density_grid")
      if (NOT archive.exists) .make_jp_density_grid
      archive.read(jp)
   end

   make_jp_density_grid
   ! Work out the paramagnetic current density on ".grid" using ".natural
   ! orbitals".  A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      MAT* :: jp
      BIN :: complex
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      ENSURE(.natural_orbitals.created, "no natural orbitals")
      ENSURE(.natural_orbitals.created, "no natural orbitals")
      complex = .natural_orbitals.number_kind == "complex"
      ENSURE(complex, "natural orbitals not complex")
      .make_ao_density_matrix
      .make_restricted_complex_NOs
      jp.create(.grid.n_pt,3)
      .make_jp_density_grid(jp)
      archive.set(.name,"jp_density_grid")
      archive.write(jp)
      archive.set(.name,"jp_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z)
      archive.set(.name,"jp_norm_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      archive.set(.name,"jp_density_grid,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      jp.destroy
   end

   make_jp_density_grid(jp)
   ! Work out the paramagnetic current density "jp" on ".grid" using ".natural
   ! orbitals" .
   !    J_p(r) = - (eh/m) Re [ \sum_i n_i \phi^*_i(r) \nabla \phi^*_i(r) ]
     MAT :: jp
     MAT* :: pt
     CMAT* :: P
     CVEC* :: D
     INT :: n_occ,n,n_pt
     ENSURE(.grid.created,  "no grid")
     ENSURE(.atom.bases_are_all_resolved, "no basis set")
     ENSURE(.natural_orbitals.created, "no density matrix")
     jp = ZERO
     n_pt = .grid.n_pt
     pt.create(n_pt,3); .grid.points(pt)
     D.create(n_pt)
     P.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_orbital_grid(D,.natural_orbitals.restricted_complex(:,n), pt)
       .make_nabla_orbital_grid(P,.natural_orbitals.restricted_complex(:,n), pt)
       jp(:,1) = jp(:,1) - .occupation.restricted(n)*aimag(conjg(D(:))*P(:,1))
       jp(:,2) = jp(:,2) - .occupation.restricted(n)*aimag(conjg(D(:))*P(:,2))
       jp(:,3) = jp(:,3) - .occupation.restricted(n)*aimag(conjg(D(:))*P(:,3))
     end
     P.destroy
     D.destroy
     pt.destroy
   end

   make_nabla_orbital_grid(g,orb)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points defined by ".grid"
      MAT, OUT :: g
      VEC, IN, target :: orb
      MAT* :: pt,sh_grid_x,sh_grid_y,sh_grid_z
      VEC* :: orb_a
      MAT3* :: sh_grid
      SHELL1 :: sh
      INT :: n_pt,fa,la,a
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = .grid.n_pt
      ENSURE(size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE(size(g,2)==3,    "grid array has wrong 2nd dimension")
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         orb_a => orb(fa:la)
         sh_grid_x => sh_grid(:,:,1)
         sh_grid_y => sh_grid(:,:,2)
         sh_grid_z => sh_grid(:,:,3)
         g(:,1).plus_product(sh_grid_x,orb_a)
         g(:,2).plus_product(sh_grid_y,orb_a)
         g(:,3).plus_product(sh_grid_z,orb_a)
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_nabla_orbital_grid(g,orb)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points defined by ".grid"
      CMAT, OUT :: g
      CVEC, IN, target :: orb
      MAT* :: pt
      MAT3* :: sh_grid
      SHELL1 :: sh
      INT :: n_pt,fa,la,a
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = .grid.n_pt
      ENSURE(size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE(size(g,2)==3,    "grid array has wrong 2nd dimension")
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_nabla_orbital_grid(g,orb,pt)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      MAT, OUT :: g
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1* :: sh
      MAT3* :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE(size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE(size(g,2)==3,    "grid array has wrong 2nd dimension")
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
   end

   make_nabla_orbital_grid(g,orb,pt)
   ! Evaluate the nabla orbital density for *one* complex AO-basis orbital "orb"
   ! on a set of grid points "pt"
      CMAT, OUT :: g
      CVEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1* :: sh
      MAT3* :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE(size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE(size(g,2)==3,    "grid array has wrong 2nd dimension")
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
   end

   make_nabla_orbital_grid_x(g,orb,pt)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt", x derivative only.
      VEC, OUT :: g
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT* :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE(size(g)==n_pt, "grid array has wrong dimension")
      g = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_nabla_grid_x(sh_grid,pt)
         g(:).plus_product(sh_grid(:,:),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_nabla_orbital_grid_y(g,orb,pt)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt", y derivative only.
      VEC, OUT :: g
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT* :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE(size(g)==n_pt, "grid array has wrong dimension")
      g = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_nabla_grid_y(sh_grid,pt)
         g(:).plus_product(sh_grid(:,:),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_nabla_orbital_grid_z(g,orb,pt)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt", z derivative only.
      VEC, OUT :: g
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT* :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE(size(g)==n_pt, "grid array has wrong dimension")
      g = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_nabla_grid_z(sh_grid,pt)
         g(:).plus_product(sh_grid(:,:),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_nabla_orbital_grid(g,h,orb,pt)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      MAT :: g
      VEC :: h
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT3* :: sh_grid
      MAT* :: sh_grid0
      INT :: n_pt,fa,la,a
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE(size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE(size(g,2)==3,    "grid array has wrong 2nd dimension")
      ENSURE(size(h)==n_pt,   "grid array has wrong 1st dimension")
      g = ZERO
      h = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh_grid0.create(n_pt,sh.n_comp)
         sh.make_nabla_grid(sh_grid,sh_grid0,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         h.plus_product(sh_grid0,orb(fa:la))
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_laplacian_orbital_grid(g,orb,pt)
   ! Evaluate the laplacian orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      MAT :: g
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1* :: sh
      MAT3* :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE(size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE(size(g,2)==3,    "grid array has wrong 2nd dimension")
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh.make_laplacian_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
   end

   make_laplacian_orbital_grid(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      MAT :: g,h
      VEC :: i
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT3* :: sh_grid,sh_grid1
      MAT* :: sh_grid0
      INT :: n_pt,fa,la,a
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE(size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE(size(g,2)==3,    "grid array has wrong 2nd dimension")
      ENSURE(size(h,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE(size(h,2)==3,    "grid array has wrong 2nd dimension")
      ENSURE(size(i)==n_pt,   "grid array has wrong 1st dimension")
      g = ZERO
      h = ZERO
      i = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh_grid1.create(n_pt,sh.n_comp,3)
         sh_grid0.create(n_pt,sh.n_comp)
         sh.make_laplacian_grid(sh_grid,sh_grid1,sh_grid0,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         h(:,1).plus_product(sh_grid1(:,:,1),orb(fa:la))
         h(:,2).plus_product(sh_grid1(:,:,2),orb(fa:la))
         h(:,3).plus_product(sh_grid1(:,:,3),orb(fa:la))
         i.plus_product(sh_grid0,orb(fa:la))
         sh_grid1.destroy
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_ELF_grid
   ! Work out the Electron Localisation Function (ELF) density on ".grid"
   ! using ".natural orbitals" and the ".occupation" number vector.
   ! Grid, basis set, and natural orbitals are required to exist.
   ! A Gnuplot ascii file is also generated.
      ARCHIVE :: archive
      VEC* :: ELF_grid
      ENSURE(.grid.created, "no grid")
      ELF_grid.create(.grid.n_pt)
      .make_ELF_grid(ELF_grid)
      archive.set(.name,"ELF_grid,gnuplot",format="ascii")
      archive.write_gnuplot(ELF_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      ELF_grid.destroy
   end

   make_ELF_grid(ELF_grid)
   ! Work out the Electron Localisation Function (ELF) density on ".grid"
   ! using ".natural orbitals" and the ".occupation" number vector.
   ! Grid, basis set, and natural orbitals are required to exist.
   ! A Gnuplot ascii file is also generated.
      VEC :: ELF_grid
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      if (.natural_orbitals.destroyed) .make_natural_orbitals
      if (.natural_orbitals.number_kind == "real") then
         .make_ELF_grid_real(ELF_grid)
      else
         .make_ELF_grid_complex(ELF_grid)
      end
   end

   make_ELF_grid_real(ELF_grid)
   ! Work out the Electron Localisation Function (ELF) density on ".grid"
   ! using ".natural orbitals" and the ".occupation" number vector.
   ! Grid, basis set, and natural orbitals are required to exist.
   ! A Gnuplot ascii file is also generated.
      VEC :: ELF_grid
      MAT* :: pt,DD
      VEC* :: mo_val,gx,gy,gz,rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s,NO
      DBL :: occu,factor,mo_val_n,gx_n,gy_n,gz_n,occ_mo
      INT :: i,n_occ,n,n_pt
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      ENSURE(.natural_orbitals.created, "no natural orbitals")
      ELF_grid = ZERO
      n_pt = .grid.n_pt
      rho_s.create(n_pt);  rho_s  = ZERO
      tau.create(n_pt);    tau    = ZERO
      rho_sx.create(n_pt); rho_sx = ZERO
      rho_sy.create(n_pt); rho_sy = ZERO
      rho_sz.create(n_pt); rho_sz = ZERO
      pt.create(n_pt,3); .grid.points(pt)
      NO.create(n_pt)
      DD.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do i = 1,n_occ
         .make_nabla_orbital_grid(DD,NO,.natural_orbitals.restricted(:,i), pt)
         mo_val => NO(:)
         gx     => DD(:,1)
         gy     => DD(:,2)
         gz     => DD(:,3)
         occu   = HALF*.occupation.restricted(i)
         do n = 1,n_pt
           mo_val_n  = mo_val(n)
           gx_n      = gx(n)
           gy_n      = gy(n)
           gz_n      = gz(n)
           occ_mo    = occu*mo_val_n
           rho_s(n)  = rho_s(n)  + occ_mo*mo_val_n
           tau(n)    = tau(n)    + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
           rho_sx(n) = rho_sx(n) + occ_mo*gx_n ! this is half grad_x rho_s
           rho_sy(n) = rho_sy(n) + occ_mo*gy_n
           rho_sz(n) = rho_sz(n) + occ_mo*gz_n
         end
      end
      DD.destroy
      NO.destroy
      pt.destroy
      d_s.create(n_pt)
      d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s
      rho_sz.destroy; rho_sy.destroy; rho_sx.destroy; tau.destroy
      d0_s.create(n_pt)
      factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
      d0_s = factor*rho_s**(FIVE/THREE)
      rho_s.destroy
      ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))
      d0_s.destroy; d_s.destroy
   end

  make_ELF_grid_complex(ELF_grid)
  ! Work out the Electron Localisation Function (ELF) density on ".grid"
  ! using ".natural orbitals" and the ".occupation" number vector.
  ! Grid, basis set, and natural orbitals are required to exist.
  ! A Gnuplot ascii file is also generated.
    VEC :: ELF_grid
    MAT* :: pt
    CVEC* :: mo_val,gx,gy,gz,NO
    CMAT* :: DD
    VEC*  :: rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s
    DBL :: occu,factor
    INT :: n_occ,n,n_pt
    ENSURE(.grid.created,  "no grid")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    ENSURE(.natural_orbitals.created, "no natural orbitals")
    ELF_grid = ZERO
    n_pt = .grid.n_pt
    rho_s.create(n_pt);  rho_s  = ZERO
    tau.create(n_pt);    tau    = ZERO
    rho_sx.create(n_pt); rho_sx = ZERO
    rho_sy.create(n_pt); rho_sy = ZERO
    rho_sz.create(n_pt); rho_sz = ZERO
    pt.create(n_pt,3); .grid.points(pt)
    NO.create(n_pt)
    DD.create(n_pt,3)
    n_occ = .no_of_occupied_NOs
    do n = 1,n_occ
      .make_orbital_grid(NO,.natural_orbitals.restricted_complex(:,n), pt)
      .make_nabla_orbital_grid(DD,.natural_orbitals.restricted_complex(:,n), pt)
      mo_val => NO(:)
      gx     => DD(:,1)
      gy     => DD(:,2)
      gz     => DD(:,3)
      occu   = HALF*.occupation.restricted(n)
      rho_s  = rho_s  + occu*conjg(mo_val)*mo_val
      tau    = tau    + occu*(conjg(gx)*gx+conjg(gy)*gy+conjg(gz)*gz)
      rho_sx = rho_sx + occu*conjg(gx)*mo_val ! this is half grad_x rho_s
      rho_sy = rho_sy + occu*conjg(gy)*mo_val
      rho_sz = rho_sz + occu*conjg(gz)*mo_val
    end
    DD.destroy
    NO.destroy
    pt.destroy
    d_s.create(n_pt)
    d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s
    rho_sz.destroy; rho_sy.destroy; rho_sx.destroy; tau.destroy
    d0_s.create(n_pt)
    factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
    d0_s = factor*rho_s**(FIVE/THREE)
    rho_s.destroy
    ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))
    d0_s.destroy; d_s.destroy
  end

  make_electric_potential_grid
  ! Make the electric potential "pot_grid" on ".grid"
    ARCHIVE :: archive
    VEC* :: pot_grid
    ENSURE(.grid.created,  "no grid")
    ENSURE(.atom.bases_are_all_resolved, "no basis set")
    ENSURE(.density_matrix.created, "no density matrix")
    ENSURE(.density_matrix.any_created, "no density matrix")
    .make_ao_density_matrix
    pot_grid.create(.grid.n_pt)
    if (.density_matrix.number_kind == "complex") then
      .make_electric_potential_grid(pot_grid,.density_matrix.restricted_complex)
    else
      .make_electric_potential_grid(pot_grid,.density_matrix.restricted)
    end
    archive.set(.name,"electric_potential_grid")
    archive.write(pot_grid)
    archive.set(.name,"electric_potential_grid,gnuplot",format="ascii")
    archive.write_gnuplot(pot_grid, .grid.n_x, .grid.n_y, .grid.n_z)
    pot_grid.destroy
  end

  make_electric_potential_grid(pot_grid,dens)
  ! Make the total electric potential "pot_grid" on ".grid" using AO density
  ! matrix "dens"
    VEC :: pot_grid
    CMAT, target :: dens
    VEC* :: elec_grid
    MAT* :: pt
    pt.create(.grid.n_pt,3); .grid.points(pt)
    .nuclear_potential(pot_grid,pt)
    pt.destroy
    elec_grid.create(size(pot_grid))
    .make_electronic_pot_grid(elec_grid,dens)
    pot_grid.plus_vec(elec_grid)
    elec_grid.destroy
  end

  make_electric_potential_grid(pot_grid,dens)
  ! Make the total electric potential "pot_grid" on ".grid" using AO density
  ! matrix "dens"
    VEC :: pot_grid
    MAT, target :: dens
    VEC* :: elec_grid
    MAT* :: pt
    pt.create(.grid.n_pt,3); .grid.points(pt)
    .nuclear_potential(pot_grid,pt)
    pt.destroy
    elec_grid.create(size(pot_grid))
    .make_electronic_pot_grid(elec_grid,dens)
    pot_grid.plus_vec(elec_grid)
    elec_grid.destroy
  end

   make_electronic_pot_grid(pot_grid,dens)
   ! Make the electronic potential "pot_grid" on ".grid" using AO density matrix
   ! "dens"
      VEC :: pot_grid
      CMAT, target :: dens
      MAT* :: pt,Vab
      CMAT* :: Dba
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      pt.create(.grid.n_pt,3); .grid.points(pt)
      pot_grid = ZERO
      do q = 1,.n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb)
         Dba => dens(fb:lb,fa:la)
         fac = TWO; if (a==b) fac=ONE
         Vab.create(shell.a.n_comp,shell.b.n_comp)
         do k = 1,.grid.n_pt
            shell.make_nuclear_attraction_ints(Vab,pt(k,:))
            pot_grid(k) = pot_grid(k) - fac*Vab.trace_of_product(real(Dba,kind=DBL_KIND))
         end
         Vab.destroy
         shell.destroy_ptr_part
      end
      pt.destroy
   end

   make_electronic_pot_grid(pot_grid,dens)
   ! Make the electronic potential "pot_grid" on ".grid" using AO density matrix
   ! "dens"
      VEC :: pot_grid
      MAT, target :: dens
      MAT* :: pt,Vab,Dba
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      pt.create(.grid.n_pt,3); .grid.points(pt)
      pot_grid = ZERO
      do q = 1,.n_shell_pairs
         .get_shell_pair(shell,q,a,b,fa,la,fb,lb)
         Dba => dens(fb:lb,fa:la)
         fac = TWO; if (a==b) fac=ONE
         Vab.create(shell.a.n_comp,shell.b.n_comp)
         do k = 1,.grid.n_pt
            shell.get_nuc(Vab,ONE,pt(k,:))
            pot_grid(k) = pot_grid(k) - fac*Vab.trace_of_product(real(Dba,kind=DBL_KIND))
         end
         Vab.destroy
         shell.destroy_ptr_part
      end
      pt.destroy
   end

   make_solenoidal_jp_grid
   ! Make the solenoidal paramagnetic current density grid "jp" on ".grid"
     ARCHIVE :: archive
     MAT* :: jp
     ENSURE(.grid.created,  "no grid")
     ENSURE(.atom.bases_are_all_resolved, "no basis set")
     .make_ao_density_matrix
     ENSURE(.density_matrix.created("restricted_complex"), "no density matrix")
     jp.create(.grid.n_pt,3)
     .make_solenoidal_jp_grid(jp,.density_matrix.restricted_complex)
     archive.set(.name,"solenoidal_jp_density_grid")
     archive.write(jp)
     archive.set(.name,"solenoidal_jp_density_grid,gnuplot",format="ascii")
     archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z)
     archive.set(.name,"solenoidal_jp_norm_density_grid,gnuplot",format="ascii")
     archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
     archive.set(.name,"solenoidal_jp_density_grid,normalized,gnuplot",format="ascii")
     archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
     jp.destroy
   end

   make_solenoidal_jp_grid(jp,dens)
   ! Make the solenoidal paramagnetic current density grid "jp" on ".grid"
   ! using AO density matrix "dens"
      MAT :: jp
      CMAT, target :: dens
      CMAT* :: Dba
      MAT* :: pt,Jxab,Jyab,Jzab
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      pt.create(.grid.n_pt,3); .grid.points(pt)
      jp = ZERO
      do q = 1,.n_shell_pairs
        .get_shell_pair(shell,q,a,b,fa,la,fb,lb)
        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (a==b) fac=ONE
        Jxab.create(shell.a.n_comp,shell.b.n_comp)
        Jyab.create(shell.a.n_comp,shell.b.n_comp)
        Jzab.create(shell.a.n_comp,shell.b.n_comp)
        do k = 1,.grid.n_pt
          shell.make_solenoidal_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
        end
        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        shell.destroy_ptr_part
      end
      pt.destroy
      jp.zero_small_values(TOL(10))
   end

   make_irrotational_jp_grid
   ! Make the irrotational paramagnetic current density grid "jp" on ".grid"
      ARCHIVE :: archive
      MAT* :: jp
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      .make_ao_density_matrix
      ENSURE(.density_matrix.created("restricted_complex"), "no density matrix")
      jp.create(.grid.n_pt,3)
      .make_irrotational_jp_grid(jp,.density_matrix.restricted_complex)
      archive.set(.name,"irrotational_jp_density_grid")
      archive.write(jp)
      archive.set(.name,"irrotational_jp_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z)
      archive.set(.name,"irrotational_jp_norm_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      archive.set(.name,"irrotational_jp_density_grid,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      jp.destroy
   end

   make_irrotational_jp_grid(jp,dens)
   ! Make the irrotational paramagnetic current density grid "jp" on ".grid"
   ! using AO density matrix "dens"
      MAT :: jp
      CMAT, target :: dens
      CMAT* :: Dba
      MAT* :: pt,Jxab,Jyab,Jzab
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      pt.create(.grid.n_pt,3); .grid.points(pt)
      jp = ZERO
      do q = 1,.n_shell_pairs
        .get_shell_pair(shell,q,a,b,fa,la,fb,lb)
        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (a==b) fac=ONE
        Jxab.create(shell.a.n_comp,shell.b.n_comp)
        Jyab.create(shell.a.n_comp,shell.b.n_comp)
        Jzab.create(shell.a.n_comp,shell.b.n_comp)
        do k = 1,.grid.n_pt
          shell.make_irrotational_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
        end
        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        shell.destroy_ptr_part
      end
      pt.destroy
      jp.zero_small_values(TOL(10))
   end

   get_vib_averaged_rho_grid(density_grid)
   ! Set "density_grid" to the vibrationally averaged electron density grid.
   ! If the archive file exists, read it; otherwise make it.
      VEC :: density_grid
      ARCHIVE :: archive
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      ENSURE(.n_atom==2,"can only do diatomics")
      archive.set(.name,"vib_averaged_rho_grid")
      if (NOT archive.exists) .make_vib_averaged_rho_grid
      archive.read(density_grid)
   end

   make_vib_averaged_rho_grid
   ! Work out the averaged density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC* :: density_grid
      ENSURE(.grid.created,  "no grid")
      ENSURE(.atom.created,  "no atom list")
      ENSURE(.atom.bases_are_all_resolved, "no basis set")
      ENSURE(.n_atom==2,"can only do diatomics")
      .atom.move_origin_to_centre_of_mass

      density_grid.create(.grid.n_pt)
      .integrate_rho_grid(density_grid,-FOUR,FOUR,TOL(4))

      archive.set(.name,"vib_averaged_rho_grid")
      archive.write(density_grid)
      archive.set(.name,"vib_averaged_rho_grid,gnuplot",format="ascii")
      archive.write_gnuplot(density_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      density_grid.destroy
   end

   integrate_rho_grid(res,a,b,accuracy,fa0,fb0) [recursive]
   ! Integrate the rho grid between the limits "a" and "b" using adaptive
   ! trapezoidal rule with Simpsons approximation.  If present, "accuracy"
   ! is the required accuracy of the integral. If present, "fa0" and
   ! "fb0" are the value of the rho_grid at "a" and "b" respectively.
   ! size of "res" is .grid.n_pt.
      DBL :: a,b
      DBL, optional :: accuracy
      VEC*, optional :: fa0,fb0
      VEC* :: res
      VEC* :: fa,fb,fm,one_trap,two_trap,left,right
      INT :: n_pt
      BIN :: same
      DBL :: tol,h,m
      INT :: depth = 0
      ENSURE(.grid.created, "no grid")
      n_pt = .grid.n_pt
      depth = depth+1
      stdout.show("depth =",depth)
      tol = TOL(6)
      if (present(accuracy)) tol = accuracy
      h  = b-a
      m  = (a+b)/TWO
      if (present(fb0)) then; fb => fb0
      else;                   fb.create(n_pt); .make_rho_grid_at(b,fb)
      end
      if (present(fa0)) then; fa => fa0
      else;                   fa.create(n_pt); .make_rho_grid_at(a,fa)
      end
      fm.create(n_pt);    .make_rho_grid_at(m,fm)
      one_trap.create(n_pt)
      two_trap.create(n_pt)
      one_trap = h*(fa+fb)/TWO
      two_trap = h*(fa+TWO*fm+fb)/FOUR
      res = abs(one_trap-two_trap)
      same = maxval(res) < THREE*tol
      if (same AND depth>1) then
        res = (FOUR*two_trap - one_trap)/THREE
        two_trap.destroy
        one_trap.destroy
        fm.destroy
        fa.destroy
      else
        two_trap.destroy
        one_trap.destroy
        left.create(n_pt);  .integrate_rho_grid(left ,a,m,tol/TWO,fa0=fa,fb0=fm)
        right.create(n_pt); .integrate_rho_grid(right,m,b,tol/TWO,fa0=fm,fb0=fb)
        res = left + right
        right.destroy
        left.destroy
      end
      if (depth==1) fb.destroy
      depth = depth-1
   end

   make_rho_grid_at(q,rho)
   ! Work out the electron density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector at nuclear separation "q", where "q" is a
   ! dimensionless normal coordinate
   ! size or "rho" is .grid.n_pt.
      DBL :: q
      VEC :: rho
      DBL :: re,w,mu, gamma,d,r, wt
      INT :: n
      re = 2.0460259 ! N2
      w  = 2708      ! N2
      re = 1.3848617 ! H2
      w  = 4658      ! H2
      mu = .atom.reduced_mass
      n = 1
      gamma = sqrt((w/WAVENUMBER_PER_HARTREE) &
                  * mu * MASS_OF_ELECTRON_PER_AMU ) ! This is gamma^(1/2)
      d = q/gamma ! d is the cartesian displacement in Bohr
      r = re + d  ! r is the actual separation of atoms in Bohr
      stdout.show("q =",q)
      stdout.show("d =",d)
      stdout.show("r =",r)
      stdout.show("g =",gamma)
      .atom(1).pos = ZERO
      .atom(2).pos = ZERO
      .atom(1).pos(3) = -r/TWO
      .atom(2).pos(3) = +r/TWO
      .atom.move_origin_to_centre_of_mass
      .delete_scf_integrals
      .scf
      .make_density_grid(rho)
      wt = q.harmonic_vibrational_fn(n)
      wt = wt*wt
      rho = wt * rho
   end

   make_fermi_mobility_grid [leaky]
   ! Work out the density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC* :: fermi_grid
      MAT* :: pt
      ENSURE(.grid.created, "no grid")
      fermi_grid.create(.grid.n_pt)
      pt.create(.grid.n_pt, 3 );       .grid.points(pt)
      .make_fermi_mobility_grid(fermi_grid,pt)
      archive.set(.name,"fermi_mobility_grid,gnuplot",format="ascii")
      archive.write_gnuplot(fermi_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      pt.destroy
      fermi_grid.destroy
   end

  make_fermi_mobility_grid(f,pt) [leaky]
  ! Evaluate the Fermi hole mobility grid "f" on a set of grid points "pt".
    MAT, IN :: pt
    VEC, OUT :: f
    VEC* :: del_gi,g,gi,rho,gx,gy,gz,orb
    INT :: n,n_pt,i,n_occ
    DBL :: del_ginx,del_giny,del_ginz,fac
    ENSURE(.grid.created,  "no grid")
    if (.natural_orbitals.destroyed) .make_natural_orbitals
    n_pt = .grid.n_pt
    n_occ = .no_of_occupied_NOs

    g.create(n_pt);     g = ZERO
    gx.create(n_pt);    gx = ZERO
    gy.create(n_pt);    gy = ZERO
    gz.create(n_pt);    gz = ZERO
    gi.create(n_pt)
    del_gi.create(n_pt)

    orb.create(.n_bf)
    do i=1, n_occ
      orb = .natural_orbitals.restricted(:,i)
      .make_orbital_grid(gi,orb,pt)
      .make_nabla_orbital_grid_x(del_gi,orb,pt)
      do n=1,n_pt
        del_ginx = del_gi(n)
        g(n) = g(n) + del_ginx*del_ginx
        gx(n) = gx(n) + gi(n)*del_ginx
      end
      .make_nabla_orbital_grid_y(del_gi,orb,pt)
      do n=1,n_pt
        del_giny = del_gi(n)
        g(n) = g(n) + del_giny*del_giny
        gy(n) = gy(n) + gi(n)*del_giny
      end
      .make_nabla_orbital_grid_z(del_gi,orb,pt)
      do n=1,n_pt
        del_ginz = del_gi(n)
        g(n) = g(n) + del_ginz*del_ginz
        gz(n) = gz(n) + gi(n)*del_ginz
      end
    end
    orb.destroy
    del_gi.destroy
    gi.destroy

    rho.create(n_pt)
    .make_density_grid(rho,pt)
    fac = (THREE*PI/FOUR) * HALF**0.666666666667d0
    f = ONE/rho * (g - TWO*(gx * gx + gy * gy + gz * gz)/rho) - fac * rho**0.666666666667d0
    rho.destroy
    gz.destroy
    gy.destroy
    gx.destroy
    g.destroy
  end

   integrate_density_numerically
   ! Integrate the density numerically
      INT :: n_pts
      MAT* :: pt
      VEC* :: wt,rho
      DBL :: n_e
      ENSURE(.dftgrid.created, "no dftgrid info!")
      n_pts = .dftgrid.n_atom_pts * .n_atom
      pt.create(n_pts,3)
      wt.create(n_pts)
      rho.create(n_pts)
      .dftgrid.make_grid(pt,wt,.atom)
      .make_density_grid(rho,pt)
      n_e = sum(rho*wt)
      stdout.show("numerically integrated charge =",n_e)
      rho.destroy
      wt.destroy
      pt.destroy
   end

!*******************************************************************************
!                        Camp-King routines
!*******************************************************************************

  camp_king(MO_old,F_old,E_HF,E_K)
  ! Uses old_MO (lambda=0) and new_MO (lambda=1) to generate MO at lambda.
  ! lambda should be between 0 and 1.
  ! E_HF and E_K are only changed if the orbitals are changed.
    OPMAT, IN :: MO_old,F_old
    OPMAT* :: F_backup,MO_backup,P_backup,constraint
    MAT* :: old_MO,new_MO,old_F
    MAT* :: Uh,V,W,U,CV,CW,S,Q,Q1,F,Cj,Cj1,Cl
    DBL, INOUT :: E_HF,E_K
    VEC* :: theta
    INT :: minpq,n,n_p,n_q,i,k,j
    DBL :: ded0,ded1,ded1a,E1,El,lambda
    DBL :: tol,diis0,diis1,diisl

    F_backup.create_copy(.fock_matrix)
    MO_backup.create_copy(.molecular_orbitals)
    P_backup.create_copy(.density_matrix)
    .fock_matrix.restricted = F_backup.restricted
    .molecular_orbitals.restricted = MO_backup.restricted
    .make_scf_density_matrix(damp=FALSE)
    .make_diis_error(diis1)
    .fock_matrix.restricted = F_old.restricted
    .molecular_orbitals.restricted = MO_old.restricted
    .make_scf_density_matrix(damp=FALSE)
    .make_diis_error(diis0)
    .fock_matrix.set_to(F_backup)
    .molecular_orbitals.set_to(MO_backup)
    .density_matrix.set_to(P_backup)
    if (diis1 < diis0) then
      F_backup.destroy
      P_backup.destroy
      MO_backup.destroy
      RETURN ! the new orbitals are better than the old.
    end

    n_p = .n_e/2
    n_q = .n_bf - n_p
    minpq = min(n_p,n_q)
    old_MO => MO_old.restricted
    old_F => F_old.restricted
    new_MO => .molecular_orbitals.restricted

    Q.create(.n_bf,.n_bf)
    Q = old_MO                                  ! Q is an orthogonal basis.

    Q1.create(.n_bf,.n_bf)                      ! Get inverse of Q, store in Q1.
    S.create(.n_bf,.n_bf)
    .get_overlap_matrix(S)
    Q1.to_product(Q,S,transpose_a=TRUE)
    S.destroy

    Cj.create(.n_bf,.n_bf)                      ! Convert the MOs into Q basis.
    Cj1.create(.n_bf,.n_bf)
    Cj.to_product(Q1,old_MO)
    Cj1.to_product(Q1,new_MO)
    Q1.destroy

    V.create(.n_bf,.n_bf)
    W.create(.n_bf,.n_bf)
    theta.create(minpq)
    U.create(.n_bf,.n_bf)
    U.to_product(Cj,Cj1)                        ! eqn 8
    V=Cj1
    W=Cj1
    U.make_corresponding_orbitals(V,W,theta,n_p)
    U.destroy

    CV.create(.n_bf,.n_bf)
    CW.create(.n_bf,.n_bf)
    CV.to_product(Cj,V)                         ! eqn 11
    CW.to_product(Cj1,W)                        ! eqn 12
    W.destroy
    V.destroy
    Cj1.destroy
    Cj.destroy

    F.create(.n_bf,.n_bf)
    !get de/dl at l=1
    F=F_backup.restricted                          ! Fbar at lambda=1
    F.change_basis(Q)                              ! F = Q^t Fbar Q
    F.change_basis(CW)                             ! eqn 28.
    CW.destroy
    ded1 = ZERO
    do n=1,n_p
      ded1 = ded1 + theta(n)*F(n+n_p,n)
    end
    ded1 = -FOUR * ded1

    !get de/dl at l=0
    F=old_F                                        ! Fbar at lambda=0
    F.change_basis(Q)                              ! F = Q^t Fbar Q
    F.change_basis(CV)                             ! eqn 27.
    ded0 = ZERO
    do n=1,n_p
      ded0 = ded0 + theta(n)*F(n+n_p,n)
    end
    ded0 = -FOUR * ded0
    F.destroy

 n=0
    if (ded1 > ZERO) then ! minimum is at a lambda less than lambda=1.
      if (ded0<ZERO) then ! minimum is at a lambda greater than lambda=0.
        if (abs(ded1) > TEN*abs(ded0)) then
          lambda = 0.1
        else
          lambda = HALF
        end
        .minimise_Camp_King_lambda(lambda,El,ded1a,Q,CV,theta,n_p,n,diis0)
        .make_diis_error(diisl)
      else
        lambda = ZERO
        diisl = diis0
      end
      if (diisl < diis1) then ! it's convergence that counts.
        Uh.create(.n_bf,.n_bf)
        .make_Camp_King_U_hat(Uh,lambda,theta)
        Cl.create(.n_bf,.n_bf)
        Cl.to_product(CV,Uh)
        Uh.destroy
        .molecular_orbitals.restricted.to_product(Q,Cl)
        Cl.destroy
        .schmidt_orthonormalise(.molecular_orbitals)
        .make_scf_density_matrix(damp=FALSE)
        .make_fock_matrix
        E_HF = .scf_energy
        E_K = .kinetic_energy
        .make_structure_factors
        .scfdata.set(crystal=.crystal)
        if (.scfdata.kind == "xray_rhf") then
          constraint.create(.n_bf,"restricted")
          .make_constraint(constraint, .scfdata.lambda )
          .add_constraint(constraint)
          constraint.destroy
        end
      else
        .fock_matrix.set_to(F_backup)
        .molecular_orbitals.set_to(MO_backup)
        .density_matrix.set_to(P_backup)
      end
    else
      .fock_matrix.set_to(F_backup)
      .molecular_orbitals.set_to(MO_backup)
      .density_matrix.set_to(P_backup)
    end
 write(*,*) n

    CV.destroy
    theta.destroy
    Q.destroy
    F_backup.destroy
    P_backup.destroy
    MO_backup.destroy
  end

  minimise_Camp_King_lambda(lambda,f,dedx,Ql,CV,theta,n_p,n,diis0) [private]
    DBL, IN :: diis0
    DBL :: lambda,f,tol,dedx
    INT, IN :: n_p
    INT, OUT :: n
    MAT :: Ql,CV
    VEC :: theta
    INT :: i
    DBL :: a,b,d,d1,d2,du,dv,dw,dx,e,fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm
    DBL :: diisl
    BIN :: ok1,ok2

    tol=0.1
    a=ZERO
    b=ONE
    v=lambda
    w=lambda
    x=lambda
    e=ZERO
    .get_Camp_King_energy(x,fx,dx,Ql,CV,theta,n_p,diisl)
    fv=fx
    fw=fx
    dv=dx
    dw=dx
 n=0
    do i=1,100
 n=n+1
      xm=HALF*(a+b)
      tol1=tol*abs(x)+TOL(10)
      tol2=TWO*tol1
      if (diisl < diis0) exit
      if (abs(x-xm)<=(tol2-HALF*(b-a))) exit
      if (abs(e)>tol1) then
        d1=TWO*(b-a)
        d2=d1
        if (dw /= dx) d1=(w-x)*dx/(dx-dw)
        if (dv /= dx) d2=(v-x)*dx/(dx-dv)
        u1=x+d1
        u2=x+d2
        ok1=((a-u1)*(u1-b)>ZERO) AND (dx*d1 <=ZERO)
        ok2=((a-u2)*(u2-b)>ZERO) AND (dx*d2 <=ZERO)
        olde=e
        e=d
    
        if (ok1 OR ok2) then
          if (ok1 AND ok2) then
            if (abs(d1)<abs(d2)) then; d=d1
            else;                      d=d2
            end
          else
            if (ok1) then; d=d1
            else;          d=d2
            end
          end if
          if (abs(d)<=abs(HALF*olde)) then
            u=x+d
            if (u-a <tol2 OR b-u <tol2) d=sign(tol1,xm-x)
          else
            if (dx<=ZERO) then; e=a-x
            else;               e=b-x
            end
            d=HALF*e
          end if
        else
          if (dx>=ZERO) then; e=a-x
          else;               e=b-x
          end
          d=HALF*e
        end if
      else
        if (dx>=ZERO) then; e=a-x
        else;               e=b-x
        end
        d=HALF*e
      end if
      if (abs(d)>=tol1) then
        u=x+d
        .get_Camp_King_energy(u,fu,du,Ql,CV,theta,n_p,diisl)
      else
        u=x+sign(tol1,d)
        .get_Camp_King_energy(u,fu,du,Ql,CV,theta,n_p,diisl)
        if (fu > fx) exit
      end if
      if (fu <= fx) then
        if (u >= x) then
          a=x
        else
          b=x
        end if
        v=w; fv=fw; dv=dw
        w=x; fw=fx; dw=dx
        x=u; fx=fu; dx=du
      else
        if (u < x) then
          a=u
        else
          b=u
        end if
        if (fu <=fw OR w ==x) then
          v=w; fv=fw; dv=dw
          w=u; fw=fu; dw=du
        else if (fu <=fv OR v ==x OR v ==w) then
          v=u; fv=fu; dv=du
        end if
      end if
    end do
    f = fx
    lambda = x
    dedx=dx
  end

  get_Camp_King_energy(lambda,El,dedl,Q,CV,theta,n_p,diisl) [private]
    MAT, IN :: Q,CV
    VEC, IN :: theta
    INT, IN :: n_p
    OPMAT* :: constraint
    DBL :: lambda,El,dedl,diisl
    MAT* :: Uh,Cl,F
    INT :: n

    Uh.create(.n_bf,.n_bf)
    .make_Camp_King_U_hat(Uh,lambda,theta)
    Cl.create(.n_bf,.n_bf)
    Cl.to_product(CV,Uh)                          ! C(lambda) = C^j V Uh(lambda)
    Uh.destroy
    .molecular_orbitals.restricted.to_product(Q,Cl) ! Cbar(lambda) = Q C(lambda)
    .schmidt_orthonormalise(.molecular_orbitals)
    .make_scf_density_matrix(damp=FALSE)
    .make_structure_factors
    .make_fock_matrix
    if (.scfdata.kind == "xray_rhf") then
      constraint.create(.n_bf,"restricted")
      .make_constraint(constraint, .scfdata.lambda )
      .add_constraint(constraint)
      constraint.destroy
    end
    .make_diis_error(diisl)
    F.create(.n_bf,.n_bf)
    F=.fock_matrix.restricted                      ! Fbar at lambda in AO basis.
    F.change_basis(Q)
    F.change_basis(Cl)
    Cl.destroy
    dedl = ZERO
    do n=1,n_p
      dedl = dedl + theta(n)*F(n+n_p,n)
    end
    dedl = -FOUR * dedl
    F.destroy
    El = .scf_energy
  end

  make_Camp_King_U_hat(Uh,lambda,theta) [private]
    IN :: self
    MAT, target :: Uh
    DBL, IN :: lambda
    VEC, IN :: theta
    VEC* :: sin_theta,cos_theta
    MAT* :: Uh_pp,Uh_qq,Uh_qp,Uh_pq
    INT :: minpq,maxpq,n_p,n_q,m,n
    BIN :: ok

    ok = size(Uh,1)==.n_bf AND size(Uh,2)==.n_bf
    n_p = ceiling(.n_e/TWO)
    n_q = .n_bf - n_p
    minpq = min(n_p,n_q)
    maxpq = max(n_p,n_q)
    m=n_p-minpq
    n=n_q-minpq
    ENSURE(ok,"incorrect dimensions for Uh matrix")
    ENSURE(size(theta)==minpq,"incorrect dimensions for theta array")

    sin_theta.create(minpq)
    cos_theta.create(minpq)
    sin_theta = sin(theta*lambda)
    cos_theta = cos(theta*lambda)

    Uh=ZERO
    Uh_pp => Uh(:n_p,:n_p)
    Uh_qq => Uh(n_p+1:,n_p+1:)
    Uh_qp => Uh(n_p+1:,:n_p)
    Uh_pq => Uh(:n_p,n_p+1:)

    Uh_pp(:minpq,:minpq).from_diagonal(cos_theta)
    Uh_qq(:minpq,:minpq).from_diagonal(cos_theta)

    Uh_qp(:minpq,:minpq).from_diagonal(-sin_theta)
    Uh_pq(:minpq,:minpq).from_diagonal(sin_theta)

    if (m>0) then ! do p-m:p block
      Uh_pp(minpq+1:,minpq+1:).to_unit_mat
    else if (n>0) then ! do p+q-n:p+q block
      Uh_qq(minpq+1:,minpq+1:).to_unit_mat
    end

    cos_theta.destroy
    sin_theta.destroy
  end

end
