!-------------------------------------------------------------------------------
!
! MOL: An object representation of a molecule.
!
! $Id$
!-------------------------------------------------------------------------------
module MOL

   use TYPES
   use SYSTEM
   use TIME
   use STR
   use INT
   use DBL
   use BUFFER

   use BINVEC
   use IVEC
   use IVECVEC
   use VEC
   use VECVEC
   use CVEC
   use STRVEC

   use IMAT
   use MAT
   use MAT3
   use MAT4
   use MATVEC
   use CMAT
   use CMAT3
   use CMAT4
   use CMAT5
   use MAT4VEC

   use OPVEC
   use OPMAT

   use FILE
   use TEXTFILE
   use ARCHIVE

   use VECDIIS

   use SHELL
   use SHELL1
   use SHELL2
   use SHELL4
   use SHELLVEC
   use BASIS
   use BASISVEC
   use ATOM
   use ATOMVEC

   use POINTGROUP
   use SPACEGROUP
   use CRYSTAL

   use PLOTGRID
   use DFTGRID
   use SCFDATA

   implicit none         

#  include "macros"
#  include "mol.int"

!   type mol_type
!
!   STR :: name
!   ! Name of molecule
!
!   INT :: charge
!   ! Electric charge of the molecule
!
!   INT :: mult
!   ! Spin multiplicity of the molecule
!
!   VEC(3) :: E_field
!   ! Applied electric field in atomic units
!
!   VEC(3) :: B_field
!   ! Applied magnetic field in atomic units
!
!   VEC(3) :: gauge_origin
!   ! Global gauge origin for magnetic field
!
!   VEC(3) :: quantization_axis
!   ! Axis for quantizing any momenta
!
!   ATOMVEC, PTR :: atom DEFAULT_NULL
!   ! List of atoms in molecule
!
!   BASISVEC, PTR :: basis DEFAULT_NULL
!   ! List of basis sets used
!
!   PLOTGRID, PTR :: grid DEFAULT_NULL
!   ! Rectangular grid data, for plots
!
!   DFTGRID, PTR :: dftgrid DEFAULT_NULL
!   ! DFT integration grid data
!
!   CRYSTAL, PTR :: crystal DEFAULT_NULL
!   ! Crystal data for the enclosing crystal
!
!   POINTGROUP, PTR :: pointgroup DEFAULT_NULL
!   ! Pointgroup symmetry of the molecule
!
!   INT :: n_e
!   ! No of electrons
!
!   INT :: n_a
!   ! No of alpha electrons
!
!   INT :: n_b
!   ! No of beta electrons
!
!   INT :: n_atom
!   ! No of atoms
!
!   INT :: n_atom_kind
!   ! No of atoms of a different kind
!
!   INT :: n_basis
!   ! No of basis sets
!
!   INT :: n_shell
!   ! Total number of shells in the molecular basis set
!
!   INT :: n_shell_pairs
!   ! Total number of shell pairs in the molecular basis set
!
!   INT :: n_bf
!   ! Total number of basis functions in the molecular basis set
!
!   INT :: n_prim
!   ! Total number of primitives in the molecular basis set
!
!   IVEC, PTR :: atom_for_shell DEFAULT_NULL
!   ! Atom index for molecular shell index array
!
!   IVEC, PTR :: atom_shell_for_shell DEFAULT_NULL
!   ! Atom shell index for molecular shell index array
!
!   IVEC, PTR :: first_shell_for_atom DEFAULT_NULL
!   ! First molecule shell index for an atom
!
!   IVEC, PTR :: first_basis_fn_for_shell DEFAULT_NULL
!   ! First basis function for a given shell
!
!   IVEC, PTR :: last_basis_fn_for_shell DEFAULT_NULL
!   ! Last basis function for a given shell
!
!   IVEC, PTR :: atom_kind DEFAULT_NULL
!   ! The unique kind of each atom in .atom
!
!   IVEC, PTR :: unique_atom DEFAULT_NULL
!   ! List of the unique atoms (of different kind)
!
!   IVEC, PTR :: first_basis_fn_for_atom DEFAULT_NULL
!   ! For the atom basis function limits
!
!   IVEC, PTR :: last_basis_fn_for_atom DEFAULT_NULL
!   ! For the atom basis function limits
!
!   SCFDATA, PTR :: scfdata DEFAULT_NULL
!   ! SCF data object
!
!   OPVEC, PTR :: orbital_energies DEFAULT_NULL
!   ! The orbital energies
!
!   OPMAT, PTR :: molecular_orbitals DEFAULT_NULL
!   ! The (real) molecular orbitals
!
!   OPMAT, PTR :: density_matrix DEFAULT_NULL
!   ! The real density matrix
!
!   OPMAT, PTR :: natural_orbitals DEFAULT_NULL
!   ! The natural orbitals
!
!   OPVEC, PTR :: occupation DEFAULT_NULL
!   ! The associated occupation numbers
!
!   OPMAT, PTR :: fock_matrix DEFAULT_NULL
!   ! The real fock matrix
!
!   MAT4VEC, PTR :: ab_ab_ERI DEFAULT_NULL
!   ! The two electron integrals of the form ab|ab
!
!   BIN :: optimise_thermals
!   ! Whether to optimise the thermal parameters
!
!   end

contains

!  **************************
!  Create and destroy methods
!  **************************

   create 
   ! Create a molecule object
      PTR :: self
      allocate(self)
      .nullify_ptr_part
      .set_defaults
      ADD_MEM(MOL_SIZE)
   end

   destroy 
   ! Destroy a molecule object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      deallocate(self)
      DELETE_MEM(MOL_SIZE)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the molecule
      nullify(.crystal)
      nullify(.pointgroup)
      nullify(.atom)
      nullify(.basis)
      nullify(.grid)
      nullify(.dftgrid)
      nullify(.atom_for_shell)
      nullify(.atom_shell_for_shell)
      nullify(.first_shell_for_atom)
      nullify(.first_basis_fn_for_shell)
      nullify(.last_basis_fn_for_shell)
      nullify(.first_basis_fn_for_atom)
      nullify(.last_basis_fn_for_atom)
      nullify(.atom_kind)
      nullify(.unique_atom)
      nullify(.scfdata)
      nullify(.orbital_energies)
      nullify(.molecular_orbitals)
      nullify(.density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation)
      nullify(.fock_matrix)
      nullify(.ab_ab_ERI)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of a molecule object
      .crystal.destroy
      .pointgroup.destroy
      if (.atom.created) .atom.nullify_basis_part ! nullify this !
      .atom.destroy
      .basis.destroy
      .grid.destroy
      .dftgrid.destroy
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .atom_kind.destroy
      .unique_atom.destroy
      .scfdata.destroy
      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation.destroy
      .fock_matrix.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has not been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_defaults [leaky]
   ! Set up a default molecule
      .E_field = ZERO
      .B_field = ZERO
      .gauge_origin = ZERO
      .quantization_axis = (/ ZERO, ZERO, ONE /)
      .charge = 0
      .mult = 1
      .optimise_thermals = FALSE
      if ( .atom.created) then
        .mult = .atom.default_multiplicity
        .set_atom_info
      end
   end

   set_atom_info [leaky]
   ! Set the associated atom information
      .n_atom = .no_of_atoms
      .n_e = .no_of_electrons
      .n_a = .no_of_alpha_electrons
      .n_b = .no_of_beta_electrons
      .atom_kind.create(.n_atom)
      .atom.make_atom_kind_list(.atom_kind,.n_atom_kind)
      .unique_atom.create(.n_atom_kind)
      .atom.make_unique_atom_list(.unique_atom)
   end

   resolve_basis_labels [leaky]
   ! Match the basis set labels for every atom with the actual atomic basis set.
   ! Also perform any initialization procedures to finalise all data objects
      if ( .basis.destroyed) return
      if ( .atom.destroyed) return
      if ( .atom.bases_are_not_all_labeled) return
      .atom.resolve_basis_labels(.basis)
      .n_basis = .no_of_basis_sets
      .set_basis_info
    ! .delete_scf_integrals
   end

   resolve_axis_system 
   ! Change the axis system to crystal coordinates, if required.
      if ( .crystal.destroyed) return
      if ( .atom.destroyed) return
      .atom.resolve_axis_system(.crystal)
   end

   set_basis_info [leaky]
   ! Set the associated basis set information
      .n_basis = .no_of_basis_sets
      .n_bf = .no_of_basis_functions
      .n_prim = .no_of_primitives
      .n_shell = .no_of_shells
      .n_shell_pairs = .no_of_shell_pairs
      .molecular_orbitals.create( .n_bf)
      .orbital_energies.create( .n_bf)
      .density_matrix.create( .n_bf)
      .natural_orbitals.create( .n_bf)
      .occupation.create( .n_bf)
      .fock_matrix.create( .n_bf)
      .make_shell_info
   end

   delete_scf_integrals
   ! Delete all integral files. This is required whenever the geometry is
   ! changed.
      ARCHIVE :: archive
      archive.set(.name,"overlap_matrix"); archive.delete
      archive.set(.name,"kinetic_matrix"); archive.delete
      archive.set(.name,"nuclear_matrix"); archive.delete
      archive.set(.name,"core_matrix");    archive.delete
      archive.set(.name,"fock_matrix");    archive.delete
      archive.set(.name,"eri_integrals");  archive.delete
      archive.set(.name,"eri_index");      archive.delete
      archive.set(.name,"ft_ints");        archive.delete
   end

   assign_natural_orbitals [leaky]
   ! Assign the natural orbitals to be the molecular_orbitals 
      STR :: kind
      .natural_orbitals.destroy
      .natural_orbitals.create_copy(.molecular_orbitals)
      kind = .natural_orbitals.spinorbital_kind
      .occupation.create(kind)
      .occupation.zero
      .set_scf_occupations(kind)
   end

   assign_MOs_to_NOs [leaky]
   ! Assign the MOs to be the same as the natural orbitals 
      STR :: kind
      .molecular_orbitals.destroy
      .molecular_orbitals.create_copy(.natural_orbitals)
      kind = .natural_orbitals.spinorbital_kind
      .occupation.create(kind)
      .occupation.zero
      .set_scf_occupations(kind)
   end

   set_scf_occupations(kind)
   ! Set the SCF occupation numbers for the natural orbitals
      STR :: kind
      select case (kind)
         case ("restricted")
            .occupation.restricted(1:.n_a) = TWO
         case ("unrestricted")
            .occupation.alpha(1:.n_a) = ONE
            .occupation.beta(1:.n_b) = ONE
         case ("general")
            .occupation.general(1:.n_e) = ONE
         case ("restricted_complex")
            .occupation.restricted(1:.n_a) = TWO
         case ("unrestricted_complex")
            .occupation.alpha(1:.n_a) = ONE
            .occupation.beta(1:.n_b) = ONE
         case ("general_complex")
            .occupation.general(1:.n_e) = ONE
      end
   end

!  ***************************
!  ATOMVEC information methods
!  ***************************
 
   nuclear_energy result(res)
   ! Return the nuclear repulsion energy
      DBL :: res
      ENSURE( .atom.created,"atom list required")
      res = .atom.nuclear_energy
   end

   chemical_formula result(res)
   ! Return the chemical formula for the molecule, as a string, in alphabetical 
   ! order of elements
      STR :: res
      ENSURE( .atom.created,"atom list required")
      res = .atom.chemical_formula
   end

   centre_of_mass result(centre)
   ! Return the centre of mass
      VEC(3) :: centre
      ENSURE( .atom.created,"atom list required")
      centre = .atom.centre_of_mass
   end
 
   move_origin_to_centre_of_mass
   ! Move the origin to the centre of mass
      VEC(3) :: com
      INT :: a
      ENSURE( .atom.created,"atom list required")
      com = .atom.centre_of_mass
      do a = 1,.n_atom
         .atom(a).pos = .atom(a).pos - com
      end
   end

   molecular_weight result(res)
   ! Return the molceular weight
      DBL:: res
      ENSURE( .atom.created,"atom list required")
      res = .atom.molecular_weight
   end

   reduced_mass result(res)
   ! Return the reduced mass
      DBL:: res
      ENSURE( .atom.created,"atom list required")
      res = .atom.reduced_mass
   end

   centre_of_atoms result(centre)
   ! Return the centroid of the atom positions
      VEC(3) :: centre
      ENSURE( .atom.created,"atom list required")
      centre = .atom.centre_of_atoms
   end

   atom_index_from_pos(pos) result(res)
   ! Return the index of atom from its position "pos"
      VEC(3) :: pos
      INT :: res
      ENSURE( .atom.created,"atom list required")
      res = .atom.atom_index_from_pos(pos)
   end

   get_geometry(g)
   ! Return the geometry "g" in a matrix
      MAT :: g
      ENSURE( .atom.created,"no atom list")
      .atom.get_geometry(g)
   end

   get_crystal_geometry(g)
   ! Return the crystal (fractional coordinate) geometry "g" in a matrix
      MAT :: g
      INT :: n
      .get_geometry(g)
      if (size(g,1)==3) then
         do n = 1,.n_atom
            .crystal.inverse_cell_matrix.rotate(g(:,n))
         end
      else if (size(g,2)==3) then
         do n = 1,.n_atom
            .crystal.inverse_cell_matrix.rotate(g(n,:))
         end
      end
   end

!  ********************************
!  ATOMVEC shell extraction methods
!  ********************************

   get_shell(index,shell) [leaky]
   ! Get basis set shell "index" in "sh" 
      INT, IN :: index
      SHELL, OUT :: shell
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy( .atom(aa).basis.shell(sa) )
   end

   get_shell1(index,shell) [leaky]
   ! Update the shell1 "shell".
      INT, IN :: index
      SHELL1, OUT :: shell
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy(shell=.atom(aa).basis.shell(sa),pos=.atom(aa).pos)
   end

   get_shell1(index,shell,fa,la) [leaky]
   ! Update the shell1 "shell".
      INT, IN :: index
      SHELL1, OUT :: shell
      INT, OUT :: fa,la
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)
      shell.copy(shell=.atom(aa).basis.shell(sa),pos=.atom(aa).pos)
   end

   get_shell_pair(index,shell,a,b) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: a,b
      INT :: aa,sa,bb,sb
      .get_shell_pair(index,a,b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy( .atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(aa).pos, .atom(bb).pos )
   end

   get_shell_pair(index,a,b,fa,la,fb,lb) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      INT, OUT :: a,b,fa,la,fb,lb
      .get_shell_pair(index,a,b)
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end

   get_shell_pair(index,shell,fa,la,fb,lb) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: fa,la,fb,lb
      INT :: a,b,aa,sa,bb,sb
      .get_shell_pair(index,a,b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy( .atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(aa).pos, .atom(bb).pos )
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end

   get_shell_pair(index,shell,a,b,fa,la,fb,lb) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: a,b,fa,la,fb,lb
      INT :: aa,sa,bb,sb
      .get_shell_pair(index,a,b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy( .atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(aa).pos, .atom(bb).pos )
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end

   get_shell_pair(index,shell,a,b,fa,la,fb,lb,atom_a,atom_b) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Plus the atoms the shells are located on, "atom_a" and "atom_b".
     INT, IN :: index
     SHELL2, OUT :: shell
     INT, OUT :: a,b,fa,la,fb,lb,atom_a,atom_b
     INT :: sa,sb
     .get_shell_pair(index,a,b)
     atom_a = .atom_for_shell(a)
     atom_b = .atom_for_shell(b)
     sa = .atom_shell_for_shell(a)
     sb = .atom_shell_for_shell(b)
     shell.copy( .atom(atom_a).basis.shell(sa), .atom(atom_b).basis.shell(sb), &
                 .atom(atom_a).pos, .atom(atom_b).pos )
     fa = .first_basis_fn_for_shell(a)
     fb = .first_basis_fn_for_shell(b)
     la = .last_basis_fn_for_shell(a)
     lb = .last_basis_fn_for_shell(b)
   end
 
   get_shell_pair(index,a,b)
   ! Return the actual shell indicies "a" and "b" which map to "index"
     INT, IN :: index
     INT, OUT :: a,b
     a  = (1+sqrt(8.0d0*index-7.0d0))/2
     b  = index - a*(a-1)/2
   end

   get_shell_quartet(index,a,b,c,d)
   ! Get the indexes a,b,c,d of the quartet from the "index".
   ! Note that "index" will die at 361 shells for integer(4).
     INT, IN :: index
     INT, OUT :: a,b,c,d
     INT :: ab,cd
     ab = (1+sqrt(8.0d0*index-7.0d0))/2
     cd = index - ab*(ab-1)/2
     a  = (1+sqrt(8.0d0*ab-7.0d0))/2
     b  = ab - a*(a-1)/2
     c  = (1+sqrt(8.0d0*cd-7.0d0))/2
     d  = cd - c*(c-1)/2
   end

   get_shell_quartet(shell,a,b,c,d) [leaky]
   ! Get the SHELL4 object "sh" correponding to the indicies "a", "b", "c" and
   ! "d".
      SHELL4, OUT :: shell
      INT, IN :: a,b,c,d
      INT :: aa,sa,bb,sb,cc,sc,dd,sd
      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy( .atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                  .atom(aa).pos, .atom(bb).pos, .atom(cc).pos, .atom(dd).pos )
   end

   get_shell_quartet(index,shell,a,b,c,d) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d
      .get_shell_quartet(index,a,b,c,d)
      .get_shell_quartet(shell,a,b,c,d)
   end

   get_shell_quartet(index,shell,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld
      .get_shell_quartet(index,a,b,c,d)
      .get_shell_quartet(shell,a,b,c,d)
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)
   end

   get_shell_quartet(index,fa,la,fb,lb,fc,lc,fd,ld) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      INT, OUT :: fa,la,fb,lb,fc,lc,fd,ld
      INT :: a,b,c,d
      .get_shell_quartet(index,a,b,c,d)
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)
   end

   get_shell_quartet(index,shell,a,b,c,d,atom_a,atom_b,atom_c,atom_d) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Plus the atoms which the shells are on.
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d,atom_a,atom_b,atom_c,atom_d
      .get_shell_quartet(index,a,b,c,d)
      .get_shell_quartet(shell,a,b,c,d)
      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
      atom_c = .atom_for_shell(c)
      atom_d = .atom_for_shell(d)
   end

   set_shell_quartet_ab(shell,a,b) [leaky]
   ! Set the a and b parts of the SHELL4 object.
     SHELL4, INOUT :: shell
     INT, IN :: a,b
     INT :: aa,sa,bb,sb
     aa = .atom_for_shell(a)
     sa = .atom_shell_for_shell(a)
     bb = .atom_for_shell(b)
     sb = .atom_shell_for_shell(b)
     shell.copy_ab( .atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(aa).pos, .atom(bb).pos)
   end

   set_shell_quartet_cd(shell,c,d) [leaky]
   ! Set the c and d parts of the SHELL4 object.
     SHELL4, INOUT :: shell
     INT, IN :: c,d
     INT :: cc,sc,dd,sd
     cc = .atom_for_shell(c)
     sc = .atom_shell_for_shell(c)
     dd = .atom_for_shell(d)
     sd = .atom_shell_for_shell(d)
     shell.copy_cd( .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(cc).pos, .atom(dd).pos)
   end

   make_contraction_matrix(cc_mat)
   ! Returns the matrix of complete contraction coefficients for each basis set
   ! Size of cc_mat is [.n_prim,.n_bf].
      MAT, OUT :: cc_mat
      INT :: a, bf_count, prim_count
      STR :: error_string
      error_string = "contraction matrix has incorrect shape"
      ENSURE(size(cc_mat,1)== .n_prim,error_string)
      ENSURE(size(cc_mat,2)== .n_bf,error_string)
      bf_count = 1
      prim_count = 1
      cc_mat.zero
      do a = 1, .n_atom
         cc_mat( prim_count : prim_count + .atom(a).basis.n_prim - 1, bf_count : bf_count + .atom(a).basis.n_bf - 1) &
                  = .atom(a).basis.contraction_matrix
         prim_count = prim_count + .atom(a).basis.n_prim
         bf_count = bf_count + .atom(a).basis.n_bf
      end
   end
   

!  **********************
!  Make shell information
!  **********************

   make_shell_info [leaky]
   ! Define a vector of atom numbers corresponding to the molecule 
   ! basis set shell numbers; also define a vector of atom shell numbers 
   ! corresponding to the molecule basis set shell number
     .atom_for_shell       => .atom.atom_for_shell
     .atom_shell_for_shell => .atom.atom_shell_for_shell
     .first_shell_for_atom => .atom.first_shell_for_atom
     .atom.get_shell_limits(.first_basis_fn_for_shell, .last_basis_fn_for_shell)
     .atom.make_atom_basis_fn_limits(.first_basis_fn_for_atom,.last_basis_fn_for_atom)
   end

!  **********************
!  Density matrix methods
!  **********************

   make_scf_density_matrix(damp,scf_kind) [leaky]
   ! Make the density matrix from the molecular orbitals. If "damp" is present
   ! use it to damp the updated density matrix.
      BIN, optional :: damp
      STR(*), optional :: scf_kind
      BIN :: damping
      OPMAT, PTR :: D_old
      MAT, PTR :: MO,D,MOa,MOb,Da,Db
      CMAT, PTR :: CMO,CD,CMOa,CMOb,CDa,CDb
      ARCHIVE :: archive
      STR :: kind
      DBL :: mix
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .molecular_orbitals.created, "no molecular orbitals")
      if ( .scfdata.destroyed) then;                 damping = FALSE
      else if ( .density_matrix.all_destroyed) then; damping = FALSE
      else
         damping = .scfdata.apply_damping
         if (present(damp)) damping = damp
      end
      if (damping) D_old.create_copy(.density_matrix)
      if ( .scfdata.destroyed) then; kind = .molecular_orbitals.spinorbital_kind
      else;                          kind = .scfdata.spinorbital_kind
      end
      .density_matrix.destroy(kind)
      .density_matrix.create(kind)
      archive.set(.name,"density_matrix",kind)
      if (present(scf_kind)) then;        kind = scf_kind
      else if ( .scfdata.destroyed) then; kind = .molecular_orbitals.guess_scf_kind
      else;                               kind = .scfdata.kind
      end
      select case (kind)
          case ("rhf","restricted_hartree_fock", &
                "xray_rhf","xray_constrained")
            DIE_IF(.mult/=1,"this is not a singlet state")
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted
            D.to_product(MO,MO,transpose_b=TRUE)
            D = TWO*D
         case ("rohf","restricted_open_shell_hartree_fock")
            MOa => .molecular_orbitals.restricted(:,1:.n_a)
            MOb => .molecular_orbitals.restricted(:,1:.n_b)
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            Da.to_product(MOa,MOa,transpose_b=TRUE)
            Db.to_product(MOb,MOb,transpose_b=TRUE)
         case ("uhf","unrestricted_hartree_fock")
            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            Da.to_product(MOa,MOa,transpose_b=TRUE)
            Db.to_product(MOb,MOb,transpose_b=TRUE)
         case ("ghf","general_hartree_fock")
            DIE_IF(.mult/=1,"this is not a singlet state")
            MO => .molecular_orbitals.general(:,1:.n_e)
            D =>  .density_matrix.general
            D.to_product(MO,MO,transpose_b=TRUE)
         case ("rchf","restricted_complex_hartree_fock")
            CMO => .molecular_orbitals.restricted_complex(:,1:.n_a)
            CD  => .density_matrix.restricted_complex
            CD.to_product(CMO,CMO,dagger_b=TRUE)
            CD = TWO*CD
         case ("uchf","unrestricted_complex_hartree_fock")
            CMOa => .molecular_orbitals.alpha_complex(:,1:.n_a)
            CMOb => .molecular_orbitals.beta_complex(:,1:.n_b)
            CDa => .density_matrix.alpha_complex
            CDb => .density_matrix.beta_complex
            CDa.to_product(CMOa,CMOa,dagger_b=TRUE)
            CDb.to_product(CMOb,CMOb,dagger_b=TRUE)
         case ("gchf","general_complex_hartree_fock")
            CMO => .molecular_orbitals.general_complex(:,1:.n_e)
            CD =>  .density_matrix.general_complex
            CD.to_product(CMO,CMO,dagger_b=TRUE)
      end
      if (damping) then
         mix = .scfdata.damp_factor
         select case (kind)
            case ("rhf","restricted_hartree_fock", &
                  "xray_rhf","xray_constrained_restricted_hartree_fock")
               D = (1-mix)*D + mix*D_old.restricted
            case ("rohf","restricted_open_shell_hartree_fock")
               Da = (1-mix)*Da + mix*D_old.alpha
               Db = (1-mix)*Db + mix*D_old.beta
            case ("uhf","unrestricted_hartree_fock")
               Da = (1-mix)*Da + mix*D_old.alpha
               Db = (1-mix)*Db + mix*D_old.beta
            case ("ghf","general_hartree_fock")
               D = (1-mix)*D + mix*D_old.general
            case ("rchf","restricted_complex_hartree_fock")
               CD = (1-mix)*CD + mix*D_old.restricted_complex
            case ("uchf","unrestricted_complex_hartree_fock")
               CDa = (1-mix)*CDa + mix*D_old.alpha_complex
               CDb = (1-mix)*CDb + mix*D_old.beta_complex
            case ("gchf","general_complex_hartree_fock")
               CD = (1-mix)*CD + mix*D_old.general_complex
        end
      end
      D_old.destroy
      archive.write(.density_matrix)
   end

   make_ao_density_matrix [leaky]
   ! Make the AO (spin independent) density matrix from the existing density
   ! matrix.
   ! The result is placed in the "restricted" part of the density matrix
      STR :: kind
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if ( kind=="restricted") return
      if ( kind=="restricted_complex") return
      if ( kind.includes("complex")) then
         .density_matrix.destroy("restricted_complex")
         .density_matrix.create("restricted_complex")
      else
         .density_matrix.destroy("restricted")
         .density_matrix.create("restricted")
      end
      select case (kind)
         case ("unrestricted")
            .density_matrix.restricted = .density_matrix.alpha + .density_matrix.beta
         case ("general")
            .density_matrix.restricted = .density_matrix.general.alpha_alpha &
                                       + .density_matrix.general.beta_beta 
         case ("unrestricted_complex")
            .density_matrix.restricted_complex = .density_matrix.alpha_complex &
                                               + .density_matrix.beta_complex
         case ("general_complex")
            .density_matrix.restricted_complex = .density_matrix.general_complex.alpha_alpha &
                                               + .density_matrix.general_complex.beta_beta 
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   make_ao_sz_density_matrix
   ! Make the AO (spin independent) density matrix from the existing density
   ! matrix.
   ! The result is placed in the "restricted" part of the density matrix
      STR :: kind
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if ( kind=="restricted") return
      if ( kind.includes("complex")) then
         .density_matrix.destroy("restricted_complex")
         .density_matrix.create("restricted_complex")
      else
         .density_matrix.destroy("restricted")
         .density_matrix.create("restricted")
      end
      select case (kind)
         case ("unrestricted")
            .density_matrix.restricted = .density_matrix.alpha - .density_matrix.beta
         case ("general")
            .density_matrix.restricted = .density_matrix.general.alpha_alpha &
                                       - .density_matrix.general.beta_beta 
         case ("unrestricted_complex")
            .density_matrix.restricted_complex = .density_matrix.alpha_complex &
                                               - .density_matrix.beta_complex
         case ("general_complex")
            .density_matrix.restricted_complex = .density_matrix.general_complex.alpha_alpha &
                                               - .density_matrix.general_complex.beta_beta 
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   make_scf_density_matrix(n,nb)
   ! Make the density matrix from orbital "n" of the molecular orbitals. 
   ! If present, orbital "nb" of the beta molecular orbitals is used.
   ! If either index is not an occupied MO, the density is set to zero.
      INT :: n
      INT, optional :: nb
      MAT, PTR :: MO,D,MOa,MOb,Da,Db
      CMAT, PTR :: CMO,CD,CMOa,CMOb,CDa,CDb
      STR :: kind
      ARCHIVE :: archive
      INT :: m
      BIN :: uhf
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .molecular_orbitals.created, "no molecular orbitals")
      uhf = .scfdata.kind.includes("unrestricted")
      WARN_IF(present(nb) AND (NOT uhf), "nb ignored")
      m = n
      if (present(nb)) m = nb
      kind = .scfdata.spinorbital_kind
      .density_matrix.destroy(kind)
      .density_matrix.create(kind)
      archive.set(.name,"density_matrix",kind)
      kind = .scfdata.kind
      select case (kind)
         case ("rhf","restricted_hartree_fock", &
               "xray_rhf","xray_constrained_restricted_hartree_fock", &
               "xray_fit","xray_constrained")
            DIE_IF(.mult/=1,"this is not a singlet state")
            D  => .density_matrix.restricted
            if (n>0 AND n<=.n_a) then
               MO => .molecular_orbitals.restricted(:,n:n)
               D.to_product(MO,MO,transpose_b=TRUE)
               D = TWO*D
            else
               D = ZERO
            end 
         case ("rohf","restricted_open_shell_hartree_fock")
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            if (n>0 AND n<=.n_b) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               MOb => .molecular_orbitals.restricted(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
               Db.to_product(MOb,MOb,transpose_b=TRUE)
            else if (n>nb AND n<=.n_a) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
               Db = ZERO
            else
               Da = ZERO
               Db = ZERO
            end
         case ("uhf","unrestricted_hartree_fock")
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            if (n>0 AND n<=.n_a) then
               MOa => .molecular_orbitals.alpha(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
            else
               Da = ZERO
            end
            if (m>0 AND m<=.n_b) then
               MOb => .molecular_orbitals.beta(:,m:m)
               Db.to_product(MOb,MOb,transpose_b=TRUE)
            else
               Db = ZERO
            end
         case ("ghf","general_hartree_fock")
            DIE_IF(.mult/=1,"this is not a singlet state")
            D =>  .density_matrix.general
            if (n>0 AND n<=.n_e) then
               MO => .molecular_orbitals.general(:,n:n)
               D.to_product(MO,MO,transpose_b=TRUE)
            else
               D = ZERO
            end 
         case ("rchf","restricted_complex_hartree_fock")
            CD  => .density_matrix.restricted_complex
            if (n>0 AND n<=.n_a) then
               CMO => .molecular_orbitals.restricted_complex(:,n:n)
               CD.to_product(CMO,CMO,dagger_b=TRUE)
               CD = TWO*CD
            else
               CD = ZERO
            end 
         case ("uchf","unrestricted_complex_hartree_fock")
            CDa => .density_matrix.alpha_complex
            CDb => .density_matrix.beta_complex
            if (n>0 AND n<=.n_a) then
               CMOa => .molecular_orbitals.alpha_complex(:,n:n)
               CDa.to_product(CMOa,CMOa,dagger_b=TRUE)
            else 
               CDa = ZERO
            end
            if (m>0 AND m<=.n_b) then
               CMOb => .molecular_orbitals.beta_complex(:,m:m)
               CDb.to_product(CMOb,CMOb,dagger_b=TRUE)
            else 
               CDb = ZERO
            end
         case ("gchf","general_complex_hartree_fock")
            CD =>  .density_matrix.general_complex
            if (n>0 AND n<=.n_e) then
               CMO => .molecular_orbitals.general_complex(:,n:n)
               CD.to_product(CMO,CMO,dagger_b=TRUE)
            else
               CD = ZERO
            end 
      end
      archive.write(.density_matrix)
   end


!****************************
!* Overlap Matrix formation *
!****************************


  get_overlap_matrix(S)
  ! Set "S" to the overlap matrix. 
  ! If the archive file exists, read it; otherwise make it.
     MAT :: S
     ARCHIVE :: archive
     archive.set(.name,"overlap_matrix")
     if ( archive.exists) then; archive.read(S)
     else;                      .make_overlap_matrix(S)
     end
  end
 
  make_overlap_matrix(S)
  ! Calculate the overlap matrix "S"
    MAT, target :: S
    INT :: q,fa,la,fb,lb
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    S = ZERO
    do q=1,.n_shell_pairs
      .get_shell_pair(q,shell,fa,la,fb,lb)
      shell.make_overlap(S(fa:la,fb:lb))
      shell.destroy_ptr_part
    end
    S.make_symmetric
    archive.set(.name,"overlap_matrix")
    archive.write(S)
  end

!  ***************
!  Inquiry methods
!  ***************

   no_of_electrons result(res) 
   ! Work out and return the number of electrons in the molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      res = 0
      do a = 1,.no_of_atoms
         res = res + .atom(a).atomic_number
      end
      res = res - .charge
   end

   no_of_alpha_electrons result(res) 
   ! Work out and return the number of alpha electrons in the molecule
      INT :: res
      res = (.no_of_electrons+.mult-1)/2
   end

   no_of_beta_electrons result(res) 
   ! Work out and return the number of beta electrons in the molecule
      INT :: res
      res = (.no_of_electrons-.mult+1)/2
   end

   no_of_atoms result(res) 
   ! Return the number of atoms in the molecule
      INT :: res
      ENSURE( .atom.created,  "no atom list")
      res = size(.atom)
   end

   no_of_basis_sets result(res) 
   ! Return the number of distinct atomic basis sets for the molecule
      INT :: res
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      res = size(.basis)
   end

   no_of_shells result(res) 
   ! Work out and return the number of gaussian shells in the basis set for the
   ! molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      res = 0
      do a = 1,.n_atom
         res = res + .atom(a).basis.n_shell
      end
   end

   no_of_shell_pairs result(res) 
   ! Return the number of shell pairs in the basis set for the molecule
      INT :: res
      INT :: n_shell
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_shell = .no_of_shells
      res = n_shell*(n_shell+1)/2
   end

   n_shell_quartets result (res)
   ! Return the number of shell quartets in the basis set for the molecule
   ! Note, "res" will die at 22 shells for integer(2).
   !       "res" will die at 361 shells for integer(4).
   !       "res" will die at 92681 shells for integer(8).
      INT :: res
      INT :: n_shell_pair
      n_shell_pair = .no_of_shell_pairs
      ENSURE(n_shell_pair/sqrt(TWO) <= (huge(n_shell_pair))**HALF,"too many shells")
      res = n_shell_pair*(n_shell_pair+1)/2
   end

   no_of_basis_functions result (res)
   ! Work out and return the number of basis functions in the basis set for the
   ! molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      res = 0
      do a = 1,.n_atom
         res = res + .atom(a).basis.n_bf
      end
   end

   no_of_primitives result (res)
   ! Work out and return the number of primitives in the basis set for the
   ! molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      res = 0
      do a= 1,.n_atom
         res = res + .atom(a).basis.n_prim
      end
   end

   no_of_occupied_NOs(kind,tol) result (res)
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      STR, optional :: kind
      DBL, optional :: tol
      INT :: res
      STR :: itemkind
      DBL :: eps
      INT :: n,n_bf
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .occupation.created, "no occupation numbers")
      itemkind = .occupation.spinorbital_kind
      if (present(kind)) itemkind=kind
      eps = TOL(7)
      if (present(tol)) eps = tol 
      select case (itemkind)
         case ("restricted")
            n_bf = .occupation.n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation.restricted(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case ("unrestricted")
            n_bf = .occupation.n_bf
            res = 2*n_bf
            do n = 1,n_bf
               if (.occupation.alpha(n)<eps) then
                  res = n-1
                  exit
               end
            end
            do n = 1,n_bf
               if (.occupation.beta(n)<eps) then
                  res = res + n-1
                  exit
               end
            end
         case ("general")
            n_bf = 2*.occupation.n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation.general(n)<eps) then
                  res = n-1
                  exit
               end
            end
      end
   end

   maximum_basis_set_l_value result (res)
   ! Returns the maximum basis set l value
      INT :: res
      INT :: i,j,l
      res = 0 
      do i = 1,size(.basis)
         do j = 1,size(.basis(i).shell)
            l = .basis(i).shell(j).l
            res = max(l,res)
         end
      end
   end

!  ****************
!  Natural orbitals
!  ****************

   make_natural_orbitals [leaky]
   ! Make the natural orbitals from the density matrix
     STR :: kind
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      ENSURE( .density_matrix.any_created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if (.natural_orbitals.created) .natural_orbitals.destroy_ptr_part
      select case (kind)
         case ("restricted");         .make_restricted_NOs
         case ("unrestricted");       .make_unrestricted_NOs
!        case ("general");            .make_general_NOs
         case ("restricted_complex"); .make_restricted_complex_NOs
         case ("general_complex");    .make_general_complex_NOs
         case default;                DIE("unknown kind" // trim(kind))
      end
   end

   make_restricted_NOs [leaky]
   ! Make the restricted natural orbitals from the density matrix
      ENSURE( .density_matrix.restricted.created, "no density matrix")
      .natural_orbitals.destroy("restricted")
      .natural_orbitals.create("restricted")
      .occupation.destroy("restricted")
      .occupation.create("restricted")
      .make_r_NOs(.natural_orbitals.restricted,.occupation.restricted,.density_matrix.restricted)
   end

   make_unrestricted_NOs [leaky]
   ! Make the unrestricted natural orbitals from the density matrix
      ENSURE( .density_matrix.alpha.created, "no density matrix")
      ENSURE( .density_matrix.beta.created, "no density matrix")
      .natural_orbitals.destroy("unrestricted")
      .natural_orbitals.create("unrestricted")
      .occupation.destroy("unrestricted")
      .occupation.create("unrestricted")
      .make_r_NOs(.natural_orbitals.alpha,.occupation.alpha,.density_matrix.alpha)
      .make_r_NOs(.natural_orbitals.beta, .occupation.beta, .density_matrix.beta)
   end

   make_r_NOs(NO,occupation,P)
   ! Make the real natural orbitals "NO" and "occupation" numbers from the
   ! density matrix "P"
      MAT :: NO,P
      VEC :: occupation
      MAT, PTR :: V,X,S
      V.create(.n_bf,.n_bf)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      V.to_sqrt(S)
      S.destroy
      X.create(.n_bf,.n_bf)
      X = P
      X.change_basis(V)
      X.solve_eigenproblem(occupation,V)
      S.create( .n_bf, .n_bf); .get_overlap_matrix(S)
      X.to_inverse_sqrt(S)
      S.destroy
      NO.to_product(X,V)
      X.destroy
      V.destroy
      occupation = occupation(.n_bf:1:-1)
      occupation.zero_small_values(TOL(10))
      NO = NO(:,.n_bf:1:-1)
   end

  make_restricted_complex_NOs [leaky]
  ! Make the restricted complex natural orbitals from the density matrix
    CMAT, PTR :: V,X
    MAT, PTR  :: S,O
    CMAT, PTR :: D
    D => .density_matrix.restricted_complex
    ENSURE( D.created, "no density matrix")
    .natural_orbitals.destroy("restricted_complex")
    .natural_orbitals.create("restricted_complex")
    .occupation.destroy("restricted")
    .occupation.create("restricted")
    V.create(.n_bf,.n_bf)
    X.create(.n_bf,.n_bf)
    O.create(.n_bf,.n_bf)
    S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
    O.to_sqrt(S)
    S.destroy
    V = O
    X = D
    X.change_basis(V)
    X.solve_eigenproblem(.occupation.restricted,V)
    S.create( .n_bf, .n_bf); .get_overlap_matrix(S)
    O.to_inverse_sqrt(S)
    S.destroy
    X = O
    O.destroy
    .natural_orbitals.restricted_complex.to_product(X,V)
    X.destroy
    V.destroy
    .occupation.restricted = .occupation.restricted(.n_bf:1:-1)
    .occupation.restricted.zero_small_values(TOL(10))
    .natural_orbitals.restricted_complex = .natural_orbitals.restricted_complex(:,.n_bf:1:-1)
  end

   make_general_complex_NOs [leaky]
   ! Make the general natural orbitals and occupations from the complex density
   ! matrix.
      MAT, PTR :: S,R
      CMAT, PTR :: V,X
      BIN :: dens_created
      dens_created = .density_matrix.general_complex.created
      ENSURE(dens_created,"no density matrix")
      .natural_orbitals.destroy("general_complex")
      .natural_orbitals.create("general_complex")
      .occupation.destroy("general")
      .occupation.create("general")
      V.create(2*.n_bf,2*.n_bf)
      R.create(.n_bf,.n_bf)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      R.to_sqrt(S)
      S.destroy
      V.alpha_alpha_set_to(R)
      V.beta_beta_set_to(R)
      R.destroy
      X.create(2*.n_bf,2*.n_bf)
      X = .density_matrix.general_complex
      X.change_basis(V)
      X.solve_eigenproblem(.occupation.general,V)
      R.create(.n_bf,.n_bf)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      R.to_inverse_sqrt(S)
      S.destroy
      X.alpha_alpha_set_to(R)
      X.beta_beta_set_to(R)
      R.destroy
      .natural_orbitals.general_complex.to_product(X,V)
      .occupation.general = .occupation.general(2*.n_bf:1:-1)
      .occupation.general.zero_small_values(TOL(10))
      .natural_orbitals.general = .natural_orbitals.general(:,2*.n_bf:1:-1)
      X.destroy
      V.destroy
   end

!  ***************************
!  Population Analysis Methods
!  ***************************
   
   make_mulliken_matrix
   ! sets the mulliken population matrix and the outputs it.
      MAT, PTR :: mulliken_matrix, S
      VEC, PTR :: diagonals
      S.create( .n_bf, .n_bf)
      mulliken_matrix.create( .n_bf, .n_bf)
      diagonals.create( .n_bf)
      .get_overlap_matrix(S)
      mulliken_matrix = matmul( .density_matrix.restricted, S)
      mulliken_matrix.get_diagonal( diagonals)
      .put_mulliken_populations( mulliken_matrix, diagonals)
      S.destroy
      mulliken_matrix.destroy
      diagonals.destroy
   end
   
   put_mulliken_populations( mulliken_matrix, diagonals)
   ! outputs the mulliken populations to the output file
      MAT :: mulliken_matrix      
      VEC :: diagonals
      DBL :: sum
      INT :: o_count, a, b, c
      stdout.flush
      stdout.text( "Mulliken population analysis: ")
      stdout.dash(int_fields=2,dbl_fields=1)
      stdout.put( "Atom", int_width = TRUE)
      stdout.put( "Type", int_width = TRUE)
      stdout.put( "Population")
      stdout.flush
      stdout.dash(int_fields=2,dbl_fields=1)
      o_count = 1
      do a = 1, .n_atom
         do b = 1, .atom.n_shell_for_atom(a)
            do c = 1, .atom(a).basis.shell(b).n_comp
               stdout.put( .atom(a).label, int_width = TRUE)
               stdout.put( .atom(a).basis.shell(b).l_chr, int_width = TRUE)
               stdout.put( diagonals(c + o_count - 1))
               stdout.flush
            end
            o_count = o_count + .atom(a).basis.shell(b).n_comp
         end
      end
      stdout.flush
      stdout.text( "Trace of the matrix: ")
      stdout.put( mulliken_matrix.trace )
      stdout.flush
      stdout.text( "Atomic Populations: ")
      stdout.dash(int_fields=1, dbl_fields=1)
      stdout.put( "Atom", int_width = TRUE)
      stdout.put( "Population")
      stdout.flush
      stdout.dash(int_fields=1, dbl_fields=1)
      o_count = 1
      do a = 1, .n_atom
         stdout.put( .atom(a).label, int_width = TRUE)
         sum = 0
         do b = 1, .atom.n_shell_for_atom(a)
            sum = sum + diagonals(b - 1 + o_count)
         end
         stdout.put( sum)
         stdout.flush
         o_count = o_count + .atom.n_bf_for_atom(a)
      end
   end

  get_kinetic_matrix(T)
  ! Set "T" to the kinetic matrix
  ! If the archive file exists, read it; otherwise make it.
     MAT :: T
     ARCHIVE :: archive
     archive.set(.name,"kinetic_matrix")
     if ( archive.exists) then; archive.read(T)
     else;                      .make_kinetic_matrix(T)
     end
  end

  make_kinetic_matrix(T,output)
  ! Calculate the kinetic energy matrix "T"
  ! if PRESENT and FALSE the matrix is not archived
    MAT :: T
    BIN, OPTIONAL :: output
    INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
    SHELL2 :: shell
    BIN :: do_archive
    ARCHIVE :: archive
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    do_archive = TRUE
    if (present(output)) do_archive=output
    if (.scfdata.nddo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (atom_a==atom_b) then; shell.get_kei(T(fa:la,fb:lb))
        else;                     T(fa:la,fb:lb) = ZERO
        end
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        shell.get_kei(T(fa:la,fb:lb))
        shell.destroy_ptr_part
      end
    end
    T.make_symmetric
    if (do_archive) then
      archive.set(.name,"kinetic_matrix")
      archive.write(T)
    end
  end

  get_kinetic_overlap(T,S)
  ! Set "S" to the overlap matrix and "T" to the kinetic matrix
  ! If both archives exists, read them; otherwise make them both!
     MAT :: T,S
     ARCHIVE :: T_archive,S_archive
     S_archive.set(.name,"overlap_matrix")
     T_archive.set(.name,"kinetic_matrix")
     if ((S_archive.exists) AND (T_archive.exists)) then
        S_archive.read(S)
        T_archive.read(T)
     else
        .make_kinetic_overlap(T,S)
     end
  end

  make_kinetic_overlap(T,S)
  ! Calculate the kinetic energy matrix "T" and overlap integral matrix "S"
    MAT :: T,S
    INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    if (.scfdata.nddo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
        shell.get_kei( T(fa:la,fb:lb), S(fa:la,fb:lb))
        if (atom_a/=atom_b) T(fa:la,fb:lb) = ZERO
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        shell.get_kei( T(fa:la,fb:lb), S(fa:la,fb:lb))
        shell.destroy_ptr_part
      end
    end
    S.make_symmetric
    T.make_symmetric
    archive.set(.name,"kinetic_matrix")
    archive.write(T)
    archive.set(.name,"overlap_matrix")
    archive.write(S)
  end

  get_nuclear_matrix(Z)
  ! Set "Z" to the nuclear attraction matrix.
  ! If the archive file exists, read it; otherwise make it.
     MAT :: Z
     ARCHIVE :: archive
     archive.set(.name,"nuclear_matrix")
     if ( archive.exists) then; archive.read(Z)
     else;                      .make_nuclear_matrix(Z)
     end
  end

  make_nuclear_matrix(Z,output)
  ! Calculate the nuclear attraction matrix "Z"
  ! if output is present and FALSE then do not make output archive
    MAT :: Z
    BIN, OPTIONAL :: output
    BIN :: do_output
    ATOM, PTR :: atom
    MAT, PTR :: Z_c
    INT :: q,c,a,b,fa,la,fb,lb,atom_a,atom_b
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    do_output=TRUE
    if (present(output)) do_output=output
    Z = ZERO
    if (.scfdata.nddo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (atom_a==atom_b) then
          Z_c.create(shell.a.n_comp,shell.b.n_comp)
          do c=1,.n_atom
            atom=>.atom(c)
            shell.get_nuc(Z_c, atom.mass,atom.pos)
          ! shell.make_nuclear_attraction_ints(Z_c, atom.pos)
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
          end
          Z_c.destroy
        end
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        Z_c.create(shell.a.n_comp,shell.b.n_comp)
        do c=1,.n_atom
          atom=>.atom(c)
        ! shell.get_nuc(Z_c, atom.mass,atom.pos)
          shell.make_nuclear_attraction_ints(Z_c, atom.pos)
          Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
        end
        Z_c.destroy
        shell.destroy_ptr_part
      end
    end
    Z.make_symmetric
    if (do_output) then
      archive.set(.name,"nuclear_matrix")
      archive.write(Z)
    end
  end

  make_nuclear_matrix(Z,nuclei)
  ! Using the nuclei specified in "nuclei"
  ! Calculate the nuclear attraction matrix "Z"
    MAT :: Z
    IVEC :: nuclei
    ATOM, PTR :: atom
    MAT, PTR :: Z_c
    INT :: q,c,a,b,fa,la,fb,lb,n_atom,atom_a,atom_b
    SHELL2 :: shell
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    Z = ZERO
    n_atom = size(nuclei)
    if (.scfdata.nddo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (atom_a==atom_b) then
          Z_c.create(shell.a.n_comp,shell.b.n_comp)
          do c=1,n_atom
            atom=>.atom(nuclei(c))
            shell.get_nuc(Z_c, atom.mass,atom.pos)
          ! shell.make_nuclear_attraction_ints(Z_c, atom.pos)
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
          end
          Z_c.destroy
        end
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        Z_c.create(shell.a.n_comp,shell.b.n_comp)
        do c=1,n_atom
          atom=>.atom(nuclei(c))
        ! shell.get_nuc(Z_c, atom.mass,atom.pos)
          shell.make_nuclear_attraction_ints(Z_c, atom.pos)
          Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
        end
        Z_c.destroy
        shell.destroy_ptr_part
      end
    end
    Z.make_symmetric
  end

  get_core_matrix(H,nuclei)
  ! Get the core hamiltonian matrix. If already in memory, do nothing. Else if
  ! the archive file exists, read it. Otherwise make it.
  ! If the nuclei are given make it regardless, since the stored one is
  ! likely to be different
     MAT :: H
     IVEC, optional :: nuclei
     ARCHIVE :: archive
     if (present(nuclei)) then
      .make_core_matrix(H,nuclei)
     else
      archive.set(.name,"core_matrix")
      if ( archive.exists) then; archive.read(H)
       else; .make_core_matrix(H)
      end
     end
  end

  make_core_matrix(H)
  ! Get the core hamiltonian matrix "H".
     MAT :: H
     MAT, PTR :: Z
     ARCHIVE :: archive
     .get_kinetic_matrix(H)
     Z.create( .n_bf, .n_bf)
     .get_nuclear_matrix(Z)
     H = H + Z
     Z.destroy
     archive.set(.name,"core_matrix")
     archive.write(H)
  end

  make_core_matrix(H,nuclei)
  ! Get the core hamiltonian matrix "H".
     MAT :: H
     IVEC :: nuclei
     MAT, PTR :: Z
     .make_kinetic_matrix(H,output=FALSE)
     Z.create( .n_bf, .n_bf)
     .make_nuclear_matrix(Z,nuclei)
     H = H + Z
     Z.destroy
  end

  get_dipole_matrices(Dx,Dy,Dz)
  ! Set "Di" to the dipole moment integral matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Dx,Dy,Dz
     ARCHIVE :: x_archive,y_archive,z_archive
     x_archive.set(.name,"dipole_x_matrix")
     y_archive.set(.name,"dipole_y_matrix")
     z_archive.set(.name,"dipole_z_matrix")
     if (x_archive.exists) then
        x_archive.read(Dx); y_archive.read(Dy); z_archive.read(Dz)
     else
        .make_dipole_matrices(Dx,Dy,Dz)
     end
  end

  make_dipole_matrices(Dx,Dy,Dz)
  ! Make "Di", the dipole moment integral matrices.
     MAT :: Dx,Dy,Dz
     MAT, PTR :: DDx,DDy,DDz
     INT :: q,fa,la,fb,lb
     SHELL2 :: shell
     ARCHIVE :: archive
     INT :: n_a,n_b
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     Dx = ZERO; Dy = ZERO; Dz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        n_a = shell.a.n_comp; n_b = shell.b.n_comp
        DDx.create(n_a,n_b); DDy.create(n_a,n_b); DDz.create(n_a,n_b)
        shell.make_dipole_ints(DDx,DDy,DDz, .gauge_origin)
        Dx(fa:la,fb:lb) = Dx(fa:la,fb:lb) + DDx
        Dy(fa:la,fb:lb) = Dy(fa:la,fb:lb) + DDy
        Dz(fa:la,fb:lb) = Dz(fa:la,fb:lb) + DDz
        shell.destroy_ptr_part
        DDz.destroy; DDy.destroy; DDx.destroy
     end
     Dx.make_symmetric; Dy.make_symmetric; Dz.make_symmetric
     archive.set(.name,"dipole_x_matrix"); archive.write(Dx)
     archive.set(.name,"dipole_y_matrix"); archive.write(Dy)
     archive.set(.name,"dipole_z_matrix"); archive.write(Dz)
  end

  get_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
  ! Set "Qij" to the quadrupole moment integral matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Qxx,Qyy,Qzz,Qxy,Qxz,Qyz
     ARCHIVE :: xx_archive,yy_archive,zz_archive
     ARCHIVE :: xy_archive,xz_archive,yz_archive
     xx_archive.set(.name,"quadrupole_xx_matrix")
     yy_archive.set(.name,"quadrupole_yy_matrix")
     zz_archive.set(.name,"quadrupole_zz_matrix")
     xy_archive.set(.name,"quadrupole_xy_matrix")
     xz_archive.set(.name,"quadrupole_xz_matrix")
     yz_archive.set(.name,"quadrupole_yz_matrix")
     if (xx_archive.exists) then
        xx_archive.read(Qxx); yy_archive.read(Qyy); zz_archive.read(Qzz)
        xy_archive.read(Qxy); xz_archive.read(Qxz); yz_archive.read(Qyz)
     else
        .make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
     end
  end

  make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
  ! Make "Qij", the quadrupole moment integral matrices.
     MAT :: Qxx,Qyy,Qzz,Qxy,Qxz,Qyz
     MAT, PTR :: QQxx,QQyy,QQzz,QQxy,QQxz,QQyz
     INT :: q,fa,la,fb,lb
     SHELL2 :: shell
     ARCHIVE :: archive
     INT :: n_a,n_b
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     Qxx = ZERO; Qyy = ZERO; Qzz = ZERO
     Qxy = ZERO; Qxz = ZERO; Qyz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        n_a = shell.a.n_comp; n_b = shell.b.n_comp
        QQxx.create(n_a,n_b); QQyy.create(n_a,n_b); QQzz.create(n_a,n_b)
        QQxy.create(n_a,n_b); QQxz.create(n_a,n_b); QQyz.create(n_a,n_b)
        shell.make_quadrupole_ints(QQxx,QQyy,QQzz,QQxy,QQxz,QQyz, .gauge_origin)
        Qxx(fa:la,fb:lb) = Qxx(fa:la,fb:lb) + QQxx
        Qyy(fa:la,fb:lb) = Qyy(fa:la,fb:lb) + QQyy
        Qzz(fa:la,fb:lb) = Qzz(fa:la,fb:lb) + QQzz
        Qxy(fa:la,fb:lb) = Qxy(fa:la,fb:lb) + QQxy
        Qxz(fa:la,fb:lb) = Qxz(fa:la,fb:lb) + QQxz
        Qyz(fa:la,fb:lb) = Qyz(fa:la,fb:lb) + QQyz
        shell.destroy_ptr_part
        QQyz.destroy; QQxz.destroy; QQxy.destroy
        QQzz.destroy; QQyy.destroy; QQxx.destroy
     end
     Qxx.make_symmetric; Qyy.make_symmetric; Qzz.make_symmetric
     Qxy.make_symmetric; Qxz.make_symmetric; Qyz.make_symmetric
     archive.set(.name,"quadrupole_xx_matrix"); archive.write(Qxx)
     archive.set(.name,"quadrupole_yy_matrix"); archive.write(Qyy)
     archive.set(.name,"quadrupole_zz_matrix"); archive.write(Qzz)
     archive.set(.name,"quadrupole_xy_matrix"); archive.write(Qxy)
     archive.set(.name,"quadrupole_xz_matrix"); archive.write(Qxz)
     archive.set(.name,"quadrupole_yz_matrix"); archive.write(Qyz)
  end

  get_spin_orbit_matrices(SOx,SOy,SOz)
  ! Set "SOx", "SOy", and "SOz" to the one electron spin orbit matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: SOx,SOy,SOz
     ARCHIVE :: SOx_archive,SOy_archive,SOz_archive
     SOx_archive.set(.name,"SOx_matrix")
     SOy_archive.set(.name,"SOy_matrix")
     SOz_archive.set(.name,"SOz_matrix")
     if (SOx_archive.exists AND SOy_archive.exists AND SOz_archive.exists) then
        SOx_archive.read(SOx)
        SOy_archive.read(SOy)
        SOz_archive.read(SOz)
     else
        .make_spin_orbit_matrices(SOx,SOy,SOz)
     end
  end

  make_spin_orbit_matrices(SOx,SOy,SOz)
  ! Calculate the spin orbit matrices "SOx" "SOy" and "SOz"
     MAT :: SOx,SOy,SOz
     MAT, PTR :: SOx_c,SOy_c,SOz_c
     INT :: q,c,fa,la,fb,lb
     DBL :: Z
     SHELL2 :: shell
     ARCHIVE :: archive
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     SOx = ZERO; SOy = ZERO; SOz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        SOx_c.create(shell.a.n_comp,shell.b.n_comp)
        SOy_c.create(shell.a.n_comp,shell.b.n_comp)
        SOz_c.create(shell.a.n_comp,shell.b.n_comp)
        do c = 1,.n_atom
           Z = .atom(c).atomic_number
           shell.make_spin_orbit_ints(SOx_c,SOy_c,SOz_c, .atom(c).pos)
           SOx(fa:la,fb:lb) = SOx(fa:la,fb:lb) + Z*SOx_c
           SOy(fa:la,fb:lb) = SOy(fa:la,fb:lb) + Z*SOy_c
           SOz(fa:la,fb:lb) = SOz(fa:la,fb:lb) + Z*SOz_c
        end
        shell.destroy_ptr_part
        SOz_c.destroy; SOy_c.destroy; SOx_c.destroy
     end
     SOx.make_antisymmetric
     SOy.make_antisymmetric
     SOz.make_antisymmetric
     archive.set(.name,"SOx_matrix"); archive.write(SOx)
     archive.set(.name,"SOy_matrix"); archive.write(SOy)
     archive.set(.name,"SOz_matrix"); archive.write(SOz)
  end

  get_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
  ! Set "SOBi" to the gauge modified (B field) one electron spin orbit matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: SOBx,SOBy,SOBz
     ARCHIVE :: x_archive,y_archive,z_archive
     x_archive.set(.name,"SOBx_matrix")
     y_archive.set(.name,"SOBy_matrix")
     z_archive.set(.name,"SOBz_matrix")
     if (x_archive.exists) then
        x_archive.read(SOBx); y_archive.read(SOBy); z_archive.read(SOBz)
     else
        .make_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
     end
  end

  make_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
  ! Calculate the gauge modified (B field) spin orbit matrices "SOBx" "SOBy"
  ! and "SOBz"
     MAT :: SOBx,SOBy,SOBz
     MAT, PTR :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
     INT :: n_bf
     ARCHIVE :: archive
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     n_bf = .n_bf
     Qxx.create(n_bf,n_bf); Qxy.create(n_bf,n_bf); Qxz.create(n_bf,n_bf)
     Qyx.create(n_bf,n_bf); Qyy.create(n_bf,n_bf); Qyz.create(n_bf,n_bf)
     Qzx.create(n_bf,n_bf); Qzy.create(n_bf,n_bf); Qzz.create(n_bf,n_bf)
     .get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
     SOBx = (Qyy + Qzz)*.B_field(1) - Qxy*.B_field(2) - Qxz*.B_field(3)
     SOBy = (Qxx + Qzz)*.B_field(2) - Qyx*.B_field(1) - Qyz*.B_field(3)
     SOBz = (Qxx + Qyy)*.B_field(3) - Qzx*.B_field(1) - Qzy*.B_field(2)
     Qzz.destroy; Qzy.destroy; Qzx.destroy
     Qyz.destroy; Qyy.destroy; Qyx.destroy
     Qxz.destroy; Qxy.destroy; Qxx.destroy
     SOBx.make_symmetric
     SOBy.make_symmetric
     SOBz.make_symmetric
     archive.set(.name,"SOBx_matrix"); archive.write(SOBx)
     archive.set(.name,"SOBy_matrix"); archive.write(SOBy)
     archive.set(.name,"SOBz_matrix"); archive.write(SOBz)
  end

  get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
  ! Set "Qij" the gauge modified (B field) spin orbit quadrupole matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
     ARCHIVE :: xx_archive,xy_archive,xz_archive
     ARCHIVE :: yx_archive,yy_archive,yz_archive
     ARCHIVE :: zx_archive,zy_archive,zz_archive
     xx_archive.set(.name,"SO_Qxx_matrix")
     xy_archive.set(.name,"SO_Qxy_matrix")
     xz_archive.set(.name,"SO_Qxz_matrix")
     yx_archive.set(.name,"SO_Qyx_matrix")
     yy_archive.set(.name,"SO_Qyy_matrix")
     yz_archive.set(.name,"SO_Qyz_matrix")
     zx_archive.set(.name,"SO_Qzx_matrix")
     zy_archive.set(.name,"SO_Qzy_matrix")
     zz_archive.set(.name,"SO_Qzz_matrix")
     if ( xx_archive.exists ) then
        xx_archive.read(Qxx); xy_archive.read(Qxy); xz_archive.read(Qxz)
        yx_archive.read(Qyx); yy_archive.read(Qyy); yz_archive.read(Qyz)
        zx_archive.read(Qzx); zy_archive.read(Qzy); zz_archive.read(Qzz)
     else
        .make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
     end
  end

  make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
  ! Calculate the gauge modified (B field) spin orbit quadrupole matrices "Qij".
     MAT :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
     MAT, PTR :: xx,xy,xz,yx,yy,yz,zx,zy,zz
     INT :: q,c,fa,la,fb,lb
     DBL :: Z
     SHELL2 :: shell
     ARCHIVE :: archive
     INT :: n_a,n_b
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     Qxx = ZERO; Qxy = ZERO; Qxz = ZERO
     Qyx = ZERO; Qyy = ZERO; Qyz = ZERO
     Qzx = ZERO; Qzy = ZERO; Qzz = ZERO
     do q = 1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        n_a = shell.a.n_comp; n_b = shell.b.n_comp
        xx.create(n_a,n_b); xy.create(n_a,n_b); xz.create(n_a,n_b)
        yx.create(n_a,n_b); yy.create(n_a,n_b); yz.create(n_a,n_b)
        zx.create(n_a,n_b); zy.create(n_a,n_b); zz.create(n_a,n_b)
        do c = 1,.n_atom
           Z = .atom(c).atomic_number
           shell.make_spin_orbit_B_ints(xx,xy,xz,yx,yy,yz,zx,zy,zz,.atom(c).pos, .gauge_origin)
           ! minus due to r-c, not c-r in the electric field part
           ! this comment should go in gaussian2?
           Qxx(fa:la,fb:lb) = Qxx(fa:la,fb:lb) - Z*xx
           Qxy(fa:la,fb:lb) = Qxy(fa:la,fb:lb) - Z*xy
           Qxz(fa:la,fb:lb) = Qxz(fa:la,fb:lb) - Z*xz
           Qyx(fa:la,fb:lb) = Qyx(fa:la,fb:lb) - Z*yx
           Qyy(fa:la,fb:lb) = Qyy(fa:la,fb:lb) - Z*yy
           Qyz(fa:la,fb:lb) = Qyz(fa:la,fb:lb) - Z*yz
           Qzx(fa:la,fb:lb) = Qzx(fa:la,fb:lb) - Z*zx
           Qzy(fa:la,fb:lb) = Qzy(fa:la,fb:lb) - Z*zy
           Qzz(fa:la,fb:lb) = Qzz(fa:la,fb:lb) - Z*zz
        end
        shell.destroy_ptr_part
        zz.destroy; zy.destroy; zx.destroy
        yz.destroy; yy.destroy; yx.destroy
        xz.destroy; xy.destroy; xx.destroy
     end
     Qxx.make_symmetric; Qxy.make_symmetric; Qxz.make_symmetric
     Qyx.make_symmetric; Qyy.make_symmetric; Qyz.make_symmetric
     Qzx.make_symmetric; Qzy.make_symmetric; Qzz.make_symmetric
     archive.set(.name,"SO_Qxx_matrix"); archive.write(Qxx)
     archive.set(.name,"SO_Qxy_matrix"); archive.write(Qxy)
     archive.set(.name,"SO_Qxz_matrix"); archive.write(Qxz)
     archive.set(.name,"SO_Qyx_matrix"); archive.write(Qyx)
     archive.set(.name,"SO_Qyy_matrix"); archive.write(Qyy)
     archive.set(.name,"SO_Qyz_matrix"); archive.write(Qyz)
     archive.set(.name,"SO_Qzx_matrix"); archive.write(Qzx)
     archive.set(.name,"SO_Qzy_matrix"); archive.write(Qzy)
     archive.set(.name,"SO_Qzz_matrix"); archive.write(Qzz)
  end

   nuclear_potential(values,pts)
   ! Calculate the nuclear potential "values" of a given set of "pts".
   ! This is usefule for numerical integration of nuclear attraction integrals.
      VEC :: values
      MAT :: pts
      INT :: n_pts,n,i
      DBL :: Z_n,r_ni
      VEC(3) :: pos
      n_pts = size(pts,1)
      values = ZERO
      do n = 1,.n_atom
         Z_n = .atom(n).atomic_number
         pos = .atom(n).pos
         do i = 1,n_pts
            r_ni = pos.distance_to(pts(i,:))
            values(i) = values(i) + Z_n/r_ni
         end
      end
   end

   ZORA_potential(values,pts)
   ! Calculate the one electron ZORA potential "values" of a given set of "pts".
   ! This is useful for numerical integration.
      VEC :: values
      MAT :: pts
      .nuclear_potential(values,pts)
      values = ONE/(TWO + values/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU))
   end

  get_1e_ZORA_matrices(T,SOx,SOy,SOz)
  ! Set "SOx", "SOy", and "SOz" to the one electron ZORA spin orbit matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: T,SOx,SOy,SOz
     ARCHIVE :: T_archive,SOx_archive,SOy_archive,SOz_archive
     T_archive.set(.name,"ZORA_kinetic_matrix")
     SOx_archive.set(.name,"ZORA_SOx_matrix")
     SOy_archive.set(.name,"ZORA_SOy_matrix")
     SOz_archive.set(.name,"ZORA_SOz_matrix")
     if (SOx_archive.exists AND SOy_archive.exists AND SOz_archive.exists) then
        T_archive.read(T)
        SOx_archive.read(SOx)
        SOy_archive.read(SOy)
        SOz_archive.read(SOz)
     else
        .make_1e_ZORA_matrices(T,SOx,SOy,SOz)
     end
  end

  make_1e_ZORA_matrices(T,Zx,Zy,Zz)
  ! Calculate the one-electron ZORA spin orbit matrices numerically.
  ! This includes the relativitically modified kinetic energy integrals.
    MAT  :: T, Zx,Zy,Zz
    MAT4, PTR :: ZORA ,SO
    INT :: q,fa,la,fb,lb, k,l,a,b, x,y,z
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .dftgrid.created, "need to specify dftgrid for ZORA")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    ZORA.create(.n_bf,.n_bf,3,3)
    ! Make the lower half of the ZORA spin orbit integrals
    ZORA = ZERO
    do q = 1,.n_shell_pairs
       .get_shell_pair(q,shell,fa,la,fb,lb)
       SO.create(shell.a.n_comp,shell.b.n_comp,3,3)
!       .dftgrid.make_SO_matrix_elements_of(ZORA_potential,self,shell,SO)
       ZORA(fa:la,fb:lb,:,:) = ZORA(fa:la,fb:lb,:,:) + SO
       SO.destroy
       shell.destroy_ptr_part
    end
    ! Make the upper half of the ZORA spin orbit integrals
    do k = 1,3
    do l = 1,k
    do a = 1,.n_bf
    do b = 1,a-1
       ZORA(b,a,l,k) = ZORA(a,b,k,l)
    end
    end
    end
    end
    ! Assemble the ZORA contribution to the 1 electron hamiltonian
    ! Scalar kinetic energy contribution
    x = 1; y = 2; z = 3
    T = ZORA(:,:,x,x) + ZORA(:,:,y,y) + ZORA(:,:,z,z)
    ! Spin-dependent spin-orbit contribution
    Zx = ZORA(:,:,y,z) - ZORA(:,:,z,y)
    Zy = ZORA(:,:,z,x) - ZORA(:,:,x,z)
    Zz = ZORA(:,:,x,y) - ZORA(:,:,y,x)
    ! HH.beta_alpha_plus(W,factor=-I*fac)
    ! HH.beta_alpha_plus(W,factor=fac)
    ! HH.alpha_alpha_plus(W,factor=-I*fac)
    ! HH.beta_beta_plus(W,factor=I*fac)
    ZORA.destroy
     archive.set(.name,"ZORA_kinetic_matrix"); archive.write(T)
     archive.set(.name,"ZORA_SOx_matrix");     archive.write(Zx)
     archive.set(.name,"ZORA_SOy_matrix");     archive.write(Zy)
     archive.set(.name,"ZORA_SOz_matrix");     archive.write(Zz)
  end

  get_L_matrices(Lx,Ly,Lz)
  ! Set "Lx", "Ly", and "Lz" to the angular momentum matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Lx,Ly,Lz
     ARCHIVE :: Lx_archive,Ly_archive,Lz_archive
     Lx_archive.set(.name,"Lx_matrix")
     Ly_archive.set(.name,"Ly_matrix")
     Lz_archive.set(.name,"Lz_matrix")
     if (Lx_archive.exists AND Ly_archive.exists AND Lz_archive.exists) then
        Lx_archive.read(Lx)
        Ly_archive.read(Ly)
        Lz_archive.read(Lz)
     else
        .make_L_matrices(Lx,Ly,Lz)
     end
  end

  make_L_matrices(Lx,Ly,Lz)
  ! Make the angular momentum matrices  "Lx", "Ly", and "Lz".
     MAT :: Lx,Ly,Lz
     INT :: q,fa,la,fb,lb
     SHELL2 :: shell
     ARCHIVE :: archive
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        shell.make_L_ints(Lx(fa:la,fb:lb),Ly(fa:la,fb:lb),Lz(fa:la,fb:lb), .gauge_origin)
        shell.destroy_ptr_part
     end
     Lx.make_antisymmetric
     Ly.make_antisymmetric
     Lz.make_antisymmetric
     archive.set(.name,"Lx_matrix"); archive.write(Lx)
     archive.set(.name,"Ly_matrix"); archive.write(Ly)
     archive.set(.name,"Lz_matrix"); archive.write(Lz)
  end

  get_eri_integrals
  ! Get the electron repulsion integrals on disk. If the integral
  ! file is already there, do nothing.
    ARCHIVE :: eri_archive,ind_archive
    eri_archive.set(.name,"eri_integrals")
    ind_archive.set(.name,"eri_index")
    if (eri_archive.does_not_exist OR does_not_exist_(ind_archive)) then
       eri_archive.open(for="write-only",buffered=TRUE,type="dbl")
       ind_archive.open(for="write-only",buffered=TRUE,type="int")
       .make_eri_integrals(eri_archive,ind_archive)
       ind_archive.close
       eri_archive.close
    end
  end

  make_eri_integrals(eri_archive,eri_index)
  ! Calculate the electron repulsion integrals (ERI's) over all basis functions
  ! Outputs to archive "eri_archive".  Note that index coincidence factors are
  ! included.
    ARCHIVE :: eri_archive,eri_index
    SHELL4 :: shell4 
    MAT4, PTR   :: ERI
    INT :: q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d
    DBL :: factor
    STR :: cutoff
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    cutoff.from_dbl(SHELL4_ERI_CUTOFF)
    skipped = 0
    if (.scfdata.output) then
      stdout.text("Skipping electron repulsion integrals less than " // cutoff.trim // ".")
    end
    do q = 1, .n_shell_quartets
      if (.scfdata.nddo) then
        .get_shell_quartet(q,shell4,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
        if (atom_a==atom_b AND atom_c==atom_d) then
          shell4.destroy_ptr_part
          .get_shell_quartet(q,shell4,a,b,c,d)
        else
          skipped = skipped + 1
          shell4.destroy_ptr_part
          cycle
        end
      else
        .get_shell_quartet(q,shell4,a,b,c,d)
      end
      if (shell4.skip_ERI) then
        skipped = skipped + 1
        shell4.destroy_ptr_part
        cycle
      end
      ERI.create(shell4.a.n_comp,shell4.b.n_comp,shell4.c.n_comp,shell4.d.n_comp)
      shell4.get_eri(ERI)
      factor = ONE
      if (a==b) factor = HALF                    ! Coincidence factors
      if (c==d) factor = HALF * factor
      if (a==c AND b==d) factor = HALF * factor
      ERI = factor * ERI
      eri_archive.file.write(ERI)
      eri_index.file.write(q)
      ERI.destroy
      shell4.destroy_ptr_part
    end
    if (.scfdata.output) then
      stdout.put_text("Skipped " // trim( skipped.to_str ) //  " out of " // &
          trim( .n_shell_quartets.to_str ) // " blocks.",flush=1)
    end
    eri_index.file.write( .n_shell_quartets + 1 )
  end

  get_spin_orbit_integrals
  ! Get the spin orbit integrals on disk. If the integral files are
  ! file is already there, do nothing.
    ARCHIVE :: SOx_archive,SOy_archive,SOz_archive,ind_archive
    SOx_archive.set(.name,"SOx_integrals")
    SOy_archive.set(.name,"SOy_integrals")
    SOz_archive.set(.name,"SOz_integrals")
    ind_archive.set(.name,"SO_indices")
    if (SOx_archive.does_not_exist) then
       SOx_archive.open(for="write-only",buffered=TRUE,type="dbl")
       SOy_archive.open(for="write-only",buffered=TRUE,type="dbl")
       SOz_archive.open(for="write-only",buffered=TRUE,type="dbl")
       ind_archive.open(for="write-only",buffered=TRUE,type="int")
       .make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)
       SOx_archive.close
       SOy_archive.close
       SOz_archive.close
       ind_archive.close
    end
  end

  make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)
  ! Calculate the spin orbit integrals. Outputs the spin same-orbit integrals
  ! to for each component i to "SOi_archive". The shell quartet index for
  ! these integrals are put in "ind_archive". Note that index coincidence
  ! factors are included.
    ARCHIVE :: SOx_archive,SOy_archive,SOz_archive,ind_archive
    SHELL4 :: shell4 
    MAT4, PTR   :: Sx,Sy,Sz,Ox,Oy,Oz
    INT :: q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d,na,nb,nc,nd
    DBL :: factor
    STR :: cutoff
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    cutoff.from_dbl(SHELL4_ERI_CUTOFF)
    skipped = 0
    if (.scfdata.output) then
      stdout.text("Skipping electron repulsion integrals less than " // cutoff.trim // ".")
    end
    do q = 1, .n_shell_quartets
      if (.scfdata.nddo) then
        .get_shell_quartet(q,shell4,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
        if (atom_a==atom_b AND atom_c==atom_d) then
          .get_shell_quartet(q,shell4,a,b,c,d)
        else
          skipped = skipped + 1
          cycle
        end
      else
        .get_shell_quartet(q,shell4,a,b,c,d)
      end
      if (shell4.skip_ERI) then
        skipped = skipped + 1
        shell4.destroy_ptr_part
        cycle
      end
      na = shell4.a.n_comp; nb = shell4.b.n_comp
      nc = shell4.c.n_comp; nd = shell4.d.n_comp
      Sx.create(na,nb,nc,nd); Sy.create(na,nb,nc,nd); Sz.create(na,nb,nc,nd)
      Ox.create(na,nb,nc,nd); Oy.create(na,nb,nc,nd); Oz.create(na,nb,nc,nd)
      shell4.make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
      factor = ONE
      if (a==b) factor = HALF                    ! Coincidence factors
      if (c==d) factor = HALF * factor
      if (a==c AND b==d) factor = HALF * factor
      Sx = factor*Sx; Sy = factor*Sy; Sz = factor*Sz
      Ox = factor*Ox; Oy = factor*Oy; Oz = factor*Oz
      SOx_archive.file.write(Sx); SOx_archive.file.write(Ox)
      SOy_archive.file.write(Sy); SOy_archive.file.write(Oy)
      SOz_archive.file.write(Sz); SOz_archive.file.write(Oz)
      ind_archive.file.write(q)
      Oz.destroy; Oy.destroy; Ox.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      shell4.destroy_ptr_part
    end
    if (.scfdata.output) then
      stdout.put_text("Skipped " // trim( skipped.to_str ) //  " out of " // &
          trim( .n_shell_quartets.to_str ) // " blocks.",flush=1)
    end
    ind_archive.file.write( .n_shell_quartets + 1 )
  end

!  **************************
!  Crystal structure routines
!  **************************

   make_ft(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [size(k_pts,1)]
      MAT, target :: dens
      MAT, IN :: k_pts
      CVEC :: res
      INT :: k_max,k,fa,fb,la,lb,q,a,b,atom_a,atom_b,i,j
      SHELL2 :: shell
      CMAT3, PTR :: ft_ab
      MAT, PTR :: dens_ba,S
      DBL :: cutoff
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      k_max = size(k_pts,1)
      res = ZERO
      cutoff = TOL(10) / .n_shell_pairs
      do q = 1, .n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         if (shell.skip_ft(cutoff)) then
           shell.destroy_ptr_part
           cycle
         end
         ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp)
         .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
         dens_ba => dens(fb:lb,fa:la)
         if (a/=b) ft_ab = TWO * ft_ab ! count off-diagonals twice.
         do k = 1,k_max
            res(k) = res(k) + ft_ab(k,:,:).trace_of_product(dens_ba)
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
   end

   make_ft(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [size(k_pts,1)].
      CMAT, target :: dens
      MAT :: k_pts
      CVEC :: res
      INT :: k_max,q,k,a,b,fa,la,fb,lb,atom_a,atom_b
      SHELL2 :: shell
      CMAT3, PTR :: ft_ab
      CMAT, PTR :: dens_ba
      DBL :: cutoff
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      k_max = size(k_pts,1)
      res = ZERO
      cutoff = TOL(10) / .n_shell_pairs
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         if (shell.skip_ft(cutoff)) then
           shell.destroy_ptr_part
           cycle
         end
         ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp)
         .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
         dens_ba => dens(fb:lb,fa:la)
         if (a/=b) ft_ab = TWO * ft_ab ! count off-diagonals twice.
         do k = 1,k_max
            res(k) = res(k) + ft_ab(k,:,:).trace_of_product(dens_ba)
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
   end

  make_ft_deriv_U(res,dens,k_pts)
  ! Fourier transform of a density described by AO density matrix dens
  ! evaluated at a series of reciprocal space points k_pts
  ! Size of res is [k_max,n_atom*6]
    MAT, target :: dens
    MAT, IN :: k_pts
    CMAT, target :: res
    CDBL :: ft_ab2,tmp1,tmp2
    INT :: k_max,k,fa,fb,la,lb,q,a,b,atom_a,atom_b,n,basea,baseb
    DBL :: delta,g,separation,x,y,z
    SHELL2 :: shell
    CMAT3, PTR :: ft_ab
    MAT, PTR :: dens_ba
    DBL :: cutoff
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    k_max = size(k_pts,1)
    res = ZERO
    cutoff = TOL(10) / .n_shell_pairs
    do q = 1, .n_shell_pairs
      .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
      if (shell.skip_ft(cutoff)) then
        shell.destroy_ptr_part
        cycle
      end
      ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp)
      .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
      dens_ba => dens(fb:lb,fa:la)
      if (a/=b) ft_ab = TWO * ft_ab ! count off-diagonals twice.

      separation = (.atom(atom_a).pos-.atom(atom_b).pos).norm
      g=HALF
      if (separation > 2.5d0) g=QUARTER
      g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

      basea = (atom_a-1) * 6
      if (atom_a == atom_b) then
        delta = TWO * g
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba) * delta
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          tmp1 = ft_ab2 * x
          tmp2 = ft_ab2 * y
          res(k,basea+1) = res(k,basea+1) + tmp1 * x
          res(k,basea+2) = res(k,basea+2) + tmp1 * y
          res(k,basea+3) = res(k,basea+3) + tmp1 * z
          res(k,basea+4) = res(k,basea+4) + tmp2 * y
          res(k,basea+5) = res(k,basea+5) + tmp2 * z
          res(k,basea+6) = res(k,basea+6) + ft_ab2 * z * z
        end
      else
        baseb = (atom_b-1) * 6
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba) * g
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          tmp1 = ft_ab2 * x
          tmp2 = ft_ab2 * y
          res(k,basea+1) = res(k,basea+1) + tmp1 * x
          res(k,basea+2) = res(k,basea+2) + tmp1 * y
          res(k,basea+3) = res(k,basea+3) + tmp1 * z
          res(k,basea+4) = res(k,basea+4) + tmp2 * y
          res(k,basea+5) = res(k,basea+5) + tmp2 * z
          res(k,basea+6) = res(k,basea+6) + ft_ab2 * z * z
          res(k,baseb+1) = res(k,baseb+1) + tmp1 * x
          res(k,baseb+2) = res(k,baseb+2) + tmp1 * y
          res(k,baseb+3) = res(k,baseb+3) + tmp1 * z
          res(k,baseb+4) = res(k,baseb+4) + tmp2 * y
          res(k,baseb+5) = res(k,baseb+5) + tmp2 * z
          res(k,baseb+6) = res(k,baseb+6) + ft_ab2 * z * z
        end
      end
      ft_ab.destroy
      shell.destroy_ptr_part
    end
  end

  make_ft_deriv_U(res,dens,k_pts)
  ! Fourier transform of a density described by AO density matrix dens
  ! evaluated at a series of reciprocal space points k_pts
  ! Size of res is [k_max,n_atom*6]
    CMAT, target :: dens
    MAT, IN :: k_pts
    CMAT, target :: res
    CDBL :: ft_ab2,tmp1,tmp2
    INT :: k_max,k,fa,fb,la,lb,q,a,b,atom_a,atom_b,n,basea,baseb
    DBL :: delta,g,separation,x,y,z
    SHELL2 :: shell
    CMAT3, PTR :: ft_ab
    CMAT, PTR :: dens_ba
    DBL :: cutoff
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    k_max = size(k_pts,1)
    res = ZERO
    cutoff = TOL(10) / .n_shell_pairs
    do q = 1, .n_shell_pairs
      .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
      if (shell.skip_ft(cutoff)) then
        shell.destroy_ptr_part
        cycle
      end
      ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp)
      .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
      dens_ba => dens(fb:lb,fa:la)
      if (a/=b) ft_ab = TWO * ft_ab ! count off-diagonals twice.

      separation = (.atom(atom_a).pos-.atom(atom_b).pos).norm
      g=HALF
      if (separation > 2.5d0) g=QUARTER
      g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

      basea = (atom_a-1) * 6
      if (atom_a == atom_b) then
        delta = TWO * g
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba) * delta
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          tmp1 = ft_ab2 * x
          tmp2 = ft_ab2 * y
          res(k,basea+1) = res(k,basea+1) + tmp1 * x
          res(k,basea+2) = res(k,basea+2) + tmp1 * y
          res(k,basea+3) = res(k,basea+3) + tmp1 * z
          res(k,basea+4) = res(k,basea+4) + tmp2 * y
          res(k,basea+5) = res(k,basea+5) + tmp2 * z
          res(k,basea+6) = res(k,basea+6) + ft_ab2 * z * z
        end
      else
        baseb = (atom_b-1) * 6
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba) * g
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          tmp1 = ft_ab2 * x
          tmp2 = ft_ab2 * y
          res(k,basea+1) = res(k,basea+1) + tmp1 * x
          res(k,basea+2) = res(k,basea+2) + tmp1 * y
          res(k,basea+3) = res(k,basea+3) + tmp1 * z
          res(k,basea+4) = res(k,basea+4) + tmp2 * y
          res(k,basea+5) = res(k,basea+5) + tmp2 * z
          res(k,basea+6) = res(k,basea+6) + ft_ab2 * z * z
          res(k,baseb+1) = res(k,baseb+1) + tmp1 * x
          res(k,baseb+2) = res(k,baseb+2) + tmp1 * y
          res(k,baseb+3) = res(k,baseb+3) + tmp1 * z
          res(k,baseb+4) = res(k,baseb+4) + tmp2 * y
          res(k,baseb+5) = res(k,baseb+5) + tmp2 * z
          res(k,baseb+6) = res(k,baseb+6) + ft_ab2 * z * z
        end
      end
      ft_ab.destroy
      shell.destroy_ptr_part
    end
  end

  make_ft_2nd_deriv_U(d2,d1,f,dens,k_pts)
  ! Second and first derivatives (d2,d1) plus the Fourier transform (f) of a
  ! density described by AO density matrix dens evaluated at a series of
  ! reciprocal space points k_pts.
  ! Size of res is [k_max,n_atom*6]
    MAT, target :: dens
    CMAT :: d2,d1
    CVEC :: f
    MAT, IN :: k_pts
    CDBL :: ft_ab2,x,y,z
    CDBL :: dt_dU_xx,dt_dU_xy,dt_dU_xz,dt_dU_yy,dt_dU_yz,dt_dU_zz
    CDBL :: d1xx,d1xy,d1xz,d1yy,d1yz,d1zz
    CDBL :: d2xx,d2xy,d2xz,d2yy,d2yz,d2zz
    INT :: k_max,k,fa,fb,la,lb,q,a,b,atom_a,atom_b,n,basea,baseb
    DBL :: half_g,half_g_delta,g,separation
    SHELL2 :: shell
    CMAT3, PTR :: ft_ab
    MAT, PTR :: dens_ba
    DBL :: cutoff
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    k_max = size(k_pts,1)
    f  = (ZERO,ZERO)
    d1 = (ZERO,ZERO)
    d2 = (ZERO,ZERO)
    cutoff = TOL(10) / .n_shell_pairs
    do q = 1, .n_shell_pairs
      .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
      if (shell.skip_ft(cutoff)) then
        shell.destroy_ptr_part
        cycle
      end
      ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp)
      .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
      dens_ba => dens(fb:lb,fa:la)
      if (a/=b) ft_ab = TWO * ft_ab ! count off-diagonals twice.

      separation = (.atom(atom_a).pos-.atom(atom_b).pos).norm
      g=HALF
      if (separation > 2.5d0) g=QUARTER
      half_g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

      basea = (atom_a-1) * 6
      if (atom_a == atom_b) then
        half_g_delta = half_g * TWO   ! delta = 2
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba)
          f(k) = f(k) + ft_ab2
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          dt_dU_xx = half_g_delta * x * x
          dt_dU_xy = half_g_delta * x * y
          dt_dU_xz = half_g_delta * x * z
          dt_dU_yy = half_g_delta * y * y
          dt_dU_yz = half_g_delta * y * z
          dt_dU_zz = half_g_delta * z * z
          d1xx = dt_dU_xx * ft_ab2
          d1xy = dt_dU_xy * ft_ab2
          d1xz = dt_dU_xz * ft_ab2
          d1yy = dt_dU_yy * ft_ab2
          d1yz = dt_dU_yz * ft_ab2
          d1zz = dt_dU_zz * ft_ab2
          d1(k,basea+1) = d1(k,basea+1) + d1xx
          d1(k,basea+2) = d1(k,basea+2) + d1xy
          d1(k,basea+3) = d1(k,basea+3) + d1xz
          d1(k,basea+4) = d1(k,basea+4) + d1yy
          d1(k,basea+5) = d1(k,basea+5) + d1yz
          d1(k,basea+6) = d1(k,basea+6) + d1zz
          d2(k,basea+1) = d2(k,basea+1) + d1xx * dt_dU_xx
          d2(k,basea+2) = d2(k,basea+2) + d1xy * dt_dU_xx
          d2(k,basea+3) = d2(k,basea+3) + d1xz * dt_dU_xx
          d2(k,basea+4) = d2(k,basea+4) + d1yy * dt_dU_xx
          d2(k,basea+5) = d2(k,basea+5) + d1yz * dt_dU_xx
          d2(k,basea+6) = d2(k,basea+6) + d1zz * dt_dU_xx
        end
      else
        baseb = (atom_b-1) * 6
        half_g_delta = half_g      ! delta = 1
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba)
          f(k) = f(k) + ft_ab2
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          dt_dU_xx = half_g_delta * x * x
          dt_dU_xy = half_g_delta * x * y
          dt_dU_xz = half_g_delta * x * z
          dt_dU_yy = half_g_delta * y * y
          dt_dU_yz = half_g_delta * y * z
          dt_dU_zz = half_g_delta * z * z
          d1xx = dt_dU_xx * ft_ab2
          d1xy = dt_dU_xy * ft_ab2
          d1xz = dt_dU_xz * ft_ab2
          d1yy = dt_dU_yy * ft_ab2
          d1yz = dt_dU_yz * ft_ab2
          d1zz = dt_dU_zz * ft_ab2
          d2xx = d1xx * dt_dU_xx
          d2xy = d1xy * dt_dU_xy
          d2xz = d1xz * dt_dU_xz
          d2yy = d1yy * dt_dU_yy
          d2yz = d1yz * dt_dU_yz
          d2zz = d1zz * dt_dU_zz
          d1(k,basea+1) = d1(k,basea+1) + d1xx
          d1(k,basea+2) = d1(k,basea+2) + d1xy
          d1(k,basea+3) = d1(k,basea+3) + d1xz
          d1(k,basea+4) = d1(k,basea+4) + d1yy
          d1(k,basea+5) = d1(k,basea+5) + d1yz
          d1(k,basea+6) = d1(k,basea+6) + d1zz
          d2(k,basea+1) = d2(k,basea+1) + d2xx
          d2(k,basea+2) = d2(k,basea+2) + d2xy
          d2(k,basea+3) = d2(k,basea+3) + d2xz
          d2(k,basea+4) = d2(k,basea+4) + d2yy
          d2(k,basea+5) = d2(k,basea+5) + d2yz
          d2(k,basea+6) = d2(k,basea+6) + d2zz
          d1(k,baseb+1) = d1(k,baseb+1) + d1xx
          d1(k,baseb+2) = d1(k,baseb+2) + d1xy
          d1(k,baseb+3) = d1(k,baseb+3) + d1xz
          d1(k,baseb+4) = d1(k,baseb+4) + d1yy
          d1(k,baseb+5) = d1(k,baseb+5) + d1yz
          d1(k,baseb+6) = d1(k,baseb+6) + d1zz
          d2(k,baseb+1) = d2(k,baseb+1) + d2xx
          d2(k,baseb+2) = d2(k,baseb+2) + d2xy
          d2(k,baseb+3) = d2(k,baseb+3) + d2xz
          d2(k,baseb+4) = d2(k,baseb+4) + d2yy
          d2(k,baseb+5) = d2(k,baseb+5) + d2yz
          d2(k,baseb+6) = d2(k,baseb+6) + d2zz
        end
      end
      ft_ab.destroy
      shell.destroy_ptr_part
    end
  end

  make_ft_2nd_deriv_U(d2,d1,f,dens,k_pts)
  ! Second and first derivatives (d2,d1) plus the Fourier transform (f) of a
  ! density described by AO density matrix dens evaluated at a series of
  ! reciprocal space points k_pts.
  ! Size of res is [k_max,n_atom*6]
    CMAT, target :: dens
    CMAT :: d2,d1
    CVEC :: f
    MAT, IN :: k_pts
    CDBL :: ft_ab2,x,y,z
    CDBL :: dt_dU_xx,dt_dU_xy,dt_dU_xz,dt_dU_yy,dt_dU_yz,dt_dU_zz
    CDBL :: d1xx,d1xy,d1xz,d1yy,d1yz,d1zz
    CDBL :: d2xx,d2xy,d2xz,d2yy,d2yz,d2zz
    INT :: k_max,k,fa,fb,la,lb,q,a,b,atom_a,atom_b,n,basea,baseb
    DBL :: half_g,half_g_delta,g,separation
    SHELL2 :: shell
    CMAT3, PTR :: ft_ab
    CMAT, PTR :: dens_ba
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    k_max = size(k_pts,1)
    f  = ZERO
    d1 = ZERO
    d2 = ZERO
    do q = 1, .n_shell_pairs
      .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
      ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp)
      .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
      dens_ba => dens(fb:lb,fa:la)
      if (a/=b) ft_ab = TWO * ft_ab ! count off-diagonals twice.

      separation = (.atom(atom_a).pos-.atom(atom_b).pos).norm
      g=HALF
      if (separation > 2.5d0) g=QUARTER
      half_g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

      basea = (atom_a-1) * 6
      if (atom_a == atom_b) then
        half_g_delta = half_g * TWO   ! delta = 2
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba)
          f(k) = f(k) + ft_ab2
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          dt_dU_xx = half_g_delta * x * x
          dt_dU_xy = half_g_delta * x * y
          dt_dU_xz = half_g_delta * x * z
          dt_dU_yy = half_g_delta * y * y
          dt_dU_yz = half_g_delta * y * z
          dt_dU_zz = half_g_delta * z * z
          d1xx = dt_dU_xx * ft_ab2
          d1xy = dt_dU_xy * ft_ab2
          d1xz = dt_dU_xz * ft_ab2
          d1yy = dt_dU_yy * ft_ab2
          d1yz = dt_dU_yz * ft_ab2
          d1zz = dt_dU_zz * ft_ab2
          d1(k,basea+1) = d1(k,basea+1) + d1xx
          d1(k,basea+2) = d1(k,basea+2) + d1xy
          d1(k,basea+3) = d1(k,basea+3) + d1xz
          d1(k,basea+4) = d1(k,basea+4) + d1yy
          d1(k,basea+5) = d1(k,basea+5) + d1yz
          d1(k,basea+6) = d1(k,basea+6) + d1zz
          d2(k,basea+1) = d2(k,basea+1) + d1xx * dt_dU_xx
          d2(k,basea+2) = d2(k,basea+2) + d1xy * dt_dU_xx
          d2(k,basea+3) = d2(k,basea+3) + d1xz * dt_dU_xx
          d2(k,basea+4) = d2(k,basea+4) + d1yy * dt_dU_xx
          d2(k,basea+5) = d2(k,basea+5) + d1yz * dt_dU_xx
          d2(k,basea+6) = d2(k,basea+6) + d1zz * dt_dU_xx
        end
      else
        baseb = (atom_b-1) * 6
        half_g_delta = half_g      ! delta = 1
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba)
          f(k) = f(k) + ft_ab2
          x = k_pts(k,1)           ! SBh_x
          y = k_pts(k,2)           ! SBh_y
          z = k_pts(k,3)           ! SBh_z
          dt_dU_xx = half_g_delta * x * x
          dt_dU_xy = half_g_delta * x * y
          dt_dU_xz = half_g_delta * x * z
          dt_dU_yy = half_g_delta * y * y
          dt_dU_yz = half_g_delta * y * z
          dt_dU_zz = half_g_delta * z * z
          d1xx = dt_dU_xx * ft_ab2
          d1xy = dt_dU_xy * ft_ab2
          d1xz = dt_dU_xz * ft_ab2
          d1yy = dt_dU_yy * ft_ab2
          d1yz = dt_dU_yz * ft_ab2
          d1zz = dt_dU_zz * ft_ab2
          d2xx = d1xx * dt_dU_xx
          d2xy = d1xy * dt_dU_xy
          d2xz = d1xz * dt_dU_xz
          d2yy = d1yy * dt_dU_yy
          d2yz = d1yz * dt_dU_yz
          d2zz = d1zz * dt_dU_zz
          d1(k,basea+1) = d1(k,basea+1) + d1xx
          d1(k,basea+2) = d1(k,basea+2) + d1xy
          d1(k,basea+3) = d1(k,basea+3) + d1xz
          d1(k,basea+4) = d1(k,basea+4) + d1yy
          d1(k,basea+5) = d1(k,basea+5) + d1yz
          d1(k,basea+6) = d1(k,basea+6) + d1zz
          d2(k,basea+1) = d2(k,basea+1) + d2xx
          d2(k,basea+2) = d2(k,basea+2) + d2xy
          d2(k,basea+3) = d2(k,basea+3) + d2xz
          d2(k,basea+4) = d2(k,basea+4) + d2yy
          d2(k,basea+5) = d2(k,basea+5) + d2yz
          d2(k,basea+6) = d2(k,basea+6) + d2zz
          d1(k,baseb+1) = d1(k,baseb+1) + d1xx
          d1(k,baseb+2) = d1(k,baseb+2) + d1xy
          d1(k,baseb+3) = d1(k,baseb+3) + d1xz
          d1(k,baseb+4) = d1(k,baseb+4) + d1yy
          d1(k,baseb+5) = d1(k,baseb+5) + d1yz
          d1(k,baseb+6) = d1(k,baseb+6) + d1zz
          d2(k,baseb+1) = d2(k,baseb+1) + d2xx
          d2(k,baseb+2) = d2(k,baseb+2) + d2xy
          d2(k,baseb+3) = d2(k,baseb+3) + d2xz
          d2(k,baseb+4) = d2(k,baseb+4) + d2yy
          d2(k,baseb+5) = d2(k,baseb+5) + d2yz
          d2(k,baseb+6) = d2(k,baseb+6) + d2zz
        end
      end
      ft_ab.destroy
      shell.destroy_ptr_part
    end
  end

  make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
  ! Make_ft for one pair of gaussians.
  ! Includes partitioning, dispersion and thermal smearing.
    CMAT3 :: ft_ab
    MAT, IN :: k_pts
    SHELL2, IN :: shell
    INT, IN :: atom_a,atom_b
    MAT3, PTR :: thermal
    MAT, PTR :: partition
    DBL :: factor_a,factor_b
    INT :: k_max
    k_max = size(k_pts,1)
    thermal.create(k_max,shell.a.n_cc,shell.b.n_cc)
    .thermal_smearing_correction(thermal,k_pts,atom_a,atom_b,shell)
    select case (.crystal.partition_model.trim)
      case ("","none")
        shell.make_ft(ft_ab,k_pts,thermal)
      case ("mulliken")
        if (.crystal.repetition_factor(atom_a)<1) then
          factor_a = ZERO
        else
          factor_a = ONE / .crystal.repetition_factor(atom_a)
        end
        if (.crystal.repetition_factor(atom_b)<1) then
          factor_b = ZERO
        else
          factor_b = ONE / .crystal.repetition_factor(atom_b)
        end
        partition.create(shell.a.n_cc,shell.b.n_cc)
        partition = HALF * ( factor_a + factor_b )
        shell.make_ft(ft_ab,k_pts,thermal,partition)
        partition.destroy
      case ("gaussian")
        if (.crystal.repetition_factor(atom_a)<1) then
          factor_a = ZERO
        else
          factor_a = ONE / .crystal.repetition_factor(atom_a)
        end
        if (.crystal.repetition_factor(atom_b)<1) then
          factor_b = ZERO
        else
          factor_b = ONE / .crystal.repetition_factor(atom_b)
        end
        partition.create(shell.a.n_cc,shell.b.n_cc)
        shell.make_gaussian_partition(partition,factor_a,factor_b)
        shell.make_ft(ft_ab,k_pts,thermal,partition)
        partition.destroy
      case default
        DIE("Unknown partition method : " // .crystal.partition_model.trim)
    end
    thermal.destroy
  end

  thermal_smearing_correction(res,k_pts,a,b,shell)
  ! Makes the thermal smearing correction term.  Note that res
  ! is done over the contraction coefficients.
  ! Dimensions of "res" are [k_max,.a.n_cc,.b.n_cc].
    MAT3, OUT :: res
    MAT, IN :: k_pts
    INT, IN :: a,b
    SHELL2, IN :: shell
    MAT(3,3) :: Ua,Ub,Uab
    VEC(3) :: S,US
    INT :: k_max,k
    DBL :: separation,bondlength,Ta,Tb,fac,g

    k_max = size(k_pts,1)
    select case (.crystal.thermal_smearing_model.trim)
      case ("","none")
        res = ONE
      case ("coppens") ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
        Ua = -HALF * .atom(a).thermal_tensor
        Ub = -HALF * .atom(b).thermal_tensor
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Ua,S)
           Ta = dot_product(S,US)
           US = matmul(Ub,S)
           Tb = dot_product(S,US)
           fac = HALF*(exp(Ta)+exp(Tb))
           res(k,:,:) = fac
        end
      case ("stewart") ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4
        bondlength=2.5
        Ua = .atom(a).thermal_tensor
        Ub = .atom(b).thermal_tensor
        Uab = Ua + Ub
        separation = (.atom(a).pos-.atom(b).pos).norm
        g=HALF
        if (separation > bondlength) g=QUARTER
        Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Uab,S)
           Ta = dot_product(S,US)
           res(k,:,:) = exp(Ta)
        end
      case ("tanaka") ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
        Ua = .atom(a).thermal_tensor
        Ub = .atom(b).thermal_tensor
        shell.make_tanaka_thermal_smearing(res,k_pts,Ua,Ub)
      case default
        DIE("unknown thermal smearing model.")
    end
  end

  ft_thermally_smear(ft_ab,k_pts,a,b)
  ! Thermally smear the fourier transform integrals "ft_ab" evaluated 
  ! on "k_pts" for shell pair (ab) centered on atoms "a" and "b" .
    INT :: a,b
    MAT :: k_pts 
    CMAT3 :: ft_ab
    MAT(3,3) :: Ua,Ub,Uab
    VEC(3) :: S,US
    DBL :: separation,bondlength,Ta,Tb,fac,g
    INT :: k,k_max
    k_max = size(k_pts,1)
    select case (.crystal.thermal_smearing_model.trim)
      case ("")
      case ("coppens") ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
        Ua = -HALF * .atom(a).thermal_tensor
        Ub = -HALF * .atom(b).thermal_tensor
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Ua,S)
           Ta = dot_product(S,US)
           US = matmul(Ub,S)
           Tb = dot_product(S,US)
           fac = HALF*(exp(Ta)+exp(Tb))
           ft_ab(k,:,:) = fac*ft_ab(k,:,:)
        end
      case ("stewart") ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4
        bondlength=2.5
        Ua = .atom(a).thermal_tensor
        Ub = .atom(b).thermal_tensor
        Uab = Ua + Ub
        separation = (.atom(a).pos-.atom(b).pos).norm
        g=HALF
        if (separation > bondlength) g=QUARTER
        Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Uab,S)
           Ta = dot_product(S,US)
           ft_ab(k,:,:) = exp(Ta)*ft_ab(k,:,:)
        end
      case ("tanaka") ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
        DIE("cannot thermally smear at contracted level.")
      case default
        DIE("unknown thermal smearing model.")
    end
  end

  add_dispersion_correction(ft,k_pts)
  ! Adds the dispersion correction.
    MAT :: k_pts
    CVEC :: ft
    CDBL :: disp,phase
    VEC(3) :: pos
    MAT(3,3) :: U
    VEC(3) :: S,US
    DBL :: x,y,z,T
    INT :: n,k,k_max

    if (.crystal.correct_dispersion) then
      select case (.crystal.thermal_smearing_model.trim)
        case ("")
          do n=1,.n_atom
            pos = .atom(n).pos
            x = pos(1); y = pos(2); z = pos(3)
            disp = .atom(n).dispersion_correction(.crystal.wavelength)
            ft(:) = ft(:) + disp * exp(cmplx(ZERO,(k_pts(:,1)*x + k_pts(:,2)*y + k_pts(:,3)*z)))
          end
        case default ! thermal smearing methods collapse to be the same
                     ! when dealing with one atom.
          k_max = size(k_pts,1)
          do n=1,.n_atom
            U = -HALF * self.atom(n).thermal_tensor
            pos = .atom(n).pos
            x = pos(1); y = pos(2); z = pos(3)
            disp = .atom(n).dispersion_correction(.crystal.wavelength)
            do k = 1,k_max
              S = k_pts(k,:)
              US = matmul(U,S)
              T = (dot_product(S,US))
              phase = exp(cmplx(T,(k_pts(k,1)*x + k_pts(k,2)*y + k_pts(k,3)*z)))
              ft(k) = ft(k) + disp * phase
            end
          end
      end
    end
  end

  get_ft_ints
  ! Get the fourier transform of the overlap integrals.
  ! If the archive file exists, read it; otherwise make it.
     ARCHIVE :: archive
     archive.set(.name,"ft_ints")
     if (archive.doesnt_exist) .make_ft_ints
  end

   make_ft_ints
   ! Make the fourier transform of the overlap integrals on an archive file
      ARCHIVE :: archive
      MAT, PTR :: k_pts
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
      SHELL2, PTR :: shell
      CMAT3, PTR :: ft_ab_eq,ft_ab

      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"ft_ints")
      archive.open(for="write-only",buffered=TRUE,type="cdbl")
      k_pts.create(.crystal.unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell.a.n_comp,shell.b.n_comp)
         ft_ab.create( .crystal.n_refl,shell.a.n_comp,shell.b.n_comp)
         .make_ft_pair(ft_ab_eq,k_pts,shell,atom_a,atom_b)
         .crystal.sum_ft_ints(ft_ab,ft_ab_eq)
         archive.file.write(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

  convert_cadpac_ft_ints
      ARCHIVE :: archive
      INT :: q,a,b,fa,la,fb,lb
      INT :: n,i,j,bs,bf,n_pass,n_batch
      SHELL2, PTR :: shell
      MAT3, PTR :: ft_ab
      CMAT3, PTR :: ft_ab_c

      ft_ab.create( .crystal.n_refl, .n_bf, .n_bf)
      n_pass = 1
      n_batch = 5

      open(98,form='formatted',status='unknown',file='FTINTS.txt')
      do b = 1,n_pass
         bs = (b-1)*n_batch+1
         bf = bs+n_batch-1
         bf = min( .crystal.n_refl,bf)
         do n = bs,bf
            do i = 1, .n_bf
            do j = 1,i
               read(98,'(D16.8)') ft_ab(n,i,j)
            end
            end
         end
      end
      close(98)

      archive.set(.name,"ft_ints.cadpac")
      archive.open(for="write-only",type="dbl")
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_ab_c.create(.crystal.n_refl,la-fa+1,lb-fb+1)
         ft_ab_c = ft_ab(:,fa:la,fb:lb)
         archive.file.write(ft_ab_c)
         ft_ab_c.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close

      ft_ab.destroy
  end

  convert_to_cadpac_ft_ints
      ARCHIVE :: archive
      INT :: q,a,b,fa,la,fb,lb
      INT :: n,i,j,bs,bf,n_pass,n_batch,l_tri,ij,ijij,k_max
      SHELL2, PTR :: shell
      MAT3, PTR :: ft_ab
      CMAT3, PTR :: ft_ab_c
      VEC, PTR :: ft_ints

      n_pass = 1
      n_batch = 58
      l_tri = .n_bf * ( .n_bf + 1) /2

      ft_ab.create( .crystal.n_refl, .n_bf, .n_bf)

      archive.set(.name,"ft_ints")
      archive.open(for="read-only",type="dbl")
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_ab_c.create(.crystal.n_refl,la-fa+1,lb-fb+1)
         archive.file.read(ft_ab_c)
         ft_ab(:,fa:la,fb:lb) = ft_ab_c
         ft_ab_c.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close

      ft_ints.create(n_batch*l_tri)
      open(99,form='unformatted',status='unknown',file='FTINTS')
      do b = 1,n_pass
        bs = (b-1)*n_batch+1
        bf = bs+n_batch-1
        bf = min( .crystal.n_refl, bf)
        k_max = (bf-bs+1)

        ijij = 0
        do n = bs,bf
           ij = 0
           do i = 1, .n_bf
           do j = 1,i
              ij = ij + 1
              ijij = ijij + 1
              ft_ints(ijij) = ft_ab(n,i,j)
           enddo
           enddo
        enddo

        write(99) (ft_ints(i),i=1,l_tri*k_max)
      enddo
      close(99)
      ft_ints.destroy

      open(98,form='formatted',status='unknown',file='FTINTS.txt_tonto')
      do b = 1,n_pass
         bs = (b-1)*n_batch+1
         bf = bs+n_batch-1
         bf = min( .crystal.n_refl,bf)
         do n = bs,bf
            do i = 1, .n_bf
            do j = 1,i
               write(98,'(D16.8)') ft_ab(n,i,j)
            end
            end
         end
      end
      close(98)

      ft_ab.destroy
  end

  fit_thermal_parameters(output) [leaky]
  ! Fit the thermal parameters to the calculated structure factors.
  ! Uses a line search method.
    target :: self
    BIN, optional :: output
    VEC, PTR :: d2U,dU,U,direction,old_U,lambda
    MAT, PTR :: therm
    DBL :: chi2,old_chi2,max_dU,old_norm,norm,err,start_lambda,tmp1,tmp2
    INT :: i,j,dim,total,n,base
    ENSURE( .crystal.created, "no crystal")
    ENSURE( .atom.created, "no atoms to fit")

    dim = .n_atom * 6
    U.create(dim)
    d2U.create(dim)
    dU.create(dim)
    old_U.create(dim)
    direction.create(dim)
    lambda.create(dim)
    .make_ao_density_matrix

    .make_dchi2_2_d2U(d2U,dU);              max_dU = dU.largest_value
    chi2 = .crystal.chi2

    if (present(output)) then
    if (output) then
    stdout.text("Fitting thermal parameters.")
    stdout.show("Old chi2         = ",chi2)
    stdout.show("Largest gradient = ",max_dU)
    stdout.flush
    end
    end

    total = 0
    old_chi2 = chi2
    old_norm = dU.norm / sqrt(ONE*dim)
    start_lambda = ONE

    do i=1,100 ! loop until converged to minimum.
      do n=1, .n_atom                 ! get thermal parameters into array
        base = (n-1) * 6
        therm => .atom(n).thermal_tensor
        old_U(base+1) = therm(1,1)
        old_U(base+2) = therm(1,2)
        old_U(base+3) = therm(1,3)
        old_U(base+4) = therm(2,2)
        old_U(base+5) = therm(2,3)
        old_U(base+6) = therm(3,3)
      end

      direction = - chi2 / (dU + HALF * d2U)
      direction = sign(min(abs(direction),TOL(2)),direction) ! limit size of dU.

      do n=1, .n_atom               ! replace thermal parameters with new ones
        base = (n-1) * 6
        therm => .atom(n).thermal_tensor
        therm(1,1) = old_U(base+1) + direction(base+1)
        therm(1,2) = old_U(base+2) + direction(base+2)
        therm(1,3) = old_U(base+3) + direction(base+3)
        therm(2,1) = therm(1,2)
        therm(2,2) = old_U(base+4) + direction(base+4)
        therm(2,3) = old_U(base+5) + direction(base+5)
        therm(3,1) = therm(1,3)
        therm(3,2) = therm(2,3)
        therm(3,3) = old_U(base+6) + direction(base+6)
      end
      .make_dchi2_2_d2U(d2U,dU);              max_dU = dU.largest_value
      chi2 = .crystal.chi2

      norm = dU.norm / sqrt(ONE*dim)

      old_chi2 = chi2
!write(*,'(i5,2f15.8)') i,norm,chi2
      if (norm < old_norm) exit
      old_norm = norm

      if (old_norm < TOL(1)) exit     ! if near the minimum

      start_lambda = TWO * maxval(lambda)
      lambda = start_lambda
    end

    if (present(output)) then
    if (output) then
    do n=1, .n_atom                 ! get thermal parameters into array
      base = (n-1) * 6
      therm => .atom(n).thermal_tensor
      U(base+1) = therm(1,1)
      U(base+2) = therm(1,2)
      U(base+3) = therm(1,3)
      U(base+4) = therm(2,2)
      U(base+5) = therm(2,3)
      U(base+6) = therm(3,3)
    end
    dU = U - old_U
    err = dU.largest_value
    err = log(err)/log(TEN)
    err = floor(err)
    err = TEN**(err+1)
    stdout.show("Iterations       = ",total)
    stdout.show("New chi2         = ",chi2)
    stdout.show("Largest gradient = ",max_dU)
    stdout.show("Average gradient = ",old_norm)
    stdout.show("Convergence      = ",err)
    end
    end

    lambda.destroy
    direction.destroy
    old_U.destroy
    dU.destroy
    d2U.destroy
    U.destroy
  end

  make_dchi2_2_d2U(d2,d1)
  ! Evaluate the diagonal of the second gradient of the chi2 with respect to the
  ! thermal parameters.
  ! Size of res is [n_atom * 6]
    CMAT, PTR :: sf_deriv,sf_deriv_eq,sf_2nd_deriv,sf_2nd_deriv_eq
    CVEC, PTR :: sf_eq
    MAT, PTR :: k_pts
    VEC, PTR :: ext,Fm
    BIN :: complex
    VEC :: d1,d2
    CDBL :: tmp1,tmp2
    DBL :: g,s,gs,Fc,Fexp
    INT :: k,j,n_refl,n_unique

    n_refl = .crystal.n_refl
    n_unique = .crystal.unique_k_pts
    complex = .density_matrix.spinorbital_kind.includes("complex")
    .crystal.F_calc.destroy
    .crystal.F_calc.create(n_refl)
    k_pts.create(n_unique,3)
    .crystal.make_unique_k_pts(k_pts)

    sf_deriv.create(n_refl, .n_atom * 6)     ! d_Fc/d_U
    sf_2nd_deriv.create(n_refl, .n_atom * 6) ! d2_Fc/d_U2

    sf_2nd_deriv_eq.create(n_unique, .n_atom * 6)
    sf_deriv_eq.create(n_unique, .n_atom * 6)
    sf_eq.create(n_unique)
    if (complex) then
      .make_ft_2nd_deriv_U(sf_2nd_deriv_eq,sf_deriv_eq,sf_eq,.density_matrix.restricted_complex,k_pts)
    else 
      .make_ft_2nd_deriv_U(sf_2nd_deriv_eq,sf_deriv_eq,sf_eq,.density_matrix.restricted,k_pts) 
    end
    .crystal.sum_unique_sf_deriv_U(sf_2nd_deriv,sf_2nd_deriv_eq)
    .crystal.sum_unique_sf_deriv_U(sf_deriv,sf_deriv_eq)
    .crystal.sum_unique_sf(.crystal.F_calc,sf_eq)
    sf_eq.destroy
    sf_deriv_eq.destroy
    sf_2nd_deriv_eq.destroy

    ext.create( .crystal.n_refl )
    ext = .crystal.extinction_correction

    ! Sum over the structure factors
    Fm.create(n_refl)
    Fm = abs(.crystal.F_calc)
    d1(:) = ZERO
    d2(:) = ZERO
    do k = 1, n_refl
      g = ext(k)
      s = .crystal.sigma(k)
      Fc = Fm(k)
      Fexp = .crystal.F_exp(k)
      gs = g*g / (s*s)
      tmp1 = g * (Fexp - g * Fc) / (s*s)
      do j=1, .n_atom*6
        tmp2 = gs * sf_deriv(k,j)
        d2(j) = d2(j) - gs * real(sf_deriv(k,j)*conjg(sf_deriv(k,j))) + &
                       tmp1 * real(sf_2nd_deriv(k,j))
        d1(j) = d1(j) + real(sf_deriv(k,j)) * tmp1
      end
    end
    Fm.destroy

    ext.destroy
    sf_2nd_deriv.destroy
    sf_deriv.destroy
    Fm.destroy
    k_pts.destroy

    d2 = d2 * (-TWO / max(n_refl-1,1))
    d1 = d1 * (-TWO / max(n_refl-1,1))
  end

  make_d_chi2_d_U(res)
  ! Evaluate the gradient of the chi2 with respect to the thermal parameters.
  ! Size of res is [n_atom * 6]
    CMAT, PTR :: sf_deriv,sf_deriv_eq
    MAT, PTR :: k_pts
    VEC, PTR :: F_c,ext
    BIN :: complex
    VEC :: res
    DBL :: temp
    INT :: k

    k_pts.create(.crystal.unique_k_pts,3)
    .crystal.make_unique_k_pts(k_pts)

    sf_deriv.create( .crystal.n_refl, .n_atom * 6) ! d_Fc/d_U
    sf_deriv_eq.create(size(k_pts,1), .n_atom * 6)

    complex = .density_matrix.spinorbital_kind.includes("complex")
    if (complex) then
      .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted_complex,k_pts) 
    else 
      .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted,k_pts) 
    end
    .crystal.sum_unique_sf_deriv_U(sf_deriv,sf_deriv_eq)
    sf_deriv_eq.destroy

    F_c.create( .crystal.n_refl )
    ext.create( .crystal.n_refl )
    F_c = abs(.crystal.F_calc)
    ext = .crystal.extinction_correction

    ! Sum over the structure factors
    res = ZERO
    do k = 1, .crystal.n_refl
      temp = (.crystal.F_exp(k) - ext(k) * F_c(k)) &
             / (.crystal.sigma(k) * .crystal.sigma(k))
      res = res + ext(k) * real(sf_deriv(k,:)) * temp
    end

    ext.destroy
    F_c.destroy
    sf_deriv.destroy
    k_pts.destroy

    res = res * (-TWO / max(.crystal.n_refl-1,1))
  end

   make_structure_factors [leaky]
   ! Make the structure factors for this molecule.
      CVEC, PTR :: sf_eq
      MAT, PTR :: k_pts
      ARCHIVE :: archive
      BIN :: complex
      ENSURE( .crystal.created, "no crystal")
      ENSURE( .density_matrix.created, "no density matrix")
      .crystal.F_calc.destroy
      .crystal.F_calc.create( .crystal.n_refl)
      k_pts.create(.crystal.unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      sf_eq.create(size(k_pts,1))
      .make_ao_density_matrix
      complex = .density_matrix.spinorbital_kind.includes("complex")
      if (complex) then
        .make_ft(sf_eq,.density_matrix.restricted_complex,k_pts) 
      else 
        .make_ft(sf_eq,.density_matrix.restricted,k_pts) 
      end
!  .add_dispersion_correction(sf_eq,k_pts)
      .crystal.sum_unique_sf(.crystal.F_calc,sf_eq)
      sf_eq.destroy
      k_pts.destroy
      .crystal.make_F_predicted
      archive.set(.name,"structure_factors")
      archive.write( .crystal.F_calc) 
   end

  get_structure_factors [leaky]
  ! Get the structure factors on disk or remake if they don't already exist
    ARCHIVE :: archive
    archive.set(.name,"structure_factors")
    if (archive.exists) then
      ENSURE( .crystal.created, "no crystal")
      .crystal.F_calc.destroy
      .crystal.F_calc.create( .crystal.n_refl)
      archive.read( .crystal.F_calc) 
    else
      .make_structure_factors
    end
  end

   make_sz_structure_factors [leaky]
   ! Make the structure factors for this molecule.
      CVEC, PTR :: sf_eq
      MAT, PTR :: k_pts
      ARCHIVE :: archive
      BIN :: complex
      ENSURE( .crystal.created, "no crystal")
      .crystal.F_calc.destroy
      .crystal.F_calc.create( .crystal.n_refl)
      k_pts.create(.crystal.unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      sf_eq.create(size(k_pts,1))
      .make_ao_sz_density_matrix
      complex = .density_matrix.spinorbital_kind.includes("complex")
      if (complex) then
        .make_ft(sf_eq,.density_matrix.restricted_complex,k_pts) 
      else 
        .make_ft(sf_eq,.density_matrix.restricted,k_pts) 
      end
      .crystal.sum_unique_sf(.crystal.F_calc,sf_eq)
      sf_eq.destroy
      k_pts.destroy
      .crystal.make_F_predicted
      archive.set(.name,"sz_structure_factors")
      archive.write( .crystal.F_calc) 
   end

   make_PND_scalar_magnetic_sf [leaky]
   ! Make the PND scalar magnetic structure factors and assign them
   ! To the crystal objects structure factors for analysis
      CVEC, PTR :: FM_s, FM_l, FM_r
      ARCHIVE :: archive
      .make_PND_spin_sf
      FM_s.create( .crystal.n_refl)
      archive.set(.name,"PND_spin_sf")
      archive.read(FM_s)
      .make_PND_nabla_sf
      FM_l.create( .crystal.n_refl)
      archive.set(.name,"PND_nabla_sf")
      archive.read(FM_l)
      .make_PND_r_sf
      FM_r.create( .crystal.n_refl)
      archive.set(.name,"PND_r_sf")
      archive.read(FM_r)
      .crystal.F_calc.destroy
      .crystal.F_calc.create( .crystal.n_refl)
      .crystal.F_calc = FM_r + FM_s + FM_l 
      archive.set(.name,"PND_scalar_magnetic_sf")
      archive.write( .crystal.F_calc)
      FM_r.destroy
      FM_l.destroy
      FM_s.destroy
   end

   make_PND_spin_sf [leaky]
   ! Make the scalar spin magnetic structure factors assuming an applied field
   ! in the z direction
      ARCHIVE :: archive
      DBL :: fac,ans
      CMAT, PTR :: d_aa,d_bb,d_ba
      CMAT5, PTR :: ft_ab
      CVEC, PTR :: FM
      CDBL :: ci
      SHELL2, PTR :: shell
      INT :: k_max,i,q,a,b,fa,la,fb,lb
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_spin_ints")
      if (archive.doesnt_exist) .make_PND_ft_spin_ints
      archive.open(for="read-only",type="dbl")
      ci = (ZERO,ONE)
      k_max = .crystal.n_refl
      FM.create(k_max)
      FM = ZERO
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp,3,3)
         archive.file.read(ft_ab)
         d_aa => .density_matrix.general_complex(      fb:      lb,      fa:      la)
         d_bb => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         d_ba => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,      fa:      la)
         fac = TWO 
         if (a==b) fac=ONE
         do i = 1,k_max
            ans =          ft_ab(i,:,:,3,1).trace_of_product(d_ba) ! real part ?
            ans = ans - ci*ft_ab(i,:,:,3,2).trace_of_product(d_ba)
            ans = ans -    ft_ab(i,:,:,1,1).trace_of_product(d_aa)
            ans = ans +    ft_ab(i,:,:,1,1).trace_of_product(d_bb)
            ans = ans -    ft_ab(i,:,:,2,2).trace_of_product(d_aa)
            ans = ans +    ft_ab(i,:,:,2,2).trace_of_product(d_bb)
            FM(i) = FM(i) + fac*ans
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close
      archive.set(.name,"PND_spin_sf")
      archive.write(FM)
      FM.destroy
   end

   make_PND_nabla_sf [leaky]
   ! Make the scalar nabla magnetic structure factors assuming an applied field
   ! in the z direction
      ARCHIVE :: archive
      DBL :: fac
      CMAT, PTR :: dens
      CMAT4, PTR :: ft_ab
      CVEC, PTR :: FM
      SHELL2, PTR :: shell
      INT :: k_max,i,q,a,b,fa,la,fb,lb
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_nabla_ints")
      if (archive.doesnt_exist) .make_PND_ft_nabla_ints
      archive.open(for="read-only",type="dbl")
      k_max = .crystal.n_refl
      FM.create(k_max)
      FM = ZERO
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp,3)
         archive.file.read(ft_ab)
         dens.create(shell.b.n_comp,shell.a.n_comp)
         dens =        .density_matrix.general_complex(      fb:      lb,      fa:      la)
         dens = dens + .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         fac = TWO 
         if (a==b) fac=ONE
         do i = 1,k_max
            FM(i) = FM(i) + fac*ft_ab(i,:,:,3).trace_of_product(dens)
         end
         dens.destroy
         ft_ab.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close
      archive.set(.name,"PND_nabla_sf")
      archive.write(FM)
      FM.destroy
   end

   make_PND_r_sf [leaky]
   ! Make the scalar dipole magnetic structure factors assuming an applied field
   ! in the z direction
      ARCHIVE :: archive
      DBL :: fac,ans
      CMAT, PTR :: d_aa,d_bb
      CMAT4, PTR :: ft_ab
      CVEC, PTR :: FM
      SHELL2, PTR :: shell
      INT :: k_max,i,q,a,b,fa,la,fb,lb
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_r_ints")
      if (archive.doesnt_exist) .make_PND_ft_r_ints
      archive.open(for="read-only",type="dbl")
      k_max = .crystal.n_refl
      FM.create(k_max)
      FM = ZERO
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_ab.create(k_max,shell.a.n_comp,shell.b.n_comp,3)
         archive.file.read(ft_ab)
         d_aa => .density_matrix.general_complex(      fb:      lb,      fa:      la)
         d_bb => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         fac = TWO
         if (a==b) fac=ONE
         do i = 1,k_max
            ans =       fac*ft_ab(i,:,:,3).trace_of_product(d_aa)
            ans = ans + fac*ft_ab(i,:,:,3).trace_of_product(d_bb)
            FM(i) = FM(i) + ans 
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close
      archive.set(.name,"PND_r_sf")
      archive.write(FM)
      FM.destroy
   end

   get_PND_ft_spin_ints
   ! Get the PND ft spin integrals on disk if they don't already exist
      ARCHIVE :: archive
      archive.set(.name,"PND_ft_spin_ints")
      if (archive.doesnt_exist) .make_PND_ft_spin_ints
   end

   make_PND_ft_spin_ints
   ! Make the fourier transform of the PND spin integrals on the archive
      ARCHIVE :: archive
      MAT, PTR :: k_pts
      SHELL2, PTR :: shell
      CMAT3, PTR :: ft_ab_eq
      CMAT5, PTR :: ft_ab
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_spin_ints")
      archive.open(for="write-only",type="cdbl")
      k_pts.create(.crystal.unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell.a.n_comp,shell.b.n_comp)
         .make_ft_pair(ft_ab_eq,k_pts,shell,atom_a,atom_b)
         ft_ab.create( .crystal.n_refl,shell.a.n_comp,shell.b.n_comp,3,3)
         .crystal.sum_ft_spin_ints(ft_ab,ft_ab_eq) 
         archive.file.write(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

   get_PND_ft_nabla_ints
   ! Get the PND ft nabla integrals on disk if they don't already exist
      ARCHIVE :: archive
      archive.set(.name,"PND_ft_nabla_ints")
      if (archive.doesnt_exist) .make_PND_ft_nabla_ints
   end

   make_PND_ft_nabla_ints
   ! Make the fourier transform of the nabla integrals on the archive
      ARCHIVE :: archive
      MAT, PTR :: k_pts
      SHELL2, PTR :: shell
      CMAT4, PTR :: ft_ab_eq, ft_ab
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_nabla_ints")
      archive.open(for="write-only",type="cdbl")
      k_pts.create(.crystal.unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell.a.n_comp,shell.b.n_comp,3)
         shell.make_ft_nabla(ft_ab_eq,k_pts)
         .ft_thermally_smear(ft_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
         ft_ab.create( .crystal.n_refl,shell.a.n_comp,shell.b.n_comp,3 )
         .crystal.sum_ft_nabla_ints(ft_ab,ft_ab_eq)
         archive.file.write(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

   get_PND_ft_r_ints
   ! Get the PND ft r integrals on disk if they don't already exist
      ARCHIVE :: archive
      archive.set(.name,"PND_ft_r_ints")
      if (archive.doesnt_exist) .make_PND_ft_r_ints
   end

   make_PND_ft_r_ints
   ! Make the fourier transform of the dipole "r" integrals on the archive
      ARCHIVE :: archive
      MAT, PTR :: k_pts
      SHELL2, PTR :: shell
      CMAT4, PTR :: ft_ab_eq, ft_ab
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_r_ints")
      archive.open(for="write-only",type="cdbl")
      k_pts.create(.crystal.unique_k_pts,3)
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell.a.n_comp,shell.b.n_comp,3)
         shell.make_ft_r(ft_ab_eq,k_pts)
         .ft_thermally_smear(ft_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
         ft_ab.create( .crystal.n_refl,shell.a.n_comp,shell.b.n_comp,3)
         .crystal.sum_ft_r_ints(ft_ab,ft_ab_eq,.B_field) 
         archive.file.write(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

   make_PND_fit_ints(ints,lambda)
   ! Make the PND constraint integrals on the archive
      CMAT, target :: ints
      DBL :: lambda
      ARCHIVE :: spin_archive,nabla_archive,r_archive
      VEC, PTR :: Fc,F_exp,sigma
      CMAT, PTR :: ints_aa,ints_bb,ints_ba
      CMAT4, PTR :: nabla,r
      CMAT5, PTR :: spin
      SHELL2, PTR :: shell
      CDBL :: ci
      DBL :: fac
      INT :: i,q,a,b,fa,la,fb,lb
      INT :: n_bf,n_refl
      .get_PND_ft_spin_ints
      .get_PND_ft_nabla_ints
      .get_PND_ft_r_ints
      spin_archive.set(.name,"PND_ft_spin_ints")
      nabla_archive.set(.name,"PND_ft_nabla_ints")
      r_archive.set(.name,"PND_ft_r_ints")
      spin_archive.open(for="read-only",type="dbl")
      nabla_archive.open(for="read-only",type="dbl")
      r_archive.open(for="read-only",type="dbl")
      ci = (ZERO,ONE)
      n_bf   =  .n_bf
      n_refl =  .crystal.n_refl
      Fc.create(n_refl)
      Fc = abs(.crystal.F_calc)
      F_exp  => .crystal.F_exp
      sigma  => .crystal.sigma
      ints = ZERO
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         spin.create(n_refl,shell.a.n_comp,shell.b.n_comp,3,3)
         spin_archive.file.read(spin)
         ints_aa => ints(     fa:     la,     fb:     lb)
         ints_bb => ints(n_bf+fa:n_bf+la,n_bf+fb:n_bf+lb)
         ints_ba => ints(n_bf+fa:n_bf+la,     fb:     lb)
         do i = 1,n_refl
            fac = TWO*lambda*(Fc(i) - F_exp(i))/(sigma(i)*sigma(i)*n_refl) 
            ints_ba = ints_ba +    fac*spin(i,:,:,3,1)
            ints_ba = ints_ba - ci*fac*spin(i,:,:,3,2)
            ints_aa = ints_aa -    fac*spin(i,:,:,1,1)
            ints_bb = ints_bb +    fac*spin(i,:,:,1,1)
            ints_aa = ints_aa -    fac*spin(i,:,:,2,2)
            ints_bb = ints_bb +    fac*spin(i,:,:,2,2)
         end
         spin.destroy
         nabla.create(n_refl,shell.a.n_comp,shell.b.n_comp,3)
         nabla_archive.file.read(nabla)
         do i = 1,n_refl
            fac = TWO*lambda*(Fc(i) - F_exp(i))/(sigma(i)*sigma(i)*n_refl) 
            ints_aa = ints_aa + fac*nabla(i,:,:,3)
            ints_bb = ints_bb + fac*nabla(i,:,:,3)
         end
         nabla.destroy
         r.create(n_refl,shell.a.n_comp,shell.b.n_comp,3)
         r_archive.file.read(r)
         do i = 1,n_refl
            fac = TWO*lambda*(Fc(i) - F_exp(i))/(sigma(i)*sigma(i)*n_refl) 
            ints_aa = ints_aa + fac*r(i,:,:,3)
            ints_bb = ints_bb + fac*r(i,:,:,3)
         end
         r.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      ints.hermitian_reflect
      r_archive.close
      nabla_archive.close
      spin_archive.close
      Fc.destroy
   end

!  ****************
!  Symmetry methods
!  ****************

   symmetrise(mat,kind)
   ! Symmetrise an opmat matrix "mat" of spinorbital_kind "kind" (if specified)
      OPMAT :: mat
      STR, optional :: kind
      STR :: itemkind
      itemkind = mat.spinorbital_kind
      if (present(kind)) itemkind = kind
      select case (itemkind)
         case ("restricted");           .symmetrise_r( mat.restricted)
         case ("unrestricted");         .symmetrise_r( mat.alpha)
                                        .symmetrise_r( mat.beta)
         case ("general");              .symmetrise_r( mat.general.alpha_alpha)
                                        .symmetrise_r( mat.general.beta_beta)
                                        .symmetrise_r( mat.general.alpha_beta)
                                        .symmetrise_r( mat.general.beta_alpha)
         case ("restricted_complex");   .symmetrise_c( mat.restricted_complex)
         case ("unrestricted_complex"); .symmetrise_c( mat.alpha_complex)
                                        .symmetrise_c( mat.beta_complex)
         case ("general_complex");      .symmetrise_c( mat.general_complex.alpha_alpha)
                                        .symmetrise_c( mat.general_complex.beta_beta)
                                        .symmetrise_c( mat.general_complex.alpha_beta)
                                        .symmetrise_c( mat.general_complex.beta_alpha)
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   symmetrise_r(mat)
   ! Symmetrise a real restricted basis kind matrix
      MAT :: mat
      MAT, PTR :: sym,w
      MAT,  PTR :: tra,trb
      SHELL, PTR :: sh
      INT :: n_bf,dim1,dim2,n,a,b,i,j,na,nb
      INT :: fa,fb,fi,fj,la,lb,li,lj
      IVEC, PTR :: first,last
      IMAT, PTR :: image
      dim1 = size(mat,1)
      dim2 = size(mat,2)
      n_bf = .n_bf
      ENSURE( .atom.created,"no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( dim1==dim2,"non-square matrix")
      ENSURE( dim1==n_bf,"incorrectly dimensioned matrix")
      first => .first_basis_fn_for_shell
      last  => .last_basis_fn_for_shell
      image.create( .n_shell, .pointgroup.order)
      .make_image_of_shell(image)
      sym.create(n_bf,n_bf)
      sym = ZERO
      sh.create
      do n = 1,.pointgroup.order
         do a = 1,.n_shell
            .get_shell(a,sh); na = sh.n_comp; la = sh.l; sh.destroy_ptr_part
            tra => .pointgroup.xyz_matrix(n,la)
            i = image(a,n)
            fa = first(a);  la = last(a); fi = first(i);  li = last(i)
            do b = 1,.n_shell
               .get_shell(b,sh); nb = sh.n_comp; lb = sh.l; sh.destroy_ptr_part
               trb => .pointgroup.xyz_matrix(n,lb)
               j = image(b,n)
               fb = first(b);  lb = last(b); fj = first(j);  lj = last(j)
               w.create(na,nb)
               w = matmul(tra, mat(fa:la,fb:lb) )
               sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + matmul(w,transpose(trb))
               w.destroy
               trb.destroy
            end
            tra.destroy
         end
      end
      sh.destroy
      mat = sym/.pointgroup.order
      sym.destroy
      image.destroy
   end

   symmetrise_c(mat)
   ! Symmetrise a complex restricted basis kind matrix
      CMAT :: mat
      CMAT, PTR :: sym,w
      MAT,  PTR :: tra,trb
      SHELL, PTR :: sh
      INT :: n_bf,dim1,dim2,n,a,b,i,j,na,nb
      INT :: fa,fb,fi,fj,la,lb,li,lj
      IVEC, PTR :: first,last
      IMAT, PTR :: image
      dim1 = size(mat,1)
      dim2 = size(mat,2)
      n_bf = .n_bf
      ENSURE( .atom.created,"no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( dim1==dim2,"non-square matrix")
      ENSURE( dim1==n_bf,"incorrectly dimensioned matrix")
      first => .first_basis_fn_for_shell
      last  => .last_basis_fn_for_shell
      image.create( .n_shell, .pointgroup.order)
      .make_image_of_shell(image)
      sym.create(n_bf,n_bf)
      sym = ZERO
      sh.create
      do n = 1,.pointgroup.order
         do a = 1,.n_shell
            .get_shell(a,sh); na = sh.n_comp; la = sh.l; sh.destroy_ptr_part
            tra => .pointgroup.xyz_matrix(n,la)
            i = image(a,n)
            fa = first(a);  la = last(a); fi = first(i);  li = last(i)
            do b = 1,.n_shell
               .get_shell(b,sh); nb = sh.n_comp; lb = sh.l; sh.destroy_ptr_part
               trb => .pointgroup.xyz_matrix(n,lb)
               j = image(b,n)
               fb = first(b);  lb = last(b); fj = first(j);  lj = last(j)
               w.create(na,nb)
               w = matmul(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + matmul(w,transpose(trb))
               w.destroy
               trb.destroy
            end
            tra.destroy
         end
      end
      sh.destroy
      mat = sym/.pointgroup.order
      sym.destroy
      image.destroy
   end

   make_image_of_shell(res)
   ! Return an array "res(a,n)" which is the image of shell "a" under pointgroup
   ! operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      IMAT, OUT :: res
      VEC(3) :: new_pos
      INT :: n,a,aa,as,new_atom,fs
      ENSURE(size(res,1) == .n_shell, "dimension of matrix incorrect")
      ENSURE(size(res,2) == .pointgroup.order, "dimension of matrix incorrect")
      do n = 1,.pointgroup.order
         do a = 1,.n_shell
            aa = .atom_for_shell(a)
            as = .atom_shell_for_shell(a)
            new_pos = matmul( .pointgroup.mat(:,:,n), .atom(aa).pos)
            new_atom = .atom_index_from_pos(new_pos) 
            fs = .first_shell_for_atom(new_atom)
            res(a,n) = fs+as-1
         end
      end
   end

!  ************
!  I/O routines
!  ************

  read_repetition_factors
  ! Useful to get structure factor contributions from a small portion of the
  ! cluster.
    INT :: n
    STR :: word
    ENSURE(.crystal.created,"no crystal information")
    ENSURE(.crystal.repetition_factor.created,"no repetition factors defined")
    do n=1,size(.crystal.repetition_factor)
      stdin.read(.crystal.repetition_factor(n))
    end
    stdin.read(word)
    word.to_lower_case
    ENSURE(word=='end','expecting "end" keyword')
  end

   read_multiplicity
   ! Read in the spin multiplicity
      stdin.read(.mult)
      ENSURE(.mult/=0,"cannot have zero multiplicity")
   end

   read_gauge_origin
   ! Read in the gauge origin vector for an applied external magnetic field
      stdin.read(.gauge_origin)
      .delete_gauge_integrals
   end

   delete_gauge_integrals
   ! Delete all integral files which depend on the gauge origin. 
   ! This is required whenever the gauge origin is changed.
      ARCHIVE :: archive
      archive.set(.name,"Lx_matrix"); archive.delete
      archive.set(.name,"Ly_matrix"); archive.delete
      archive.set(.name,"Lz_matrix"); archive.delete
   end

   read_plotgrid [leaky]
   ! Read in the plot grid data
      if ( .crystal.destroyed) then
        .grid.read(.atom)
      else if ( .crystal.created) then
        .grid.read(.atom,.crystal)
      end
   end

   read_dftgrid [leaky]
   ! Read in the DFT grid data
      .dftgrid.destroy
      .dftgrid.create
      .dftgrid.read
      .dftgrid.archive.set_root_name(.name)
   end

   read_crystal [leaky]
   ! Read in the crystal data
      .crystal.destroy
      .crystal.create
      .crystal.read
      if (associated(.atom)) then
         .resolve_axis_system
         .crystal.make_reduced_group_data(.atom)
      end
   end

   read_pointgroup [leaky]
   ! Read in the pointgroup data
      .pointgroup.destroy
      .pointgroup.create
      .pointgroup.read
   end

   read_scfdata [leaky] 
   ! Read in the scf data
      .scfdata.destroy
      .scfdata.create
      .scfdata.read
      if (.scfdata.using_diis) then
      .scfdata.diis.set_archive_root_name(.name) 
      .scfdata.diis.set_archive_name("fock_matrix,DIIS")
      end
   end

   read_atoms [leaky]
   ! Read in the atom list information
      .atom.read
      DIE_IF(.atom.bases_are_part_labeled,"some empty basis labels exist")
      .resolve_basis_labels
      .set_atom_info
      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_reduced_group_data(.atom)
      end
   end
  
!  read_basis_labels
!  ! Read in a list of basis set labels for every atom in the molecule
!  ! If a basis set is defined, all atoms must have a resolved basis set
!     ENSURE( .atom.created,"no atoms in atom list")
!     .atom.read_basis_labels
!     .resolve_basis_labels
!  end

   read_basis_sets [leaky]
   ! Read in a list of atomic basis sets for the molecule
      .basis.read
      .resolve_basis_labels
   end

   read_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g.
   ! "restricted".
   ! For use with TONTO generated archives.
      STR :: name,kind
      ARCHIVE :: archive
      ENSURE(stdin.buffer.n_items==3, "must specify an archive and a kind")
      stdin.read(name)
      stdin.read(kind)
      stdout.text("reading archive : " // trim(name))
      archive.set(.name,name,kind)
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals)
         case ("density_matrix");     archive.read(.density_matrix)
         case ("orbital_energies");   archive.read(.orbital_energies)
         case ("natural_orbitals");   archive.read(.natural_orbitals)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("covalent_orbitals");  archive.read(.natural_orbitals)
         case ("ionic_orbitals");     archive.read(.natural_orbitals)
         case default;                DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_ascii_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g.
   ! "restricted".
   ! If required, the input order may be specified as "by_row" (default) or
   ! "by_column".
      STR :: name,kind,order
      ARCHIVE :: archive
      ENSURE(stdin.buffer.n_items==3, "must specify an archive and a kind")
      stdin.read(name)
      stdin.read(kind)
      order = "by_row"
      if (stdin.buffer.not_exhausted) stdin.read(order)
      archive.set(.name,name,kind,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.read(.density_matrix,order=order)
         case ("orbital_energies");   archive.read(.orbital_energies)
         case ("natural_orbitals");   archive.read(.natural_orbitals,order=order)
         case ("occupation");         archive.read(.occupation)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("fock_matrix");        .fock_matrix.create("restricted")
                                      archive.read(.fock_matrix,order=order)
         case default; DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_g94_checkpoint_file [leaky]
   ! Read a g94 checkpoint file (after fchk conversion to ASCII) into TONTO
      STR :: name
      TEXTFILE, PTR :: chkfile
      IVEC, PTR :: shell_l, nps, shell_to_atom, e_atom
      IVEC, PTR :: tmp_nps, tmp_sta, tmp_shells
      VEC, PTR :: tmp_pe, tmp_cc
      VEC, PTR :: pe, cc, extra_cc, temp_vec
      MAT, PTR :: temp_mat
      OPMAT, PTR :: temp_spin, temp_total
      INT :: c, t, a, s, u, m1, m2, i,n_basis
      INT :: n_shell, n_comp, n_cc
      BIN :: same
      BASIS, PTR :: basis
      ARCHIVE :: archive
      if ( .basis.created) .basis.destroy
      if ( .atom.created)  .atom.destroy
      name = trim(.name) // achar(46) // "FChk"        ! name.FChk or
      if (stdin.buffer.not_exhausted) stdin.read(name) ! specified on stdin
      .scfdata.create

      ! Read in basic stuff.
      chkfile.create(name)
      chkfile.open_for_read
      chkfile.read_line
      chkfile.look_for("Number of atoms")
      chkfile.move_to_line_item(5); chkfile.read( .n_atom)
      chkfile.look_for("Charge")
      chkfile.move_to_line_item(3); chkfile.read( .charge)
      chkfile.look_for("Multiplicity")
      chkfile.move_to_line_item(3); chkfile.read( .mult)
      chkfile.look_for("Number of electrons")
      chkfile.move_to_line_item(5); chkfile.read( .n_e)
      chkfile.look_for("Number of alpha electrons")
      chkfile.move_to_line_item(6); chkfile.read( .n_a)
      chkfile.look_for("Number of beta electrons")
      chkfile.move_to_line_item(6); chkfile.read( .n_b)
      chkfile.look_for("Number of basis functions")
      chkfile.move_to_line_item(6); chkfile.read( .n_bf)
      chkfile.look_for("Number of contracted shells") 
      chkfile.move_to_line_item(6); chkfile.read( .n_shell)
      chkfile.look_for("Number of primitive shells")
      chkfile.move_to_line_item(6); chkfile.read( .n_prim)
      chkfile.look_for("Total Energy")
      chkfile.move_to_line_item(4)
      chkfile.read_dbl( .scfdata.energy )
      chkfile.look_for("Atomic numbers"); chkfile.read_line
      .atom.create( .n_atom)
      do a = 1, .n_atom
         chkfile.read( .atom(a).atomic_number )
         .atom(a).label = .atom(a).chemical_symbol.trim // a.to_str.trim
      end
      chkfile.look_for("Current cartesian coordinates")
      chkfile.read_line
      do a = 1, .n_atom
         chkfile.read( .atom(a).pos)
      end

      ! Shell info.
      chkfile.look_for("Shell types"); chkfile.read_line
      tmp_shells.create( .n_shell); tmp_nps.create( .n_shell)
      tmp_sta.create( .n_shell); tmp_pe.create( .n_prim)
      tmp_cc.create( .n_prim)
      chkfile.read(tmp_shells)
      chkfile.look_for("Number of primitives per shell")
      chkfile.read_line; chkfile.read(tmp_nps)
      chkfile.look_for("Shell to atom map"); chkfile.read_line
      chkfile.read(tmp_sta)
      chkfile.look_for("Primitive exponents"); chkfile.read_line
      chkfile.read(tmp_pe)
      chkfile.look_for("Contraction coefficients"); chkfile.read_line
      chkfile.read(tmp_cc)
      e_atom.create( .n_atom); e_atom.zero
      extra_cc.create( .n_prim)
      if (any( tmp_shells == (-1) )) then
        do a = 1, .n_shell
           if (tmp_shells(a) == (-1)) then
              e_atom(tmp_sta(a)) = e_atom(tmp_sta(a)) + 1
              .n_prim = .n_prim + tmp_nps(a)
           end
        end
        chkfile.look_for("P(S=P)"); chkfile.read_line
        chkfile.read( extra_cc)
      end
      s = .n_shell + sum(e_atom)
      shell_l.create(s); nps.create(s)
      pe.create(.n_prim); cc.create(.n_prim)
      shell_to_atom.create(s)
      a = 0
      m1 = 1; m2 = 1
      do c = 1, .n_shell
        a = a + 1
        if (tmp_shells(c) == (-1)) then
           shell_l(a) = 0
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+tmp_nps(c)-1) = tmp_pe(m2:m2+tmp_nps(c)-1)
           cc(m1:m1+tmp_nps(c)-1) = tmp_cc(m2:m2+tmp_nps(c)-1)
           a = a+1; m1=m1+tmp_nps(c)
           shell_l(a) = 1
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+tmp_nps(c)-1) = tmp_pe(m2:m2+tmp_nps(c)-1)
           cc(m1:m1+tmp_nps(c)-1) = extra_cc(m2:m2+tmp_nps(c)-1)
        else
           pe(m1:m1+tmp_nps(c)-1) = tmp_pe(m2:m2+tmp_nps(c)-1)    
           cc(m1:m1+tmp_nps(c)-1) = tmp_cc(m2:m2+tmp_nps(c)-1)
           shell_l(a) = tmp_shells(c)
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c) 
        end
        m1 = m1 + tmp_nps(c); m2 = m2 + tmp_nps(c)
      end
      extra_cc.destroy
      tmp_shells.destroy; tmp_sta.destroy
      tmp_nps.destroy; tmp_pe.destroy; tmp_cc.destroy
      .n_shell = s
      c = 0      ! for recording number of primitives read
      t = 0      ! for recording number of shells read
      n_basis = 0
      .basis.create(n_basis)
      do a = 1, .n_atom
         basis.create
         basis.label = .atom(a).label.trim // "_g94_basis"
         n_shell = count(shell_to_atom==a)
         basis.n_shell = n_shell
         basis.shell.create(n_shell)
         basis.shell.nullify_ptr_part
         do s = 1, n_shell
            n_comp = shell_l(t+s).n_comp
            n_cc = nps(t+s)
            basis.shell(s).l = shell_l(t+s)
            basis.shell(s).n_comp = n_comp
            basis.shell(s).n_cc = n_cc
            basis.shell(s).ex.create( n_cc )
            basis.shell(s).cc.create( n_cc )
            basis.shell(s).ex = pe( c+1 : c+n_cc )
            basis.shell(s).cc = cc( c+1 : c+n_cc )
            c = c + n_cc
         end
         basis.n_bf = basis.no_of_basis_functions
         basis.n_prim = basis.no_of_primitives
         basis.unnormalise
         t = t + n_shell
         same = FALSE
         do i = 1,n_basis
            if (.basis(i).same_as(basis)) then
               same = TRUE
               exit
            end
         end
         .atom(a).basis.create
         if (same) then
            .atom(a).basis.label = .basis(i).label
         else
            .atom(a).basis.label =  basis.label
            n_basis = n_basis + 1
            .basis.expand(n_basis)
            .basis(n_basis).copy(basis)
         end
         basis.destroy
      end
      pe.destroy; cc.destroy
      shell_to_atom.destroy; nps.destroy; e_atom.destroy
      shell_l.destroy
      .resolve_basis_labels
      .set_atom_info

      ! Read in orbital energies.
      temp_vec.create( .n_bf)
      chkfile.look_for("Alpha Orbital Energies")
      chkfile.read_line; chkfile.read( temp_vec)      
      if (chkfile.next_str == "Beta") then
         u = 1
         .scfdata.kind = "uhf"
         .orbital_energies.create(.n_bf, "beta")
         chkfile.read_line; chkfile.read( .orbital_energies.beta)
         .orbital_energies.alpha => temp_vec
         nullify(temp_vec)
      else
         u = 0
         .scfdata.kind = "rhf"
         .orbital_energies.create(.n_bf)
         .orbital_energies.restricted => temp_vec
         nullify(temp_vec)
      end

      ! Read in molecular orbitals.
      temp_mat.create( .n_bf, .n_bf)
      chkfile.look_for("Alpha MO"); chkfile.read_line
      chkfile.read( temp_mat)
      temp_mat.to_transpose
      if (chkfile.next_str == "Beta") then
         .molecular_orbitals.create( .n_bf, "beta")
         chkfile.read_line; chkfile.read( .molecular_orbitals.beta)
         .molecular_orbitals.beta.to_transpose
         .molecular_orbitals.alpha => temp_mat
         nullify(temp_vec)
         .swap_g94_orbital_order(.molecular_orbitals.alpha,"row") 
         .swap_g94_orbital_order(.molecular_orbitals.beta, "row") 
      else
         .molecular_orbitals.create(.n_bf)
         .molecular_orbitals.restricted => temp_mat
         nullify(temp_vec)
         .swap_g94_orbital_order(.molecular_orbitals.restricted,"row") 
      end

      ! Read in density matrix.
      if (u==0) then
         .density_matrix.create( .n_bf, "restricted")
         .density_matrix.triangle.create( .density_matrix.l_compress( "restricted"))
         chkfile.look_for( "Total SCF Density"); chkfile.read_line
         chkfile.read( .density_matrix.triangle)
         .density_matrix.uncompress
         .swap_g94_orbital_order(.density_matrix.restricted,"row") 
         .swap_g94_orbital_order(.density_matrix.restricted,"column") 
      else
         temp_total.create( .n_bf, "restricted")
         temp_spin.create( .n_bf, "restricted")
         temp_total.triangle.create( temp_total.l_compress( "restricted"))
         chkfile.look_for( "Total SCF Density"); chkfile.read_line
         chkfile.read( temp_total.triangle)
         temp_total.uncompress
         temp_spin.triangle.create( temp_spin.l_compress( "restricted"))
         chkfile.look_for( "Spin SCF Density"); chkfile.read_line    
         chkfile.read( temp_spin.triangle)
         temp_spin.uncompress
         .density_matrix.create( .n_bf, "alpha")
         .density_matrix.create( "beta")
         .density_matrix.beta = (temp_total.restricted - temp_spin.restricted)/2
         .density_matrix.alpha = (temp_spin.restricted + temp_total.restricted)/2 
         temp_spin.destroy
         temp_total.destroy
         .swap_g94_orbital_order(.density_matrix.alpha,"row") 
         .swap_g94_orbital_order(.density_matrix.alpha,"column") 
         .swap_g94_orbital_order(.density_matrix.beta, "row") 
         .swap_g94_orbital_order(.density_matrix.beta, "column") 
         .make_unrestricted_NOs
      end

      chkfile.close; chkfile.destroy

      ! Save data in archive files
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_reduced_group_data(.atom)
      end
   end

   swap_g94_orbital_order(X,swap) 
   ! Swap the order of f orbitals on matrix "X" after reading a g94 checkpoint
   ! file, for "swap" equal to "row" or "1", or "coloumn" or "2". 
      MAT :: X
      STR(*) :: swap
      INT :: n,f,l
      IVEC(10) :: ff = (/ 1, 2, 3, 5, 6, 4, 9, 7, 8,10 /)
      select case (swap)
         case("row","1")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(f:l,:) = X(f-1+ff,:)
               end
            end
         case("column","2")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(:,f:l) = X(:,f-1+ff)
               end
            end
         case default
            DIE("unknown swap option")
      end
   end

   write_wfn_file [leaky]
   ! writes a .wfn file for input to morphy98
      STR :: name
      TEXTFILE, PTR :: wfnfile
      IVEC, PTR :: lvec
      VEC, PTR :: evec
      MAT, PTR :: dmatrix, cc
      INT :: i, j, pcount, n_orbitals, b, a, l, atom, shell
      STR, parameter :: title_format = "(A80)"
      STR, parameter :: n_vars_format = "(A8, 10X, I5, 15X, I5, 15X, I5, 17X)"
      STR, parameter :: atom_format = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      STR, parameter :: c_assignment_format = "('CENTRE ASSIGNMENTS  ', 20I3)"
      STR, parameter :: t_assignment_format = "('TYPE ASSIGNMENTS    ', 20I3)"
      STR, parameter :: exponent_format = "('EXPONENTS ', 5E14.7)"
      STR, parameter :: mol_title_format = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      STR, parameter :: coefficient_format = "(5E16.8)"
      STR, parameter :: e_v_format = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"
      SHELL, PTR :: sh
      ENSURE(.occupation.restricted.created, "No occupation numbers")
      ENSURE(.orbital_energies.restricted.created, "No orbital energies")
      ENSURE(.molecular_orbitals.restricted.created, "No orbitals")
      name = .name 
      if (stdin.buffer.not_exhausted) stdin.read(name)
      wfnfile.create(name)
      wfnfile.open_for_write
      if (mod( .n_e, 2) == 0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end
      write( unit = wfnfile.unit, fmt = title_format) trim( name) // " computed by TONTO"
      write( unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write( unit = wfnfile.unit, fmt = atom_format) ( .atom(i).label, i, i, &
         .atom(i).pos, dble( .atom(i).atomic_number ) , i = 1, .n_atom)
      write( unit = wfnfile.unit, fmt = c_assignment_format) (( j, i = 1, .atom(j).n_prim ), j = 1, .n_atom )
      pcount = 1
      lvec.create( .n_prim)
      evec.create( .n_prim)
      do a = 1, .n_shell
        atom  = .atom_for_shell(a)
        shell = .atom_shell_for_shell(a)
        sh => .atom(atom).basis.shell(shell) 
        l = sh.l.n_comp_sum - sh.n_comp
        do j = 1, sh.n_cc
          do i = 1, sh.n_comp
            evec( pcount ) = sh.ex(j)
            lvec( pcount ) = l + i
            pcount = pcount + 1
          end
        end
      end
      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write( unit = wfnfile.unit, fmt = exponent_format) evec 
      lvec.destroy
      evec.destroy
      dmatrix.create( .n_prim, .n_bf)
      dmatrix.zero
      cc.create(.n_prim, .n_bf);    .make_contraction_matrix(cc)
      dmatrix.to_product(cc,.molecular_orbitals.restricted)
      do i = 1, n_orbitals
         write(unit = wfnfile.unit, fmt = mol_title_format) "MO  ", i, "OCC NO = ", &
            .occupation.restricted(i), " ORB. ENERGY = ", .orbital_energies.restricted(i)
         write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end
      write( unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
      write( unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy
   end
   
   write_archive
   ! Write the archive called "name". The kind is defined by the object to be
   ! written.
      STR :: name
      ARCHIVE :: archive
      stdin.read(name)
      archive.set(.name,name)
      select case (name)
         case ("molecular_orbitals"); archive.write(.molecular_orbitals)
         case ("density_matrix");     archive.write(.density_matrix)
         case ("natural_orbitals");   archive.write(.natural_orbitals)
         case ("occupation");         archive.write(.occupation)
         case ("fock_matrix");        archive.write(.fock_matrix)
         case ("orbital_energies");   archive.write(.orbital_energies)
         case default;     DIE("unknown archive name, " // trim(name))
      end
      archive.close
   end
   
   write_ascii_archive
   ! Write the archive called "name". The kind is defined by the object to be
   ! written. If required, the output order may be specified as 
   ! "by_row" (default) or "by_column".
      STR :: name,order
      ARCHIVE :: archive
      stdin.read(name)
      order = "by_row"
      if (stdin.buffer.not_exhausted) stdin.read(order)
      archive.set(.name,name,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.write(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.write(.density_matrix,order=order)
         case ("natural_orbitals");   archive.write(.natural_orbitals,order=order)
         case ("occupation");         archive.write(.occupation,order=order)
         case ("fock_matrix");        archive.write(.fock_matrix,order=order)
         case ("orbital_energies");   archive.write(.orbital_energies,order=order)
         case default;     DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

!  **************
!  Output methods
!  **************

   put
   ! Put all the available molecule information on file "out"
     stdout.flush
     stdout.text("Molecule information:")
     stdout.flush
     stdout.show("Name                   =",.name)
     stdout.show("Charge                 =",.charge)
     stdout.show("Multiplicity           =",.mult)
     stdout.show("Applied E Field        =",.E_field(1),.E_field(2),.E_field(3))
     stdout.show("Applied B Field        =",.B_field(1),.B_field(2),.B_field(3))
     stdout.show("B field Gauge origin   =",.gauge_origin)
     if (.atom.created)        .put_atoms
     if (.pointgroup.created)  .put_pointgroup
     if (.crystal.created)     .put_crystal
!    if (.grid.created)        .put_grid
     if (.dftgrid.created)     .put_dftgrid
   end

   put_atoms
   ! Output the atom coordinate and basis set information
      ENSURE(.atom.created,"no atom list")
      stdout.flush
      stdout.text("Molecule atom information:")
      stdout.flush
      stdout.show("Chemical Formula       =",trim(.chemical_formula))
      stdout.show("No of atoms            =",.n_atom)
      stdout.show("No of electrons        =",.n_e)
      stdout.show("No of alpha electrons  =",.n_a)
      stdout.show("No of beta  electrons  =",.n_b)
      .atom.put_coord_info
      .put_bases
      .put_atom_thermal_tensors
   end

   put_bases
   ! Output the molecule basis set information, if the bases are all resolved.
      ENSURE(.atom.created,"no atom list")
      RETURN_IF(.atom.bases_are_unresolved)
      ENSURE(.basis.created,"no basis set list")
      stdout.flush
      stdout.text("Molecule atom basis set information:")
      stdout.flush
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.n_shell_pairs)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      .basis.put
   end 

  put_atom_thermal_tensors
  ! Output the thermal tensors if they exist.
    STR :: thermal_smearing_model
    RETURN_IF(.crystal.destroyed)
    thermal_smearing_model = .crystal.thermal_smearing_model
    if (thermal_smearing_model=="") then
      stdout.flush
      stdout.put("No thermal smearing.")
      stdout.flush
    else
      stdout.flush
      stdout.put("Thermal tensor information:")
      stdout.flush
      stdout.show("Thermal smearing model = ", thermal_smearing_model.trim)
      stdout.flush
      ENSURE(.atom.created,"no atom list data")
      .atom.put_thermal_tensors
    end
  end

   put_basis
   ! Output the molecule basis set information
      ENSURE(.basis.created,"no basis set list")
      stdout.flush
      stdout.text("Molecule atom basis set information:")
      stdout.flush
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.n_shell_pairs)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      .basis.put
   end 

   put_pointgroup
   ! Output the current pointgroup
      .pointgroup.put
   end

  put_plotgrid
  ! Output the current grid.
    ENSURE(.grid.created,"no plot grid to output")
    .grid.put
  end

  put_dftgrid
  ! Output the current DFT grid.
    ENSURE(.dftgrid.created,"no DFT grid to output")
    .dftgrid.put
  end

   put_crystal
   ! Output the current crystal
      if (.atom.created) then; .crystal.put(.atom)
      else;                    .crystal.put
      end
   end

   put_crystal_reflection_data
   ! Output the current crystal
      .crystal.put_reflection_data
   end

   put_molecular_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put( .molecular_orbitals)
   end

   put_mos_and_energies
   ! Output the current associated molecular orbitals and their energies
      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put( .orbital_energies, format="column")
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put( .molecular_orbitals)
   end

   put_natural_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Natural orbital occupations:")
      stdout.put( .occupation, format="column")
      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put( .natural_orbitals)
   end

   put_density_matrix
   ! Output the current associated density matrix 
      ENSURE(.density_matrix.created,"no density matrix")
      stdout.flush
      stdout.text("Density matrix:")
      stdout.put( .density_matrix)
   end

   put_fock_matrix
   ! Output the current associated fock matrix 
      ENSURE(.fock_matrix.created,"no fock matrix")
      stdout.flush
      stdout.text("Fock matrix:")
      stdout.put( .fock_matrix)
   end

   put_PND_sf
   ! Output the magnetic structure factors
      CVEC, PTR :: FM_s, FM_l, FM_r
      ARCHIVE :: archive
      INT :: n
      FM_s.create( .crystal.n_refl)
      archive.set(.name,"PND_spin_sf")
      archive.read(FM_s)
      FM_l.create( .crystal.n_refl)
      archive.set(.name,"PND_nabla_sf")
      archive.read(FM_l)
      FM_r.create( .crystal.n_refl)
      archive.set(.name,"PND_r_sf")
      archive.read(FM_r)
      stdout.text("PND magnetic structure factors:")
      stdout.flush
      stdout.dash(int_fields=3,dbl_fields=4)
      stdout.put("h", int_width=TRUE)
      stdout.put("k", int_width=TRUE)
      stdout.put("l", int_width=TRUE)
      stdout.put("FM_s")
      stdout.put("FM_l")
      stdout.put("FM_r")
      stdout.put("FM")
      stdout.flush
      stdout.dash(int_fields=3,dbl_fields=4)
      do n = 1, .crystal.n_refl
         stdout.put( .crystal.h(n))
         stdout.put( .crystal.k(n))
         stdout.put( .crystal.l(n))
         stdout.put( real(FM_s(n)) )
         stdout.put( real(FM_l(n)) )
         stdout.put( real(FM_r(n)) )
         stdout.put( real(FM_s(n)+FM_l(n)+FM_r(n)) )
         stdout.flush
      end
      stdout.dash(int_fields=3,dbl_fields=4)
      FM_r.destroy
      FM_l.destroy
      FM_s.destroy
   end

  put_cluster_operations
  ! Outputs a list of the symmetry operations and translations of the molecules
  ! which are within distance_max of the centre of the molecule.
  ! Optional input position must be in crystal coordinates.
    IMAT, PTR :: op_list
    VEC, PTR :: dist_list
    INT :: q
    DBL :: dist_max
    VEC(3) :: position
    STR :: word

    ! defaults
    dist_max  = 5
    position = (/ZERO,ZERO,ZERO/)

    read_loop : do
      stdin.read(word)
      word.to_lower_case
      select case (word)
         case("end");                     exit read_loop
         case("distance");                stdin.read(dist_max)
         case("position");                stdin.read(position)
         case("centre");                  stdin.read(position)
      end
    end do read_loop
    position.rotate_by(.crystal.direct_cell_matrix)

    .crystal.create_closest_molecule_list(op_list,dist_list,position,dist_max)

    q=size(op_list,2)
    if (op_list(1,1) == 0) q=0

    stdout.flush
    stdout.text("Cluster operations.")
    stdout.show("No of molecules                = ", q)
    stdout.show("Cutoff radius of cluster (au)  = ", dist_max)
    if (q>0) then
      stdout.put("symop",int_width=TRUE)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.put("distance (au)")
      stdout.flush
      do q=1,size(dist_list)
        if (op_list(1,q)==0) exit
        stdout.put(op_list(1,q))
        stdout.put(op_list(2,q))
        stdout.put(op_list(3,q))
        stdout.put(op_list(4,q))
        stdout.put(dist_list(q))
        stdout.flush
      end
    end
    op_list.destroy
    dist_list.destroy
  end

  put_cluster_input
  ! Outputs the input data for a cluster of molecules around the centre of the
  ! molecule.
  ! Optional input position must be in crystal coordinates.
  ! Output atom positions are in crystal coordinates.
  ! Output of thermal tensors is optional.
    IMAT, PTR :: op_list
    VEC, PTR :: dist_list
    VEC(3) :: pos
    STR :: word
    MAT3, PTR :: therm1
    MAT(3,3) :: therm
    MAT, PTR :: pos1,pos2
    VEC(3) :: position
    INT :: s,h,k,l,n,q
    DBL :: dist_max
    BIN :: put_thermal

    ENSURE(.crystal.created,            "no crystal data")
    ENSURE(.atom.created,               "no atom data")
    ENSURE(.atom.bases_are_all_labeled, "atoms must all have basis labes")

    ! defaults
    dist_max  = 5
    position = (/ZERO,ZERO,ZERO/)
    put_thermal = FALSE

    read_loop : do
      stdin.read(word)
      word.to_lower_case
      select case (word)
         case("end");                     exit read_loop
         case("put_thermal_tensors");     stdin.read(put_thermal)
         case("distance");                stdin.read(dist_max)
         case("position");                stdin.read(position)
         case("centre");                  stdin.read(position)
         case default; DIE("unknown keyword : " // trim(word))
      end
    end do read_loop
    position.rotate_by(.crystal.direct_cell_matrix)

    .crystal.create_closest_molecule_list(op_list,dist_list,position,dist_max)
    dist_list.destroy

    q=size(op_list,2)
    if (op_list(1,1) == 0) q=0

    stdout.flush
    stdout.text("Cluster input.")
    stdout.show("No of molecules                = ", q)
    stdout.show("Cutoff radius of cluster (au)  = ", dist_max)
    if (put_thermal) then
    stdout.show("Thermal tensor axis system     = ", "cartesian")
    stdout.show("Thermal tensor units           = ", "bohr^2")
    end

    if (q>0) then
      stdout.put_text("atoms")
      stdout.flush
      stdout.put_text('data_order label "axis_system crystal" pos basis_label')
      if (put_thermal) &
      stdout.put_text(' thermal_tensor ')
      stdout.text(' end')
      stdout.text("loop")

      pos1.create(3,.n_atom)
      pos2.create(3,.n_atom)
      pos1 = .crystal.fragment_geometry
      .crystal.move_to_unit_cell(pos1)

      therm1.create(3,3,.n_atom)
      do n = 1, .n_atom
        therm1(:,:,n) = .atom(n).thermal_tensor
      end

      do q=1,size(dist_list)
        s = op_list(1,q)
        if (s==0) exit
        h = op_list(2,q)
        k = op_list(3,q)
        l = op_list(4,q)
        pos2 = pos1
        .crystal.transform_geometry(pos2,s)
        stdout.put_text("! symop = " // s.to_str)
        stdout.put_text(", h k l = ")
        stdout.text(h.to_str // " " // h.to_str // " " // l.to_str)
        do n = 1, .n_atom
          therm = therm1(:,:,n)
          therm.change_basis(.crystal.spacegroup.seitz(1:3,1:3,s))
          pos = pos2(:,n) + (/h,k,l/)
          stdout.put_text(trim(.atom(n).label),int_width=TRUE)
          stdout.put(pos(1))
          stdout.put(pos(2))
          stdout.put(pos(3))
          stdout.put_text(" " // trim(.atom(n).basis.label))
          if (put_thermal) then
            stdout.put(therm(1,1))
            stdout.put(therm(2,2))
            stdout.put(therm(3,3))
            stdout.put(therm(1,2))
            stdout.put(therm(1,3))
            stdout.put(therm(2,3))
          end
          stdout.flush
        end
      end
      stdout.text("end end",flush=2)

      therm1.destroy
      pos2.destroy
      pos1.destroy
    end
    op_list.destroy
  end

!  ***********
!  SCF methods
!  ***********

   set_scf_defaults [leaky]
   ! Set up scf defaults for molecule
      .scfdata.destroy
      .scfdata.create
      if (.mult==1) .scfdata.kind = "rhf"
      if (.mult/=1) .scfdata.kind = "uhf"
      .scfdata.using_diis = TRUE
      .scfdata.direct = FALSE
      .scfdata.diis.set_archive_root_name(.name) 
      .scfdata.diis.set_archive_name("fock_matrix,DIIS")
   end

   make_molecule_from_atom(n,mol) [leaky]
   ! Make a fully fledged molecule "mol" from a single atom "n" in self
      INT :: n
      MOL :: mol
      ENSURE(n<=.n_atom,"atom number n too big")
      mol.atom.create(1)
      mol.atom = .atom(n) ! WARNING: dont destroy ptr parts of mol.atom !
      mol.atom(1).pos = (/ZERO,ZERO,ZERO/)
      mol.set_defaults
      mol.name  =  .name.trim // "_" // (.atom(n).label).trim
      mol.basis => .basis ! WARNING: dont destroy basis of mol !
      mol.set_basis_info
      mol.set_scf_defaults
   end

! ************
! SCF routines
! ************

  scf    [recursive] [leaky]
  ! Do an SCF calculation. The following :
  !   .molecular_orbitals, .orbital_energies, .density_matrix  
  ! are produced as results.
    select case (.scfdata.kind)
      case ("xray_rhf","xray_constrained_restricted_hartree_fock")
        .constrained_scf_rhf
      case default;
        .hf_scf
    end
  end

  hf_scf [recursive] [leaky]
  ! Do a Hartree-Fock SCF calculation. The following :
  !   .molecular_orbitals, .orbital_energies, .density_matrix  
  ! are produced as results.
    MAT, PTR :: S
    OPMAT, PTR :: dP,dF,old_P,old_F
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    .get_initial_guess

    .make_fock_matrix(core=TRUE)

    .scfdata.set(nuclear_energy=.nuclear_energy)
    .scfdata.reset(energy=.scf_energy, kinetic_energy=.kinetic_energy)
    .scfdata.put_banner

    dP.create(.n_bf)
    dF.create(.n_bf)
    old_P.create_copy(.density_matrix)
    old_F.create_copy(.fock_matrix)

    ! first iteration.
    .extrapolate_scf
    .update_molecular_orbitals

    S.create( .n_bf, .n_bf)
    .get_overlap_matrix(S)
    .molecular_orbitals.schmidt_orthonormalise(S)
    S.destroy

    .make_scf_density_matrix
    .save_scf_results
    .make_fock_matrix(core=TRUE)
    .scfdata.update( energy=.scf_energy, kinetic_energy=.kinetic_energy )
    .scfdata.put_results

    do
      .extrapolate_scf
      .update_molecular_orbitals
      S.create( .n_bf, .n_bf)
      .get_overlap_matrix(S)
      .molecular_orbitals.schmidt_orthonormalise(S)
      S.destroy
      .make_scf_density_matrix
      .save_scf_results
      dP.set_to(.density_matrix)
      dP.minus(old_P)
      .make_fock_matrix(dP,dF,core=FALSE)
      .fock_matrix.set_to(old_F)
      .fock_matrix.plus(dF)
      old_P.set_to(.density_matrix)
      old_F.set_to(.fock_matrix)
      .scfdata.update( energy=.scf_energy, kinetic_energy=.kinetic_energy )
      .scfdata.put_results
      if (.scfdata.scf_done) exit
    end

    dF.destroy
    dP.destroy
    old_F.destroy
    old_P.destroy

    .scfdata.cleanup_diis
    .fock_matrix.destroy("all")
  end

  update_molecular_orbitals
  ! Solve for the molecular orbitals.  Requires a set of old molecular orbitals.
  ! The new molecular orbitals "cU" are found from the old MOs "c" by solving :
  ! (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
    STR :: kind
    BIN :: mos_exist
    VEC, PTR :: e
    CMAT, PTR :: MOc,Fc
    kind = .scfdata.kind
    mos_exist = .molecular_orbitals.created
    ENSURE(mos_exist, "need old MOs for initial guess")
    select case (kind)
       case ("rhf","restricted_hartree_fock", &
             "rohf","restricted_open_shell_hartree_fock", &
             "xray_rhf","xray_constrained")
          .update_r_MO(.orbital_energies.restricted,.molecular_orbitals.restricted,.fock_matrix.restricted)
       case ("uhf","unrestricted_hartree_fock")
          .update_r_MO(.orbital_energies.alpha,.molecular_orbitals.alpha, .fock_matrix.alpha)
          .update_r_MO(.orbital_energies.beta ,.molecular_orbitals.beta , .fock_matrix.beta )
       case ("gchf","cghf","general_complex_hartree_fock","complex_general_hartree_fock")
          e   => .orbital_energies.general
          MOc => .molecular_orbitals.general_complex
          Fc  => .fock_matrix.general_complex
          .update_gc_MO(e,MOc,Fc)
    end
  end

  update_r_MO(MO_energies,MO,F)
  ! Solve for the new molecular orbital energies "MO_energies" and the new 
  ! molecular orbitals "MO", given an initial old set (in "MO") and a fock
  ! matrix "F".  The new molecular orbitals "MO*U" are found from the old MOs
  ! "MO" by solving : (c^T F c)U = c^T S c U E ...... where U is an orthogonal
  ! matrix.
    VEC :: MO_energies
    MAT :: MO,F
    MAT, PTR :: G,U
    INT :: i

    G.create(.n_bf,.n_bf)
    U.create(.n_bf,.n_bf)
    G = F
    G.change_basis(MO)

    ! Level shifting
    if ( .scfdata.apply_level_shifting) then
      do i = .n_a + 1, .n_bf
        G(i,i) = .scfdata.level_shift + G(i,i)
      end
    end

    G.solve_eigenproblem(MO_energies,U)
    G.to_product(MO,U)
    MO = G
    U.destroy
    G.destroy
  end

  update_gc_MO(MO_energies,MO,F)
  ! Solve for the new molecular orbital energies "MO_energies" and the new 
  ! molecular orbitals "MO", given an initial old set (in "MO") and a fock
  ! matrix "F".
  ! The new molecular orbitals "MO*U" are found from the old MOs "MO" by
  ! solving (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
    VEC :: MO_energies
    CMAT :: MO,F
    CMAT, PTR :: G,U
    INT :: i
    G.create(2*.n_bf,2*.n_bf)
    U.create(2*.n_bf,2*.n_bf)
    G = F
    G.change_basis(MO)
      !  stdout.text("F in MO basis, real")
      !  stdout.put( real(G))
      !  stdout.text("F in MO basis, imag")
      !  stdout.put( aimag(G))
    ! Level shifting
    if ( .scfdata.apply_level_shifting) then
      do i = .n_e + 1, 2*.n_bf
        G(i,i) = .scfdata.level_shift + G(i,i)
      end
    end
    G.solve_eigenproblem(MO_energies,U)
      !  stdout.text("MO energies")
      !  stdout.put( MO_energies, format="column")
    G.to_product(MO,U)
    MO = G
    U.destroy
    G.destroy
  end

  kinetic_energy result (res)
  ! Evaluates the SCF kinetic energy as a trace of ".density_matrix" with the
  ! ".kinetic matrix". 
    DBL :: res
    STR :: kind
    MAT, PTR :: H
    CMAT, PTR :: HH
    kind = .scfdata.kind
    ENSURE( .density_matrix.any_created, "no density matrix")
    select case (kind)
       case ("rhf","restricted_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock")
          H.create(.n_bf,.n_bf); .get_kinetic_matrix(H)
          res = - .density_matrix.restricted.trace_of_product(H)
          H.destroy
       case ("uhf","unrestricted_hartree_fock","rohf","restricted_open_shell_hartree_fock")
          H.create(.n_bf,.n_bf); .get_kinetic_matrix(H)
          res = - .density_matrix.alpha.trace_of_product(H)
          res = - .density_matrix.beta.trace_of_product(H) + res
          H.destroy
       case ("cghf","gchf","general_complex_hartree_fock","complex_general_hartree_fock")
          HH.create(2*.n_bf,2*.n_bf); HH=ZERO
          H.create(.n_bf,.n_bf)
          .get_kinetic_matrix(H)
          HH.alpha_alpha_set_to(H)
          HH.beta_beta_set_to(H)
          H.destroy
          res = - .density_matrix.general_complex.trace_of_product(HH)
          HH.destroy
       case default; DIE("don't know what to do with " // .scfdata.kind)
    end
  end

  scf_energy result (res)
  ! Evaluates the total SCF energy (including nuclear) as a trace of 
  ! ".density_matrix" with the ".fock matrix". 
    DBL :: res
    res = .scf_electronic_energy(.density_matrix) + .nuclear_energy
  end

  put_scf_energy
  ! Out put the scf energy.
    DBL :: energy
    energy = .scf_energy
    stdout.show("The SCF energy is ", .scf_energy)
    stdout.show("The kinetic energy is ", .kinetic_energy)
  end

  scf_energy(P) result (res)
  ! Evaluates the total SCF energy (including nuclear) as a trace of 
  ! "P" with the ".fock matrix". 
    OPMAT, target :: P
    DBL :: res
    res = .scf_electronic_energy(P) + .nuclear_energy
  end

  scf_electronic_energy(P,core) result (res)
  ! Evaluates the SCF electronic energy as a trace of "D" with the ".fock
  ! matrix". 
  ! If "core" is present and FALSE, the core contribution is not added.
    OPMAT, target :: P
    BIN, optional :: core
    BIN :: add_core
    DBL :: res
    STR :: kind
    MAT, PTR :: F
    CMAT, PTR :: FF
    kind = .scfdata.kind
    ENSURE( .fock_matrix.any_created,    "no fock matrix")
    ENSURE( .density_matrix.any_created, "no density matrix")
    add_core = TRUE
    if (present(core)) add_core = core
    select case (kind)
       case ("rhf","restricted_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock")
          F.create(.n_bf,.n_bf)
          F = .fock_matrix.restricted
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P.restricted.trace_of_product(F)
          F.destroy
       case ("uhf","unrestricted_hartree_fock","rohf","restricted_open_shell_hartree_fock")
          F.create(.n_bf,.n_bf);
          F = .fock_matrix.alpha
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P.alpha.trace_of_product(F)
          F = .fock_matrix.beta
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P.beta.trace_of_product(F) + res
          F.destroy
       case ("cghf","gchf","general_complex_hartree_fock","complex_general_hartree_fock")
          FF.create(2*.n_bf,2*.n_bf);
          FF = .fock_matrix.general_complex
          if (add_core) .add_core_hamiltonian(FF)
          res = HALF * P.general_complex.trace_of_product(FF)
          FF.destroy
       case default; DIE("not yet implemented, " // .scfdata.kind)
    end
  end

  scf_electronic_energy(P,nuclei) result (res)
  ! Evaluates the SCF electronic energy as a trace of "D" with the ".fock
  ! matrix". 
  ! "nuclei" lists the nuclei to be used for obtaining n->e attractions.
    OPMAT, target :: P
    IVEC :: nuclei
    BIN :: add_core
    DBL :: res
    STR :: kind
    MAT, PTR :: F
    CMAT, PTR :: FF
    kind = .scfdata.kind
    ENSURE( .fock_matrix.any_created,    "no fock matrix")
    ENSURE( .density_matrix.any_created, "no density matrix")
    add_core = TRUE
    select case (kind)
       case ("rhf","restricted_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock")
          F.create(.n_bf,.n_bf)
          F = .fock_matrix.restricted
          .add_core_hamiltonian(F,nuclei)
          res = HALF * P.restricted.trace_of_product(F)
          F.destroy
       case ("uhf","unrestricted_hartree_fock","rohf","restricted_open_shell_hartree_fock")
          F.create(.n_bf,.n_bf);
          F = .fock_matrix.alpha
          .add_core_hamiltonian(F,nuclei)
          res = HALF * P.alpha.trace_of_product(F)
          F = .fock_matrix.beta
          .add_core_hamiltonian(F,nuclei)
          res = HALF * P.beta.trace_of_product(F) + res
          F.destroy
       case ("cghf","gchf","general_complex_hartree_fock","complex_general_hartree_fock")
          FF.create(2*.n_bf,2*.n_bf);
          FF = .fock_matrix.general_complex
          .add_core_hamiltonian(FF,nuclei)
          res = HALF * P.general_complex.trace_of_product(FF)
          FF.destroy
       case default; DIE("not yet implemented, " // .scfdata.kind)
    end
  end

  get_scf_results [leaky]
  ! Get the SCF results in from archives. Do not get the density matrix, because
  ! it can/should be generated from the orbitals, depending on the kind of SCF.
    ARCHIVE :: archive
    STR :: k
    k = .scfdata.molecular_orbital_kind
    archive.set(.name,"molecular_orbitals",kind=k)
    archive.read(.molecular_orbitals,kind=k)
    k = .scfdata.orbital_energies_kind
    archive.set(.name,"orbital_energies",kind=k)
    archive.read(.orbital_energies,kind=k)
  end

  save_scf_results
  ! Save the SCF results in various archives
    ARCHIVE :: archive
    archive.set(.name,"density_matrix")
    archive.write(.density_matrix)
    archive.set(.name,"molecular_orbitals")
    archive.write(.molecular_orbitals)
    archive.set(.name,"orbital_energies")
    archive.write(.orbital_energies)
  end

  destroy_scf_results [leaky]
  ! Destroy the SCF results
    .density_matrix.destroy
    .density_matrix.create(.n_bf)
    .molecular_orbitals.destroy
    .molecular_orbitals.create(.n_bf)
    .orbital_energies.destroy
    .orbital_energies.create(.n_bf)
  end

  delete_integrals
  ! Delete all integral files.
  ! This is required whenever the geometry is changed.
     ARCHIVE :: archive
     archive.set(.name,"overlap_matrix")
     archive.delete
     archive.set(.name,"kinetic_matrix")
     archive.delete
     archive.set(.name,"nuclear_matrix")
     archive.delete
     archive.set(.name,"core_matrix")
     archive.delete
     archive.set(.name,"fock_matrix")
     archive.delete
     archive.set(.name,"eri_integrals")
     archive.delete
     archive.set(.name,"eri_index")
     archive.delete
     archive.set(.name,"ft_ints")
     archive.delete
  end

  delete_matrices
  ! Delete any matrices stored on disk.
     ARCHIVE :: archive
     archive.set(.name,"density_matrix")
     archive.delete_all
     archive.set(.name,"molecular_orbitals")
     archive.delete_all
     archive.set(.name,"orbital_energies")
     archive.delete_all
  end

  canonicalize_MOs
  ! Generate the Fock matrix from the molecular orbitals and diagonalise it 
  ! on the occupied-occupied block to get the canonical molecular orbitals.
    STR :: kind
    VEC, PTR :: e
    CMAT, PTR :: MOc,Fc
    ENSURE(.molecular_orbitals.created, "need old MOs for initial guess")
    ENSURE(.orbital_energies.created, "need old energies")
    .make_scf_density_matrix
    .make_fock_matrix  
    kind = .scfdata.kind
    select case (kind)
       case ("rhf","restricted_hartree_fock", &
             "rohf","restricted_open_shell_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock", &
             "xray_fit","xray_constrained")
          .orbital_energies.destroy
          .orbital_energies.create(.n_bf,"restricted")
          .canonicalize_r_MO(.orbital_energies.restricted, &
                             .molecular_orbitals.restricted, &
                             .fock_matrix.restricted)
          stdout.flush
          stdout.text("Canonicalized molecular orbital energies:")
          stdout.put( .orbital_energies.restricted(1:.n_e/2), format="column")
       case default; DIE("unknown or unimplemented code")
    end
  end

  canonicalize_r_MO(MO_energies,MO,F)
  ! Digaonalise the Fock matrix "F" in the occupied-occupied block of the
  ! molecular orbitals "MO", and reset the occupied "MO_energies".
    VEC :: MO_energies
    MAT :: MO,F
    MAT, PTR :: G,U,MO_old
    INT :: n
    n = .n_e/2
    G.create(n,n)
    U.create(n,n)
    MO_old.create(.n_bf,n)
    MO_old = MO(:,1:n)
    F.change_basis(G,MO_old)
    MO_energies = ZERO
    G.solve_eigenproblem(MO_energies,U)
    MO(:,1:n).to_product(MO_old,U)
    MO_old.destroy
    U.destroy
    G.destroy
  end

!*******************************
! Initial orbital guess routines
!*******************************

  get_initial_guess [leaky]
  ! Get the initial guess for the ".density_matrix" and ".molecular_orbitals"
  ! If .scfdata.initial_mos is set, it overides .initial_density.
     STR :: initial_mos
     initial_mos = .scfdata.initial_mos
     if (initial_mos/=" ") then; .get_initial_MOs
     else;                       .get_initial_density
     end
  end

  get_initial_MOs [leaky]
  ! Get the initial guess for the .molecular_orbitals
  ! Convert the .molecular_orbitals, if neccesary.
     STR :: initial_mos
     initial_mos = .scfdata.initial_mos
     select case (initial_mos)
      ! case ("atom")
      !    .make_atom_MOs_guess
        case("restricted","unrestricted","general", &
             "restricted_complex","unrestricted_complex","general_complex", &
             "complex_restricted","complex_unrestricted","complex_general")
           .read_old_MOs_guess
        case default
           DIE("unknown initial MO's, "// initial_mos.trim)
     end
  end

  read_old_MOs_guess [leaky]
  ! Get the initial guess for the .molecular_orbitals by reading an old archive of 
  ! .molecular_orbitals, and then make the SCF density matrix as well. 
  ! Convert the .molecular_orbitals, if neccesary.
     STR :: kind
     ARCHIVE :: archive
     kind = .scfdata.initial_mos
     archive.set(.name,"molecular_orbitals",kind=kind)
     archive.read(.molecular_orbitals)
     .molecular_orbitals.convert_to( .scfdata.molecular_orbital_kind,.n_bf,.n_a,.n_b)
     .make_scf_density_matrix
     .orbital_energies.create(kind=.scfdata.orbital_energies_kind)
  end

  make_atom_MOs_guess [leaky]
  ! Get the initial guess for the .molecular_orbitals by getting the highest
  ! occupied restricted natural orbitals from the sum of atomic densities guess 
  ! for the density matrix. Convert these .molecular_orbitals, if neccesary.
  ! Also make the SCF .density_matrix from these .molecular_orbitals.
     STR :: initial_mos,kind
     ARCHIVE :: archive
     .get_atom_density
     kind = .density_matrix.spinorbital_kind
     if (kind/="restricted") then
        archive.set(.name,"atom_density_matrix", kind="restricted")
        .density_matrix.destroy("restricted")
        archive.read(.density_matrix)
     end
     .make_natural_orbitals
     .put_natural_orbitals
     .assign_MOs_to_NOs
     kind = .scfdata.molecular_orbital_kind
     .molecular_orbitals.convert_to(kind,.n_bf,.n_a,.n_b)
     .make_scf_density_matrix
     .orbital_energies.create(kind=.scfdata.orbital_energies_kind)
  end

  get_initial_density [leaky]
  ! Get the initial guess for the ".density_matrix" 
     STR :: initial_density
     initial_density = .scfdata.initial_density
     select case (initial_density)
        case ("core"); .make_core_guess
        case ("fock"); .make_fock_guess
        case ("atom"); .make_atom_guess
        case("restricted","unrestricted","general", &
             "restricted_complex","unrestricted_complex","general_complex", &
             "complex_restricted","complex_unrestricted","complex_general")
           .make_density_guess
        case default
           DIE("unknown initial guess density, "// initial_density.trim)
     end
  end

  make_density_guess [leaky]
  ! Read an old .density_matrix of type "initial_guess" and use it to
  ! make initial .molecular_orbitals to start an scf calculation.
  ! Convert the .density_matrix, if neccesary.
     STR :: initial_density
     ARCHIVE :: archive
     initial_density = .scfdata.initial_density
     archive.set(.name,"density_matrix")
     archive.read(.density_matrix,kind=initial_density)
     .density_matrix.convert_to(newkind = .scfdata.spinorbital_kind)
     .make_fock_matrix  ! Make a fock matrix
     .make_fock_guess   ! Get a reasonable set of starting MO's
  end

  make_core_guess [leaky]
  ! Do a core scf for the ".density_matrix", ".molecular_orbitals" and
  ! ".orbital_energies"
    STR :: kind
    .destroy_scf_results
    .orbital_energies.destroy("restricted")
    .orbital_energies.create("restricted")
    .molecular_orbitals.destroy("restricted")
    .molecular_orbitals.create("restricted")
    .make_r_core_guess(.orbital_energies.restricted,.molecular_orbitals.restricted)
    kind = .scfdata.orbital_energies_kind
    .orbital_energies.convert_to(kind)
    kind = .scfdata.molecular_orbital_kind
    .molecular_orbitals.convert_to(kind,factor=HALF)
    .make_scf_density_matrix
    .make_fock_matrix  ! Make a fock matrix (only to get MO's)
    .make_fock_guess   ! Get a reasonable set of starting MO's
  end

  make_r_core_guess(MO_energies,MO)
  ! Do a real core scf for the molecular orbital energies  "MO_energies" 
  ! and the molecular_orbitals "MO"
    VEC :: MO_energies
    MAT :: MO
    MAT, PTR :: S,R,H
    !  H~ = S^-1/2 H S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
    R.create(.n_bf,.n_bf); R.to_inverse_sqrt(S)
    H.create(.n_bf,.n_bf); .get_core_matrix(H)
    S.to_product(R,H)
    H.to_product(S,R)
    H.solve_eigenproblem(MO_energies,MO)
    H.to_product(R,MO)
    MO = H
    H.destroy
    R.destroy
    S.destroy
  end

  make_atom_guess [leaky]
  ! Make a ".density matrix" and fock matrix from the sum of atomic densities.
  ! Then get initial orbitals from this fock matrix, and make the density
  ! corresponding to these initial orbitals.
     ENSURE(.scfdata.kind/="rohf","atom guess not available for ROHF")
     .get_atom_density
     .make_fock_matrix       ! Make a fock matrix (only to get MO's)
     .make_fock_guess        ! Get a reasonable set of starting MO's
  end

  get_atom_density [leaky]
  ! Reads ".density_matrix" from the archive, otherwise makes it and
  ! writes to the archive.
    ARCHIVE :: archive
    archive.set(.name,"atom_density_matrix", kind="restricted")
    if ( archive.exists) then
       archive.read(.density_matrix)
       .density_matrix.convert_to( .scfdata.spinorbital_kind,factor=HALF)
    else
       .make_atom_density
    end
  end

  make_atom_density(output) [leaky]
  ! Make a ".density matrix" from the sum of atomic densities
  ! if output is present and FALSE the density matrix is not archived
    BIN, OPTIONAL :: output
    BIN :: do_output
    INT :: k,n_k,l,kl,a,b
    MOL, PTR :: mol
    IVEC, PTR :: first,last
    IVECVEC, PTR :: atom_kind
    ARCHIVE :: archive
    ENSURE( .scfdata.created, "no scf data present.")
    do_output=TRUE
    if (present(output)) do_output=output
    .density_matrix.destroy("restricted")
    .density_matrix.create("restricted")
    .density_matrix.restricted = ZERO
    .atom.make_atom_basis_fn_limits(first,last)
    .atom.make_atom_kind_list(atom_kind)
    n_k = size(atom_kind)
    do k = 1,n_k ! Do an SCF for every different kind of atom
      mol.create
      l = atom_kind(k).vec(1)
      .make_molecule_from_atom(l,mol)
      if (mol.no_of_electrons >= 1) then
        mol.scfdata.convergence = 0.0001
        mol.scfdata.output = FALSE
        mol.scfdata.direct = TRUE
        mol.scf
        mol.make_ao_density_matrix
        mol.pointgroup.create("oh")
        mol.symmetrise(mol.density_matrix)
        do l = 1,size(atom_kind(k).vec) ! Copy this atom density 
          kl = atom_kind(k).vec(l)
          a = first(kl); b = last(kl)
         .density_matrix.restricted(a:b,a:b) = &
         .density_matrix.restricted(a:b,a:b) &
         + mol.density_matrix.restricted
        end
      end
      mol.atom.nullify_ptr_part ! do not destroy these
      nullify(mol.basis)        ! do not destroy this
      mol.delete_integrals
      mol.delete_matrices
      mol.destroy
    end
    if (do_output) then
     archive.set(.name,"atom_density_matrix", kind="restricted")
     archive.write(.density_matrix, kind="restricted")
    end
    .density_matrix.convert_to( .scfdata.spinorbital_kind,factor=HALF)
    atom_kind.destroy
    last.destroy
    first.destroy
  end

  make_fock_guess [leaky]
  ! From an initial .fock_matrix make the .molecular_orbitals, and .orbital_energies.
  ! Then make the .density_matrix from these orbitals. Destroy .fock_matrix afterwards
    STR :: kind
    VEC, PTR :: e
    MAT, PTR :: MO,F
    CMAT, PTR :: MOc,Fc
    kind = .scfdata.spinorbital_kind
    ENSURE( .fock_matrix.created(kind),"need an initial fock matrix")
    .destroy_scf_results
    kind = .scfdata.kind
    select case (kind)
    !  F~ = S^-1/2 F S^-1/2
    !  c  = S^-1/2 c~
       case ("rhf","restricted_hartree_fock", &
             "rohf","restricted_open_shell_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock", &
             "xray_fit","xray_constrained")
          .orbital_energies.destroy("restricted")
          .orbital_energies.create("restricted")
          .molecular_orbitals.destroy("restricted")
          .molecular_orbitals.create("restricted")
          e  => .orbital_energies.restricted
          MO => .molecular_orbitals.restricted
          F  => .fock_matrix.restricted
          .make_r_fock_guess(e,MO,F)
       case ("uhf","unrestricted_hartree_fock")
          .orbital_energies.destroy("unrestricted")
          .orbital_energies.create("unrestricted")
          .molecular_orbitals.destroy("unrestricted")
          .molecular_orbitals.create("unrestricted")
          e  => .orbital_energies.alpha
          MO => .molecular_orbitals.alpha
          F  => .fock_matrix.alpha
          .make_r_fock_guess(e,MO,F)
          e  => .orbital_energies.beta
          MO => .molecular_orbitals.beta
          F  => .fock_matrix.beta
          .make_r_fock_guess(e,MO,F)
       case ("cghf","gchf","general_complex_hartree_fock","complex_general_hartree_fock")
          .orbital_energies.destroy("general")
          .orbital_energies.create("general")
          .molecular_orbitals.destroy("general_complex")
          .molecular_orbitals.create("general_complex")
          e   => .orbital_energies.general
          MOc => .molecular_orbitals.general_complex
          Fc  => .fock_matrix.general_complex
          .make_gc_fock_guess(e,MOc,Fc)
       case default; DIE("unknown spinorbital kind, " // kind.trim)
    end
    kind = .scfdata.spinorbital_kind
    .fock_matrix.destroy(kind)
    .make_scf_density_matrix
    .save_scf_results
  end

  make_r_fock_guess(MO_energies,MO,fock_matrix) 
  ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
  ! a given real restricted "fock_matrix".
    VEC :: MO_energies
    MAT :: MO, fock_matrix
    MAT, PTR :: S,R,H
    !  F~ = S^-1/2 F S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
    R.create(.n_bf,.n_bf); R.to_inverse_sqrt(S)
    H.create(.n_bf,.n_bf); H = fock_matrix
    S.to_product(R,H)
    H.to_product(S,R)
    H.solve_eigenproblem(MO_energies,MO)
    H.to_product(R,MO)
    MO = H
    H.destroy
    R.destroy
    S.destroy
  end

  make_gc_fock_guess(MO_energies,MO,fock_matrix) 
  ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
  ! a given complex general "fock_matrix".
    VEC :: MO_energies
    CMAT :: MO, fock_matrix
    MAT, PTR :: S,R
    CMAT, PTR :: H,W
    !  F~ = S^-1/2 F S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf)
    R.create(.n_bf,.n_bf)
    .get_overlap_matrix(R)
    S.to_inverse_sqrt(R)
    R.destroy
    R.create(2*.n_bf,2*.n_bf); R=ZERO
    R.alpha_alpha_set_to(S)
    R.beta_beta_set_to(S)
    S.destroy
    H.create(2*.n_bf,2*.n_bf); H = fock_matrix
    W.create(2*.n_bf,2*.n_bf)
    W = matmul(R,H)
    H = matmul(W,R)
    W.destroy
    H.solve_eigenproblem(MO_energies,MO)
    H = matmul(R,MO)
    MO = H
    H.destroy
    R.destroy
  end
 
! ******************
! DIIS extrapolation 
! ******************

   extrapolate_scf 
   ! Extrapolate the scf objects
      STR :: kind
      OPMAT, PTR :: error
      CMAT, PTR :: err,F,P
      if ( .scfdata.skip_diis) return
      kind = .scfdata.kind
      select case (kind)
         case ("rhf","restricted_hartree_fock", &
               "xray_rhf","xray_constrained_restricted_hartree_fock", &
               "xray_fit","xray_constrained")
            error.create(.n_bf,"restricted")
            .make_r_diis_error(error.restricted,.fock_matrix.restricted,.density_matrix.restricted)
            error.compress
            .fock_matrix.compress
            .scfdata.diis.extrapolate(.fock_matrix.triangle,error.triangle)
            .fock_matrix.uncompress
            error.destroy
         case ("rohf","restricted_open_shell_hartree_fock")
            error.create(.n_bf,"restricted")
            .make_r_diis_error(error.restricted,.fock_matrix.restricted,.density_matrix.alpha)
            error.compress
            .fock_matrix.compress("restricted")
            .scfdata.diis.extrapolate(.fock_matrix.triangle,error.triangle)
            .fock_matrix.uncompress
            error.destroy
         case ("uhf","unrestricted_hartree_fock")
            error.create(.n_bf,"unrestricted")
            .make_r_diis_error(error.alpha,.fock_matrix.alpha,.density_matrix.alpha)
            .make_r_diis_error(error.beta, .fock_matrix.beta, .density_matrix.beta)
            error.compress
            .fock_matrix.compress
            .scfdata.diis.extrapolate(.fock_matrix.triangle,error.triangle)
            .fock_matrix.uncompress
            error.destroy
         case ("gchf","cghf","complex_general_hartree_fock","general_complex_hartree_fock")
            error.create(.n_bf,"general_complex")
            err => error.general_complex
            F   => .fock_matrix.general_complex
            P   => .density_matrix.general_complex
            .make_gc_diis_error(err,F,P)
            error.compress
            .fock_matrix.compress
            .scfdata.diis.extrapolate(.fock_matrix.square,error.square)
            .fock_matrix.uncompress
            error.destroy
      end
   end

   make_r_diis_error(error,F,P)
   ! Make the real DIIS error matrix, error = FPS - SPF
      MAT :: error,F,P
      MAT, PTR :: S,W
      W.create(.n_bf, .n_bf)
      S.create(.n_bf, .n_bf); .get_overlap_matrix(S)
      W.to_product(P,S)
      S.destroy
      error.to_product(F,W)
      W.destroy
      error.antisymmetric_fold
      error.make_antisymmetric
   end

   make_gc_diis_error(error,F,P)
   ! Make the complex general DIIS error matrix, error = FPS - SPF
      CMAT :: error,F,P
      MAT, PTR :: R
      CMAT, PTR :: S,W
      W.create(2*.n_bf, 2*.n_bf)
      S.create(2*.n_bf,2*.n_bf); S=ZERO
      R.create(.n_bf,.n_bf)
      .get_overlap_matrix(R)
      S.alpha_alpha_set_to(R)
      S.beta_beta_set_to(R)
      R.destroy
      W.to_product(P,S)
      S.destroy
      error.to_product(F,W)
      W.destroy
      error.antihermitian_fold
      error.make_antihermitian
   end
 
! *******************
! Pairwise SCF energy
! *******************

   put_scf_energy_in_mo_pairs
   ! Analyse the SCF energy into MO pairs
      OPMAT, PTR :: Di
      VEC, PTR :: core_energy
      MAT, PTR :: pair_energy
      INT :: i,j
      DBL :: energy,fac
      BIN :: direct
      core_energy.create(.n_a)
      pair_energy.create(.n_a,.n_a)
      core_energy = ZERO
      pair_energy = ZERO
      Di.create(.n_bf)
      direct = .scfdata.direct
      .scfdata.direct = TRUE 
      do i = 1,.n_a
         .make_scf_density_matrix(i) 
         Di.set_to(.density_matrix)
         .make_fock_matrix(core=TRUE,r12=FALSE)
         core_energy(i) = .scf_electronic_energy(Di,core=TRUE)
         do j = 1,i
            .make_scf_density_matrix(j)
            .make_fock_matrix(core=FALSE,r12=TRUE)
            fac = TWO
            if (i==j) fac = ONE
            pair_energy(i,j) = fac*.scf_electronic_energy(Di,core=FALSE)
         end
      end  
      Di.destroy
      .scfdata.direct = direct
      stdout.flush
      stdout.text("SCF MO pair energy decomposition:",flush=1)
      energy = sum(core_energy)+sum(transfer(pair_energy,(/ONE/)))+.nuclear_energy
      stdout.show("SCF energy =",energy)
      stdout.text("Core energies:",flush=1)
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=1)
      stdout.put("MO_i",int_width=TRUE)
      stdout.put("Core energy")
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=1)
      do i = 1,.n_a
         stdout.put(i)
         stdout.put(core_energy(i),flush=1)
      end 
      stdout.dash(int_fields=1,dbl_fields=1)
      stdout.flush
      stdout.text("Orbital pair energies:",flush=1)
      stdout.dash(int_fields=2,dbl_fields=1)
      stdout.put("MO_i",int_width=TRUE)
      stdout.put("MO_j",int_width=TRUE)
      stdout.put("Pair energy",flush=1)
      stdout.dash(int_fields=2,dbl_fields=1)
      do i = 1,.n_a
      do j = 1,i
         stdout.put(i)
         stdout.put(j)
         stdout.put(pair_energy(i,j),flush=1)
      end 
      end 
      stdout.dash(int_fields=2,dbl_fields=1)
      stdout.flush
  end

!*********************
! Fock matrix routines
!*********************

  get_fock_matrix [leaky]
  ! Get the Fock matrix. If already in memory, do nothing. Else if 
  ! the archive file exists, read it. Otherwise make it.
     ARCHIVE :: archive
     STR :: kind
     kind = .scfdata.spinorbital_kind
     archive.set(.name,"fock_matrix",kind)
     if ( archive.exists) then; archive.read(.fock_matrix)
     else;                      .make_fock_matrix
     end
  end

  make_fock_matrix(core,r12) [leaky]
  ! If core is present and FALSE, the core hamiltonian is not added
  ! If r12  is present and FALSE, the r12 part is not computed
    BIN, optional :: core,r12
    BIN :: direct
    STR :: scf_kind 
    scf_kind = .scfdata.kind 
    direct = .scfdata.direct 
    if (NOT direct) .get_eri_integrals
    select case (scf_kind)
       case ("rhf","restricted_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock")
                                 .make_r_fock(direct,core,r12)
       case ("rohf","restricted_open_shell_hartree_fock")
                                 .make_ro_fock(direct,core,r12)
       case ("uhf","unrestricted_hartree_fock")
                                 .make_u_fock(direct,core,r12)
       case ("gchf","cghf", &
             "general_complex_hartree_fock","complex_general_hartree_fock")
                                 .make_gc_fock(direct,core,r12) 
                                 .add_gc_so_fock 
       case default; DIE("unknown scf kind, "// scf_kind.trim)
    end
  end

  make_fock_matrix(P,F,core,r12) [leaky]
  ! For the quicker ERI method.
    OPMAT, PTR :: P,F
    BIN, optional :: core,r12
    STR :: scf_kind 
    BIN :: direct
    scf_kind = .scfdata.kind 
    direct = .scfdata.direct 
    select case (scf_kind)
       case ("rhf","restricted_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock")
                                 .make_r_fock(P,F,direct,core,r12)
       case ("rohf","restricted_open_shell_hartree_fock")
                                 .make_ro_fock(P,F,direct,core,r12)
       case ("uhf","unrestricted_hartree_fock")
                                 .make_u_fock(P,F,direct,core,r12)
       case ("gchf","cghf", &
             "general_complex_hartree_fock","complex_general_hartree_fock")
                                 .make_gc_fock(P,F,direct,core,r12) 
                                 .add_gc_so_fock(P,F)
       case default; DIE("unknown scf kind, "// scf_kind.trim)
    end
  end

  add_core_hamiltonian(F,nuclei)
  ! Add the core hamiltonain to "F"
  ! if "nuclei" is present then the core_matrix is calculated using 
  ! only the nuclei specified
     MAT :: F
     IVEC, optional :: nuclei
     MAT, PTR :: H
     H.create( .n_bf, .n_bf)
     .get_core_matrix(H,nuclei)
     F = F + H
     H.destroy
  end

  add_core_hamiltonian(F,nuclei)
  ! Add the core hamiltonain to a general complex "F"
     CMAT :: F
     IVEC, optional :: nuclei
     CMAT,PTR :: HH
     MAT, PTR :: H,S,T,xx,yy,zz,xy,xz,yz,Lx,Ly,Lz
     MAT(3,3) :: BB
     INT :: k,l
     DBL :: fac
     CDBL :: I
     HH.create( 2*.n_bf, 2*.n_bf); HH = ZERO
     H.create( .n_bf, .n_bf)
     .get_core_matrix(H,nuclei)
     HH.alpha_alpha_plus(H)
     HH.beta_beta_plus(H)
     H.destroy
     I = (ZERO,ONE)
     if ( .scfdata.using_1e_sl_term) then
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_spin_orbit_matrices(Lx,Ly,Lz) 
           fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
           fac = fac * .scfdata.sl_1e_factor
           HH.beta_alpha_plus(Lx,factor=-fac*I)
           HH.beta_alpha_plus(Ly,factor=fac)
           HH.alpha_alpha_plus(Lz,factor=-fac*I)
           HH.beta_beta_plus(Lz,factor=fac*I)
           Lz.destroy; Ly.destroy; Lx.destroy
     else if ( .scfdata.using_1e_zora_term) then
           T.create(.n_bf,.n_bf)
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_1e_ZORA_matrices(T,Lx,Ly,Lz) 
           HH.alpha_alpha_plus(T)
           HH.beta_beta_plus(T)
           .get_kinetic_matrix(T) ! remove normal kinetic energy
           HH.alpha_alpha_plus(T,factor=-ONE)
           HH.beta_beta_plus(T,factor=-ONE)
           fac = -G_FACTOR/TWO  ! minus factor to be consistent with above
           fac = fac * .scfdata.sl_1e_factor
           HH.beta_alpha_plus(Lx,factor=-fac*I)
           HH.beta_alpha_plus(Ly,factor=fac)
           HH.alpha_alpha_plus(Lz,factor=-fac*I)
           HH.beta_beta_plus(Lz,factor=fac*I)
           T.destroy
           Lz.destroy; Ly.destroy; Lx.destroy
     end
     if ( .B_field.is_not_zero) then
        if ( .scfdata.using_bs_term) then
           S.create(.n_bf,.n_bf)
           .get_overlap_matrix(S) 
           fac = G_FACTOR/FOUR
           HH.alpha_alpha_plus(S,factor=fac*.B_field(3))
           HH.beta_beta_plus(S,factor=-fac*.B_field(3))
           HH.beta_alpha_plus(S,factor=fac*.B_field(1))
           HH.beta_alpha_plus(S,factor=fac*.B_field(2)*I)
           S.destroy
        end
        if ( .scfdata.using_bs_t_term) then
           T.create(.n_bf,.n_bf)
           .get_kinetic_matrix(T) 
           fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU**2)
           HH.alpha_alpha_plus(T,factor=fac*.B_field(3))
           HH.beta_beta_plus(T,factor=-fac*.B_field(3))
           HH.beta_alpha_plus(T,factor=fac*.B_field(1))
           HH.beta_alpha_plus(T,factor=fac*.B_field(2)*I)
           T.destroy
        end
        if ( .scfdata.using_bl_term) then
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_L_matrices(Lx,Ly,Lz) 
           Lx = Lx*.B_field(1) + Ly*.B_field(2) + Lz*.B_field(3)
           fac = HALF
           HH.alpha_alpha_plus(Lx,factor=fac*I)
           HH.beta_beta_plus(Lx,factor=fac*I)
           Lz.destroy; Ly.destroy; Lx.destroy
        end
        if ( .scfdata.using_aa_term) then
          xx.create(.n_bf,.n_bf); yy.create(.n_bf,.n_bf); zz.create(.n_bf,.n_bf)
          xy.create(.n_bf,.n_bf); xz.create(.n_bf,.n_bf); yz.create(.n_bf,.n_bf)
          .get_quadrupole_matrices(xx,yy,zz,xy,xz,yz) 
          fac = ONE/EIGHT
          do k = 1,3
             BB(k,k) = fac*(sum(.B_field*.B_field) - .B_field(k)*.B_field(k))
          end
          do k = 1,3
          do l = k+1,3
             BB(k,l) = -TWO*fac*.B_field(k)*.B_field(l)
          end
          end
          xx =      BB(1,1)*xx; xx = xx + BB(2,2)*yy; xx = xx + BB(3,3)*zz
          xx = xx + BB(1,2)*xy; xx = xx + BB(1,3)*xz; xx = xx + BB(2,3)*yz
          HH.alpha_alpha_plus(xx)
          HH.beta_beta_plus(xx)
          yz.destroy; xz.destroy; xy.destroy
          zz.destroy; yy.destroy; xx.destroy
        end
        if ( .scfdata.using_1e_srxa_term) then
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_spin_orbit_B_matrices(Lx,Ly,Lz) 
           fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
           HH.beta_alpha_plus(Lx,factor=fac)
           HH.beta_alpha_plus(Ly,factor=fac*I)
           HH.alpha_alpha_plus(Lz,factor=fac)
           HH.beta_beta_plus(Lz,factor=-fac)
           Lz.destroy; Ly.destroy; Lx.destroy
        end
     end
     HH.make_hermitian
     F = HH + F
     HH.destroy
  end

  make_r_fock(direct,core,r12) [leaky]
  ! Make a new restricted Fock matrix. 
    BIN, optional :: direct,core,r12
    .make_r_fock(.density_matrix,.fock_matrix,direct,core,r12)
  end

  make_u_fock(direct,core,r12) [leaky]
  ! Make a new unrestricted Fock matrix. 
    BIN, optional :: direct,core,r12
    .make_u_fock(.density_matrix,.fock_matrix,direct,core,r12)
  end

  make_ro_fock(direct,core,r12) [leaky]
  ! Make a new restricted open shell Fock matrix. 
    BIN, optional :: direct,core,r12
    .make_ro_fock(.density_matrix,.fock_matrix,direct,core,r12)
  end

  make_gc_fock(direct,core,r12) [leaky]
  ! Make a new complex general Fock matrix.
    BIN, optional :: direct,core,r12
    .make_gc_fock(.density_matrix,.fock_matrix,direct,core,r12)
  end

  add_gc_so_fock [leaky]
  ! Add the general complex two electron spin orbit contribution to the 
  ! .fock_matrix. 
    .add_gc_so_fock(.density_matrix,.fock_matrix)
  end

  make_r_fock(P,F,direct,core,r12) [leaky]
  ! Make a new restricted Fock matrix "F" from the density matrix "P".
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    OPMAT, PTR :: P,F
    MAT, PTR :: J,K
    BIN :: do_direct,add_core,add_r12
    ENSURE(P.created,"no density matrix")
    ENSURE(F.created,"no fock matrix")
    ENSURE(F.n_bf == .n_bf, "Fock matrix dimensions wrong")
    ENSURE(P.n_bf == .n_bf, "Density matrix dimensions wrong")
    ENSURE(P.restricted.created, "no density matrix")
    F.destroy("restricted")
    F.create("restricted")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core))   add_core = core
    if (present(r12))    add_r12  = r12
    if (add_r12) then
       J.create(.n_bf,.n_bf)
       K.create(.n_bf,.n_bf)
       if (do_direct) then; .make_r_JK_direct(J,K,P.restricted)
       else;                .make_r_JK_disk(J,K,P.restricted)
       end
       F.restricted = J - HALF*K 
       K.destroy
       J.destroy
    else
       F.restricted = ZERO
    end
    if (add_core) .add_core_hamiltonian(F.restricted)
  end

  make_u_fock(P,F,direct,core,r12) [leaky]
  ! Make a new unrestricted Fock matrix. 
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    OPMAT, PTR :: P,F
    BIN, optional :: direct,core,r12
    MAT, PTR :: J,Ka,Kb,Pab
    BIN :: do_direct,add_core,add_r12
    ENSURE(P.created,"no density matrix")
    ENSURE(F.created,"no fock matrix")
    ENSURE(P.alpha.created,"no density matrix")
    ENSURE(P.beta.created, "no density matrix")
    ENSURE(F.n_bf == .n_bf, "Fock matrix dimensions wrong")
    ENSURE(P.n_bf == .n_bf, "Density matrix dimensions wrong")
    F.destroy("unrestricted")
    F.create("unrestricted")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core))   add_core = core
    if (present(r12))    add_r12  = r12
    if (add_r12) then
       J.create(.n_bf,.n_bf)
       Ka.create(.n_bf,.n_bf)
       Kb.create(.n_bf,.n_bf)
       Pab.create(.n_bf,.n_bf)
       Pab  = P.alpha + P.beta
       if (do_direct) then; .make_u_JK_direct(J,Ka,Kb,Pab,P.alpha,P.beta)
       else;                .make_u_JK_disk(J,Ka,Kb,Pab,P.alpha,P.beta)
       end
       Pab.destroy
                               ! stdout.text("J:")
                               ! stdout.put(J)
                               ! stdout.text("Ka:")
                               ! stdout.put(Ka)
                               ! stdout.text("Kb:")
                               ! stdout.put(Kb)
       F.alpha = J - Ka 
       F.beta = J - Kb 
       Kb.destroy
       Ka.destroy
       J.destroy
    else
       F.alpha = ZERO
       F.beta  = ZERO
    end
                               ! stdout.text("r12 part")
                               ! .put_fock_matrix
    if (add_core) .add_core_hamiltonian(F.alpha)
    if (add_core) .add_core_hamiltonian(F.beta)
                               ! stdout.text("total fock")
                               ! .put_fock_matrix
  end

  make_ro_fock(P,F,direct,core,r12) [leaky]
  ! Make a new restricted open shell Fock matrix. 
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    OPMAT, PTR :: F,P
    BIN, optional :: direct,core,r12
    MAT, PTR :: Fr,Fa,Fb,S,W
    ENSURE(.molecular_orbitals.restricted.created,"no orbitals")
    F.destroy("restricted")
    F.create("restricted")
    .make_u_fock(P,F,direct,core,r12)
    Fr => F.restricted
    Fa.create(.n_bf,.n_bf); Fa = F.alpha
    Fb.create(.n_bf,.n_bf); Fb = F.beta
    Fa.change_basis(.molecular_orbitals.restricted)
    Fb.change_basis(.molecular_orbitals.restricted)
    Fr = HALF*(Fa+Fb)
    Fr(.n_b+1:.n_a,     1:.n_b) = Fb(.n_b+1:.n_a,     1:.n_b)
    Fr(     1:.n_b,.n_b+1:.n_a) = Fb(     1:.n_b,.n_b+1:.n_a)
    Fr(.n_a+1:    ,.n_b+1:.n_a) = Fa(.n_a+1:    ,.n_b+1:.n_a)
    Fr(.n_b+1:.n_a,.n_a+1:    ) = Fa(.n_b+1:.n_a,.n_a+1:    )
    S => Fb; .get_overlap_matrix(S)
    W => Fa; W.to_product(.molecular_orbitals.restricted,S,transpose_a=TRUE)
    Fr.change_basis(W) ! change to AO basis
    Fb.destroy
    Fa.destroy
  end

  make_gc_fock(P,F,direct,core,r12) [leaky]
  ! Make a new complex general Fock matrix.
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    OPMAT, PTR :: P,F
    CMAT, PTR :: Ka,Kb,Kba,Pa,Pb,Pba,Fgc
    MAT, PTR :: J, Pab
    BIN :: do_direct,add_core,add_r12
    ENSURE(P.created,"no density matrix")
    ENSURE(F.created,"no fock matrix")
    ENSURE(P.general_complex.created, "no density matrix")
    ENSURE(F.n_bf == .n_bf, "Fock matrix dimensions wrong")
    ENSURE(P.n_bf == .n_bf, "Density matrix dimensions wrong")
    F.destroy("general_complex")
    F.create("general_complex")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core)) add_core = core
    if (present(r12))  add_r12  = r12
    Fgc => F.general_complex
    if (add_r12) then
       J.create(.n_bf,.n_bf)
       Ka.create(.n_bf,.n_bf)
       Kb.create(.n_bf,.n_bf)
       Kba.create(.n_bf,.n_bf)
       Pa.create(.n_bf,.n_bf);  P.general_complex.alpha_alpha_put_to(Pa)
       Pb.create(.n_bf,.n_bf);  P.general_complex.beta_beta_put_to(Pb)
       Pba.create(.n_bf,.n_bf); P.general_complex.beta_alpha_put_to(Pba)
       Pab.create(.n_bf,.n_bf)
       Pab  = Pa + Pb
       if (do_direct) then; .make_gc_JK_direct(J,Ka,Kb,Kba,Pab,Pa,Pb,Pba)
       else;                .make_gc_JK_disk(J,Ka,Kb,Kba,Pab,Pa,Pb,Pba)
       end
       Pab.destroy
       Pba.destroy
       Pb.destroy
       Pa.destroy
                               ! stdout.text("J:")
                               ! stdout.put(J)
                               ! stdout.text("Ka:")
                               ! stdout.put(Ka)
                               ! stdout.text("Kb:")
                               ! stdout.put(Kb)
       Ka = J - Ka; Fgc.alpha_alpha_set_to(Ka)
       Kb = J - Kb; Fgc.beta_beta_set_to(Kb)
       Kba = -Kba;  Fgc.beta_alpha_set_to(Kba)
       Kba.destroy
       Kb.destroy
       Ka.destroy
       J.destroy
    else
       Fgc = ZERO
    end
    Fgc.make_hermitian
                               ! stdout.text("r12 part")
                               ! .put_fock_matrix
    if (add_core) .add_core_hamiltonian(Fgc)
                               ! stdout.text("total fock")
                               ! .put_fock_matrix
  end

  add_gc_so_fock(P,F) [leaky]
  ! Make the general complex two electron spin orbit contribution to the Fock
  ! matrix. 
    OPMAT, PTR :: P,F
    CMAT5, PTR :: JS,KS,JO,KO
    CMAT4, PTR :: Pgc
    CMAT, PTR  :: Faa,Fbb,Fba
    ARCHIVE    :: SOx_archive,SOy_archive,SOz_archive,ind_archive
    CDBL :: I
    DBL :: fac
    INT :: a,b,x,y,z
    ENSURE(P.created,"no density matrix")
    ENSURE(F.created,"no fock matrix")
    ENSURE(P.general_complex.created, "no density matrix")
    ENSURE(F.general_complex.created, "no fock matrix")
    ENSURE(F.n_bf == .n_bf, "Fock matrix dimensions wrong")
    ENSURE(P.n_bf == .n_bf, "Density matrix dimensions wrong")
    if (.scfdata.using_2e_sl_term) then
      .get_spin_orbit_integrals
      Faa.create(.n_bf,.n_bf)
      Fbb.create(.n_bf,.n_bf)
      Fba.create(.n_bf,.n_bf)
      JS.create(.n_bf,.n_bf,2,2,3); KS.create(.n_bf,.n_bf,2,2,3)
      JO.create(.n_bf,.n_bf,2,2,3); KO.create(.n_bf,.n_bf,2,2,3)
      Pgc.create(.n_bf,.n_bf,2,2)
      P.general_complex.alpha_alpha_put_to(Pgc(:,:,1,1))
      P.general_complex.beta_alpha_put_to(Pgc(:,:,2,1))
      P.general_complex.alpha_beta_put_to(Pgc(:,:,1,2))
      P.general_complex.beta_beta_put_to(Pgc(:,:,2,2))
      SOx_archive.set(.name,"SOx_integrals")
      SOy_archive.set(.name,"SOy_integrals")
      SOz_archive.set(.name,"SOz_integrals")
      ind_archive.set(.name,"SO_indices")
      .make_gc_so_JK_disk(JS(:,:,:,:,1),KS(:,:,:,:,1),JO(:,:,:,:,1),KO(:,:,:,:,1),Pgc,SOx_archive,ind_archive)
      .make_gc_so_JK_disk(JS(:,:,:,:,2),KS(:,:,:,:,2),JO(:,:,:,:,2),KO(:,:,:,:,2),Pgc,SOy_archive,ind_archive)
      .make_gc_so_JK_disk(JS(:,:,:,:,3),KS(:,:,:,:,3),JO(:,:,:,:,3),KO(:,:,:,:,3),Pgc,SOz_archive,ind_archive)
      Pgc.destroy
      I = (ZERO,ONE)
      a = 1; b = 2; x = 1; y = 2; z = 3
      Faa =  THREE*JO(:,:,a,a,z) +       JO(:,:,b,b,z) + THREE*JS(:,:,a,a,z) -   JS(:,:,b,b,z) &
          +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
          +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
          -    TWO*KO(:,:,b,a,x) -       KO(:,:,a,b,x) -   TWO*KS(:,:,a,b,x) -   KS(:,:,b,a,x) &
          +  I*TWO*KO(:,:,b,a,y) -     I*KO(:,:,a,b,y) - I*TWO*KS(:,:,a,b,y) + I*KS(:,:,b,a,y) &
          -  THREE*KO(:,:,a,a,z) - THREE*KS(:,:,a,a,z)
      Fbb = -THREE*JO(:,:,b,b,z) -       JO(:,:,a,a,z) - THREE*JS(:,:,b,b,z) +   JS(:,:,a,a,z) &
          +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
          +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
          -    TWO*KO(:,:,a,b,x) -       KO(:,:,b,a,x) -   TWO*KS(:,:,b,a,x) -   KS(:,:,a,b,x) &
          -  I*TWO*KO(:,:,a,b,y) + I*KO(:,:,b,a,y)     + I*TWO*KS(:,:,b,a,y) - I*KS(:,:,a,b,y) &
          +  THREE*KO(:,:,b,b,z) + THREE*KS(:,:,b,b,z)
      Fba =    TWO*JO(:,:,a,a,x) +   TWO*JO(:,:,b,b,x) +       JS(:,:,a,a,x) +   JS(:,:,b,b,x) &
          +  I*TWO*JO(:,:,a,a,y) + I*TWO*JO(:,:,b,b,y) +     I*JS(:,:,a,a,y) + I*JS(:,:,b,b,y) &
          -    TWO*KO(:,:,a,a,x) -       KO(:,:,b,b,x) -   TWO*KS(:,:,b,b,x) -   KS(:,:,a,a,x) &
          -  I*TWO*KO(:,:,a,a,y) -     I*KO(:,:,b,b,y) - I*TWO*KS(:,:,b,b,y) - I*KS(:,:,a,a,y) &
          +        KO(:,:,b,a,z) -       KS(:,:,b,a,z)
      KO.destroy; JO.destroy; KS.destroy; JS.destroy

      fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
      fac = fac * .scfdata.sl_2e_factor
      F.general_complex.alpha_alpha_plus(Faa,factor=I*fac)
      F.general_complex.beta_beta_plus(Fbb,factor=I*fac)
      F.general_complex.beta_alpha_plus(Fba,factor=I*fac)
      Fbb = conjg(transpose(Fba))
      F.general_complex.alpha_beta_plus(Fbb,factor=-I*fac)
      Fba.destroy; Fbb.destroy; Faa.destroy
    end
  end

!**********************
! J & K matrix routines
!**********************

  make_r_JK_direct(J,K,P)
  ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a 
  ! symmetric density matrix "P" directly. 
    MAT :: J,K,P
    MAT4, PTR   :: Iabab,I
    VEC, PTR :: max_I
    SHELL4 :: shell4
    INT :: ab,cd,i_a,i_b,i_c,i_d,n_comp_a,n_comp_b
    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd,factor,P_dc,P_db,P_cb,cutoff
    DBL :: Jcd,Kbc,Kbd,Iab,Pmax,Imax
    BIN :: do_it

    J = ZERO
    K = ZERO
    cutoff = .scfdata.eri_cutoff

    max_I.create( .n_shell_pairs )
    do ab = 1, .n_shell_pairs              ! Store the largest integral for each
      .get_shell_pair(ab,i_a,i_b)          ! shell pair ab|ab
      fa = .first_basis_fn_for_shell(i_a)
      fb = .first_basis_fn_for_shell(i_b)
      la = .last_basis_fn_for_shell(i_a)
      lb = .last_basis_fn_for_shell(i_b)
      n_comp_a = la-fa+1
      n_comp_b = lb-fb+1
      .set_shell_quartet_ab(shell4,i_a,i_b)
      .set_shell_quartet_cd(shell4,i_a,i_b)
      Iabab.create(n_comp_a,n_comp_b,n_comp_a,n_comp_b)
      shell4.get_ERI(Iabab)
      shell4.destroy_ptr_part

      Imax = ZERO
      do a=1,n_comp_a
        do b=1,n_comp_b
          Iab = abs(Iabab(a,b,a,b))
          Imax = max(Iab,Imax)
        end
      end
      max_I(ab) = sqrt(Imax)
      Iabab.destroy
    end

    do ab = 1, .n_shell_pairs
      .get_shell_pair(ab,i_a,i_b)                      ! a & b shell indices.
      fa = .first_basis_fn_for_shell(i_a)
      fb = .first_basis_fn_for_shell(i_b)
      la = .last_basis_fn_for_shell(i_a)
      lb = .last_basis_fn_for_shell(i_b)
      .set_shell_quartet_ab(shell4,i_a,i_b)
      do cd = 1,ab
        .get_shell_pair(cd,i_c,i_d)                    ! c & d shell indices.

        fc = .first_basis_fn_for_shell(i_c)
        fd = .first_basis_fn_for_shell(i_d)
        lc = .last_basis_fn_for_shell(i_c)
        ld = .last_basis_fn_for_shell(i_d)

        Pmax = ZERO                    ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
        do d = fd,ld
          do c = fc,lc
            Pmax = max(abs(P(d,c)),Pmax)
            do b = fb,lb
              Pmax = max(abs(P(d,b)),abs(P(c,b)),Pmax)
              do a = fa,la
                Pmax = max(abs(P(b,a)),abs(P(d,a)),abs(P(c,a)),Pmax)
              end
            end
          end
        end
        if (Pmax * max_I(ab) * max_I(cd) > cutoff) then
          do_it = TRUE
        else
          do_it = FALSE
        end

        if (do_it) then                        ! calculate ab|cd
          fc = .first_basis_fn_for_shell(i_c)
          fd = .first_basis_fn_for_shell(i_d)
          lc = .last_basis_fn_for_shell(i_c)
          ld = .last_basis_fn_for_shell(i_d)
          .set_shell_quartet_cd(shell4,i_c,i_d)
    
          factor = ONE                         ! Evaluate the integrals'
          if (i_a==i_b) factor = HALF          ! coincidence factors
          if (i_c==i_d) factor = HALF * factor
          if (i_a==i_c AND i_b==i_d) factor = HALF * factor
    
          I.create(fa,la,fb,lb,fc,lc,fd,ld)
          shell4.get_ERI(I)
          do d = fd,ld
            do c = fc,lc
              P_dc = P(d,c)
              Jcd = ZERO
              do b = fb,lb
                P_db = P(d,b)
                P_cb = P(c,b)
                Kbc = ZERO
                Kbd = ZERO
                do a = fa,la
                  I_abcd = factor * I(a,b,c,d)
                  J(a,b) = J(a,b) + I_abcd*P_dc
                  Jcd    = Jcd    + I_abcd*P(b,a)
                  K(a,c) = K(a,c) + I_abcd*P_db
                  K(a,d) = K(a,d) + I_abcd*P_cb
                  Kbc    = Kbc    + I_abcd*P(d,a)
                  Kbd    = Kbd    + I_abcd*P(c,a)
                end
                K(b,c) = K(b,c) + Kbc
                K(b,d) = K(b,d) + Kbd
              end
              J(c,d) = J(c,d) + Jcd
            end
          end
          I.destroy
        end
        shell4.destroy_cd
      end
      shell4.destroy_ab
    end
    max_I.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(K)
    J.make_symmetric
    K.make_symmetric
    J = TWO*J 
  end

  make_r_JK_disk(J,K,P)
  ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a 
  ! symmetric density matrix "P" from disk integral archive "eri_integrals"
    MAT :: J,K,P
    ARCHIVE :: eri_archive,ind_archive
    MAT4, PTR :: I
    INT :: q,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,n_quartets
    DBL :: I_abcd,P_dc,P_db,P_cb
    eri_archive.set(.name,"eri_integrals")
    ind_archive.set(.name,"eri_index")
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    ENSURE( eri_archive.exists, "no integral file")
    ENSURE( ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J = ZERO
    K = ZERO
    n_quartets = .n_shell_quartets
    do
      ind_archive.file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
      I.create(fa,la,fb,lb,fc,lc,fd,ld)
      eri_archive.file.read(I)
      do d = fd,ld
        do c = fc,lc
          P_dc = P(d,c)
          do b = fb,lb
            P_db = P(d,b)
            P_cb = P(c,b)
            do a = fa,la
               I_abcd = I(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               J(c,d) = J(c,d) + I_abcd*P(b,a)
               K(a,c) = K(a,c) + I_abcd*P_db
               K(a,d) = K(a,d) + I_abcd*P_cb
               K(b,c) = K(b,c) + I_abcd*P(d,a)
               K(b,d) = K(b,d) + I_abcd*P(c,a)
            end
          end
        end
      end
      I.destroy
    end
    ind_archive.close
    eri_archive.close
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(K)
    J.make_symmetric
    K.make_symmetric
    J = TWO*J
  end

  make_u_JK_direct(J,Ka,Kb,P,Pa,Pb)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
  ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly. 
    MAT,target :: J,Ka,Kb,P,Pa,Pb
    MAT4, PTR   :: Iabab,I
    MAT, PTR :: abs_P
    VEC, PTR :: max_I
    SHELL4 :: shell4
    INT :: ab,cd,i_a,i_b,i_c,i_d,n_comp_a,n_comp_b
    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd,factor,Pa_db,Pa_cb,Pb_db,Pb_cb,cutoff
    DBL :: P_dc,Iab,Pmax,Jcd,Ka_bc,Ka_bd,Kb_bc,Kb_bd,Imax
    BIN :: do_it

    J  = ZERO
    Ka = ZERO
    Kb = ZERO
    cutoff = .scfdata.eri_cutoff
    abs_P.create( .n_bf, .n_bf)
    abs_P = max(abs(P),abs(Pa),abs(Pb))

    max_I.create( .n_shell_pairs )
    do ab = 1, .n_shell_pairs              ! Store the largest integral for each
      .get_shell_pair(ab,i_a,i_b)          ! shell pair ab|ab
      fa = .first_basis_fn_for_shell(i_a)
      fb = .first_basis_fn_for_shell(i_b)
      la = .last_basis_fn_for_shell(i_a)
      lb = .last_basis_fn_for_shell(i_b)
      n_comp_a = la-fa+1
      n_comp_b = lb-fb+1
      .set_shell_quartet_ab(shell4,i_a,i_b)
      .set_shell_quartet_cd(shell4,i_a,i_b)
      Iabab.create(n_comp_a,n_comp_b,n_comp_a,n_comp_b)
      shell4.get_ERI(Iabab)
      shell4.destroy_ptr_part

      Imax = ZERO
      do a=1,n_comp_a
        do b=1,n_comp_b
          Iab = abs(Iabab(a,b,a,b))
          Imax = max(Iab,Imax)
        end
      end
      max_I(ab) = sqrt(Imax)
      Iabab.destroy
    end

    do ab = 1, .n_shell_pairs
      .get_shell_pair(ab,i_a,i_b)                      ! a & b shell indices.
      .set_shell_quartet_ab(shell4,i_a,i_b)
      fa = .first_basis_fn_for_shell(i_a)
      fb = .first_basis_fn_for_shell(i_b)
      la = .last_basis_fn_for_shell(i_a)
      lb = .last_basis_fn_for_shell(i_b)

      do cd = 1,ab
        .get_shell_pair(cd,i_c,i_d)                    ! c & d shell indices.

        fc = .first_basis_fn_for_shell(i_c)
        fd = .first_basis_fn_for_shell(i_d)
        lc = .last_basis_fn_for_shell(i_c)
        ld = .last_basis_fn_for_shell(i_d)

        Pmax = ZERO                    ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
        do d = fd,ld
          do c = fc,lc
            Pmax = max(abs_P(d,c),Pmax)
            do b = fb,lb
              Pmax = max(abs_P(d,b),abs_P(c,b),Pmax)
              do a = fa,la
                Pmax = max(abs_P(b,a),abs_P(d,a),abs_P(c,a),Pmax)
              end
            end
          end
        end
        if (Pmax * max_I(ab) * max_I(cd) > cutoff) then
          do_it = TRUE
        else
          do_it = FALSE
        end

        if (do_it) then                        ! calculate ab|cd
          fc = .first_basis_fn_for_shell(i_c)
          fd = .first_basis_fn_for_shell(i_d)
          lc = .last_basis_fn_for_shell(i_c)
          ld = .last_basis_fn_for_shell(i_d)
          .set_shell_quartet_cd(shell4,i_c,i_d)
    
          factor = ONE                         ! Evaluate the integrals'
          if (i_a==i_b) factor = HALF          ! coincidence factors
          if (i_c==i_d) factor = HALF * factor
          if (i_a==i_c AND i_b==i_d) factor = HALF * factor
    
          I.create(fa,la,fb,lb,fc,lc,fd,ld)
          shell4.get_ERI(I)
          do d = fd,ld
            do c = fc,lc
              P_dc = P(d,c)
              Jcd = ZERO
              do b = fb,lb
                Pa_db = Pa(d,b)
                Pb_db = Pb(d,b)
                Pa_cb = Pa(c,b)
                Pb_cb = Pb(c,b)
                Ka_bc = ZERO
                Kb_bc = ZERO
                Ka_bd = ZERO
                Kb_bd = ZERO
                do a = fa,la
                  I_abcd  = factor  * I(a,b,c,d)
                  J(a,b)  = J(a,b)  + I_abcd*P_dc
                  Jcd     = Jcd     + I_abcd*P(b,a)
                  Ka(a,c) = Ka(a,c) + I_abcd*Pa_db
                  Ka(a,d) = Ka(a,d) + I_abcd*Pa_cb
                  Ka_bc   = Ka_bc   + I_abcd*Pa(d,a)
                  Ka_bd   = Ka_bd   + I_abcd*Pa(c,a)
                  Kb(a,c) = Kb(a,c) + I_abcd*Pb_db
                  Kb(a,d) = Kb(a,d) + I_abcd*Pb_cb
                  Kb_bc   = Kb_bc   + I_abcd*Pb(d,a)
                  Kb_bd   = Kb_bd   + I_abcd*Pb(c,a)
                end
                Ka(b,c) = Ka(b,c) + Ka_bc
                Ka(b,d) = Ka(b,d) + Ka_bd
                Kb(b,c) = Kb(b,c) + Kb_bc
                Kb(b,d) = Kb(b,d) + Kb_bd
              end
              J(c,d) = J(c,d) + Jcd
            end
          end
          I.destroy
        end
        shell4.destroy_cd
      end
      shell4.destroy_ab
    end
    max_I.destroy
    abs_P.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(Ka)
    .blockwise_symmetric_fold(Kb)
    J.make_symmetric
    Ka.make_symmetric
    Kb.make_symmetric
    J = TWO*J 
  end

  make_u_JK_disk(J,Ka,Kb,P,Pa,Pb)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
  ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly. 
    MAT :: J,Ka,Kb,P,Pa,Pb
    ARCHIVE, PTR :: eri_archive,ind_archive
    MAT4, PTR   :: I
    INT :: q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd,P_dc,Pa_db,Pa_cb,Pb_db,Pb_cb
    eri_archive.create(.name,"eri_integrals")
    ind_archive.create(.name,"eri_index")
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    ENSURE( eri_archive.exists, "no integral file")
    ENSURE( ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J  = ZERO
    Ka = ZERO
    Kb = ZERO
    n_quartets = .n_shell_quartets
    do
      ind_archive.file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
      I.create(fa,la,fb,lb,fc,lc,fd,ld)
      eri_archive.file.read(I)
      do d = fd,ld
        do c = fc,lc
          P_dc = P(d,c)
          do b = fb,lb
            Pa_db = Pa(d,b)
            Pb_db = Pb(d,b)
            Pa_cb = Pa(c,b)
            Pb_cb = Pb(c,b)
            do a = fa,la
               I_abcd = I(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               J(c,d) = J(c,d) + I_abcd*P(b,a)
               Ka(a,c) = Ka(a,c) + I_abcd*Pa_db
               Ka(a,d) = Ka(a,d) + I_abcd*Pa_cb
               Ka(b,c) = Ka(b,c) + I_abcd*Pa(d,a)
               Ka(b,d) = Ka(b,d) + I_abcd*Pa(c,a)
               Kb(a,c) = Kb(a,c) + I_abcd*Pb_db
               Kb(a,d) = Kb(a,d) + I_abcd*Pb_cb
               Kb(b,c) = Kb(b,c) + I_abcd*Pb(d,a)
               Kb(b,d) = Kb(b,d) + I_abcd*Pb(c,a)
            end
          end
        end
      end
      I.destroy
    end
    ind_archive.destroy
    eri_archive.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(Ka)
    .blockwise_symmetric_fold(Kb)
    J.make_symmetric
    Ka.make_symmetric
    Kb.make_symmetric
    J = TWO*J 
  end

  make_gc_JK_direct(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
  ! Make the general complex matrices "J" and exchange matrices 
  ! "Ka", "Kb" and "Kba" from a density matrices "P", "Pa", "Pb" and "Pba"
  ! directly from the integrals.
    MAT :: J,P
    CMAT :: Ka,Kb,Kba,Pa,Pb,Pba
    MAT4, PTR   :: I
    SHELL4, PTR :: shell4
    INT :: ac,ab,cd,aa,cc
    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd,factor
    J   = ZERO
    Ka  = ZERO
    Kb  = ZERO
    Kba = ZERO
    shell4.create
    do ac = 1, .n_shell_pairs
      .get_shell_pair(ac,ab,cd)
      do aa = 1,ab
        .get_shell_pair(ab,a,b)
        fa = .first_basis_fn_for_shell(a)
        fb = .first_basis_fn_for_shell(b)
        la = .last_basis_fn_for_shell(a)
        lb = .last_basis_fn_for_shell(b)
        do cc = 1,cd
          .get_shell_pair(cd,c,d)
          fc = .first_basis_fn_for_shell(c)
          fd = .first_basis_fn_for_shell(d)
          lc = .last_basis_fn_for_shell(c)
          ld = .last_basis_fn_for_shell(d)
          .get_shell_quartet(shell4,a,b,c,d)
          if (shell4.skip_ERI) then
            shell4.destroy_ptr_part
            cycle
          end
          I.create(fa,la,fb,lb,fc,lc,fd,ld)
          shell4.get_ERI(I)
          factor = ONE                          ! Evaluate the integrals
          if (a==b) factor = HALF               ! Coincidence factors   
          if (c==d) factor = HALF * factor
          if (a==c AND b==d) factor = HALF * factor
          do d = fd,ld
            do c = fc,lc
              do b = fb,lb
                do a = fa,la
                   I_abcd = factor * I(a,b,c,d)
                   J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
                   J(c,d)   = J(c,d)   + I_abcd*P(b,a)
                   Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric
                   Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)  ! but must be folded
                   Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
                   Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
                   Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric
                   Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)  ! but must be folded
                   Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
                   Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
                   Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
                   Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d) 
                   Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
                   Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
                   Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
                   Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
                   Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
                   Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
                end
              end
            end
          end
          I.destroy
          shell4.destroy_ptr_part
        end
      end
    end
    shell4.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_hermitian_fold(Ka)
    .blockwise_hermitian_fold(Kb)
    J.make_symmetric
    Ka.make_hermitian
    Kb.make_hermitian
    J = TWO*J 
  end

  make_gc_JK_disk(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
  ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly. 
    MAT :: J,P
    CMAT :: Ka,Kb,Kba,Pa,Pb,Pba
    ARCHIVE, PTR :: eri_archive,ind_archive
    MAT4, PTR   :: I
    INT :: q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd
    eri_archive.create(.name,"eri_integrals")
    ind_archive.create(.name,"eri_index")
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    ENSURE( eri_archive.exists, "no integral file")
    ENSURE( ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J   = ZERO
    Ka  = ZERO
    Kb  = ZERO
    Kba = ZERO
    n_quartets = .n_shell_quartets
    do
      ind_archive.file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
      I.create(fa,la,fb,lb,fc,lc,fd,ld)
      eri_archive.file.read(I)
      do d = fd,ld
      do c = fc,lc
      do b = fb,lb
      do a = fa,la
          I_abcd = I(a,b,c,d)
          J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
          J(c,d)   = J(c,d)   + I_abcd*P(b,a)
          Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric but must be folded
          Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)  
          Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
          Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
          Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric but must be folded
          Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)  
          Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
          Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
          Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
          Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d) 
          Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
          Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
          Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
          Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
          Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
          Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
      end
      end
      end
      end
      I.destroy
    end
    ind_archive.destroy
    eri_archive.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_hermitian_fold(Ka)
    .blockwise_hermitian_fold(Kb)
    J.make_symmetric
    Ka.make_hermitian
    Kb.make_hermitian
    J = TWO*J 
  end

  make_gc_so_JK_disk(JS,KS,JO,KO,P,SO_archive,ind_archive)
  ! Make the general complex spin orbit Classical and Exchange matrices.
    CMAT4 :: JS,KS,JO,KO,P
    ARCHIVE :: SO_archive,ind_archive
    MAT4, PTR   :: S,O
    INT :: q,n_quartets
    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,m,n
    DBL :: S_abcd,O_abcd
    CDBL :: I
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    ENSURE( SO_archive.exists,  "no spin orbit integral file!")
    ENSURE( ind_archive.exists, "no spin orbit integral index file")
    SO_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="dbl")
    JS = ZERO; KS = ZERO; JO = ZERO; KO = ZERO
    I = (ZERO,ONE)
    n_quartets = .n_shell_quartets
    do
       ind_archive.file.read(q)
       if (q > n_quartets) exit
       .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
       S.create(fa,la,fb,lb,fc,lc,fd,ld)
       O.create(fa,la,fb,lb,fc,lc,fd,ld)
       SO_archive.file.read(S)
       SO_archive.file.read(O)
       do a = fa,la
       do b = fb,lb
       do c = fc,lc
       do d = fd,ld
          S_abcd = S(a,b,c,d)
          O_abcd = O(a,b,c,d)
          do m = 1,2
          do n = 1,2
             !
             JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(d,c, m,n)
             JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(c,d, m,n)
             JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(d,c, m,n)
             JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(c,d, m,n)
             JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(b,a, m,n)
             JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(a,b, m,n)
             JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(b,a, m,n)
             JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(a,b, m,n)
             !
             JO(a,b, m,n) = JO(a,b, m,n) + O_abcd*P(d,c, m,n)
             JO(a,b, m,n) = JO(a,b, m,n) - O_abcd*P(c,d, m,n)
             JO(b,a, m,n) = JO(b,a, m,n) + O_abcd*P(d,c, m,n)
             JO(b,a, m,n) = JO(b,a, m,n) - O_abcd*P(c,d, m,n)
             JO(c,d, m,n) = JO(c,d, m,n) + S_abcd*P(b,a, m,n)
             JO(c,d, m,n) = JO(c,d, m,n) - S_abcd*P(a,b, m,n)
             JO(d,c, m,n) = JO(d,c, m,n) + S_abcd*P(b,a, m,n)
             JO(d,c, m,n) = JO(d,c, m,n) - S_abcd*P(a,b, m,n)
             !
             KS(a,d, m,n) = KS(a,d, m,n) + S_abcd*P(b,c, m,n)
             KS(a,c, m,n) = KS(a,c, m,n) + S_abcd*P(b,d, m,n)
             KS(b,d, m,n) = KS(b,d, m,n) - S_abcd*P(a,c, m,n)
             KS(b,c, m,n) = KS(b,c, m,n) - S_abcd*P(a,d, m,n)
             KS(c,b, m,n) = KS(c,b, m,n) + O_abcd*P(d,a, m,n)
             KS(c,a, m,n) = KS(c,a, m,n) + O_abcd*P(d,b, m,n)
             KS(d,b, m,n) = KS(d,b, m,n) - O_abcd*P(c,a, m,n)
             KS(d,a, m,n) = KS(d,a, m,n) - O_abcd*P(c,b, m,n)
             !
             KO(a,d, m,n) = KO(a,d, m,n) + O_abcd*P(b,c, m,n)
             KO(a,c, m,n) = KO(a,c, m,n) - O_abcd*P(b,d, m,n)
             KO(b,d, m,n) = KO(b,d, m,n) + O_abcd*P(a,c, m,n)
             KO(b,c, m,n) = KO(b,c, m,n) - O_abcd*P(a,d, m,n)
             KO(c,b, m,n) = KO(c,b, m,n) + S_abcd*P(d,a, m,n)
             KO(c,a, m,n) = KO(c,a, m,n) - S_abcd*P(d,b, m,n)
             KO(d,b, m,n) = KO(d,b, m,n) + S_abcd*P(c,a, m,n)
             KO(d,a, m,n) = KO(d,a, m,n) - S_abcd*P(c,b, m,n)
          end
          end
       end
       end
       end
       end
       O.destroy; S.destroy
    end
    SO_archive.close
    ind_archive.close
  end
 
  weight_diagonal_blocks(X,fac) [pure]
  ! Weight the diagonal blocks of matrix "X" by "fac"
     IN :: self
     MAT, INOUT :: X
     DBL, IN :: fac
     INT :: n,f,l
     do n = 1,.n_shell
        f = .first_basis_fn_for_shell(n)
        l = .last_basis_fn_for_shell(n)
        X(f:l,f:l) = fac*X(f:l,f:l)
     end
  end
 
  weight_diagonal_blocks(X,fac) [pure]
  ! Weight the diagonal blocks of matrix "X" by "fac"
     IN :: self
     CMAT, INOUT :: X
     DBL, IN :: fac
     INT :: n,f,l
     do n = 1,.n_shell
        f = .first_basis_fn_for_shell(n)
        l = .last_basis_fn_for_shell(n)
        X(f:l,f:l) = fac*X(f:l,f:l)
     end
  end

  set_diagonal_blocks(X,fac) [pure]
  ! Set the diagonal blocks of matrix "X" to "fac"
     IN :: self
     MAT, INOUT :: X
     DBL, IN :: fac
     INT :: n,f,l
     do n = 1,.n_shell
        f = .first_basis_fn_for_shell(n)
        l = .last_basis_fn_for_shell(n)
        X(f:l,f:l) = fac
     end
  end

  blockwise_symmetric_fold(X)
  ! Symmetrically fold the matrix "X" blockwise
     MAT :: X
     INT :: a,fa,la,b,fb,lb
     do a = 1,.n_shell
     do b = 1,a
        fa = .first_basis_fn_for_shell(a)
        la = .last_basis_fn_for_shell(a)
        fb = .first_basis_fn_for_shell(b)
        lb = .last_basis_fn_for_shell(b)
        X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(X(fb:lb,fa:la))
     end
     end
  end

  blockwise_hermitian_fold(X)
  ! Hermitian fold the matrix "X" blockwise
     CMAT :: X
     INT :: a,fa,la,b,fb,lb
     do a = 1,.n_shell
     do b = 1,a
        fa = .first_basis_fn_for_shell(a)
        la = .last_basis_fn_for_shell(a)
        fb = .first_basis_fn_for_shell(b)
        lb = .last_basis_fn_for_shell(b)
        X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(conjg(X(fb:lb,fa:la)))
     end
     end
  end


! ******************
! Constraint methods
! ******************

  constrained_scf_rhf [leaky]
  ! Do a restricted Hartree-Fock calculation. The following objects 
  ! are destroyed and made new:
  !   .overlap_matrix, .core_matrix, .fock_matrix, 
  ! The following objects are produced as results:
  !   .molecular_orbitals, .orbital_energies, .density_matrix  
  ! The following objects are deleted from memory after execution:
  !   .overlap_matrix, .core_matrix, .fock_matrix

    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    DIE_IF( .mult/=1,"this is not a singlet state")

    .get_initial_guess
    .make_fock_matrix

    if (.optimise_thermals) then
      .fit_thermal_parameters
    else
      .make_structure_factors
    end

    .scfdata.set(nuclear_energy=.nuclear_energy)
    .scfdata.reset(energy=.scf_energy, kinetic_energy=.kinetic_energy)
    .scfdata.set_stats(.crystal.chi2, .crystal.goodness_of_fit, &
                         .crystal.r_factor, .crystal.weighted_r_factor)
    .scfdata.put_banner

    .crystal.put_corrections(stdout)

    do
      .scfdata.diis.cleanup
      do
        .add_constraint
        .extrapolate_scf
        .update_molecular_orbitals
        .make_scf_density_matrix
        .save_scf_results
        .make_fock_matrix                      ! To get new Hartree-Fock energy.
        .make_structure_factors

        .scfdata.update(energy=.scf_energy, kinetic_energy=.kinetic_energy)
        .scfdata.set_stats(.crystal.chi2, .crystal.goodness_of_fit, &
                              .crystal.r_factor, .crystal.weighted_r_factor)
        .scfdata.put_results
        if (.scfdata.scf_done) exit
      end
      .scfdata.update_lambda

      if (.optimise_thermals) .fit_thermal_parameters
      if (.scfdata.exceeded_lambda_max) exit
    end

    .crystal.put_reflection_data
    .scfdata.diis.delete_archives
    if (.optimise_thermals) .put_atom_thermal_tensors
  end

  add_constraint
  ! Make the constraint matrix for wavefunction fitting and add it to the fock
  ! matrix.
    MAT, PTR :: MO,temp,S
    MAT, PTR :: constraint
    STR :: kind
    kind = .scfdata.spinorbital_kind

    if (kind == "restricted") then
      if ( .molecular_orbitals.destroyed(kind) ) .make_fock_guess
      MO => .molecular_orbitals.restricted
    else
      DIE("can only do restricted calculations.")
    end

    constraint.create( .n_bf, .n_bf)
    .make_constraint(constraint, .scfdata.lambda / (.scfdata.lambda + 1) )

    constraint.change_basis(MO)          ! Zero out the occ-occ and vir-vir
    constraint(:.n_a, :.n_a) = ZERO      ! blocks of the constraint matrix
    constraint(.n_a+1:, .n_a+1:) = ZERO  ! to improve convergence.
    .fock_matrix.restricted.change_basis(MO)
    .fock_matrix.restricted(.n_a+1:,:.n_a).to_product(ONE/(.scfdata.lambda+1))
    .fock_matrix.restricted(:.n_a,.n_a+1:).to_product(ONE/(.scfdata.lambda+1))

    .fock_matrix.restricted.plus(constraint)
    constraint.destroy

    temp.create( .n_bf, .n_bf)
    S.create( .n_bf, .n_bf)
    .get_overlap_matrix(S)
    temp.to_product(MO,S,transpose_a=TRUE)
    S.destroy
    .fock_matrix.restricted.change_basis(temp) ! Back to AO basis.
    temp.destroy
  end

  make_constraint(constraint,lambda)
  ! Make the constraint matrix for wavefunction fitting.
    MAT :: constraint
    DBL, IN :: lambda
    MAT, PTR :: k_pts
    CMAT3, PTR :: ft_ab_eq,ft_ab
    CVEC, PTR :: Fc,fac_times_alpha
    VEC, PTR :: Fm,Fexp,sig,alpha
    SHELL2 :: shell
    DBL :: fac,cutoff
    INT :: q,a,b,fa,la,fb,lb,n,i,j,n_refl,n_unique,atom_a,atom_b

    ENSURE( .crystal.created,  "no crystal info")
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")

    n_unique = .crystal.unique_k_pts
    n_refl = .crystal.n_refl
    Fc => .crystal.F_calc
    Fexp => .crystal.F_exp
    sig => .crystal.sigma
    fac = TWO*lambda/max(n_refl - .crystal.n_param,1)

    fac_times_alpha.create(n_refl)

    Fm.create(n_refl)
    Fm = abs(.crystal.F_calc)
    alpha.create(n_refl)
    alpha = .crystal.corrections
    do n=1,n_refl
      fac_times_alpha(n)=fac*alpha(n)*(alpha(n)*Fm(n)-Fexp(n))/(sig(n)*sig(n)*Fm(n))
    end
    alpha.destroy
    Fm.destroy

    k_pts.create(n_unique,3)
    .crystal.make_unique_k_pts(k_pts)

    cutoff = TOL(10) / .n_shell_pairs
    do q=1, .n_shell_pairs
      .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
      if (shell.skip_ft(cutoff)) then
        constraint(fa:la,fb:lb) = ZERO
        shell.destroy_ptr_part
        cycle
      end
      ft_ab.create((/1,n_refl/),(/fa,la/),(/fb,lb/))
      ft_ab_eq.create(n_unique,shell.a.n_comp,shell.b.n_comp)
      .make_ft_pair(ft_ab_eq,k_pts,shell,atom_a,atom_b)
      .crystal.sum_ft_ints(ft_ab,ft_ab_eq)
      ft_ab_eq.destroy
      do i = fa,la
        do j = fb,min(lb,i)
          constraint(i,j) = sum(fac_times_alpha(:) * &
           real(ft_ab(:,i,j) * conjg(Fc)))
        end
      end
      ft_ab.destroy
      shell.destroy_ptr_part
    end
    constraint.make_symmetric

    k_pts.destroy
    fac_times_alpha.destroy
  end

! ****************
! Plotting methods
! ****************

  plot [leaky]
  ! Do one of the many kinds of plot calculations
    ENSURE( .grid.created, "no grid")
    .grid.put
    select case (.grid.kind)
       case("electron_density");     .make_electron_density_grid
       case("laplacian_density");    .make_laplacian_density_grid
       case("orbital_density");      .make_orbital_density_grid( .grid.orbital)
       case("orbital");              .make_orbital_grid( .grid.orbital)
       case("difference_density");   .make_difference_density_grid
       case("fermi_mobility");       .make_fermi_mobility_grid
       case("crystal_error_map");    .make_crystal_error_map
       case("spin_density");         .make_spin_density_grid
       case("current_density");      .make_j_density_grid
       case("j_density");            .make_j_density_grid
       case("jp_density");           .make_jp_density_grid
       case("jd_density");           .make_jd_density_grid
       case("elf");                  .make_ELF_grid
       case("electric_potential");   .make_electric_potential_grid
       case("potential");            .make_electric_potential_grid
       case("solenoidal_jp");        .make_solenoidal_jp_grid
       case default;                 DIE("unknown plot type")
    end
  end

   bounding_cube_width result(width)
   ! Return "width", the width of a cube in which the molecule nicely sits.
   ! Suitable for generating plot widths.
      DBL :: width
      width = .atom.bounding_cube_width
   end

   get_electron_density_grid(density_grid) [leaky]
   ! Set "density_grid" to the electron density grid.
   ! If the archive file exists, read it; otherwise make it.
      VEC :: density_grid
      ARCHIVE :: archive
      archive.set(.name,"electron_density_grid")
      if ( archive.doesnt_exist) .make_electron_density_grid
      archive.read(density_grid)
   end

   make_electron_density_grid [leaky]
   ! Work out the density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC, PTR :: density_grid
      ENSURE( .grid.created, "no grid")
      density_grid.create( .grid.n_pt)
      .make_density_grid(density_grid)
      archive.set(.name,"electron_density_grid")
      archive.write(density_grid)
      archive.set(.name,"electron_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(density_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      density_grid.destroy
   end

   get_laplacian_density_grid(laplacian_grid) [leaky]
   ! Set "laplacian_grid" to the Laplacian density grid.
   ! If the archive file exists, read it; otherwise make it.
      VEC :: laplacian_grid
      ARCHIVE :: archive
      archive.set(.name,"laplacian_density_grid")
      if ( archive.doesnt_exist) .make_laplacian_density_grid
      archive.read(laplacian_grid)
   end

   make_laplacian_density_grid [leaky]
   ! Work out the laplacian density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC, PTR :: laplacian_grid
      ENSURE( .grid.created, "no grid")
      laplacian_grid.create( .grid.n_pt)
      .make_laplacian_grid(laplacian_grid)
      archive.set(.name,"laplacian_density_grid")
      archive.write(laplacian_grid)
      archive.set(.name,"laplacian_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(laplacian_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      laplacian_grid.destroy
   end

  make_difference_density_grid [leaky]
  ! Make a Gnuplot ascii file containing the difference density grid.
    ARCHIVE :: archive
    VEC, PTR :: density_grid,NO
    CVEC, PTR :: NOc
    OPMAT :: old_density_matrix,atom_NOs,molecule_NOs
    OPVEC :: atom_occ,molecule_occ
    MAT, PTR :: pts
    BIN :: old_dens,old_NOs
    INT :: n
    ENSURE( .grid.created, "no grid")

    ! Get NOs for the molecule
    old_NOs = FALSE;      old_dens = FALSE
    if (.density_matrix.created)   old_dens = .density_matrix.any_created
    if (.natural_orbitals.created) old_NOs = .natural_orbitals.any_created
    if (NOT old_NOs) .make_natural_orbitals
    if (old_dens) old_density_matrix.set_to(.density_matrix)
    molecule_NOs.set_to(.natural_orbitals)
    molecule_occ.set_to(.occupation)

    ! Get NOs for the promolecule
    .get_atom_density
    .make_natural_orbitals
    atom_NOs.set_to(.natural_orbitals)
    atom_occ.set_to(.occupation)

    ! Destroy .density_matrix if it wasn't there when we started.
    .density_matrix.destroy
    if (old_dens) then
      .density_matrix.create(.n_bf)
      .density_matrix.set_to(old_density_matrix)
    end

    ! Destroy .natural_orbitals if it wasn't there when we started.
    if (old_NOs) then
      .natural_orbitals.set_to(molecule_NOs)
      .occupation.set_to(molecule_occ)
    else
      .natural_orbitals.destroy
      .occupation.destroy
    end
    molecule_occ.destroy_ptr_part
    molecule_NOs.destroy_ptr_part

    density_grid.create(.grid.n_pt)
    density_grid = ZERO
    pts.create(.grid.n_pt,3); .grid.points(pts)
    if (.natural_orbitals.number_kind == "real") then
      NO.create(.grid.n_pt)
      do n = 1,.no_of_occupied_NOs
        .make_orbital_grid(NO,.natural_orbitals.restricted(:,n), pts)
        density_grid(:).plus_vec(.occupation.restricted(n)*NO(:)*NO(:))
        .make_orbital_grid(NO,atom_NOs.restricted(:,n), pts)
        density_grid(:).minus_vec(atom_occ.restricted(n)*NO(:)*NO(:))
      end
      NO.destroy
    else
      NOc.create(.grid.n_pt)
      do n = 1,.no_of_occupied_NOs
         .make_orbital_grid(NOc,.natural_orbitals.restricted_complex(:,n), pts)
         density_grid(:).plus_vec(.occupation.restricted(n)*real(conjg(NOc(:))*NOc(:)))
         .make_orbital_grid(NOc,atom_NOs.restricted_complex(:,n), pts)
         density_grid(:).minus_vec(atom_occ.restricted(n)*real(conjg(NOc(:))*NOc(:)))
      end
      NOc.destroy
    end
    pts.destroy

    archive.set(.name,"difference_density_grid,gnuplot",format="ascii")
    archive.write_gnuplot(density_grid, .grid.n_x, .grid.n_y, .grid.n_z)
    density_grid.destroy
    atom_occ.destroy_ptr_part
    atom_NOs.destroy_ptr_part
  end

   get_spin_density_grid(density_grid) [leaky]
   ! Set "density_grid" to the electron spin density grid.
   ! If the archive file exists, read it; otherwise make it.
      VEC :: density_grid
      ARCHIVE :: archive
      archive.set(.name,"spin_density_grid")
      if ( archive.doesnt_exist) .make_spin_density_grid
      archive.read(density_grid)
   end

   make_spin_density_grid [leaky]
   ! Work out the spin density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC, PTR :: density_grid
      ENSURE( .grid.created, "no grid")
      .make_ao_sz_density_matrix
      density_grid.create( .grid.n_pt)
      .make_density_grid(density_grid)
      archive.set(.name,"spin_density_grid")
      archive.write(density_grid)
      archive.set(.name,"spin_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(density_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      density_grid.destroy
   end

   make_density_grid(density_grid)
   ! Work out the density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector.
      VEC :: density_grid
      BIN :: old_NOs
      if (.natural_orbitals.created) old_NOs = .natural_orbitals.any_created
      if (NOT old_NOs) .make_natural_orbitals
      if (.natural_orbitals.number_kind == "real") then
         .make_density_grid_r(density_grid)
      else
         .make_density_grid_c(density_grid)
      end
      if (NOT old_NOs) .natural_orbitals.destroy_ptr_part
   end

   make_density_grid_r(density_grid)
   ! Make the density grid from restricted real natural orbitals
      VEC :: density_grid
      MAT, PTR :: pt
      INT :: n_pt
      ENSURE( .grid.created,  "no grid")
      density_grid = ZERO
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      .make_density_grid_r(density_grid,pt)
      pt.destroy
   end

   make_density_grid_c(density_grid)
   ! Make the density from restricted complex natural orbitals
      VEC :: density_grid
      MAT, PTR :: pt
      INT :: n_pt
      ENSURE( .grid.created,  "no grid")
      density_grid = ZERO
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      .make_density_grid_c(density_grid,pt)
      pt.destroy
   end

   make_density_grid(density_grid,pts) [leaky]
   ! Work out the electron "density_grid" on "pts" using ".natural orbitals" and
   ! the ".occupation" number vector.
      VEC :: density_grid
      MAT :: pts
      if (.natural_orbitals.number_kind == "real") then
         .make_density_grid_r(density_grid,pts)
      else
         .make_density_grid_c(density_grid,pts)
      end
   end

   make_density_grid_r(density_grid,pts)
   ! Make the "density_grid" for the supplied points "pts" from restricted real
   ! natural orbitals
     VEC :: density_grid
     MAT :: pts
     VEC, PTR :: NO
     INT :: n_occ,n,n_pts
     ENSURE( size(pts,2)==3,  "incorrect dimension for points array")
     ENSURE( .natural_orbitals.created("restricted"), "no natural orbitals")
     ENSURE( .occupation.restricted.created, "no occupation numbers")
     n_pts = size(pts,1)
     density_grid = ZERO
     NO.create(n_pts)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_orbital_grid(NO,.natural_orbitals.restricted(:,n), pts)
       density_grid(:) = density_grid(:) + .occupation.restricted(n)*NO(:)*NO(:)
     end
     NO.destroy
   end

   make_density_grid_c(density_grid,pts)
   ! Make the "density_grid" for the supplied points "pts" from restricted
   ! complex natural orbitals.
      VEC :: density_grid
      MAT :: pts
      CVEC, PTR :: NO
      INT :: n_occ,n,n_pts
      ENSURE( size(pts,2)==3,  "incorrect dimension for points array")
      ENSURE( .natural_orbitals.created("restricted_complex"), "no natural orbitals")
      ENSURE( .occupation.restricted.created, "no occupation numbers")
      n_pts = size(pts,1)
      density_grid = ZERO
      NO.create(n_pts)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
         .make_orbital_grid(NO,.natural_orbitals.restricted_complex(:,n), pts)
         density_grid(:) = density_grid(:) + .occupation.restricted(n)*conjg(NO(:))*NO(:)
      end
      NO.destroy
   end

   make_laplacian_grid(laplacian_grid) [leaky]
   ! Work out the laplacian density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector.
      VEC :: laplacian_grid
      BIN :: old_NOs
      if (.natural_orbitals.created) old_NOs = .natural_orbitals.any_created
      if (NOT old_NOs) .make_natural_orbitals
      .make_laplacian_grid_r(laplacian_grid)
   end

   make_laplacian_grid_r(laplacian_grid)
   ! Make the laplacian density grid from restricted real natural orbitals
      VEC :: laplacian_grid
      MAT, PTR :: pt
      INT :: n_pt
      ENSURE( .grid.created,  "no grid")
      ENSURE( .natural_orbitals.created("restricted"), "no natural orbitals")
      laplacian_grid = ZERO
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      .make_laplacian_grid_r(laplacian_grid,pt)
      pt.destroy
   end

   make_laplacian_grid(laplacian_grid,pts) [leaky]
   ! Work out the electron "laplacian_grid" on "pts" using ".natural orbitals"
   ! and  the ".occupation" number vector.
      VEC :: laplacian_grid
      MAT :: pts
      .make_laplacian_grid_r(laplacian_grid,pts)
   end

   make_laplacian_grid_r(laplacian_grid,pts)
   ! Make the "laplacian_grid" for the supplied points "pts" from restricted
   ! real natural orbitals
     VEC :: laplacian_grid
     MAT :: pts
     VEC, PTR :: NO
     MAT, PTR :: P,D
     INT :: n_occ,n,n_pts
     ENSURE( size(pts,2)==3,  "incorrect dimension for points array")
     ENSURE( .natural_orbitals.created, "no natural orbitals")
     n_pts = size(pts,1)
     laplacian_grid = ZERO
     NO.create(n_pts)
     P.create(n_pts,3)
     D.create(n_pts,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_laplacian_orbital_grid(D,P,NO,.natural_orbitals.restricted(:,n), pts)
       laplacian_grid(:) = laplacian_grid(:) + &
          .occupation.restricted(n)*NO(:)*(D(:,1) + D(:,2) + D(:,3)) + &
          .occupation.restricted(n)*(P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
     end
     laplacian_grid(:) = TWO*laplacian_grid(:)
     D.destroy
     P.destroy
     NO.destroy
   end

   get_crystal_error_map(map) [leaky]
   ! Set "map" to the crystal error map. If an archive file exists, read it; 
   ! otherwise make it.
      VEC :: map
      ARCHIVE :: archive
      archive.set(.name,"crystal_error_map")
      if ( archive.doesnt_exist) .make_crystal_error_map
      archive.read(map)
   end

   make_crystal_error_map [leaky]
   ! Work out the crystal_error map on ".grid". A Gnuplot ascii file is
   ! generated.
      ARCHIVE :: archive
      VEC, PTR :: map
      ENSURE( .grid.created, "no grid")
      map.create( .grid.n_pt)
      .make_crystal_error_map(map)
      archive.set(.name,"crystal_error_map")
      archive.write(map)
      archive.set(.name,"crystal_error_map,gnuplot",format="ascii")
      archive.write_gnuplot(map, .grid.n_x, .grid.n_y, .grid.n_z)
      map.destroy
   end

   make_crystal_error_map(map) [leaky]
   ! Work out the crystal error map on ".grid".
      VEC :: map
      .make_crystal_error_map_r(map)
   end

   make_crystal_error_map_r(map)
   ! Make the crystal error "map" from restricted real natural orbitals
      VEC :: map
      MAT, PTR :: pt
      INT :: n_pt
      ENSURE( .grid.created,  "no grid")
      map = ZERO
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      .make_crystal_error_map_r(map,pt)
      pt.destroy
   end

   make_crystal_error_map_r(map,pts)
   ! Make the crystal error "map" for the supplied points "pts" from the crystal
   ! structure factors
     VEC :: map
     MAT :: pts
     MAT, PTR :: k
     VEC, PTR :: F,phase
     INT :: n_pts,n_refl,n
     DBL :: fac
     ENSURE( .crystal.created,  "no crystal")
     ENSURE( .crystal.F_calc.created, "no calculated structure factors")
     ENSURE( .crystal.F_exp.created,  "no experimental structure factors")
     ENSURE( size(pts,2)==3,  "incorrect dimension for points array")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     ENSURE( .natural_orbitals.created, "no orbitals")
     n_pts = size(pts,1)
     n_refl = .crystal.n_refl
     k.create(n_refl,3); .crystal.make_k_pts(k)
     F.create(n_refl)
     F = .crystal.F_exp - abs(.crystal.F_pred)
     phase.create(n_refl)
     do n = 1,n_pts
        phase.to_product(k,pts(n:n,:),transpose_b=TRUE)
        map(n) = sum(F*cos(phase))
     end
     fac = TWO/.crystal.unit_cell_volume
     map = fac*map
     phase.destroy
     F.destroy
     k.destroy
   end

   get_orbital_density_grid(g,orb) [leaky]
   ! Set "g" to the orbital density grid for orbital "orb".
   ! If the archive file exists, read it; otherwise make it.
      VEC :: g
      INT :: orb
      ARCHIVE :: archive
      archive.set(.name,"orbital_density_grid"//trim( orb.to_str))
      if ( archive.doesnt_exist) .make_orbital_density_grid(orb)
      archive.read(g)
   end

   make_orbital_density_grid(orb) [leaky]
   ! Work out the orbital on ".grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
      INT :: orb
      ARCHIVE :: archive
      VEC, PTR  :: gr
      CVEC, PTR :: gc
      ENSURE( .grid.created, "no grid")
      .make_natural_orbitals
      if (.natural_orbitals.number_kind == "real") then
        gr.create(.grid.n_pt)
        .make_orbital_grid(gr,orb,square=TRUE)
        archive.set(.name,"orbital_density_grid")
        archive.write(gr)
        archive.set(.name,"orbital_density_grid"//trim( orb.to_str)//",gnuplot",format="ascii")
        archive.write_gnuplot(gr, .grid.n_x, .grid.n_y, .grid.n_z)
        gr.destroy
      else
        gr.create(.grid.n_pt)
        gc.create(.grid.n_pt)
        .make_orbital_grid(gc,orb,square=TRUE)
        gr = gc
        archive.set(.name,"complex_orbital_density_grid")
        archive.write(gr)
        archive.set(.name,"complex_orbital_density_grid,gnuplot",format="ascii")
        archive.write_gnuplot(gr, .grid.n_x, .grid.n_y, .grid.n_z)
        gc.destroy
        gr.destroy
      end
   end

   make_orbital_grid(orb) [leaky]
   ! Work out the orbital on ".grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
      INT :: orb
      ARCHIVE :: archive
      VEC, PTR  :: gr
      CVEC, PTR :: gc
      ENSURE( .grid.created, "no grid")
      .make_natural_orbitals
      if (.natural_orbitals.number_kind == "real") then
         gr.create(.grid.n_pt)
         .make_orbital_grid(gr,orb)
         archive.set(.name,"orbital_grid")
         archive.write(gr)
         archive.set(.name,"orbital_grid"//trim( orb.to_str)//",gnuplot",format="ascii")
         archive.write_gnuplot(gr, .grid.n_x, .grid.n_y, .grid.n_z)
         gr.destroy
      else
         gc.create(.grid.n_pt)
         .make_orbital_grid(gc,orb)
         archive.set(.name,"complex_orbital_grid")
         archive.write(gc)
         archive.set(.name,"complex_orbital_grid,gnuplot",format="ascii")
         ! archive.write_gnuplot(gc, .grid.n_x, .grid.n_y, .grid.n_z)
         gc.destroy
      end
   end

   make_orbital_grid(g,orb,square) [leaky]
   ! Make the orbital density grid "g" for orbital
   ! no. "orb" of the restricted real natural orbitals.
   ! If present and TRUE, "square" will produce the square of the
   ! orbital density (i.e. probability density)
      VEC :: g
      INT :: orb,n_pt
      BIN, optional :: square
      VEC, PTR :: NO
      MAT, PTR :: pt
      BIN :: sq
      ENSURE( .grid.created,  "no grid")
      ENSURE( .natural_orbitals.created, "no natural orbitals")
      sq = FALSE
      if (present(square)) sq = square
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      NO.create(n_pt)
      .make_orbital_grid(NO,.natural_orbitals.restricted(:,orb), pt)
      if (sq) then; g(:) = NO(:)*NO(:)
      else;         g(:) = NO(:)
      end
      NO.destroy
      pt.destroy
   end

   make_orbital_grid(g,orb,square)
   ! Make the orbital density grid "g" for orbital
   ! no. "orb" of the restricted complex natural orbitals.
   ! If present and TRUE, "square" will produce the square of the
   ! orbital density (i.e. probability density)
      CVEC :: g
      INT :: orb,n_pt
      BIN, optional :: square
      CVEC, PTR :: NO
      MAT, PTR :: pt
      BIN :: sq
      ENSURE( .grid.created,  "no grid")
      ENSURE( .natural_orbitals.created, "no natural orbitals")
      sq = FALSE
      if (present(square)) sq = square
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      NO.create(n_pt)
      .make_orbital_grid(NO,.natural_orbitals.restricted_complex(:,orb), pt)
      if (sq) then; g(:) = conjg(NO(:))*NO(:)
      else;         g(:) = NO(:)
      end
      NO.destroy
      pt.destroy
   end

   make_orbital_grid(g,orb)
   ! Evaluate the orbital density grid "g" for *one* AO-basis orbital vector
   ! "orb" on a set of grid points defined by ".grid"
      VEC, OUT :: g
      VEC, IN :: orb
      MAT, PTR :: pt
      SHELL1 :: sh
      MAT, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_orbital_grid(g,orb)
   ! Evaluate the orbital density grid "g" for *one* AO-basis orbital vector
   ! "orb" on a set of grid points defined by ".grid"
      CVEC, OUT :: g
      CVEC, IN :: orb
      MAT, PTR :: pt
      SHELL1 :: sh
      MAT, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_orbital_grid(g,orb,pt)
   ! Evaluate the orbital density grid "g" for *one* AO-basis orbital vector
   ! "orb" on a set of grid points "pt"
      VEC, OUT :: g
      VEC, IN :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_orbital_grid(g,orb,pt)
   ! Evaluate the orbital density for *one* AO-basis orbital vector "orb"
   ! on a set of grid points "pt"
      CVEC, OUT :: g
      CVEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1, PTR :: sh
      MAT, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
   end

   make_j_density_grid
   ! Make the current density on ".grid" using ".natural orbitals"
   ! and the ".occupation" number vector.
   !    J(r) = J_p(r) + J_d(r)
      ARCHIVE :: archive
      MAT, PTR :: j,jp
      ENSURE( .grid.created, "no grid")
      j.create(.grid.n_pt,3);  .get_jd_density_grid(j)
      jp.create(.grid.n_pt,3); .get_jp_density_grid(jp)
      j = j + jp
      jp.destroy
      archive.set(.name,"current_density")
      archive.write(j)
      archive.set(.name,"current_density,gnuplot",format="ascii")
      archive.write_gnuplot(j, .grid.n_x, .grid.n_y, .grid.n_z)
      archive.set(.name,"current_norm_density,gnuplot",format="ascii")
      archive.write_gnuplot(j, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      archive.set(.name,"current_density,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(j, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      j.destroy
   end

   get_jd_density_grid(jd)
   ! Set "jd" to the diamagnetic current density grid.
   ! If the archive file exists, read it; otherwise make it.
      MAT :: jd
      ARCHIVE :: archive
      archive.set(.name,"jd_density_grid")
      if ( archive.doesnt_exist) .make_jd_density_grid
      archive.read(jd)
   end

   make_jd_density_grid
   ! Work out the diamagnetic current density on ".grid" using ".natural
   ! orbitals" and the ".occupation" number vector.
   !    J_d(r) = - (e^2/2m) (B x r) rho(r)
      ARCHIVE :: archive
      MAT, PTR :: jd,r
      VEC, PTR :: rho
      ENSURE( .grid.created, "no grid")
      nullify(r)
      if ( .B_field.norm<TOL(10)) return
      jd.create(.grid.n_pt,3)
      r.create(.grid.n_pt,3)
      .grid.make_points(r)
      jd(:,1) = .B_field(2)*r(:,3) - .B_field(3)*r(:,2)
      jd(:,2) = .B_field(3)*r(:,1) - .B_field(1)*r(:,3)
      jd(:,3) = .B_field(1)*r(:,2) - .B_field(2)*r(:,1)
      r.destroy
      rho.create(.grid.n_pt)
      .get_electron_density_grid(rho)
      jd(:,1) = -HALF*jd(:,1)*rho
      jd(:,2) = -HALF*jd(:,2)*rho
      jd(:,3) = -HALF*jd(:,3)*rho
      rho.destroy
      archive.set(.name,"jd_density")
      archive.write(jd)
      archive.set(.name,"jd_density,gnuplot",format="ascii")
      archive.write_gnuplot(jd, .grid.n_x, .grid.n_y, .grid.n_z)
      archive.set(.name,"jd_norm_density,gnuplot",format="ascii")
      archive.write_gnuplot(jd, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      archive.set(.name,"jd_density,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(jd, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      jd.destroy
   end

   get_jp_density_grid(jp)
   ! Set "jp" to the paramagnetic current density grid.
   ! If the archive file exists, read it; otherwise make it.
      MAT :: jp
      ARCHIVE :: archive
      archive.set(.name,"jp_density_grid")
      if ( archive.doesnt_exist) .make_jp_density_grid
      archive.read(jp)
   end

   make_jp_density_grid
   ! Work out the paramagnetic current density on ".grid" using ".natural
   ! orbitals".  A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      MAT, PTR :: jp
      BIN :: complex
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .natural_orbitals.created, "no natural orbitals")
      ENSURE( .natural_orbitals.created, "no natural orbitals")
      complex = .natural_orbitals.number_kind == "complex"
      ENSURE(complex, "natural orbitals not complex")
      .make_ao_density_matrix
      .make_restricted_complex_NOs
      jp.create(.grid.n_pt,3)
      .make_jp_density_grid(jp)
      archive.set(.name,"jp_density_grid")
      archive.write(jp)
      archive.set(.name,"jp_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z)
      archive.set(.name,"jp_norm_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      archive.set(.name,"jp_density_grid,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      jp.destroy
   end

   make_jp_density_grid(jp)
   ! Work out the paramagnetic current density "jp" on ".grid" using ".natural
   ! orbitals" .
   !    J_p(r) = - (eh/m) Re [ \sum_i n_i \phi^*_i(r) \nabla \phi^*_i(r) ]
     MAT :: jp
     MAT, PTR :: pt
     CMAT, PTR :: P
     CVEC, PTR :: D
     INT :: n_occ,n,n_pt
     ENSURE( .grid.created,  "no grid")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     ENSURE( .natural_orbitals.created, "no density matrix")
     jp = ZERO
     n_pt = .grid.n_pt
     pt.create(n_pt,3); .grid.points(pt)
     D.create(n_pt)
     P.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_orbital_grid(D,.natural_orbitals.restricted_complex(:,n), pt)
       .make_nabla_orbital_grid(P,.natural_orbitals.restricted_complex(:,n), pt)
       jp(:,1) = jp(:,1) - .occupation.restricted(n)*aimag(conjg(D(:))*P(:,1))
       jp(:,2) = jp(:,2) - .occupation.restricted(n)*aimag(conjg(D(:))*P(:,2))
       jp(:,3) = jp(:,3) - .occupation.restricted(n)*aimag(conjg(D(:))*P(:,3))
     end
     P.destroy
     D.destroy
     pt.destroy
   end

   make_nabla_orbital_grid(g,orb)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points defined by ".grid"
      MAT, OUT :: g
      VEC, IN, target :: orb
      MAT, PTR :: pt,sh_grid_x,sh_grid_y,sh_grid_z
      VEC, PTR :: orb_a
      SHELL1 :: sh
      MAT3, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = .grid.n_pt
      ENSURE( size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(g,2)==3,    "grid array has wrong 2nd dimension")
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         orb_a => orb(fa:la)
         sh_grid_x => sh_grid(:,:,1)
         sh_grid_y => sh_grid(:,:,2)
         sh_grid_z => sh_grid(:,:,3)
         g(:,1).plus_product(sh_grid_x,orb_a)
         g(:,2).plus_product(sh_grid_y,orb_a)
         g(:,3).plus_product(sh_grid_z,orb_a)
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_nabla_orbital_grid(g,orb)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points defined by ".grid"
      CMAT, OUT :: g
      CVEC, IN, target :: orb
      MAT, PTR :: pt
      SHELL1 :: sh
      MAT3, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = .grid.n_pt
      ENSURE( size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(g,2)==3,    "grid array has wrong 2nd dimension")
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_nabla_orbital_grid(g,orb,pt)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      MAT, OUT :: g
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1, PTR :: sh
      MAT3, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE( size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(g,2)==3,    "grid array has wrong 2nd dimension")
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
   end

   make_nabla_orbital_grid(g,orb,pt)
   ! Evaluate the nabla orbital density for *one* complex AO-basis orbital "orb"
   ! on a set of grid points "pt"
      CMAT, OUT :: g
      CVEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1, PTR :: sh
      MAT3, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE( size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(g,2)==3,    "grid array has wrong 2nd dimension")
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
   end

   make_nabla_orbital_grid_x(g,orb,pt)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt", x derivative only.
      VEC, OUT :: g
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE(size(g)==n_pt, "grid array has wrong dimension")
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_nabla_grid_x(sh_grid,pt)
         g(:).plus_product(sh_grid(:,:),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_nabla_orbital_grid_y(g,orb,pt)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt", y derivative only.
      VEC, OUT :: g
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE(size(g)==n_pt, "grid array has wrong dimension")
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_nabla_grid_y(sh_grid,pt)
         g(:).plus_product(sh_grid(:,:),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_nabla_orbital_grid_z(g,orb,pt)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt", z derivative only.
      VEC, OUT :: g
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE(size(g)==n_pt, "grid array has wrong dimension")
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_nabla_grid_z(sh_grid,pt)
         g(:).plus_product(sh_grid(:,:),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_nabla_orbital_grid(g,h,orb,pt)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      MAT :: g
      VEC :: h
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT3, PTR :: sh_grid
      MAT, PTR :: sh_grid0
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE( size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(g,2)==3,    "grid array has wrong 2nd dimension")
      ENSURE( size(h)==n_pt,   "grid array has wrong 1st dimension")
      g = ZERO
      h = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh_grid0.create(n_pt,sh.n_comp)
         sh.make_nabla_grid(sh_grid,sh_grid0,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         h.plus_product(sh_grid0,orb(fa:la))
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_laplacian_orbital_grid(g,orb,pt)
   ! Evaluate the laplacian orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      MAT :: g
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1, PTR :: sh
      MAT3, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE( size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(g,2)==3,    "grid array has wrong 2nd dimension")
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh.make_laplacian_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
   end

   make_laplacian_orbital_grid(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      MAT :: g,h
      VEC :: i
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT3, PTR :: sh_grid,sh_grid1
      MAT, PTR :: sh_grid0
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE( size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(g,2)==3,    "grid array has wrong 2nd dimension")
      ENSURE( size(h,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(h,2)==3,    "grid array has wrong 2nd dimension")
      ENSURE( size(i)==n_pt,   "grid array has wrong 1st dimension")
      g = ZERO
      h = ZERO
      i = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh_grid1.create(n_pt,sh.n_comp,3)
         sh_grid0.create(n_pt,sh.n_comp)
         sh.make_laplacian_grid(sh_grid,sh_grid1,sh_grid0,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         h(:,1).plus_product(sh_grid1(:,:,1),orb(fa:la))
         h(:,2).plus_product(sh_grid1(:,:,2),orb(fa:la))
         h(:,3).plus_product(sh_grid1(:,:,3),orb(fa:la))
         i.plus_product(sh_grid0,orb(fa:la))
         sh_grid1.destroy
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_ELF_grid
   ! Work out the Electron Localisation Function (ELF) density on ".grid"
   ! using ".natural orbitals" and the ".occupation" number vector.
   ! Grid, basis set, and natural orbitals are required to exist.
   ! A Gnuplot ascii file is also generated.
      ARCHIVE :: archive
      VEC, PTR :: ELF_grid
      ENSURE( .grid.created, "no grid")
      ELF_grid.create( .grid.n_pt)
      .make_ELF_grid(ELF_grid)
      archive.set(.name,"ELF_grid,gnuplot",format="ascii")
      archive.write_gnuplot(ELF_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      ELF_grid.destroy
   end

   make_ELF_grid(ELF_grid)
   ! Work out the Electron Localisation Function (ELF) density on ".grid"
   ! using ".natural orbitals" and the ".occupation" number vector.
   ! Grid, basis set, and natural orbitals are required to exist.
   ! A Gnuplot ascii file is also generated.
      VEC :: ELF_grid
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      if (.natural_orbitals.destroyed) .make_natural_orbitals
      if (.natural_orbitals.number_kind == "real") then
         .make_ELF_grid_real(ELF_grid)
      else
         .make_ELF_grid_complex(ELF_grid)
      end
   end

   make_ELF_grid_real(ELF_grid)
   ! Work out the Electron Localisation Function (ELF) density on ".grid"
   ! using ".natural orbitals" and the ".occupation" number vector.
   ! Grid, basis set, and natural orbitals are required to exist.
   ! A Gnuplot ascii file is also generated.
      VEC :: ELF_grid
      MAT, PTR :: pt
      VEC, PTR :: mo_val,gx,gy,gz,rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s
      DBL :: occu,factor,mo_val_n,gx_n,gy_n,gz_n,occ_mo
      VEC, PTR :: NO
      MAT, PTR :: DD
      INT :: i,n_occ,n,n_pt
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .natural_orbitals.created, "no natural orbitals")
      ELF_grid = ZERO
      n_pt = .grid.n_pt
      rho_s.create(n_pt);  rho_s  = ZERO
      tau.create(n_pt);    tau    = ZERO
      rho_sx.create(n_pt); rho_sx = ZERO
      rho_sy.create(n_pt); rho_sy = ZERO
      rho_sz.create(n_pt); rho_sz = ZERO
      pt.create(n_pt,3); .grid.points(pt)
      NO.create(n_pt)
      DD.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do i = 1,n_occ
         .make_nabla_orbital_grid(DD,NO,.natural_orbitals.restricted(:,i), pt)
         mo_val => NO(:)
         gx     => DD(:,1)
         gy     => DD(:,2)
         gz     => DD(:,3)
         occu   = HALF*.occupation.restricted(i)
         do n = 1,n_pt
           mo_val_n  = mo_val(n)
           gx_n      = gx(n)
           gy_n      = gy(n)
           gz_n      = gz(n)
           occ_mo    = occu*mo_val_n
           rho_s(n)  = rho_s(n)  + occ_mo*mo_val_n
           tau(n)    = tau(n)    + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
           rho_sx(n) = rho_sx(n) + occ_mo*gx_n ! this is half grad_x rho_s
           rho_sy(n) = rho_sy(n) + occ_mo*gy_n
           rho_sz(n) = rho_sz(n) + occ_mo*gz_n
         end
      end
      DD.destroy
      NO.destroy
      pt.destroy
      d_s.create(n_pt)
      d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s
      rho_sz.destroy; rho_sy.destroy; rho_sx.destroy; tau.destroy
      d0_s.create(n_pt)
      factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
      d0_s = factor*rho_s**(FIVE/THREE)
      rho_s.destroy
      ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))
      d0_s.destroy; d_s.destroy
   end

  make_ELF_grid_complex(ELF_grid)
  ! Work out the Electron Localisation Function (ELF) density on ".grid"
  ! using ".natural orbitals" and the ".occupation" number vector.
  ! Grid, basis set, and natural orbitals are required to exist.
  ! A Gnuplot ascii file is also generated.
    VEC :: ELF_grid
    MAT, PTR :: pt
    CVEC, PTR :: mo_val,gx,gy,gz
    VEC, PTR  :: rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s
    DBL :: occu,factor
    CVEC, PTR :: NO
    CMAT, PTR :: DD
    INT :: n_occ,n,n_pt
    ENSURE( .grid.created,  "no grid")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    ENSURE( .natural_orbitals.created, "no natural orbitals")
    ELF_grid = ZERO
    n_pt = .grid.n_pt
    rho_s.create(n_pt);  rho_s  = ZERO
    tau.create(n_pt);    tau    = ZERO
    rho_sx.create(n_pt); rho_sx = ZERO
    rho_sy.create(n_pt); rho_sy = ZERO
    rho_sz.create(n_pt); rho_sz = ZERO
    pt.create(n_pt,3); .grid.points(pt)
    NO.create(n_pt)
    DD.create(n_pt,3)
    n_occ = .no_of_occupied_NOs
    do n = 1,n_occ
      .make_orbital_grid(NO,.natural_orbitals.restricted_complex(:,n), pt)
      .make_nabla_orbital_grid(DD,.natural_orbitals.restricted_complex(:,n), pt)
      mo_val => NO(:)
      gx     => DD(:,1)
      gy     => DD(:,2)
      gz     => DD(:,3)
      occu   = HALF*.occupation.restricted(n)
      rho_s  = rho_s  + occu*conjg(mo_val)*mo_val
      tau    = tau    + occu*(conjg(gx)*gx+conjg(gy)*gy+conjg(gz)*gz)
      rho_sx = rho_sx + occu*conjg(gx)*mo_val ! this is half grad_x rho_s
      rho_sy = rho_sy + occu*conjg(gy)*mo_val
      rho_sz = rho_sz + occu*conjg(gz)*mo_val
    end
    DD.destroy
    NO.destroy
    pt.destroy
    d_s.create(n_pt)
    d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s
    rho_sz.destroy; rho_sy.destroy; rho_sx.destroy; tau.destroy
    d0_s.create(n_pt)
    factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
    d0_s = factor*rho_s**(FIVE/THREE)
    rho_s.destroy
    ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))
    d0_s.destroy; d_s.destroy
  end

  make_electric_potential_grid
  ! Make the electric potential "pot_grid" on ".grid"
    ARCHIVE :: archive
    VEC, PTR :: pot_grid
    ENSURE( .grid.created,  "no grid")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    ENSURE( .density_matrix.created, "no density matrix")
    .make_ao_density_matrix
    pot_grid.create(.grid.n_pt)
    if (.density_matrix.number_kind == "complex") then
      .make_electric_potential_grid(pot_grid,.density_matrix.restricted_complex)
    else
      .make_electric_potential_grid(pot_grid,.density_matrix.restricted)
    end
    archive.set(.name,"electric_potential_grid")
    archive.write(pot_grid)
    archive.set(.name,"electric_potential_grid,gnuplot",format="ascii")
    archive.write_gnuplot(pot_grid, .grid.n_x, .grid.n_y, .grid.n_z)
    pot_grid.destroy
  end

  make_electric_potential_grid(pot_grid,dens)
  ! Make the total electric potential "pot_grid" on ".grid" using AO density
  ! matrix "dens"
    VEC :: pot_grid
    CMAT, target :: dens
    VEC, PTR :: elec_grid
    MAT, PTR :: pt
    pt.create(.grid.n_pt,3); .grid.points(pt)
    .nuclear_potential(pot_grid,pt)
    pt.destroy
    elec_grid.create(size(pot_grid))
    .make_electronic_pot_grid(elec_grid,dens)
    pot_grid.plus_vec(elec_grid)
    elec_grid.destroy
  end

  make_electric_potential_grid(pot_grid,dens)
  ! Make the total electric potential "pot_grid" on ".grid" using AO density
  ! matrix "dens"
    VEC :: pot_grid
    MAT, target :: dens
    VEC, PTR :: elec_grid
    MAT, PTR :: pt
    pt.create(.grid.n_pt,3); .grid.points(pt)
    .nuclear_potential(pot_grid,pt)
    pt.destroy
    elec_grid.create(size(pot_grid))
    .make_electronic_pot_grid(elec_grid,dens)
    pot_grid.plus_vec(elec_grid)
    elec_grid.destroy
  end

   make_electronic_pot_grid(pot_grid,dens)
   ! Make the electronic potential "pot_grid" on ".grid" using AO density matrix
   ! "dens"
      VEC :: pot_grid
      CMAT, target :: dens
      MAT, PTR :: pt,Vab
      CMAT, PTR :: Dba
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      pt.create(.grid.n_pt,3); .grid.points(pt)
      pot_grid = ZERO
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         Dba => dens(fb:lb,fa:la)
         fac = TWO; if (a==b) fac=ONE
         Vab.create(shell.a.n_comp,shell.b.n_comp)
         do k = 1,.grid.n_pt
            shell.make_nuclear_attraction_ints(Vab,pt(k,:))
            pot_grid(k) = pot_grid(k) - fac*Vab.trace_of_product(real(Dba,kind=DBL_KIND))
         end
         Vab.destroy
         shell.destroy_ptr_part
      end
      pt.destroy
   end

   make_electronic_pot_grid(pot_grid,dens)
   ! Make the electronic potential "pot_grid" on ".grid" using AO density matrix
   ! "dens"
      VEC :: pot_grid
      MAT, target :: dens
      MAT, PTR :: pt,Vab
      MAT, PTR :: Dba
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      pt.create(.grid.n_pt,3); .grid.points(pt)
      pot_grid = ZERO
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         Dba => dens(fb:lb,fa:la)
         fac = TWO; if (a==b) fac=ONE
         Vab.create(shell.a.n_comp,shell.b.n_comp)
         do k = 1,.grid.n_pt
            shell.get_nuc(Vab,ONE,pt(k,:))
            pot_grid(k) = pot_grid(k) - fac*Vab.trace_of_product(real(Dba,kind=DBL_KIND))
         end
         Vab.destroy
         shell.destroy_ptr_part
      end
      pt.destroy
   end

   make_solenoidal_jp_grid
   ! Make the solenoidal paramagnetic current density grid "jp" on ".grid"
     ARCHIVE :: archive
     MAT, PTR :: jp
     ENSURE( .grid.created,  "no grid")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     .make_ao_density_matrix
     ENSURE(.density_matrix.created("restricted_complex"), "no density matrix")
     jp.create(.grid.n_pt,3)
     .make_solenoidal_jp_grid(jp,.density_matrix.restricted_complex)
     archive.set(.name,"solenoidal_jp_density_grid")
     archive.write(jp)
     archive.set(.name,"solenoidal_jp_density_grid,gnuplot",format="ascii")
     archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z)
     archive.set(.name,"solenoidal_jp_norm_density_grid,gnuplot",format="ascii")
     archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
     archive.set(.name,"solenoidal_jp_density_grid,normalized,gnuplot",format="ascii")
     archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
     jp.destroy
   end

   make_solenoidal_jp_grid(jp,dens)
   ! Make the solenoidal paramagnetic current density grid "jp" on ".grid"
   ! using AO density matrix "dens"
      MAT :: jp
      CMAT, target :: dens
      CMAT, PTR :: Dba
      MAT, PTR :: pt,Jxab,Jyab,Jzab
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      pt.create(.grid.n_pt,3); .grid.points(pt)
      jp = ZERO
      do q = 1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (a==b) fac=ONE
        Jxab.create(shell.a.n_comp,shell.b.n_comp)
        Jyab.create(shell.a.n_comp,shell.b.n_comp)
        Jzab.create(shell.a.n_comp,shell.b.n_comp)
        do k = 1,.grid.n_pt
          shell.make_solenoidal_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
        end
        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        shell.destroy_ptr_part
      end
      pt.destroy
      jp.zero_small_values(TOL(10))
   end

   make_irrotational_jp_grid
   ! Make the irrotational paramagnetic current density grid "jp" on ".grid"
      ARCHIVE :: archive
      MAT, PTR :: jp
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      .make_ao_density_matrix
      ENSURE(.density_matrix.created("restricted_complex"), "no density matrix")
      jp.create(.grid.n_pt,3)
      .make_irrotational_jp_grid(jp,.density_matrix.restricted_complex)
      archive.set(.name,"irrotational_jp_density_grid")
      archive.write(jp)
      archive.set(.name,"irrotational_jp_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z)
      archive.set(.name,"irrotational_jp_norm_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      archive.set(.name,"irrotational_jp_density_grid,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      jp.destroy
   end

   make_irrotational_jp_grid(jp,dens)
   ! Make the irrotational paramagnetic current density grid "jp" on ".grid"
   ! using AO density matrix "dens"
      MAT :: jp
      CMAT, target :: dens
      CMAT, PTR :: Dba
      MAT, PTR :: pt,Jxab,Jyab,Jzab
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      pt.create(.grid.n_pt,3); .grid.points(pt)
      jp = ZERO
      do q = 1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (a==b) fac=ONE
        Jxab.create(shell.a.n_comp,shell.b.n_comp)
        Jyab.create(shell.a.n_comp,shell.b.n_comp)
        Jzab.create(shell.a.n_comp,shell.b.n_comp)
        do k = 1,.grid.n_pt
          shell.make_irrotational_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_of_product(real(aimag(Dba),kind=DBL_KIND))
        end
        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        shell.destroy_ptr_part
      end
      pt.destroy
      jp.zero_small_values(TOL(10))
   end

   get_vib_averaged_rho_grid(density_grid)
   ! Set "density_grid" to the vibrationally averaged electron density grid.
   ! If the archive file exists, read it; otherwise make it.
      VEC :: density_grid
      ARCHIVE :: archive
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE(.n_atom==2,"can only do diatomics")
      archive.set(.name,"vib_averaged_rho_grid")
      if ( archive.doesnt_exist) .make_vib_averaged_rho_grid
      archive.read(density_grid)
   end

   make_vib_averaged_rho_grid
   ! Work out the averaged density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC, PTR :: density_grid
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE(.n_atom==2,"can only do diatomics")
      .move_origin_to_centre_of_mass

      density_grid.create(.grid.n_pt)
      .integrate_rho_grid(density_grid,-FOUR,FOUR,TOL(4))

      archive.set(.name,"vib_averaged_rho_grid")
      archive.write(density_grid)
      archive.set(.name,"vib_averaged_rho_grid,gnuplot",format="ascii")
      archive.write_gnuplot(density_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      density_grid.destroy
   end

   integrate_rho_grid(res,a,b,accuracy,fa0,fb0) [recursive]
   ! Integrate the rho grid between the limits "a" and "b" using adaptive
   ! trapezoidal rule with Simpsons approximation.  If present, "accuracy"
   ! is the required accuracy of the integral. If present, "fa0" and
   ! "fb0" are the value of the rho_grid at "a" and "b" respectively.
   ! size of "res" is .grid.n_pt.
      DBL :: a,b
      DBL, optional :: accuracy
      VEC, PTR, optional :: fa0,fb0
      VEC, PTR :: res
      INT :: n_pt
      BIN :: same
      DBL :: tol,h,m
      VEC,PTR :: fa,fb,fm,one_trap,two_trap,left,right
      INT :: depth = 0
      ENSURE( .grid.created, "no grid")
      n_pt = .grid.n_pt
      depth = depth+1
      stdout.show("depth =",depth)
      tol = TOL(6)
      if (present(accuracy)) tol = accuracy
      h  = b-a
      m  = (a+b)/TWO
      if (present(fb0)) then; fb => fb0
      else;                   fb.create(n_pt); .make_rho_grid_at(b,fb)
      end
      if (present(fa0)) then; fa => fa0
      else;                   fa.create(n_pt); .make_rho_grid_at(a,fa)
      end
      fm.create(n_pt);    .make_rho_grid_at(m,fm)
      one_trap.create(n_pt)
      two_trap.create(n_pt)
      one_trap = h*(fa+fb)/TWO
      two_trap = h*(fa+TWO*fm+fb)/FOUR
      res = abs(one_trap-two_trap)
      same = maxval(res) < THREE*tol
      if (same AND depth>1) then
        res = (FOUR*two_trap - one_trap)/THREE
        two_trap.destroy
        one_trap.destroy
        fm.destroy
        fa.destroy
      else
        two_trap.destroy
        one_trap.destroy
        left.create(n_pt);  .integrate_rho_grid(left ,a,m,tol/TWO,fa0=fa,fb0=fm)
        right.create(n_pt); .integrate_rho_grid(right,m,b,tol/TWO,fa0=fm,fb0=fb)
        res = left + right
        right.destroy
        left.destroy
      end
      if (depth==1) fb.destroy
      depth = depth-1
   end

   make_rho_grid_at(q,rho)
   ! Work out the electron density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector at nuclear separation "q", where "q" is a
   ! dimensionless normal coordinate
   ! size or "rho" is .grid.n_pt.
      DBL :: q
      VEC :: rho
      DBL :: re,w,mu, gamma,d,r, wt
      INT :: n
      re = 2.0460259 ! N2
      w  = 2708      ! N2
      re = 1.3848617 ! H2
      w  = 4658      ! H2
      mu = .atom.reduced_mass
      n = 1
      gamma = sqrt( (w/WAVENUMBER_PER_HARTREE) &
                  * mu * MASS_OF_ELECTRON_PER_AMU ) ! This is gamma^(1/2)
      d = q/gamma ! d is the cartesian displacement in Bohr
      r = re + d  ! r is the actual separation of atoms in Bohr
      stdout.show("q =",q)
      stdout.show("d =",d)
      stdout.show("r =",r)
      stdout.show("g =",gamma)
      .atom(1).pos = ZERO
      .atom(2).pos = ZERO
      .atom(1).pos(3) = -r/TWO
      .atom(2).pos(3) = +r/TWO
      .move_origin_to_centre_of_mass
      .delete_scf_integrals
      .scf
      .make_density_grid(rho)
      wt = q.harmonic_vibrational_fn(n)
      wt = wt*wt
      rho = wt * rho
   end

   make_fermi_mobility_grid [leaky]
   ! Work out the density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC, PTR :: fermi_grid
      MAT, PTR :: pt
      ENSURE( .grid.created, "no grid")
      fermi_grid.create( .grid.n_pt)
      pt.create( .grid.n_pt, 3 );       .grid.points(pt)
      .make_fermi_mobility_grid(fermi_grid,pt)
      archive.set(.name,"fermi_mobility_grid,gnuplot",format="ascii")
      archive.write_gnuplot(fermi_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      pt.destroy
      fermi_grid.destroy
   end

  make_fermi_mobility_grid(f,pt) [leaky]
  ! Evaluate the Fermi hole mobility grid "f" on a set of grid points "pt".
    MAT, IN :: pt
    VEC, OUT :: f
    VEC, PTR :: del_gi
    VEC, PTR :: g,gi,rho,gx,gy,gz,orb
    INT :: n,n_pt,i,n_occ
    DBL :: gin,del_ginx,del_giny,del_ginz,fac
    ENSURE( .grid.created,  "no grid")
    if (.natural_orbitals.destroyed) .make_natural_orbitals
    n_pt = .grid.n_pt
    n_occ = .no_of_occupied_NOs

    g.create(n_pt);     g = ZERO
    gx.create(n_pt);    gx = ZERO
    gy.create(n_pt);    gy = ZERO
    gz.create(n_pt);    gz = ZERO
    gi.create(n_pt)
    del_gi.create(n_pt)

    orb.create(.n_bf)
    do i=1, n_occ
      orb = .natural_orbitals.restricted(:,i)
      .make_orbital_grid(gi,orb,pt)
      .make_nabla_orbital_grid_x(del_gi,orb,pt)
      do n=1,n_pt
        del_ginx = del_gi(n)
        g(n) = g(n) + del_ginx*del_ginx
        gx(n) = gx(n) + gi(n)*del_ginx
      end
      .make_nabla_orbital_grid_y(del_gi,orb,pt)
      do n=1,n_pt
        del_giny = del_gi(n)
        g(n) = g(n) + del_giny*del_giny
        gy(n) = gy(n) + gi(n)*del_giny
      end
      .make_nabla_orbital_grid_z(del_gi,orb,pt)
      do n=1,n_pt
        del_ginz = del_gi(n)
        g(n) = g(n) + del_ginz*del_ginz
        gz(n) = gz(n) + gi(n)*del_ginz
      end
    end
    orb.destroy
    del_gi.destroy
    gi.destroy

    rho.create(n_pt)
    .make_density_grid(rho,pt)
    fac = (THREE*PI/FOUR) * HALF**0.666666666667d0
    f = ONE/rho * (g - TWO*(gx * gx + gy * gy + gz * gz)/rho) - fac * rho**0.666666666667d0
    rho.destroy
    gz.destroy
    gy.destroy
    gx.destroy
    g.destroy
  end

   integrate_density_numerically
   ! Integrate the density numerically
      INT :: n_pts
      MAT, PTR :: pt
      VEC, PTR :: wt,rho
      DBL :: n_e
      ENSURE( .dftgrid.created, "no dftgrid information supplied")
      n_pts = .dftgrid.n_atom_pts * .n_atom
      pt.create(n_pts,3)
      wt.create(n_pts)
      rho.create(n_pts)
      .dftgrid.make_grid(pt,wt,.atom)
      .make_density_grid(rho,pt)
      n_e = sum(rho*wt)
      stdout.show("numerically integrated charge =",n_e)
      rho.destroy
      wt.destroy
      pt.destroy
   end

end 
