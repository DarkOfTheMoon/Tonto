!---------------------------------------------------------------------------
!
!  INT: methods which apply to integers
!
!  (c) dylan jayatilaka, 1998
!
! $Id$
!---------------------------------------------------------------------------
module INT

   use TYPES
   use SYSTEM
   use STR

   implicit none         

#include "macros"
#include "int.int"

contains

   is_even result(res)
   ! Return TRUE is self is an even number
      BIN :: res
      res = mod(self,2)==0
   end

   is_odd result(res)
   ! Return TRUE is self is an odd number
      BIN :: res
      res = mod(self,2)==1
   end

   to_str result(string)
   ! Change integer to a default length string
      STR :: string
      string = ""
      write(string,"(i64)") self
      string.left_justify
   end

   raised_to(n) result(res)
   ! Raise "self" to the power "n"
      INT :: n
      DBL :: res
      INT :: i
      res = ONE
      do i = 1,abs(n)
         res = res*self
      end
      if (n<0) res = ONE/res
   end

   factorial result(res) [always_elemental]
   ! Return the factorial of the integer
   ! res cannot be int, as int(4) dies as 13!.
      IN :: self
      DBL :: res
      INT :: i
   !  ENSURE(self>=0,"must have non-negative argument")
      select case (self)
         case (0); res=1.0d0
         case (1); res=1.0d0
         case (2); res=2.0d0
         case (3); res=6.0d0
         case (4); res=24.0d0
         case (5); res=120.0d0
         case (6); res=720.0d0
         case (7); res=5040.0d0
         case (8); res=40320.0d0
         case (9); res=362880.0d0
         case default
           res = 3628800.0d0
           do i=11,self
             res = res * i
           end
      end 
   end 

   double_factorial result(res) [always_elemental]
   ! Return the double factorial of the integer
   ! res cannot be int, as int(4) dies as 11!!.
      IN :: self
      DBL :: res
      INT :: i
   !  ENSURE(self>=0,"must have non-negative argument")
      select case (self)
         case (0); res=1.0d0
         case (1); res=1.0d0
         case (2); res=3.0d0
         case (3); res=15.0d0
         case (4); res=105.0d0
         case (5); res=945.0d0
         case (6); res=10395.0d0
         case (7); res=135135.0d0
         case (8); res=2027025.0d0
         case (9); res=34459425.0d0
         case default
           res=654729075.0d0
           do i=11,self
             res = res * (2 * i - 1)
           end
      end 
   end 

   permutation(n) result(res)
   ! Return self!/n! , self>n
      IN :: self
      INT :: n
      DBL :: res
      INT :: i
   !  ENSURE(self>=0,"must have non-negative argument")
   !  ENSURE(self>=n,"must have self>=n")
      res = ONE
      do i = n+1,self
         res = res * i
      end
   end 

   permutation(n,m) result(res)
   ! Return self!/(n!m!) , self>n, self>m
      IN :: self
      INT :: n,m
      DBL :: res
      INT :: i
   !  ENSURE(self>=0,"must have non-negative argument")
   !  ENSURE(self>=n,"must have self>=n")
   !  ENSURE(self>=m,"must have self>=m")
      res = self.permutation(n)
      do i = 2,m
         res = res / i
      end
   end 

   choose(n) result(res)
   ! Return self!/n!(self-n)! , self>=n
      IN :: self
      INT :: n
      DBL :: res
   !  ENSURE(self>=0,"must have non-negative argument")
   !  ENSURE(self>=n,"must have self>=n")
      res = self.permutation(n,self-n)
   end 

   sqrt_permutation(n) result(res)
   ! Return sqrt(self!)/n! , self>n
      IN :: self
      INT :: n
      DBL :: res,top,bot
      INT :: i
   !  ENSURE(self>=0,"must have non-negative argument")
   !  ENSURE(self>=n,"must have self>=n")
      bot = ONE
      top = ONE
      do i = 1,n
         bot = bot * i
      end
      do i = n+1,self
         top = top * i
      end
      res = sqrt(top / bot)
   end 

   sqrt_permutation(n,m) result(res)
   ! Return sqrt(self!)/(n!m!) , self>n, self>m
      IN :: self
      INT :: n,m
      DBL :: res
      INT :: i
   !  ENSURE(self>=0,"must have non-negative argument")
   !  ENSURE(self>=n,"must have self>=n")
   !  ENSURE(self>=m,"must have self>=m")
      res = self.sqrt_permutation(n)
      do i = 2,m
         res = res / i
      end
   end 

  n_comp result(res) [always_pure]
  ! No. of cartesian components in a gaussian shell of momentum "self".
    IN :: self
    INT :: res
    res = (self+1)*(self+2)/2
  end

  n_comp_sum result(res) [always_pure]
  ! No. of cartesian components up to shell with momentum "self".
    IN :: self
    INT :: res
    res = (self+1)*(self+2)*(self+3)/6
  end

  momentum_from_index result(res) [always_pure]
  ! Returns the total momentum of the cartesian component angular momentum
  ! vector with index "self".
    IN :: self
    INT :: res
    DBL :: mess
    mess = (81d0*real(self,kind=DBL_KIND) + &
                sqrt(real(6561*self*self-27,kind=DBL_KIND)))**(0.333333333333333333d0)
    res = ceiling(1.0d0/mess + mess*(0.33333333333333333d0)-2.0000001d0)
  end

  cartesian_components(res) [always_pure]
  ! Returns the cartesian components of the angular momentum "self".
  ! Size of the result is [3,self.n_comp].
    IN :: self
    IMAT(3,(self+1)*(self+2)/2), OUT :: res
    INT :: a,b,c,ind
    ind=1
    do a = self,floor((self+2)/3.0),-1
      do b = min(self-a,a),floor((self-a+1)/2.0),-1
        c = self-a-b
        if (a==b AND b==c) then
          res(1:3,ind)   = (/a,a,a/)
          ind = ind+1
        else if (a>b AND b==c) then
          res(1:3,ind)   = (/a,b,b/)
          res(1:3,ind+1) = (/b,a,b/)
          res(1:3,ind+2) = (/b,b,a/)
          ind = ind+3
        else if (a==b AND b>c) then
          res(1:3,ind)   = (/a,a,c/)
          res(1:3,ind+1) = (/a,c,a/)
          res(1:3,ind+2) = (/c,a,a/)
          ind = ind+3
        else
          res(1:3,ind)   = (/a,b,c/)
          res(1:3,ind+1) = (/a,c,b/)
          res(1:3,ind+2) = (/b,a,c/)
          res(1:3,ind+3) = (/c,a,b/)
          res(1:3,ind+4) = (/b,c,a/)
          res(1:3,ind+5) = (/c,b,a/)
          ind = ind+6
        end
      end
    end
  end

  hermite_polynomial(normalise) result(res) 
  ! Returns an array with the coefficients of the Hermite Polynomials.  First
  ! elements is for x^0, second for x^1, and so on.  The length of the result
  ! is (self+1).  Method used is equation 13.9 from Arfken and Weber 4th ed.
  ! If present and TRUE, "normalise" gives coefficients normalised for use
  ! in generating harmonic vibrational wavefunctions.
    BIN, optional :: normalise
    VEC* :: res
    BIN :: norm
    INT :: n
    INT :: s,i,t
    DBL :: sign
!   ENSURE(self>=0,"order must be 0 or greater")
    n = self
    norm = FALSE
    if (present(normalise)) norm = normalise
    allocate(res(n+1))
    t = 2
    res = ZERO
    if (norm) then 
       sign = -ONE/sqrt(sqrt(PI))
       do s = 0,(n/2)
          sign = -sign
          i = n - 2*s
          res(i+1) = sign * sqrt( t.raised_to(2*i-n)) * n.sqrt_permutation(s,i)
       end
    else
       sign = -ONE
       do s = 0,(n/2)
          sign = -sign
          i = n - 2*s
          res(i+1) = sign * t.raised_to(i) * n.permutation(s,i)
       end
    end
!   select case (self)
!     case (0); res = [   1.0d0]
!     case (1); res = [   0.0d0,   2.0d0]
!     case (2); res = [  -2.0d0,   0.0d0,   4.0d0]
!     case (3); res = [   0.0d0, -12.0d0,   0.0d0,   8.0d0]
!     case (4); res = [  12.0d0,   0.0d0, -48.0d0,   0.0d0,  16.0d0]
!     case (5); res = [   0.0d0, 120.0d0,   0.0d0,-160.0d0,   0.0d0, 32.0d0]
!     case (6); res = [-120.0d0,   0.0d0, 720.0d0,   0.0d0,-480.0d0,  0.0d0,  64.0d0]
!     case default; 
!        res(2:n+1) = TWO* (n-1).hermite_polynomial
!        res(1:n-1) = res(1:n-1) - TWO*(n-1)* (n-2).hermite_polynomial
!   end
  end

  legendre_polynomials result(res) [always_pure]
  ! Returns an array with the coefficients of the Legendre Polynomials.  First
  ! elements is for x^0, second for x^1, and so on.  The length of the result
  ! is (self+1).  Method used is equation 12.64 from Arfken and Weber 4th ed.
    IN :: self
    VEC(self+1) :: res
    INT :: k
    DBL :: the_sign,self2
    select case (self)
      case (0); self2 = 1.0d0
      case (1); self2 = 2.0d0
      case (2); self2 = 4.0d0
      case default; self2 = 2.0d0**self
    end
    res=0.0d0
    do k=0,self/2
      if (mod(k,2) == 0) then
        the_sign = 1.0d0
      else
        the_sign = -1.0d0
      end
      res(self-2*k+1) = the_sign * (2*(self-k)).factorial / &
               (self2 * k.factorial * (self-k).factorial * (self-2*k).factorial)
    end
  end

  spherical_to_cartesians result(res) [always_pure]
  ! Returns the matrix which gives the cartesian to spherical conversion.
  ! Self is the angular momentum.
    IN :: self
    MAT(2*self+1,(self+1)*(self+2)/2) :: res
    MAT3(0:self,0:self,0:self) :: mat0
    CMAT3(0:self,0:self,0:self) :: plus,minus
    CMAT3(0:self,0:self,0:self) :: dx,dy,dz
    IMAT(3,(self+1)*(self+2)/2) :: components
    DBL :: temp1,temp2,temp3
    INT :: start,i,j,array_pos,x,y,z,r_power,ind,m
    VEC(0:self) :: P_l_0

    P_l_0 = self.legendre_polynomials
    self.cartesian_components(components)
    do ind = 1, n_comp(self)
      x = components(1,ind)
      y = components(2,ind)
      z = components(3,ind)
    end
    mat0 = ZERO
    if (mod(self,2)==0) then
      start = 0
    else
      start = 1
    end
    do array_pos = start,self,2
      r_power = (self - array_pos)/2
      temp1 = P_l_0(array_pos) * r_power.factorial
      do i = 0, r_power
        temp2 = temp1 / ( i.factorial )
        x = 2*i
        do j = 0, r_power-i
          y = 2*j
          z = 2*(r_power - i - j) + array_pos
          temp3 = temp2 / (j.factorial * (r_power-i-j).factorial )
          mat0(x,y,z) = mat0(x,y,z) + temp3
        end
      end
    end
    do ind = 1, n_comp(self)
      x = components(1,ind)
      y = components(2,ind)
      z = components(3,ind)
      res(1,ind) = mat0(x,y,z)
    end

    plus = (1,1) * mat0
    minus =  (1,1) * mat0
    do m=1,self
      dx = eoshift(plus,1,(ZERO,ZERO),1)
      dy = eoshift(plus,1,(ZERO,ZERO),2)
      dz = eoshift(plus,1,(ZERO,ZERO),3)
      do i=0,self
        dx(i,:,:) = dx(i,:,:) * (i+1)
        dy(:,i,:) = dy(:,i,:) * (i+1)
        dz(:,:,i) = dz(:,:,i) * (i+1)
      end
      plus = eoshift(dx,-1,(ZERO,ZERO),3) - eoshift(dz,-1,(ZERO,ZERO),1) &
        + (1,0) * (-eoshift(aimag(dy),-1,ZERO,3)+eoshift(aimag(dz),-1,ZERO,2)) &
        + (0,1) * (eoshift(real(dy),-1,ZERO,3)-eoshift(real(dz),-1,ZERO,2))

      dx = eoshift(minus,1,(ZERO,ZERO),1)
      dy = eoshift(minus,1,(ZERO,ZERO),2)
      dz = eoshift(minus,1,(ZERO,ZERO),3)
      do i=0,self
        dx(i,:,:) = dx(i,:,:) * (i+1)
        dy(:,i,:) = dy(:,i,:) * (i+1)
        dz(:,:,i) = dz(:,:,i) * (i+1)
      end
      minus = - eoshift(dx,-1,(ZERO,ZERO),3) + eoshift(dz,-1,(ZERO,ZERO),1) &
        + (1,0) * (-eoshift(aimag(dy),-1,ZERO,3)+eoshift(aimag(dz),-1,ZERO,2)) &
        + (0,1) * (eoshift(real(dy),-1,ZERO,3)-eoshift(real(dz),-1,ZERO,2))

      temp1 = sqrt(real(self*(self+1)-(m-1)*(m),kind=DBL_KIND))
      plus = plus / temp1
      minus = minus / temp1
      do ind = 1, n_comp(self)
        x = components(1,ind)
        y = components(2,ind)
        z = components(3,ind)
        res(2*m,ind)   = (-1)**m * real(plus(x,y,z)) + real(minus(x,y,z))
        res(2*m+1,ind) = (-1)**m * aimag(plus(x,y,z)) - aimag(minus(x,y,z))
      end
    end
    res(2:,:) = res(2:,:) / sqrt(TWO)
  end

  assoc_legendre(m) result(res)
  ! Returns d^m/dx^m(Pn(x)) for the associated Legendre polynomial, but does
  ! not multiply by (1-x^2)^(m/2).
    INT, IN :: m
    VEC(self+1) :: res
    INT :: i,j
    res = self.legendre_polynomials
    do i=1,abs(m)
      do j=1,self+1
        res(j) = res(j) * (j-1)
      end
      res = eoshift(res,1,ZERO)
    end
    if (m < 0) then
      res = (self+m).factorial / (self-m).factorial * res
      if (mod(m,2)==1) res = - res
    end
  end

  cos_coeff(comp) result(res)
  ! Returns the coefficient of cos^comp(self-2*comp) sin^(2*comp)(phi) of the
  ! expansion of cos(self phi)
    IN :: self
    INT, IN :: comp
    INT :: res,i,comp2,factor
    if (self==0) then
      if (comp==0) then; res = 1
      else;              res = 0
      end
    else if (mod(comp,2)==0 OR comp<0) then
      res = 0
    else
      comp2 = (comp - 1) / 2
      if (mod(comp2,2)==0) then; res = 1
      else;                      res = -1
      end
      do i = abs(self) - 2 * comp2 + 1, abs(self)
        res = res * i
      end
      factor=1
      do i = 1, comp2 - 1
        factor = factor * (2 * i + 1) * (i + 1)
      end
      res = res / (2**comp2 * factor)
      if (self<0) res = - res
    end
  end

  sin_coeff(comp) result(res)
  ! Returns the coefficient of cos^(self-2*comp-1)(phi) sin^(2*comp+1)(phi)
  ! of the expansion of sin(self * phi).
    IN :: self
    INT, IN :: comp
    INT :: res,i,comp2,factor
    if (mod(comp,2)==0 OR comp<0 OR self==0) then
      res = 0
    else
      comp2 = (comp - 1) / 2
      if (mod(comp2,2)==0) then; res = 1
      else;                      res = -1
      end
      do i = abs(self) - 2 * comp2, abs(self)
        res = res * i
      end
      factor=1
      do i = 1, comp2 - 1
        factor = factor * (2 * i + 1) * (i + 1)
      end
      res = res / (2**comp2 * (2 * comp2 + 1) * factor)
    end
  end

  make_gaussian_xyz_indices(nx,ny,nz) [always_pure]
  ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
  ! momentum "self".
  ! (actually adds one to each power to avoid 0 as lower bound).
    IN :: self
    IVEC, OUT :: nx,ny,nz
    .make_gaussian_xyz_indices(nx,ny,nz,self)
  end

  make_gaussian_xyz_indices(nx,ny,nz,maxl) [always_pure]
  ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
  ! momentum "self".
  ! (actually adds one to each power to avoid 0 as lower bound).
    IN :: self
    INT, IN :: maxl
    IVEC, OUT :: nx,ny,nz
    INT :: a,b,c,i,j,a1,b1,c1
    i = 1
    do j=self,maxl
      do a = j,floor((j+2)/3.0),-1
         do b = min(j-a,a),floor((j-a+1)/2.0),-1
           c = j-a-b
           a1=a+1;   b1=b+1;   c1=c+1
           if (a==b AND b==c) then
             nx(i  ) = a1; ny(i  ) = a1; nz(i  ) = a1
             i = i+1
           else if (a>b AND b==c) then
             nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = b1
             nx(i+1) = b1; ny(i+1) = a1; nz(i+1) = b1
             nx(i+2) = b1; ny(i+2) = b1; nz(i+2) = a1
             i = i+3
           else if (a==b AND b>c) then
             nx(i  ) = a1; ny(i  ) = a1; nz(i  ) = c1
             nx(i+1) = a1; ny(i+1) = c1; nz(i+1) = a1
             nx(i+2) = c1; ny(i+2) = a1; nz(i+2) = a1
             i = i+3
           else
             nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = c1
             nx(i+1) = a1; ny(i+1) = c1; nz(i+1) = b1
             nx(i+2) = b1; ny(i+2) = a1; nz(i+2) = c1
             nx(i+3) = c1; ny(i+3) = a1; nz(i+3) = b1
             nx(i+4) = b1; ny(i+4) = c1; nz(i+4) = a1
             nx(i+5) = c1; ny(i+5) = b1; nz(i+5) = a1
             i = i+6
           end
        end
      end
    end
  end

  make_gaussian_xyz_powers(mat) [pure]
  ! Returns the cartesian components of the angular momentum "self".
  ! Size of mat is [3,l.n_comp].
    IN :: self
    IMAT, OUT :: mat
    .make_gaussian_xyz_powers(mat,self)
  end

  make_gaussian_xyz_powers(mat,index) [pure]
  ! Returns the cartesian components of the angular momentum "self".
  ! Size of mat is [3,l.n_comp].
    IN :: self
    IMAT, OUT :: mat
    IMAT3, OUT :: index
    .make_gaussian_xyz_powers(mat,self,index)
  end

  make_gaussian_xyz_powers(nx,ny,nz) [always_pure]
  ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
  ! momentum "self".
    IN :: self
    IVEC, OUT :: nx,ny,nz
    .make_gaussian_xyz_powers(nx,ny,nz,self)
  end

  make_gaussian_xyz_powers(nx,ny,nz,maxl) [always_pure]
  ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
  ! momentum "self".
  ! (actually adds one to each power to avoid 0 as lower bound).
    IN :: self
    INT, IN :: maxl
    IVEC, OUT :: nx,ny,nz
    INT :: a,b,c,i,j
    i = 1
    do j=self,maxl
      do a = j,floor((j+2)/3.0),-1
        do b = min(j-a,a),floor((j-a+1)/2.0),-1
          c = j-a-b
          if (a==b AND b==c) then
            nx(i  ) = a; ny(i  ) = a; nz(i  ) = a
            i = i+1
          else if (a>b AND b==c) then
            nx(i  ) = a; ny(i  ) = b; nz(i  ) = b
            nx(i+1) = b; ny(i+1) = a; nz(i+1) = b
            nx(i+2) = b; ny(i+2) = b; nz(i+2) = a
            i = i+3
          else if (a==b AND b>c) then
            nx(i  ) = a; ny(i  ) = a; nz(i  ) = c
            nx(i+1) = a; ny(i+1) = c; nz(i+1) = a
            nx(i+2) = c; ny(i+2) = a; nz(i+2) = a
            i = i+3
          else
            nx(i  ) = a; ny(i  ) = b; nz(i  ) = c
            nx(i+1) = a; ny(i+1) = c; nz(i+1) = b
            nx(i+2) = b; ny(i+2) = a; nz(i+2) = c
            nx(i+3) = c; ny(i+3) = a; nz(i+3) = b
            nx(i+4) = b; ny(i+4) = c; nz(i+4) = a
            nx(i+5) = c; ny(i+5) = b; nz(i+5) = a
            i = i+6
          end
        end
      end
    end
  end

  make_gaussian_xyz_powers(nx,ny,nz,maxl,index) [always_pure]
  ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
  ! momentum "self".
  ! (actually adds one to each power to avoid 0 as lower bound).
    IN :: self
    INT, IN :: maxl
    IVEC, OUT :: nx,ny,nz
    IMAT3, OUT :: index
    INT :: a,b,c,i,j,a1,b1,c1
    i = 1
    do j=self,maxl
      do a = j,floor((j+2)/3.0),-1
        do b = min(j-a,a),floor((j-a+1)/2.0),-1
          c = j-a-b
          if (a==b AND b==c) then
            a1=a+1
            nx(i  ) = a; ny(i  ) = a; nz(i  ) = a
            index(a1,a1,a1) = i
            i = i+1
          else if (a>b AND b==c) then
            a1=a+1;   b1=b+1
            nx(i  ) = a; ny(i  ) = b; nz(i  ) = b
            nx(i+1) = b; ny(i+1) = a; nz(i+1) = b
            nx(i+2) = b; ny(i+2) = b; nz(i+2) = a
            index(a1,b1,b1) = i
            index(b1,a1,b1) = i+1
            index(b1,b1,a1) = i+2
            i = i+3
          else if (a==b AND b>c) then
            a1=a+1;   c1=c+1
            nx(i  ) = a; ny(i  ) = a; nz(i  ) = c
            nx(i+1) = a; ny(i+1) = c; nz(i+1) = a
            nx(i+2) = c; ny(i+2) = a; nz(i+2) = a
            index(a1,a1,c1) = i
            index(a1,c1,a1) = i+1
            index(c1,a1,a1) = i+2
            i = i+3
          else
            a1=a+1;   b1=b+1;   c1=c+1
            nx(i  ) = a; ny(i  ) = b; nz(i  ) = c
            nx(i+1) = a; ny(i+1) = c; nz(i+1) = b
            nx(i+2) = b; ny(i+2) = a; nz(i+2) = c
            nx(i+3) = c; ny(i+3) = a; nz(i+3) = b
            nx(i+4) = b; ny(i+4) = c; nz(i+4) = a
            nx(i+5) = c; ny(i+5) = b; nz(i+5) = a
            index(a1,b1,c1) = i
            index(a1,c1,b1) = i+1
            index(b1,a1,c1) = i+2
            index(c1,a1,b1) = i+3
            index(b1,c1,a1) = i+4
            index(c1,b1,a1) = i+5
            i = i+6
          end
        end
      end
    end
  end

  make_gaussian_xyz_powers(mat,maxl) [pure]
  ! Returns the cartesian components of all angular momenta between "self"
  ! and "maxl".
  ! Size of mat is [3, maxl.n_comp_sum - (minl-1).n_comp_sum )].
    IN :: self
    INT, IN :: maxl
    IMAT, OUT :: mat
    INT :: a,b,c,ind,j
    ind=1
    do j=self,maxl
      do a = j,floor((j+2)/3.0),-1
        do b = min(j-a,a),floor((j-a+1)/2.0),-1
          c = j-a-b
          if (a==b AND b==c) then
            mat(1:3,ind)   = (/a,a,a/)
            ind = ind+1
          else if (a>b AND b==c) then
            mat(1:3,ind)   = (/a,b,b/)
            mat(1:3,ind+1) = (/b,a,b/)
            mat(1:3,ind+2) = (/b,b,a/)
            ind = ind+3
          else if (a==b AND b>c) then
            mat(1:3,ind)   = (/a,a,c/)
            mat(1:3,ind+1) = (/a,c,a/)
            mat(1:3,ind+2) = (/c,a,a/)
            ind = ind+3
          else
            mat(1:3,ind)   = (/a,b,c/)
            mat(1:3,ind+1) = (/a,c,b/)
            mat(1:3,ind+2) = (/b,a,c/)
            mat(1:3,ind+3) = (/c,a,b/)
            mat(1:3,ind+4) = (/b,c,a/)
            mat(1:3,ind+5) = (/c,b,a/)
            ind = ind+6
          end
        end
      end
    end
  end

  make_gaussian_xyz_powers(mat,maxl,index) [pure]
  ! Returns the cartesian components of all angular momenta between "self"
  ! and "maxl".
  ! Size of mat is [3, maxl.n_comp_sum - (minl-1).n_comp_sum )].
    IN :: self
    INT, IN :: maxl
    IMAT, OUT :: mat
    IMAT3, OUT :: index
    INT :: a,b,c,i,j,a1,b1,c1
    i=1
    do j=self,maxl
      do a = j,floor((j+2)/3.0),-1
        do b = min(j-a,a),floor((j-a+1)/2.0),-1
          c = j-a-b
          if (a==b AND b==c) then
            a1=a+1
            mat(1:3,i)   = (/a,a,a/)
            index(a1,a1,a1) = i
            i = i+1
          else if (a>b AND b==c) then
            a1=a+1;   b1=b+1
            mat(1:3,i)   = (/a,b,b/)
            mat(1:3,i+1) = (/b,a,b/)
            mat(1:3,i+2) = (/b,b,a/)
            index(a1,b1,b1) = i
            index(b1,a1,b1) = i+1
            index(b1,b1,a1) = i+2
            i = i+3
          else if (a==b AND b>c) then
            a1=a+1;   c1=c+1
            mat(1:3,i)   = (/a,a,c/)
            mat(1:3,i+1) = (/a,c,a/)
            mat(1:3,i+2) = (/c,a,a/)
            index(a1,a1,c1) = i
            index(a1,c1,a1) = i+1
            index(c1,a1,a1) = i+2
            i = i+3
          else
            a1=a+1;   b1=b+1;   c1=c+1
            mat(1:3,i)   = (/a,b,c/)
            mat(1:3,i+1) = (/a,c,b/)
            mat(1:3,i+2) = (/b,a,c/)
            mat(1:3,i+3) = (/c,a,b/)
            mat(1:3,i+4) = (/b,c,a/)
            mat(1:3,i+5) = (/c,b,a/)
            index(a1,b1,c1) = i
            index(a1,c1,b1) = i+1
            index(b1,a1,c1) = i+2
            index(c1,a1,b1) = i+3
            index(b1,c1,a1) = i+4
            index(c1,b1,a1) = i+5
            i = i+6
          end
        end
      end
    end
  end

  make_gaussian_xyz_powers(mat,maxl,index,first_nonzero) [pure]
  ! Returns the cartesian components of all angular momenta between "self"
  ! and "maxl".
  ! Size of mat is [3, maxl.n_comp_sum - (minl-1).n_comp_sum )].
    IN :: self
    INT, IN :: maxl
    IMAT, OUT :: mat
    IMAT3, OUT :: index
    IVEC, OUT :: first_nonzero
    INT :: a,b,c,i,j,a1,b1,c1,k
    i=1
    do j=self,maxl
      k=1
      do a = j,floor((j+2)/3.0),-1
        do b = min(j-a,a),floor((j-a+1)/2.0),-1
          c = j-a-b
          if (a==b AND b==c) then
            a1=a+1
            mat(1:3,i)   = (/a,a,a/)
            index(a1,a1,a1) = k
            first_nonzero(i)=1
            i = i+1
            k = k+1
          else if (a>b AND b==c) then
            a1=a+1;   b1=b+1
            mat(1:3,i)   = (/a,b,b/)
            mat(1:3,i+1) = (/b,a,b/)
            mat(1:3,i+2) = (/b,b,a/)
            index(a1,b1,b1) = k
            index(b1,a1,b1) = k+1
            index(b1,b1,a1) = k+2
            first_nonzero(i)  =1
            first_nonzero(i+1)=2
            first_nonzero(i+2)=3
            if (b>0) then
              first_nonzero(i+1)=1
              first_nonzero(i+2)=1
            end
            i = i+3
            k = k+3
          else if (a==b AND b>c) then
            a1=a+1;   c1=c+1
            mat(1:3,i)   = (/a,a,c/)
            mat(1:3,i+1) = (/a,c,a/)
            mat(1:3,i+2) = (/c,a,a/)
            index(a1,a1,c1) = k
            index(a1,c1,a1) = k+1
            index(c1,a1,a1) = k+2
            first_nonzero(i)  =1
            first_nonzero(i+1)=1
            first_nonzero(i+2)=2
            if (c>0) then
              first_nonzero(i+2)=1
            end
            i = i+3
            k = k+3
          else
            a1=a+1;   b1=b+1;   c1=c+1
            mat(1:3,i)   = (/a,b,c/)
            mat(1:3,i+1) = (/a,c,b/)
            mat(1:3,i+2) = (/b,a,c/)
            mat(1:3,i+3) = (/c,a,b/)
            mat(1:3,i+4) = (/b,c,a/)
            mat(1:3,i+5) = (/c,b,a/)
            index(a1,b1,c1) = k
            index(a1,c1,b1) = k+1
            index(b1,a1,c1) = k+2
            index(c1,a1,b1) = k+3
            index(b1,c1,a1) = k+4
            index(c1,b1,a1) = k+5
            if (a>0) then
              first_nonzero(i)  =1
              first_nonzero(i+1)=1
              first_nonzero(i+2)=2
              first_nonzero(i+3)=2
              first_nonzero(i+4)=3
              first_nonzero(i+5)=3
            else
              first_nonzero(i:i+3)=3
              ! i+4,i+5 must have b or c nonzero.
            end
            if (b>0) then
              first_nonzero(i+2)=1
              first_nonzero(i+4)=1
              first_nonzero(i+5)=2
            end
            if (c>0) then
              first_nonzero(i+3)=1
              first_nonzero(i+5)=1
            end
            i = i+6
            k = k+6
          end
        end
      end
    end
  end

  make_gaussian_xyz_power_index(index,maxl) [pure]
  ! Returns the cartesian components of all angular momenta between "self"
  ! and "maxl".
  ! Size of mat is [3, maxl.n_comp_sum - (minl-1).n_comp_sum )].
    IN :: self
    INT, IN :: maxl
    IMAT3, OUT :: index
    INT :: a,b,c,i,j,a1,b1,c1
    i=1
    do j=self,maxl
      do a = j,floor((j+2)/3.0),-1
        do b = min(j-a,a),floor((j-a+1)/2.0),-1
          c = j-a-b
          if (a==b AND b==c) then
            a1=a+1
            index(a1,a1,a1) = i
            i = i+1
          else if (a>b AND b==c) then
            a1=a+1;   b1=b+1
            index(a1,b1,b1) = i
            index(b1,a1,b1) = i+1
            index(b1,b1,a1) = i+2
            i = i+3
          else if (a==b AND b>c) then
            a1=a+1;   c1=c+1
            index(a1,a1,c1) = i
            index(a1,c1,a1) = i+1
            index(c1,a1,a1) = i+2
            i = i+3
          else
            a1=a+1;   b1=b+1;   c1=c+1
            index(a1,b1,c1) = i
            index(a1,c1,b1) = i+1
            index(b1,a1,c1) = i+2
            index(c1,a1,b1) = i+3
            index(b1,c1,a1) = i+4
            index(c1,b1,a1) = i+5
            i = i+6
          end
        end
      end
    end
  end

end 
