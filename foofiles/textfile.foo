!-----------------------------------------------------------------------
!
! TEXTFILE : Line-oriented formatted sequential advancing file
! input/output, including input from standard input, and output to
! standard output.
!
! The TEXTFILE object is a FILE with a BUFFER and a DBLFMT formatting
! object. The input/output proceeds via a line buffer. It is forbidden
! to open a TEXTFILE simultaneously for input and output.
!
! There is a default internal standard input object, "stdin",
! and a default standard output object, "stdout".
!
! A line count is maintained to allow back-tracking to previous lines,
! and particular items on each line. This is useful for input.
!
! For output, items can be put in columns of a specified width, with
! double precision numbers having a specified precision and "style"
! (set using fortran conventions). This is useful for dynamic tables,
! which the user can change at run time. Rewind and backtracking
! are not allowed for output files.
!
! Note that the input buffer is limited to size BSTR_SIZE, set in the
! "macros" file.
!
! Updates the entry in std_system at start of every routine.
! Update the entry in std_system whenever record number is changed.
! Create and destory routines excepted.
!
! (c) dylan jayatilaka, university of western australia, december 1999
!
! $Id$
!---------------------------------------------------------------------------
module TEXTFILE

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL
   use BUFFER
   use UNITNUMBER

   use STRVEC
   use BINVEC
   use IVEC
   use VEC
   use CVEC
   use MAT

   use INPUT
   use OUTPUT

   implicit none

#  include "macros"
#  include "textfile.int"

!   type textfile_type
!
!   STR :: name
!   ! The name of the file
!
!   STR :: action
!   ! The action status of the file, "read" or "write"
!
!   INT :: unit
!   ! The unit number
!
!   INT :: record
!   ! The current record of the output
!
!   INT :: io_status DEFAULT(0)
!   ! Set non-zero if there is an error condition
!
!   BIN :: ignore_end_of_file DEFAULT(FALSE)
!   ! Set to TRUE if the end of file is not to be regarded as an error.
!
!   INT :: fields DEFAULT(TEXTFILE_NO_OF_FIELDS)
!   ! No of fields (i.e. columns) to use for outputting the variable
!
!   INT :: int_width DEFAULT(TEXTFILE_INT_WIDTH)
!   ! Width of an integer field
!
!   INT :: dbl_width DEFAULT(TEXTFILE_DBL_WIDTH)
!   ! Width of a dbl field
!
!   INT :: dbl_precision DEFAULT(TEXTFILE_PRECISION)
!   ! No. of decimal places to use for outputing a dbl variable
!
!   STR :: dbl_style DEFAULT(TEXTFILE_DBL_STYLE)
!   ! Fortran style character for a dbl variable
!
!   INT :: margin DEFAULT(TEXTFILE_MARGIN_WIDTH)
!   ! Margin width
!
!   BIN :: labels DEFAULT(TEXTFILE_USE_LABELS)
!   ! Whether to use column and row labels on vectors and matrices
!
!   STR :: default_units DEFAULT(" ")
!   ! Each DBL number is assumed to have "default_units", and are converted
!   ! into generic (internal) units, usually A.U.
!
!   BUFFER :: buffer
!   ! The output buffer which holds one line of output to be flushed
!
!   end

   interface read
      read_str, read_dbl_quantity, read_formatted_dbl
      read_cdbl, read_int, read_bin
      read_ivec, read_binvec, read_strvec
      read_vec_quantity, read_cvec
      read_mat_quantity, read_cmat
   end

   interface get
      read_str, read_dbl_quantity, read_formatted_dbl
      read_cdbl, read_int, read_bin
      read_ivec, read_binvec, read_strvec
      read_vec_quantity, read_cvec
      read_mat_quantity, read_cmat
   end

   interface read_ptr
      read_strvec_ptr, read_binvec_ptr, read_ivec_ptr, 
      read_vec_ptr, read_cvec_ptr
   end

   interface put
      put_str, put_int, put_bin, put_dbl, put_cdbl
      put_ivec, put_strvec, put_vec, put_cvec
      put_imat, put_mat, put_mat3, put_mat4,
      put_cmat, put_cmat3, put_cmat4, put_cmat5
      put_gaussian, put_gaussian2, put_opvec, put_opmat
   end

   interface write
      put_str, put_int, put_bin, put_dbl, put_cdbl
      put_ivec, put_strvec, put_vec, put_cvec
      put_imat, put_mat, put_mat3, put_mat4,
      put_cmat, put_cmat3, put_cmat4, put_cmat5
      put_gaussian, put_gaussian2, put_opvec, put_opmat
   end

   interface show
      show_str, show_int, show_bin, show_dbl_1, show_dbl_3,
      show_vec
   end

   TEXTFILE, PTR, public :: stdin  DEFAULT_NULL

   TEXTFILE, PTR, public :: stdout DEFAULT_NULL

contains

!  *****************************
!  File creation type operations
!  *****************************

   create_stdin
   ! Create a the standard input file object, if needed.
   ! Return a pointer to it if already created
      PTR :: self
      if (stdin.destroyed) then
         allocate(stdin)
         ADD_MEM(TEXTFILE_SIZE)
         stdin.name = "stdin"
         stdin.action = "read"
         stdin.record = 0
         stdin.unit = TEXTFILE_STD_INPUT_UNIT
         stdin.io_status = 0
         stdin.ignore_end_of_file = FALSE
         stdin.default_units = " "
      end
      stdin.buffer.clear
      self => stdin
   end

   create_stdout
   ! Create a standard output file object.
   ! Return a pointer to it if already created
      PTR :: self
      if (stdout.destroyed) then
         allocate(stdout)
         ADD_MEM(TEXTFILE_SIZE)
         stdout.name = "stdout"
         stdout.action = "write"
         stdout.record = 0
         stdout.unit = TEXTFILE_STD_OUTPUT_UNIT
         stdout.io_status = 0
         stdout.ignore_end_of_file = FALSE
         stdin.default_units = " "
         stdout.set_default_format
      end
      stdout.buffer.clear
      stdout.put_margin
      self => stdout
   end

   create(name)
   ! Create a textfile. Does not open the file.
      PTR :: self
      CHR(*) :: name
      UNITNUMBER :: unitnumber
      nullify(self)
      allocate(self)
      ADD_MEM(TEXTFILE_SIZE)
      .name = name
      .action = "unknown"
      .record = 0
      .io_status = 0
      .ignore_end_of_file = FALSE
      .default_units = " "
      unitnumber.get( .unit)
      .buffer.clear
   end

   destroy
   ! Destroy a textfile
      PTR :: self
      UNITNUMBER :: unitnumber
      if (.destroyed) return
      unitnumber.free( .unit)
      DELETE_MEM(INPUT_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   open(for)
   ! Open the textfile "for" either "read" or "write".
     STR(*) :: for
     select case (for)
        case("read","reading","read-only","reading-only");    .open_for_read
        case("write","writing","write-only","writing-only");  .open_for_write
        case default; DIE("unknown open option, "//trim(for))
     end
   end

   open_for_read
   ! Open the input file. The input file object must already be created
      .system_update
      .action = "read"
      if (.exists) then
         open(unit=.unit,      &
              file=.name,      &
              status="old",        &
              access="sequential", &
              form="formatted",    &
              iostat=.io_status)
         DIE_IF(.io_status>0,"error opening old file "//.name)
      else
         DIE("opening new file "//.name//"for read!")
      end
   end

   open_for_write
   ! Open the output file associated with the output object
      .system_update
      .action = "write"
      if (.exists) then
         open(unit=.unit,      &
              file=.name,      &
              status="old",        &
              access="sequential", &
              form="formatted",    &
              iostat=.io_status)
         DIE_IF(.io_status>0,"error opening old file"//.name)
      else
         open(unit=.unit,      &
              file=.name,      &
              status="new",        &
              access="sequential", &
              form="formatted",    &
              iostat=.io_status)
         DIE_IF(.io_status>0,"error opening new file"//.name)
      end
      .set_default_format
      .put_margin
   end

   close
   ! Close the input file
      .system_update
      close(unit=.unit)
      .system_done
   end

   close_and_delete
   ! Close the input file and delete it from the file system
      .system_update
      close(unit=.unit,status="delete")
      .system_done
   end

   delete
   ! Delete the input file from the file system
      .system_update
      if (.is_not_open) .open(for="read")
      .close_and_delete
      .system_done
   end

  read_output_style_options(in)
  ! Read the default output style parameters from another textfile, "in"
    TEXTFILE :: in
    STR :: word
    ENSURE(in.action=="read",'file "in" is not an input file')
    .system_update
    read_loop : do
      in.read(word); word.to_lower_case
      select case (word)
        case("labels");      in.read( .labels )
        case("margin");      in.read( .margin )
        case("fields");      in.read( .fields )
        case("width");       in.read( .dbl_width )
        case("precision");   in.read( .dbl_precision )
        case("dbl_style");   in.read( .dbl_style )
        case default;        DIE("unknown directive, "//word.trim)
      end
    end do read_loop
  end

!  **************************
!  Data input type operations
!  **************************

   read_line
   ! Read a line into the buffer from the input file
   ! If ".ignore_end_of_file" is  TRUE, it is not
   ! an error to try to real a line.
      INT :: fail
      BSTR :: string
      ENSURE(.is_open,"file is not open")
      ENSURE(.action=="read","file does not have read action!")
      .system_update
      string = ""
      fail = 2
      read(unit=.unit,fmt="(a)",end=20,err=10) string
      fail = fail-1
20    fail = fail-1
10    continue
      select case (fail)
        case (0)   ! No errors.  Let's read a line into the buffer.
          .buffer.set(string)
          .record = .record+1
          .system_update
        case (1)   ! At end of file.
          .io_status = 1
           DIE_IF(NOT .ignore_end_of_file,"End of file")
        case (2)   ! Some error, but not end of file.
           DIE("read error")
      end
   end

   move_to_next_item
   ! Move to the next item. Get a new line if the current buffer is exhausted
      .system_update
      if (.buffer.exhausted) then            ! No more line items to read
         .move_to_next_nonblank_line
      end
   end

   move_to_previous_item
   ! Move to the previous item in the input file. Backspace a line if required.
      .system_update
      if (.next_line_item==1) then          ! If next item to be read is item 1
         .move_to_previous_nonblank_line
         .move_to_last_item_on_line         ! move to last item on previous line
      else
         .move_to_previous_item_on_line     ! move to the last read item
      end
   end

   move_to_next_nonblank_line
   ! Move to the next non blank line in the file
      do
         .read_line
         if (.buffer.not_empty) exit
      end
   end

   move_to_previous_nonblank_line
   ! Move to the last non blank line in the file
      do
         .backspace_line
         .system_update
         if (.buffer.not_empty) exit
      end
   end

   move_to_last_item_on_line
   ! Move the cursor over to the beginning of the last item on the line
      INT :: item
      .system_update
      item = .last_line_item
      .move_to_line_item(item)
   end

   move_to_previous_item_on_line
   ! Move the cursor over to the beginning of the previous item on the
      INT :: item
      .system_update
      item = .previous_line_item
      .move_to_line_item(item)
   end

   move_to_line_item(number)
   ! Move the cursor over to the beginning of the item with index "number"
   ! on the current line
      INT :: number
      INT :: n
      .system_update
      n = number
      .buffer.move_to_item(n)
   end

   look_for( search, from_update)
   ! sets record to the line updateing with "search" string
   ! if from_update is present then the search is updateed from the beginning
      STR(*) :: search
      STR, optional :: from_update
      INT :: update_record
      .system_update
      update_record = .record
      if (present(from_update)) .rewind
      .ignore_end_of_file = TRUE
      do
         if (search.is_included_in( .buffer_str)) exit
         .read_line
         if (.end_of_file) then
            .move_to_record(update_record)
            exit
         end
      end
      .ignore_end_of_file = FALSE
   end

  rest_of_line(res)
  ! If there is anything left on the input line, then it is returned, else
  ! nothing is returned.  Pointer moves to next line.
    INOUT :: self
    STR :: res
    ENSURE(.action=="read","file does not have read action!")
    .system_update
    if ( .buffer.not_empty ) then
      .move_to_next_item
      res = .buffer.buffer_str( .buffer.pos : )
      .read_line
    else
      res = ""
      .read_line
    end
  end

   get_next_item(word)
   ! Get the next item in the file
      STR :: word
      .system_update
      .move_to_next_item
      .buffer.get(word)
   end

  read_str(word)
  ! Read a str into "word"
    STR :: word
    ENSURE(.action=="read","file does not have read action!")
    .system_update
    .move_to_next_item
    .buffer.get(word)
  end

  read_chr(chr)
  ! Read a character into "chr"
    CHR :: chr
    STR :: word
    ENSURE(.action=="read","file does not have read action!")
    .system_update
    .read_str(word)
    if (len_trim(word)>1) then
      .system_update
      DIE("Expecting 1 character, not this: "// word.trim)
    end
    chr = word
  end

  read_dbl_quantity(value)
  ! Read a dbl quantity into "value". Will convert the value of the quantity
  ! from atomic units, if followed by a unit specifier.
    DBL :: value
    STR :: units
    ENSURE(.action=="read","file does not have read action!")
    .read_dbl(value)
    .ignore_end_of_file = TRUE
    units = "unknown"
    .read_str(units)                              ! Read possible unit string
    value.convert_from(units)
    if (NOT .end_of_file AND units=="unknown") &
    .move_to_previous_item                        ! No units, move back one item
    if (.default_units/=" " AND units=="unknown") &
    value.convert_from(.default_units)            ! Convert from assumed default units
    .ignore_end_of_file = FALSE
  end

  read_dbl(value)
  ! Read a dbl into "value"
    DBL :: value
    ENSURE(.action=="read","file does not have read action!")
    .system_update
    .move_to_next_item
    .buffer.get(value)
  end

  read_formatted_dbl(value,format)
  ! Read a formatted dbl into "value". Does not check the end of line!
    DBL :: value
    CHR(*), IN :: format
    ENSURE(.action=="read","file does not have read action!")
    .system_update
    .buffer.get(value,format)
  end

   read_cdbl(value)
   ! Read a cdbl into "value"
      CDBL :: value
      DBL :: real,imag
      ENSURE(.action=="read","file does not have read action!")
      .system_update
      .move_to_next_item
      .buffer.get(real)
      .move_to_next_item
      .buffer.get(imag)
      value = cmplx(real,imag)
   end

   read_int(value)
   ! Read an integer into "value"
      INT :: value
      ENSURE(.action=="read","file does not have read action!")
      .system_update
      .move_to_next_item
      .buffer.get(value)
   end

   read_bin(value)
   ! Read a logical into "value"
      BIN :: value
      ENSURE(.action=="read","file does not have read action!")
      .system_update
      .move_to_next_item
      .buffer.get(value)
   end

   read_binvec(v)
   ! Read in a BIN vector sequentially. Line breaks are not significant.
      BINVEC :: v
      INT :: dim,i
      .system_update
      dim = size(v)
      do i = 1,dim
         .read_bin(v(i))
      end
   end

   list_length result (res)
   ! Return the size of the list, by reading the input until an 
   ! "end" token is found. Line breaks are not significant. 
      INT :: res
      INT :: line,item,dim
      STR :: word
      line = .line_number
      item = .next_line_item
      res = 0
      do
         .read(word)
         if (word=="end") exit 
         res = res+1
      end 
      .move_to_line(line)
      .move_to_line_item(item)
   end

   read_binvec_ptr(v) [leaky]
   ! Read in a BIN vector pointer "v" sequentially. Line breaks are not significant.
   ! The "v" vector pointer in created to be the right size.
      BINVEC, PTR :: v
      INT :: dim
      dim = .list_length
      v.create(dim)
      .read(v)
      .move_to_next_item  ! Remember to read trailing "end" token
   end

   read_strvec(v)
   ! Read in an string vector sequentially. Line breaks are not significant.
      STRVEC :: v
      INT :: dim,i
      .system_update
      dim = size(v)
      do i = 1,dim
         .read_str(v(i))
      end
   end

   read_strvec_ptr(v) [leaky]
   ! Read in a string vector pointer "v" sequentially. Line breaks are not significant.
   ! The "v" vector pointer in created to be the right size.
      STRVEC, PTR :: v
      INT :: dim
      dim = .list_length
      v.create(dim)
      .read(v)
      .move_to_next_item  ! Remember to read trailing "end" token
   end

   read_ivec(v)
   ! Read in an integer vector sequentially. Line breaks are not significant.
      IVEC :: v
      INT :: dim,i
      .system_update
      dim = size(v)
      do i = 1,dim
         .read_int(v(i))
      end
   end

   read_ivec_ptr(v) [leaky]
   ! Read in a integer vector pointer "v" sequentially. Line breaks are not significant.
   ! The "v" vector pointer in created to be the right size.
      IVEC, PTR :: v
      INT :: dim
      dim = .list_length
      v.create(dim)
      .read(v)
      .move_to_next_item  ! Remember to read trailing "end" token
   end

   read_vec_quantity(v)
   ! Read in a vector sequentially. Line breaks are not significant.
      VEC :: v
      STR :: units
      .read_vec(v)
      .ignore_end_of_file = TRUE
      units = "unknown"
      .read_str(units)                      ! Read possible unit string
      v.convert_from(units)
      if (NOT .end_of_file AND units=="unknown") &
      .move_to_previous_item                ! No units, move back one item
      if (.default_units/=" " AND units=="unknown") &
      v.convert_from(.default_units)        ! Convert from assumed default units
      .ignore_end_of_file = FALSE
   end

   read_vec(v)
   ! Read in a vector sequentially. Line breaks are not significant.
      VEC :: v
      INT :: dim,i
      .system_update
      dim = size(v)
      do i = 1,dim
         .read_dbl(v(i))
      end
   end

   read_vec_ptr(v) [leaky]
   ! Read in a vector pointer "v" sequentially. Line breaks are not significant.
   ! The "v" vector pointer in created to be the right size.
      VEC, PTR :: v
      INT :: dim
      dim = .list_length
      v.create(dim)
      .read(v)
      .move_to_next_item  ! Remember to read trailing "end" token
   end

   read_cvec(v)
   ! Read in a complex vector sequentially. Line breaks are not significant.
      CVEC :: v
      INT :: dim,i
      .system_update
      dim = size(v)
      do i = 1,dim
         .read_cdbl(v(i))
      end
   end

   read_cvec_ptr(v) [leaky]
   ! Read in a complex vector pointer "v" sequentially. Line breaks are not significant.
   ! The "v" vector pointer in created to be the right size.
      CVEC, PTR :: v
      INT :: dim
      dim = .list_length
      v.create(dim)
      .read(v)
      .move_to_next_item  ! Remember to read trailing "end" token
   end

   read_mat_quantity(m,order)
   ! Read in a matrix sequentially by row (default) or by column.
   ! If a units string appears after the matrix, the elements are
   ! converted into atomic units or generic units.
   ! Line breaks are not significant.
      MAT :: m
      STR(*), optional :: order
      STR :: units
      .read_mat(m,order)
      .ignore_end_of_file = TRUE
      units = "unknown"
      .read_str(units)                      ! Read possible unit string
      m.convert_from(units)
      if (NOT .end_of_file AND units=="unknown") &
      .move_to_previous_item                ! No units, move back one item
      if (.default_units/=" " AND units=="unknown") &
      m.convert_from(.default_units)        ! Convert from assumed default units
      .ignore_end_of_file = FALSE
   end

   read_mat(m,order)
   ! Read in a complex matrix sequentially by row (default) or by column.
   ! Line breaks are not significant.
      MAT :: m
      STR(*), optional :: order
      INT :: dim1,dim2,i,j
      STR :: print_order
      .system_update
      dim1 = size(m,1)
      dim2 = size(m,2)
      print_order = "by_row"
      if (present(order)) print_order = order
      select case (print_order)
         case ("by_column","column_major")
            do j = 1,dim2
            do i = 1,dim1
              .read_dbl(m(i,j))
            end
            end
         case ("by_row","row_major")
            do i = 1,dim1
            do j = 1,dim2
              .read_dbl(m(i,j))
            end
            end
         case default
            DIE("unknown print order, "//print_order.trim)
      end
   end

  read_formatted_mat(m,format,items_per_line)
  ! Read a formatted matrix "m" with fortran "format" and a given
  ! number of "items_per_line".
    MAT, OUT :: m
    CHR(*), IN :: format
    INT, IN :: items_per_line
    INT :: i,j,d,count
    .system_update
    .buffer.pos = 0
    d = size(m,1)
    count=0
    do i=1,d
      do j=1,d
        .read_formatted_dbl(m(i,j),format)
        count = count + 1
         if (count==items_per_line) then
           do
              .read_line
              if (.buffer.not_empty) exit
           end
           count=0
         end
      end
    end
  end

  read_cadpac_mat(m)
  ! Read in a matrix produced by the constraint part of cadpac.
    IN :: self
    MAT, OUT :: m
    .system_update
    .read_formatted_mat(m,"5D16.8",5)
  end

   read_cmat(m,order)
   ! Read in a complex matrix sequentially by row (default) or by column.
   ! Line breaks are not significant.
      CMAT :: m
      STR, optional :: order
      INT :: dim1,dim2,i,j
      STR :: print_order
      .system_update
      dim1 = size(m,1)
      dim2 = size(m,2)
      print_order = "by_row"
      if (present(order)) print_order = order
      select case (print_order)
         case ("by_column","column_major")
            do j = 1,dim2
            do i = 1,dim1
              .read_cdbl(m(i,j))
            end
            end
         case ("by_row","row_major")
            do i = 1,dim1
            do j = 1,dim2
              .read_cdbl(m(i,j))
            end
            end
         case default
            DIE("unknown print order, "//print_order.trim)
      end
   end

  next_str result(word)
  ! Read a str from the input file and return it
    STR :: word
    .system_update
    .read_str(word)
  end

  next_dbl result(value)
  ! Read a dbl from the input file and return it
    DBL :: value
    .system_update
    .read_dbl(value)
  end

  next_cdbl result(value)
  ! Read a cdbl from the input file and return it
    CDBL :: value
    .system_update
    .read_cdbl(value)
  end

  next_int result(value)
  ! Read a integer from the input file and return it
    INT :: value
    .system_update
    .read_int(value)
  end

  next_bin result(value)
  ! Read a logical from the input file and return it
    BIN :: value
    .system_update
    .read_bin(value)
  end

  next_chr result(chr)
  ! Read a character from the input file and return it
    CHR :: chr
    .system_update
    .read_chr(chr)
  end

  next_formatted_dbl(format) result(value)
  ! Read a formatted dbl from the input file and return it.
  ! Does not check the end of line!
    DBL :: value
    CHR(*), IN :: format
    .system_update
    .read_formatted_dbl(value,format)
  end

!  **********************************
!  Line repositioning type operations
!  **********************************

   rewind
   ! Rewind the input file
      .system_update
      rewind(unit=.unit,iostat=.io_status)
      DIE_IF(.io_status>0,"rewind error")
      .record = 0
      .system_update
      .read_line
   end

   move_to_end
   ! Move to the end of the input file
      .system_update
      do
         read(unit=.unit, fmt="()", iostat=.io_status)
         if (.io_status/=0) exit
         .record = .record + 1
         .system_update
      end
      backspace(unit=.unit,iostat=.io_status)
      backspace(unit=.unit,iostat=.io_status)
      .record = max(0,.record-1)
      .system_update
      .read_line
   end

   backspace_line
   ! Reprocess previously input line
      .system_update
      .move_to_record(.record-1)
   end

   skip_line
   ! Skip the next line in the input file
      .system_update
      .move_to_record(.record+1)
   end

   move_to_line(line)
   ! Move to be positioned *before* the start of the requested "line"
   ! in the input file
      INT :: line
      ENSURE(line>=1,"line number must be non-negative")
      .move_to_record(line-1)
   end

   move_to_record(rec)
   ! Move to the requested record "rec" in the input file.
   ! Remember: .record is the last processed record.
      INT :: rec
      ENSURE(rec>=0,"record number must be non-negative")
      .system_update
      if (rec<(.record+1)) then
         do
            backspace(unit=.unit,iostat=.io_status)
            DIE_IF(.io_status>0,"backspace error")
            .record = .record-1
            .system_update
            if (rec==(.record+1)) exit
         end
      else if (rec>(.record+1)) then
         do
            read(unit=.unit,fmt="()",iostat=.io_status)
            DIE_IF(.io_status>0,"read error")
            .record = .record + 1
            .system_update
            if (rec==(.record+1)) exit
         end
      end
      .read_line
   end

!  ********************
!  Data output routines
!  ********************

   put_margin
   ! Put a margin into the buffer of the output object
      .system_update
      .buffer.put(repeat(" ",.margin))
   end

   flush
   ! Flush the buffer to the output file
      ENSURE(.is_open,"file is not open!")
      ENSURE(.action=="write","file does not have write action!")
      .system_update
      write(.unit,'(a)') trim( .buffer_str )
      .buffer.clear
      .put_margin
      .record = .record + 1
      .system_update
   end

   flush(times)
   ! Flush the buffer multiple times to get extra carriage returns
     INT :: times
     INT :: i
     .system_update
     do i=1,times
        .flush
     end
   end

   tab(dbl_fields,int_fields,bin_fields,width)
   ! Tab across the specified number of fields in the output buffer
   ! "dbl_fields", "int_fields" and "bin_fields" refer to the number of
   ! dbl, integer and logical fields to tab; "width" is the width of spaces
   ! to tab.
      INT, optional :: dbl_fields,int_fields,bin_fields,width
      .system_update
      if (present(dbl_fields)) &
         .buffer.put(repeat(repeat(" ",.dbl_width),dbl_fields))
      if (present(int_fields)) &
         .buffer.put(repeat(repeat(" ",.int_width),int_fields))
      if (present(bin_fields)) &
         .buffer.put(repeat(repeat(" ",.int_width),bin_fields))
      if (present(width)) &
         .buffer.put(repeat(" ",width))
   end

   dash(dbl_fields,int_fields,bin_fields,width)
   ! Put a dashed line into the buffer. "dbl_fields", "int_fields" and
   ! "bin_fields" refer to the number of dbl, integer and logical fields
   ! to draw the line over; "width" is the width of characters to draw the
   ! dashed line.
      INT, optional :: dbl_fields,int_fields,bin_fields,width
      .system_update
      .put_dash(dbl_fields,int_fields,bin_fields,width,flush=1)
   end

   put_dash(dbl_fields,int_fields,bin_fields,width,flush)
   ! Put a dashed line into the buffer. "dbl_fields", "int_fields" and
   ! "bin_fields" refer to the number of dbl, integer and logical fields
   ! to draw the line over; "width" is the width of characters to draw the
   ! dashed line.
      INT, optional :: dbl_fields,int_fields,bin_fields,width,flush
      .system_update
      if (present(dbl_fields)) &
         .buffer.put(repeat(repeat("-",.dbl_width),dbl_fields))
      if (present(int_fields)) &
         .buffer.put(repeat(repeat("-",.int_width),int_fields))
      if (present(bin_fields)) &
         .buffer.put(repeat(repeat("-",.int_width),bin_fields))
      if (present(width)) &
         .buffer.put(repeat("-",width))
      if (present(flush)) .flush(flush)
   end

   show_str(pretext,string,int_width)
   ! Put a formatted STR into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      CHR(*) :: string
      BIN, optional :: int_width
      .system_update
      .put_text(pretext)
      .put_str(string,int_width,flush=1)
   end

   show_int(pretext,value,dbl_width)
   ! Put a formatted INT into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      BIN, optional :: dbl_width
      INT :: value
      .system_update
      .put_text(pretext)
      .put(value,dbl_width,flush=1)
   end

   show_bin(pretext,value,dbl_width)
   ! Put a formatted BIN into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      BIN, optional :: dbl_width
      BIN :: value
      .system_update
      .put_text(pretext)
      .put(value,dbl_width,flush=1)
   end

   show_dbl_1(pretext,value)
   ! Put a formatted DBL into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      DBL :: value
      .system_update
      .put_text(pretext)
      .put(value,flush=1)
   end

   show_dbl_3(pretext,val1,val2,val3)
   ! Put a formatted DBL's into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      DBL :: val1,val2,val3
      .system_update
      .put_text(pretext)
      .put(val1)
      .put(val2)
      .put(val3,flush=1)
   end

   show_vec(pretext,value)
   ! Put a formatted DBL "value" into the output buffer with descriptive
   ! "pretext".
      CHR(*) :: pretext
      VEC :: value
      BIN :: labels
      .system_update
      .put_text(pretext)
      labels = .labels
      .set_labels(FALSE)
      .put(value)
      .set_labels(labels)
      .flush
   end

   text(string,dbl_width,int_width,flush)
   ! Put text into the output buffer as is and flush,
   ! unless an explicit flush is present
      CHR(*) :: string
      BIN, optional :: dbl_width,int_width
      INT, optional :: flush
      .system_update
      if (present(flush)) then
         .put_text(string,dbl_width,int_width,flush)
      else
         .put_text(string,dbl_width,int_width,flush=1)
      end
   end

   put_text(string,dbl_width,int_width,flush)
   ! Put text into the output buffer as is.
      CHR(*) :: string
      BIN, optional :: dbl_width,int_width
      INT, optional :: flush
      CHR( .int_width ) :: int_string
      CHR( .dbl_width ) :: dbl_string
      .system_update
      if (present(dbl_width) AND (len(string) <= .dbl_width )) then
        dbl_string = string
        .buffer.put( dbl_string )
      else if (present(int_width) AND (len(string) <= .int_width )) then
        int_string = string
        .buffer.put( int_string )
      else
        .buffer.put( string )
      end
      if (present(flush)) .flush(flush)
   end

   put_str(string,int_width,flush)
   ! Put a formatted STR into the output buffer; if too big, put as is.
   ! if present and TRUE, "int_width" says to use field width of int_width
   ! if present, flush is how many times to flush the buffer.
      CHR(*) :: string
      INT, optional :: flush
      BIN, optional :: int_width
      STR :: form
      INT :: wid
      .system_update
      wid = .dbl_width
      if (present(int_width)) wid = .int_width
      if (len_trim(string)>wid) then
         .buffer.put(trim(string))
      else if (len_trim(string)/=0) then
         form = "a" // trim( wid.to_str)
         .buffer.put(trim(string),form)
      end
      if (present(flush)) .flush(flush)
   end

   put_unit(value,units)
   ! Put a formatted value and its units into the output buffer.
     INT, IN :: value
     STR, IN :: units
     STR :: format
     .system_update
     format = .format_for_int( .nice_field_width_for(value) )
     .buffer.put(value,format)
     .put_text( " " // units.trim)
     if (value /= 1) .put_text("s")
   end

   put_int(value,dbl_width,flush)
   ! Put a formatted integer into the output buffer; the field width used is
   ! int_width, usually the length of the nondecimal part of a formatted DBL
   ! number.
   ! Can override the width and use dbl_width if "dbl_width" is set to TRUE.
      INT :: value
      INT, optional :: flush
      BIN, optional :: dbl_width
      STR :: format
      .system_update
      format = .format_for_int( .int_width)
      if (present(dbl_width)) then
        if (dbl_width) format = .format_for_int( .dbl_width)
      end
      .buffer.put(value,format)
      if (present(flush)) .flush(flush)
   end

   put_int_with_zeros(int,width,flush)
     INT, IN :: int, width
     INT, optional :: flush
     INT :: int_width
     STR :: format
     .system_update
     int_width = .nice_field_width_for(int)
     if (int<0) then
       .buffer.put("-")
       format = .format_for_int(int_width-1)
     else
       format = .format_for_int(int_width)
     end
     .buffer.put(repeat("0",width-int_width))
     .buffer.put(abs(int),format)
     if (present(flush)) .flush(flush)
   end

   put_bin(value,dbl_width,flush)
   ! Put a formatted logical into the output buffer; can specify the width of
   ! the field if desired. Otherwise, the field with used is int_width, or
   ! the length of the nondecimal part of a formatted DBL number
      BIN :: value
      INT, optional :: flush
      BIN, optional :: dbl_width
      STR :: format
      .system_update
      format = .format_for_bin( .int_width)
      if (present(dbl_width)) then
        if (dbl_width) format = .format_for_bin( .dbl_width)
      end
      .buffer.put(value,format)
     if (present(flush)) .flush(flush)
   end

   put_dbl(value,flush)
   ! Put a formatted DBL into the output buffer
   ! The field with used is int_width, or
   ! the length of the nondecimal part of a formatted DBL number
      DBL :: value
      STR :: format
      INT, optional :: flush
      .system_update
      format = .format_for_dbl( .dbl_style, .dbl_width, .dbl_precision)
      .buffer.put(value,format)
      if (present(flush)) .flush(flush)
   end

   put_cdbl(value,flush)
   ! Put a formatted CDBL into the output buffer
   ! The field with used is int_width, or
   ! the length of the nondecimal part of a formatted DBL number
      CDBL :: value
      STR :: format
      INT, optional :: flush
      .system_update
      format = .format_for_dbl( .dbl_style, .dbl_width, .dbl_precision)
      .buffer.put(value,format)
      if (present(flush)) .flush(flush)
   end

   put_ivec(vec,format)
   ! Put a formatted integer vector into the output buffer
      IVEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      .system_update
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_ivec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_ivec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_ivec_by_column(vec)
   ! Put a formatted integer vector into the output buffer
      IVEC :: vec
      INT :: dim,i
      .system_update
      dim = size(vec)
      do i = 1,dim
         if (.labels_used) then
            .put_int(i)
         end
         .put_int(vec(i),flush=1)
      end
   end

   put_ivec_by_row(vec)
   ! Put a formatted integer vector into the output buffer
      IVEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      .system_update
      dim = size(vec)
      fields = .fields
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         if (.labels_used) then
!           .tab(int_fields=1)
            do i = f,l
               .put_int(i)
            end
            .flush(2)
!           .tab(int_fields=1)
         end
         do i = f,l
            .put_int(vec(i))
         end
         .flush
      end
   end

   put_strvec(vec,format)
   ! Put a formatted dbl vector into the output buffer
      STRVEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      .system_update
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_strvec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_strvec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_strvec_by_column(vec)
   ! Put a formatted integer vector into the output buffer
      STRVEC :: vec
      INT :: dim,i
      .system_update
      dim = size(vec)
      do i = 1,dim
         if (.labels_used) then
            .put_int(i)
         end
         .put(vec(i))
         .flush
      end
   end

   put_strvec_by_row(vec)
   ! Put a formatted string vector into the output buffer
      STRVEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      .system_update
      dim = size(vec)
      fields = .fields
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         if (.labels_used) then
!           .tab(dbl_fields=1)
            do i = f,l
               .put_int(i,dbl_width=TRUE)
            end
            .flush(2)
!           .tab(dbl_fields=1)
         end
         do i = f,l
            .put_str(vec(i))
         end
         .flush
      end
   end

   put_vec(vec,format)
   ! Put a formatted dbl vector into the output buffer
      VEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      .system_update
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_vec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_vec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_vec_by_column(vec)
   ! Put a formatted integer vector into the output buffer
      VEC :: vec
      INT :: dim,i
      .system_update
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      do i = 1,dim
         if (.labels_used) then
!           .put_int(i,dbl_width=TRUE)
            .put_int(i)
         end
         .put(vec(i),flush=1)
      end
   end

   put_vec_by_row(vec)
   ! Put a formatted DBL vector into the output buffer
      VEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      .system_update
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      fields = .fields
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
!         if (block>1) .flush
         if (.labels_used) then
!           .tab(int_fields=1)
            do i = f,l
               .put_int(i,dbl_width=TRUE)
            end
            .flush(2)
!           .tab(int_fields=1)
         end
         do i = f,l
            .put(vec(i))
         end
         .flush
      end
   end

   put_cvec(vec,format)
   ! Put a formatted dbl vector into the output buffer
      CVEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      .system_update
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_cvec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_cvec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_cvec_by_column(vec)
   ! Put a formatted complex vector into the output buffer
      CVEC :: vec
      INT :: dim,i
      .system_update
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      do i = 1,dim
         if (.labels_used) then
            .put_int(i,dbl_width=TRUE)
         end
         .put(vec(i),flush=1)
      end
   end

   put_cvec_by_row(vec)
   ! Put a formatted DBL vector into the output buffer
      CVEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      .system_update
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      fields = .fields/2
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         if (.labels_used) then
!           .tab(int_fields=1)
            do i = f,l
               .tab(dbl_fields=1)
               .put_int(i,dbl_width=TRUE)
            end
            .flush(2)
!           .tab(int_fields=1)
         end
         do i = f,l
            .put(vec(i))
         end
         .flush
      end
   end

   put_imat(mx,order)
   ! Put a formatted integer matrix into the output buffer
   ! If "order" is present use unformatted output suitable for ASCII archive
      IMAT :: mx
      CHR(*), optional :: order
      INT :: i,j,block,nb,f,l,dim1,dim2,fields
      .system_update
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      fields = .fields
      if (NOT present(order)) then     ! formatted output
         nb = (dim2-0.1)/fields+1
         do block = 1,nb
            f = 1+fields*(block-1)
            l = min(f+fields-1,dim2)
            if (block>1) .flush
            if (.labels_used) then
               .tab(int_fields=1)
               do j = f,l
                  .put_int(j)
               end
               .flush(2)
            end
            do i = 1,dim1
               if (.labels_used)     .put_int(i)
               if (.labels_not_used) .tab(int_fields=1)
               do j = f,l
                  .put_int(mx(i,j))
               end
               .flush
            end
         end
      else                             ! unformatted output
         select case (order)
            case ("by_column","column_wise","transpose")
               do j = 1,dim2
               do i = 1,dim1
                  .put_int(mx(i,j))
                  if(mod(i,fields)==0) .flush
               end
               .flush
               end
            case ("by_row","row_wise","normal")
               do i = 1,dim1
               do j = 1,dim2
                  .put_int(mx(i,j))
                  if(mod(j,fields)==0) .flush
               end
               .flush
               end
         end
      end
   end

   put_mat(mx,order)
   ! Put a formatted DBL matrix into the output buffer
   ! If "order" is present use unformatted output suitable for ASCII archive
      MAT :: mx
      STR, optional :: order
      INT :: i,j,block,nb,f,l,dim1,dim2,fields
      .system_update
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      fields = .fields
      if (NOT present(order)) then
         nb = (dim2-0.1)/fields+1
         do block = 1,nb
            f = 1+fields*(block-1)
            l = min(f+fields-1,dim2)
            if (block>1) .flush
            if (.labels_used) then
               .tab(int_fields=1)
               do j = f,l
                  .put_int(j,dbl_width=TRUE)
               end
               .flush(2)
            end
            do i = 1,dim1
               if (.labels_used)     .put_int(i)
               if (.labels_not_used) .tab(int_fields=1)
               do j = f,l
                  .put_dbl(mx(i,j))
               end
               .flush
            end
         end
      else
         select case (order)
            case ("by_column","column_wise","transpose"); .put_mat_by_column(mx)
            case ("by_row","row_wise","normal");          .put_mat_by_row(mx)
         end
      end
   end

   put_mat_by_column(mx)
   ! Put a DBL matrix into the output buffer by column, without labels
      MAT :: mx
      INT :: i,j,dim1,dim2
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      do j = 1,dim2
      do i = 1,dim1
         .put_dbl(mx(i,j))
         if(mod(i,.fields)==0) .flush
      end
      .flush
      end
   end

   put_mat_by_row(mx)
   ! Put a DBL matrix into the output buffer by row, without labels
      MAT :: mx
      INT :: i,j,dim1,dim2
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      do i = 1,dim1
      do j = 1,dim2
         .put_dbl(mx(i,j))
         if(mod(j,.fields)==0) .flush
      end
      .flush
      end
   end

   put_formatted_mat(mx,form)
   ! Put out a matrix suitable to be read in by other programs.
   ! Will overwrite the current buffer.
     MAT, IN :: mx
     CHR(*), IN :: form
     INT :: columns,first,last,i,j,nbasis,count,old_margin
     STR :: forma,formb
     .system_update
     i = form.scan("FfEe")
     form.get_next_item_position(first,last)
     DIE_IF( i==0, "incorrect format specification")
     forma=" "
     forma(1:i-first)=form(first:i-1)
     DIE_IF( forma.is_not_int, "incorrect format specification")
     columns = forma.to_int
     formb=" "
     formb(1:last-i+1) = form(i:last)
     .buffer.pos = 0
     .system_update
     old_margin = .margin
     .margin = 0
     nbasis=size(mx,1)
     count=0
     do i=1,nbasis
       do j=1,nbasis
         .buffer.put(mx(i,j), formb.trim)
         count=count+1
         if (count==columns) then
           .flush
           count=0
         end
       end
     end
     if (NOT count == 0) .flush
     .margin = old_margin
   end

   put_cmat(mx,order)
   ! Put a formatted CDBL matrix into the output buffer
   ! If "order" is present use unformatted output suitable for ASCII archive
      CMAT :: mx
      CHR(*), optional :: order
      INT :: i,j,block,nb,f,l,dim1,dim2,fields
      .system_update
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      fields = .fields/2
      if (NOT present(order)) then
         nb = (dim2-0.1)/fields+1
         do block = 1,nb
            f = 1+fields*(block-1)
            l = min(f+fields-1,dim2)
            if (block>1) .flush
            if (.labels_used) then
               .tab(int_fields=1)
               do j = f,l
                  .tab(dbl_fields=1)
                  .put_int(j,dbl_width=TRUE)
               end
               .flush(2)
            end
            do i = 1,dim1
               if (.labels_used)     .put_int(i)
               if (.labels_not_used) .tab(int_fields=1)
               do j = f,l
                  .put(mx(i,j))
               end
               .flush
            end
         end
      else
         select case (order)
            case ("by_column","column_wise","transpose")
               do j = 1,dim2
               do i = 1,dim1
                  .put(mx(i,j))
                  if(mod(i,fields)==0) .flush
               end
               .flush
               end
            case ("by_row","row_wise","normal")
               do i = 1,dim1
               do j = 1,dim2
                  .put(mx(i,j))
                 if(mod(j,fields)==0) .flush
               end
               .flush
               end
         end
      end
   end

   put_mat3(mx)
   ! Put a MAT3 into the output buffer flat style
     MAT3 :: mx
     INT :: a,b,c,aub,bub,cub
     .system_update
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           .put(a)
           .put(b)
           .put(c)
           .put_dbl(mx(a,b,c),flush=1)
         end
       end
     end
   end

   put_mat4(mx)
   ! Put a MAT4 into the output buffer flat style
     MAT4 :: mx
     INT :: a,b,c,d,aub,bub,cub,dub
     .system_update
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,4)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     WARN_IF(dub==0,"zero sized 4th dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           do d=1,dub
             .put(a)
             .put(b)
             .put(c)
             .put(d)
             .put_dbl(mx(a,b,c,d),flush=1)
           end
         end
       end
     end
   end

   put_cmat3(mx)
   ! Put a MAT3 into the output buffer flat style
     CMAT3 :: mx
     INT :: a,b,c,aub,bub,cub
     .system_update
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           .put(a)
           .put(b)
           .put(c)
           .put(mx(a,b,c),flush=1)
         end
       end
     end
   end

   put_cmat4(mx)
   ! Put a CMAT4 into the output buffer flat style
     CMAT4 :: mx
     INT :: a,b,c,d,aub,bub,cub,dub
     .system_update
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,4)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     WARN_IF(dub==0,"zero sized 4th dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           do d=1,dub
             .put(a)
             .put(b)
             .put(c)
             .put(d)
             .put(mx(a,b,c,d),flush=1)
           end
         end
       end
     end
   end

   put_cmat5(mx)
   ! Put a CMAT5 into the output buffer flat style
     CMAT5 :: mx
     INT :: a,b,c,d,e,aub,bub,cub,dub,eub
     .system_update
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,4)
     eub=size(mx,5)
     do a=1,aub
     do b=1,bub
     do c=1,cub
     do d=1,dub
     do e=1,eub
        .put(a)
        .put(b)
        .put(c)
        .put(d)
        .put(e)
        .put(mx(a,b,c,d,e),flush=1)
     end
     end
     end
     end
     end
   end

   put_gaussian(g)
   ! Output gaussian information
      GAUSSIAN :: g
      .system_update
      .flush
      .show("L quantum number = ", g.l)
      .show("Position         = ", g.pos(1), g.pos(2), g.pos(3))
      .show("Exponent         = ", g.ex)
   end

   put_gaussian2(g)
   ! Output gaussian information
      GAUSSIAN2 :: g
      .system_update
      .flush
      .put_text("Shell a:\n")
      .show("L quantum number = ", g.l_a)
      .show("Position         = ", g.pos_a(1), g.pos_a(2), g.pos_a(3))
      .show("Exponent         = ", g.ex_a)
      .put_text("Shell b:\n")
      .show("L quantum number = ", g.l_b)
      .show("Position         = ", g.pos_b(1), g.pos_b(2), g.pos_b(3))
      .show("Exponent         = ", g.ex_b)
   end

  put_opvec(vec,format)
  ! Outputs the opvec
    OPVEC, IN :: vec
    CHR(*), optional :: format
    .system_update
    if (associated( vec.restricted)) then
      .flush
      .put_text("restricted part:",flush=2)
      .put( vec.restricted,format)
    end
    if (associated( vec.alpha)) then
      .flush
      .put_text("alpha part:",flush=2)
      .put( vec.alpha,format)
    end
    if (associated( vec.beta)) then
      .flush
      .put_text("beta part:",flush=2)
      .put( vec.beta,format)
    end
    if (associated( vec.general)) then
      .flush
      .put_text("general part:",flush=2)
      .put( vec.general,format)
    end
  end

  put_opmat(mat,order)
  ! Outputs the opmat
    OPMAT, IN :: mat
    CHR(*), optional :: order
    .system_update
    if (associated( mat.restricted)) then
      .flush
      .put_text("restricted part:",flush=2)
      .put( mat.restricted,order)
    end
    if (associated( mat.alpha)) then
      .flush
      .put_text("alpha part:",flush=2)
      .put( mat.alpha,order)
    end
    if (associated( mat.beta)) then
      .flush
      .put_text("beta part:",flush=2)
      .put( mat.beta,order)
    end
    if (associated( mat.general)) then
      .flush
      .put_text("general part:",flush=2)
      .put( mat.general,order)
    end
    if (associated( mat.restricted_complex)) then
      .flush
      .put_text("complex restricted part:",flush=2)
      .put( mat.restricted_complex,order)
    end
    if (associated( mat.alpha_complex)) then
      .flush
      .put_text("complex alpha part:",flush=2)
      .put( mat.alpha_complex,order)
    end
    if (associated( mat.beta_complex)) then
      .flush
      .put_text("beta part:",flush=2)
      .put( mat.beta_complex,order)
    end
    if (associated( mat.general_complex)) then
      .flush
      .put_text("complex general part:",flush=2)
      .put( mat.general_complex,order)
    end
  end

!  ***************
!  Set fmt methods
!  ***************

   set_default_units(units)
   ! Set the .default_units to "units".
      STR(*) :: units
      DBL :: value
      value = ONE
      if (units/=" ") &
      ENSURE(value.is_convertible_to(units),"Unknown units for conversion!")
      .system_update
      .default_units = units
   end

   set_labels(labels)
   ! Set whether to use numbered labels on matrix or vector output
      BIN :: labels
      .system_update
      .labels = labels
   end

   set_margin(margin)
   ! Set the width of the margin in the buffer. Takes effect at the next
   ! output line
      INT :: margin
      .system_update
      DIE_IF(margin<0,"margin less than zero")
      DIE_IF(margin>STR_SIZE,"margin too large")
      DIE_IF( .buffer.pos>.margin,"set margin only on empty buffers")
      .margin = margin
      .buffer.clear
      .put_margin
   end

!  ************************
!  Inherited dblfmt methods
!  ************************

   set_default_format
   ! Set the default settings for the DBL formatting object
   ! Extra functions added compared to inherited code
      .system_update
      .labels        = TEXTFILE_USE_LABELS
      .margin        = TEXTFILE_MARGIN_WIDTH
      .fields        = TEXTFILE_NO_OF_FIELDS
      .int_width     = TEXTFILE_INT_WIDTH
      .dbl_width     = TEXTFILE_DBL_WIDTH
      .dbl_precision = TEXTFILE_PRECISION
      .dbl_style     = TEXTFILE_DBL_STYLE
   end

   set_page_width(width)
   ! Set the default number of fields to fit in printer page
      INT, IN :: width
      INT :: fields
      .system_update
      fields=floor(real(width - .margin,kind=DBL_KIND) / .dbl_width)
      .set_fields(fields)
   end

   set_dbl_width(width)
   ! Set the width in the dblfmt format object
      INT :: width
      .system_update
      DIE_IF(width<0,"width less than zero")
      DIE_IF(width<.dbl_precision,"width smaller than precision")
      .dbl_width = width
   end

   set_fields(fields)
   ! Set the number of fields in the dblfmt format object
      INT :: fields
      .system_update
      DIE_IF(fields<1,"not enough fields")
      .fields = fields
   end

   set_dbl_precision(precision)
   ! Set the precision required in the dblfmt format object
      INT :: precision
      .system_update
      DIE_IF(precision<0,"precision less than zero")
      DIE_IF(precision>.dbl_width,"precision greater than field width")
      .dbl_precision = precision
   end

   set_dbl_style(dbl_style)
   ! Set the fortran format style string in the dblfmt format object
      CHR(*) :: dbl_style
      CHR(2) :: style
      .system_update
      style = adjustl(dbl_style)
      if (style/="f" AND style/="d" AND style/="e" AND style/="en" AND style/="es") &
         DIE("unrecognized style, "//style)
      .dbl_style = style
   end

   nice_field_width_for(num) result (res)
   ! Return the field width that would look nice
     INT :: res
     INT, IN :: num
     DBL :: temp
      .system_update
     res=0
     if (num<0) res=res+1
     temp=abs(num)
     do
       res=res+1
       temp=temp/10
       if (temp < 1.0d0) exit
     end
   end

   format_for_dbl(style,width,precision) result (res)
   ! Format for a DBL string
      STR :: res
      STR, IN :: style
      INT, IN :: width,precision
      .system_update
      res = trim(style) // trim( width.to_str) // "." // trim( precision.to_str)
   end

   format_for_int(width) result (res)
   ! Format for a INT string
      STR :: res
      INT, IN :: width
      .system_update
      res = "i" // trim( width.to_str)
   end

   format_for_bin(width) result (res)
   ! Format for a INT string
      STR :: res
      INT, IN :: width
      .system_update
      res = "l" // trim( width.to_str)
   end

!  ***************
!  Inquiry methods
!  ***************

   exists result(res)
   ! Returns true if the file exists on the file system
      BIN :: res
      .system_update
      inquire(file=.name,exist=res)
   end

   does_not_exist result(res)
   ! Returns true if the file does *not* exist on the file system
      BIN :: res
      .system_update
      res = NOT (.exists)
   end

   is_open result(res)
   ! Returns true if the file has been opened
      BIN :: res
      .system_update
      ! inquire(unit=.unit,opened=res)
      inquire(file=.name,opened=res)
   end

   is_not_open result(res)
   ! Returns true if the file has *not* been opened
      BIN :: res
      .system_update
      res = NOT (.is_open)
   end

   unit_used result(res)
   ! Returns true if the file unit is in use
      BIN :: res
      .system_update
      inquire(unit=.unit,opened=res)
   end

   unit_not_used result(res)
   ! Returns true if the file unit is *not* in use
      BIN :: res
      .system_update
      inquire(unit=.unit,opened=res)
      res = NOT res
   end

   next_line_item result (res)
   ! Return the index of the next item to be processed on the line
      INT :: res
      res = .buffer.next_item
   end

   previous_line_item  result (res)
   ! Return the index of the previous item to be processed on the line
      INT :: res
      res = .buffer.item
   end

   last_line_item  result (res)
   ! Return the index of the final item on the line
      INT :: res
      res = .buffer.n_items
   end

   n_line_items result (res)
   ! Return the number of items on the line
      INT :: res
      res = .buffer.n_items
   end

   position result(res)
   ! Return record position of the file
      INT :: res
      .system_update
      res = .record
   end

   line_number result(res)
   ! Return the input file line number which is being processed,
   ! or will be processed next.
      INT :: res
      .system_update
      res = .record + 1
   end

   buffer_str result(res)
   ! Put a string into the buffer
      BSTR :: res
      res = .buffer.buffer_str
   end

   end_of_file result(res)
   ! See if .io_status==1, indicating the end of file.
   ! Reset .io_status to zero, if so.
      BIN :: res
      res = FALSE
      if (.io_status==1) then
         res = TRUE
         .io_status = 0
      end
   end

   at_end_of_file result(res)
   ! Read a line into the buffer from the input file and see
   ! if it is at the end of file. This is an explicit test,
   ! not just a viewing of ".io_status".
      INT :: fail
      BIN :: res
      BSTR :: string
      ENSURE(.action=="read","file does not have read status")
      .system_update
      fail = 2
      read(unit=.unit,fmt="(a)",end=20,err=10) string
      fail = fail-1
20    fail = fail-1
10    continue
      select case (fail)
        case (0)
          res = FALSE
          backspace(unit=.unit,iostat=.io_status)
          DIE_IF(.io_status>0,"backspace error")
        case (1)
          res = TRUE
        case (2)
          DIE("unknown read error")
      end
   end

   labels_used result(res)
   ! Return true if labels are used on matrix output
      BIN :: res
      .system_update
      res = .labels
   end

   labels_not_used result(res)
   ! Return true if labels are not used on matrix output
      BIN :: res
      .system_update
      res = NOT (.labels)
   end

! ***************
! System routines
! ***************

  system_update
  ! Lets the system know info about the file being read, in case of error.
    std_system.file_name = .name
    std_system.file_record = .record
    std_system.file_operation = "read"
  end

  system_done
  ! Lets the system know the file has suspended being used.
    std_system.file_name = ""
    std_system.file_record = 0
    std_system.file_operation = ""
  end

end
