!-----------------------------------------------------------------------
!
! TEXTFILE : Line-oriented formatted sequential advancing file
! input/output, including input from standard input, and output to
! standard output.
!
! The TEXTFILE object is a FILE with a BUFFER and a DBLFMT formatting
! object. The input/output proceeds via a line buffer. It is forbidden
! to open a TEXTFILE simultaneously for input and output.
!
! There is a default internal standard input object, "stdin",
! and a default standard output object, "stdout".
!
! A line count is maintained to allow back-tracking to previous lines,
! and particular items on each line. This is useful for input.
!
! For output, items can be put in columns of a specified width, with
! double precision numbers having a specified precision and "style"
! (set using fortran conventions). This is useful for dynamic tables,
! which the user can change at run time. Rewind and backtracking
! are not allowed for output files.
!
! It is possible to redirect the input or output to a new file
! using the "redirect" command. The previous file can be recovered
! using "unsave", or it will revert back automatically to the previous
! file if the redirected file ends. It is also possibile to redirect 
! input to an internal file. This is useful for processing a list of
! text as if it were a file. Output to an internal file is not allowed.
!
! Note that the input buffer is limited to size BSTR_SIZE, set in the
! "macros" file.
!
! The system information in "tonto" is updated whenever a I/O operation 
! or a buffer operation is performed.
!
! (c) dylan jayatilaka, university of western australia, december 1999
!
! $Id$
!---------------------------------------------------------------------------
module TEXTFILE

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL
   use BUFFER
   use STRVEC
   use BINVEC
   use IVEC
   use VEC
   use MAT
   use CVEC
   use UNITNUMBER

   implicit none

#  include "macros"
#  include "textfile.int"

!   type textfile_type
!
!   STR :: name
!   ! The name of the file
!
!   STR :: action
!   ! The action status of the file, "read" or "write"
!
!   INT :: unit
!   ! The unit number
!
!   INT :: record
!   ! The current record of the file which is being processed
!
!   INT :: io_status DEFAULT(0)
!   ! Set non-zero if there is an error condition
!
!   BIN :: ignore_end_of_file DEFAULT(FALSE)
!   ! Set to TRUE if the end of file is not to be regarded as an error.
!
!   INT :: fields DEFAULT(TEXTFILE_NO_OF_FIELDS)
!   ! No of fields (i.e. columns) to use for outputting the variable
!
!   INT :: int_width DEFAULT(TEXTFILE_INT_WIDTH)
!   ! Width of an integer field
!
!   INT :: dbl_width DEFAULT(TEXTFILE_DBL_WIDTH)
!   ! Width of a dbl field
!
!   INT :: dbl_precision DEFAULT(TEXTFILE_PRECISION)
!   ! No. of decimal places to use for outputing a dbl variable
!
!   STR :: dbl_style DEFAULT(TEXTFILE_DBL_STYLE)
!   ! Fortran style character for a dbl variable
!
!   INT :: margin DEFAULT(TEXTFILE_MARGIN_WIDTH)
!   ! Margin width
!
!   BIN :: labels DEFAULT(TEXTFILE_USE_LABELS)
!   ! Whether to use column and row labels on vectors and matrices
!
!   STR :: default_units DEFAULT(" ")
!   ! Each DBL number is assumed to have "default_units", and are converted
!   ! into generic (internal) units, usually A.U.
!
!   BUFFER :: buffer
!   ! The output buffer which holds one line of output to be flushed
!
!   STRVEC* :: internal DEFAULT(NULL)
!   ! Used to keep a record of of the entire file, internally
!
!   TEXTFILE* :: saved DEFAULT(NULL)
!   ! Used to keep a record of a previous file, say for input redirect
!
!   end

   interface read
      read_str, read_dbl_quantity, read_formatted_dbl
      read_cdbl, read_int, read_bin
      read_ivec, read_binvec, read_strvec
      read_vec_quantity, read_vec_pair, read_cvec
      read_mat_quantity, read_cmat
      read_mat3, read_mat4, read_cmat3, read_cmat4
      read_cmat5
   end

   interface get
      read_str, read_dbl_quantity, read_formatted_dbl
      read_cdbl, read_int, read_bin
      read_ivec, read_binvec, read_strvec
      read_vec_quantity, read_vec_pair, read_cvec
      read_mat_quantity, read_cmat
      read_mat3, read_mat4, read_cmat3, read_cmat4
      read_cmat5
   end

   interface read_ptr
      read_strvec_ptr, read_binvec_ptr, read_ivec_ptr, 
      read_vec_ptr, read_cvec_ptr
   end

   interface put
      put_info
      put_str, put_int, put_bin, put_dbl, put_cdbl
      put_ivec, put_strvec, put_vec, put_cvec
      put_imat, put_mat, put_mat3, put_mat4,
      put_cmat, put_cmat3, put_cmat4, put_cmat5
      put_gaussian, put_gaussian2, put_opvec, put_opmat
   end

   interface write
      put_str, put_int, put_bin, put_dbl, put_cdbl
      put_ivec, put_strvec, put_vec, put_cvec
      put_imat, put_mat, put_mat3, put_mat4,
      put_cmat, put_cmat3, put_cmat4, put_cmat5
      put_gaussian, put_gaussian2, put_opvec, put_opmat
   end

   interface show
      show_str, show_int, show_bin, show_dbl_1, show_dbl_3,
      show_ivec, show_vec
   end

   TEXTFILE*, public :: stdin

   TEXTFILE*, public :: stdout

contains

!  *****************************
!  File creation type operations
!  *****************************

   create_stdin
   ! Create a the standard input file object, if needed.
   ! Return a pointer to it if already created
      PTR :: self
      if (stdin.destroyed) then
         allocate(stdin)
         ADD_MEM(TEXTFILE_SIZE)
         stdin.nullify_ptr_part
         stdin.name = "stdin"
         stdin.action = "read"
         stdin.record = 0
         stdin.unit = TEXTFILE_STD_INPUT_UNIT
         stdin.io_status = 0
         stdin.ignore_end_of_file = FALSE
         stdin.default_units = " "
      end
      stdin.buffer.clear
      self => stdin
   end

   create_stdout
   ! Create a standard output file object.
   ! Return a pointer to it if already created
      PTR :: self
      if (stdout.destroyed) then
         allocate(stdout)
         ADD_MEM(TEXTFILE_SIZE)
         stdout.nullify_ptr_part
         stdout.name = "stdout"
         stdout.action = "write"
         stdout.record = 0
         stdout.unit = TEXTFILE_STD_OUTPUT_UNIT
         stdout.io_status = 0
         stdout.ignore_end_of_file = FALSE
         stdout.default_units = " "
         stdout.set_default_format
      end
      stdout.buffer.clear
      stdout.put_margin
      self => stdout
   end

   create(name)
   ! Create a textfile. Does not open the file.
      PTR :: self
      CHR(*) :: name
      UNITNUMBER :: unitnumber
      nullify(self)
      allocate(self)
      ADD_MEM(TEXTFILE_SIZE)
      .nullify_ptr_part
      .name = name
      .action = "unknown"
      .record = 0
      .io_status = 0
      .ignore_end_of_file = FALSE
      .default_units = " "
      unitnumber.get( .unit)
      .buffer.clear
   end

   create(internal)
   ! Create an internal textfile
      PTR :: self
      STRVEC :: internal
      ENSURE(.internal.destroyed,"internal file already exists")
      nullify(self)
      allocate(self)
      ADD_MEM(TEXTFILE_SIZE)
      .nullify_ptr_part
      .name = "internal"
      .record = 0
      .io_status = 0
      .ignore_end_of_file = FALSE
      .default_units = " "
      .internal.create(size(internal))
      .internal = internal
      .action = "read"    ! only read action allowed
      .read_line
   end

   destroy
   ! Destroy a textfile
      PTR :: self
      UNITNUMBER :: unitnumber
      if (.destroyed) return
      .destroy_ptr_part
      unitnumber.free( .unit)
      DELETE_MEM(TEXTFILE_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of "self". 
      nullify(.internal)
      nullify(.saved)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of "self", including any saved parts,
   ! which are destroyed recursively.
      .internal.destroy
      .saved.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

!  **********************
!  Saving and redirection
!  **********************

   save [leaky]
   ! Saved everything about the current textfile "self" in ".saved"
   ! Do not open a new textfile. Can be used to save style settings.
      PTR :: self
      TEXTFILE* :: saved
      saved => self
      nullify(self)
      allocate(self)
      ADD_MEM(TEXTFILE_SIZE)
      self = saved            ! Keep all settings, even line number
      .saved => saved
   end

   unsave [leaky]
   ! Revert to previously saved textfile settings. Note that this 
   ! is not the same as reverting to a previously saved textfile
      TEXTFILE* :: saved
      ENSURE(.saved.created,"no previous settings")
      saved => .saved
      self  = saved
      DELETE_MEM(TEXTFILE_SIZE)
      deallocate(saved)       
   end

   redirect(name) [leaky]
   ! Save all the info for the current file in ".saved", and open a new textfile.
   ! This is used for input, or output redirection. The new file retains
   ! the style settings of the saved file
      PTR :: self
      STR(*) :: name
      TEXTFILE* :: saved
      saved => self
      .create(name)
      .saved => saved
      .use_style(saved)
      .open(for=.saved.action)
   end

   redirect(internal) [leaky]
   ! Save all the info for the current file in ".saved", and open a new 
   ! internal textfile. This is used for *only* input redirection. 
   ! The new file retains the style settings of the saved file
      PTR :: self
      STRVEC :: internal
      TEXTFILE* :: saved
      saved => self
      .create(internal)
      .saved => saved
      .use_style(saved)
   end

   use_style(saved)
   ! Revert to the previously saved style settings, including
   ! any default units.
      TEXTFILE :: saved
      .default_units = saved.default_units
      .labels        = saved.labels
      .margin        = saved.margin
      .fields        = saved.fields
      .int_width     = saved.int_width
      .dbl_width     = saved.dbl_width
      .dbl_precision = saved.dbl_precision
      .dbl_style     = saved.dbl_style
      .default_units = saved.default_units
   end

   revert [leaky]
   ! Revert to the previously saved textfile, but keep current style
   ! settings, including any default_units settings.
      TEXTFILE* :: saved
      UNITNUMBER :: unitnumber
      ENSURE(.saved.created,"no previous settings")
      saved => .saved
      if (.internal.created) then
         .internal.destroy      ! Do not destroy .saved recursively ...
      else
         .close
         unitnumber.free(.unit)
      end
      saved.use_style(self)
      self  = saved
      .io_status = 2            ! Set soft end-of-file
      DELETE_MEM(TEXTFILE_SIZE)
      deallocate(saved)         ! instead, just deallocate it
   end

!  ******************************
!  Opening, closing, and deletion
!  ******************************

   open(for)
   ! Open the textfile "for" either "read" or "write".
     STR(*) :: for
     select case (for)
        case("read","reading","read-only","reading-only");    .open_for_read
        case("write","writing","write-only","writing-only");  .open_for_write
        case default; DIE("unknown open option, "//trim(for))
     end
   end
 
   open_for_read
   ! Open the input file. The input file object must already be created
      ENSURE(.internal.destroyed,"no need to open an internal file")
      .action = "read"
      if (.exists) then
         open(unit=.unit,      &
              file=.name,      &
              status="old",        &
              access="sequential", &
              form="formatted",    &
              iostat=.io_status)
         DIE_IF(.io_status>0,"error opening old file "//trim(.name))
      else
         DIE("opening new file "//trim(.name)//" for read!")
      end
      .read_line
   end

   open_for_write
   ! Open the output file associated with the output object
      ENSURE(.internal.destroyed,"no need to open an internal file")
      .action = "write"
      if (.exists) then
         open(unit=.unit,      &
              file=.name,      &
              status="old",        &
              access="sequential", &
              form="formatted",    &
              iostat=.io_status)
         DIE_IF(.io_status>0,"error opening old file "//trim(.name))
      else
         open(unit=.unit,      &
              file=.name,      &
              status="new",        &
              access="sequential", &
              form="formatted",    &
              iostat=.io_status)
         DIE_IF(.io_status>0,"error opening new file "//trim(.name))
      end
      .set_default_format
      .put_margin
   end

   close
   ! Close the input file
      close(unit=.unit)
   end

   close_and_delete
   ! Close the input file and delete it from the file system
      close(unit=.unit,status="delete")
   end

   delete
   ! Delete the input file from the file system
      if (.is_not_open) .open(for="read")
      .close_and_delete
   end

   read_output_style_options(in)
   ! Read the default output style parameters from another textfile, "in"
      TEXTFILE :: in
      STR :: word
      ENSURE(in.action=="read",'file "in" is not an input file')
      read_loop: do             ! Loop over keywords
         in.read(word)
         word.to_lower_case
         if (in.end_of_file) exit read_loop
         if (word=="end")    exit read_loop
         .process(word,in)      
      end do read_loop
   end

   process(word,in) [leaky]
   ! Process a keyword "word". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case, 
   ! the sequence is processed as if it were a separate file.
      STR(*) :: word
      TEXTFILE, target, optional :: in
      TEXTFILE* :: input
      target :: self
      BIN :: bin
      STR :: style
      INT :: val
      if (present(in)) then; input => in
      else;                  input => self
      end 
      select case (word)
         case("labels");        input.read(bin);   .set_labels(bin)
         case("margin");        input.read(val);   .set_margin(val)
         case("fields");        input.read(val);   .set_fields(val)
         case("page_width");    input.read(val);   .set_page_width(val)
         case("int_width");     input.read(val);   .set_int_width(val)
         case("field_width");   input.read(val);   .set_dbl_width(val)
         case("dbl_width");     input.read(val);   .set_dbl_width(val)
         case("precision");     input.read(val);   .set_dbl_precision(val)
         case("dbl_precision"); input.read(val);   .set_dbl_precision(val)
         case("style");         input.read(style); .set_dbl_style(style)
         case("dbl_style");     input.read(style); .set_dbl_style(style)
         case default;          DIE("unknown directive, "//word.trim)
      end
   end

!  **********************************
!  Line repositioning type operations
!  **********************************

   read_line [leaky]
   ! Read a line into the buffer
      if (.internal.created) then; .read_line_internal
      else;                        .read_line_external
      end
   end

   read_line_internal [leaky]
   ! Read a line into the buffer from the internal file
   ! If ".ignore_end_of_file" is  TRUE, it is not
   ! an error to try to real a line.
      BSTR :: string
      ENSURE(.internal.created,"no internal file")
      .update_system_info
      if (.record<size(.internal)) then ! No errors.  
         .io_status = 0
         .record = .record+1
         string = .internal(.record)
         .buffer.set(string)
         .update_system_info
      else                                   ! At end of file.
         .io_status = 1
         if (NOT .ignore_end_of_file) then   ! Do not ignore end of file
            if(.saved.created) then          ! Automatically return to saved file
               .revert                       ! Get back previous settings
            else
               DIE("unexpected end of file") ! Die if nothing to unsave
            end
         end
      end
   end

   read_line_external [leaky]
   ! Read a line into the buffer from the input file
   ! If ".ignore_end_of_file" is  TRUE, it is not
   ! an error to try to real a line.
      INT :: fail
      BSTR :: string
      ENSURE(.is_open,"file is not open")
      ENSURE(.action=="read","file does not have read action!")
      .update_system_info
      string = ""
      fail = 2
      read(unit=.unit,fmt="(a)",end=20,err=10) string
      fail = fail-1
20    fail = fail-1
10    continue
      select case (fail)
        case (0)                             ! No errors.  
          .io_status = 0
          .buffer.set(string)                ! Read a line into the buffer.
          .record = .record+1
          .update_system_info
        case (1)                             ! At end of file.
          .io_status = 1
           if (NOT .ignore_end_of_file) then ! This end shouldnt be ignored
             if(.saved.created) then         ! It's OK, go back to saved file
               .revert
             else 
               DIE("unexpected end of file") ! Die if nothing saved
             end
           end
        case (2)                             ! Some error, but not end of file.
           DIE("read error")
      end
   end

   update_line [leaky]
   ! Get the next non-exhausted line if the current one is exhausted;
   ! and in this case, the buffer pointer is positioned before the 
   ! first line item.
      do
         if (.end_of_file) exit
         if (.buffer.not_exhausted) exit
         .read_line
      end
   end

   revert_line
   ! Revert back to the previous non-exhausted line in the input file if the 
   ! current buffer pointer is before the first item; and in this case, 
   ! the buffer pointer is repositioned *after* the last line item.
      do
         if (.buffer.next_item>1) exit
         .backspace_line
         .move_to_line_item(.last_line_item+1)
      end
   end

   skip_next_item [leaky]
   ! Move to the next item in the input file.
      .update_line
      DIE_IF(.end_of_file,"file has ended")
      DIE_IF(.reverted,   "internal file has ended")
      .buffer.skip_item
      .update_system_info
   end

   move_to_previous_item
   ! Move to the previous item in the input file. Backspace a line if required.
      .revert_line
      .move_to_previous_item_on_line     ! move to the last read item
   end

   move_to_last_item_on_line
   ! Move the cursor over to the beginning of the last item on the line
      INT :: item
      item = .last_line_item
      .move_to_line_item(item)
   end

   move_to_previous_item_on_line
   ! Move the cursor over to the beginning of the previous item on the
      INT :: item
      item = .previous_line_item
      .move_to_line_item(item)
   end

   move_to_line_item(number)
   ! Move the cursor over to the beginning of the item with index "number"
   ! on the current line
      INT :: number
      INT :: n
      .update_system_info
      n = number
      .buffer.move_to_item(n)
      .update_system_info
   end

   look_for( search, from_update)
   ! sets record to the line updateing with "search" string
   ! if from_update is present then the search is updateed from the beginning
      STR(*) :: search
      STR, optional :: from_update
      INT :: update_record
      update_record = .record
      if (present(from_update)) .rewind
      .ignore_end_of_file = TRUE
      do
         if (search.is_included_in( .buffer_str)) exit
         .read_line
         if (.end_of_file) then
            .move_to_record(update_record)
            exit
         end
      end
      .ignore_end_of_file = FALSE
   end

  rest_of_line(res) 
  ! If there is anything left on the input line, then it is returned, else
  ! nothing is returned.  Pointer moves to next line.
    INOUT :: self
    STR :: res
    ENSURE(.action=="read","file does not have read action!")
    if ( .buffer.not_empty ) then
      .update_line                     ! ?? is this needed ??
      DIE_IF(.end_of_file,  "file has ended")
      DIE_IF(.reverted,     "internal file has ended")
      res = .buffer.buffer_str( .buffer.pos : )
      .read_line
    else
      res = ""
      .read_line
    end
  end

   rewind
   ! Rewind the input file
      if (.internal.created) then; .rewind_internal
      else;                        .rewind_external
      end
   end

   rewind_internal
   ! Rewind the input file
      .record = 0
      .io_status = 0
      .read_line
   end

   rewind_external
   ! Rewind the input file
      .update_system_info
      rewind(unit=.unit,iostat=.io_status)
      DIE_IF(.io_status>0,"rewind error")
      .record = 0
      .io_status = 0
      .read_line
   end

   move_to_end
   ! Move to the end of the input file
      if (.internal.created) then; .move_to_end_internal
      else;                        .move_to_end_external
      end
   end

   move_to_end_internal
   ! Move to the end of the input file
      .record = size(.internal)-1
      .read_line
   end

   move_to_end_external
   ! Move to the end of the input file
      .update_system_info
      do
         read(unit=.unit, fmt="()", iostat=.io_status)
         if (.io_status/=0) exit
         .record = .record + 1
         .update_system_info
      end
      backspace(unit=.unit,iostat=.io_status)
      backspace(unit=.unit,iostat=.io_status)
      .record = max(0,.record-1)
      .read_line
   end

   backspace_line
   ! Reprocess previously input line
      .move_to_record(.record-1)
   end

   skip_line
   ! Skip the next line in the input file
      .move_to_record(.record+1)
   end

   move_to_line(line)
   ! Make sure that "line" was the last one processed
   ! in the input file
      INT :: line
      ENSURE(line>=0,"line number must be non-negative")
      .move_to_record(line)
   end

   move_to_record(rec)
   ! Move to the requested record "rec" in the input file.
   ! Remember: .record is the last processed record.
      INT :: rec
      if (.internal.created) then; .move_to_record_internal(rec)
      else;                        .move_to_record_external(rec)
      end
   end

   move_to_record_internal(rec)
   ! Move to the requested record "rec" in the internal file.
   ! Remember: .record is the last processed record.
      INT :: rec
      ENSURE(rec>=0,"record number must be non-negative")
      ENSURE(rec<=size(.internal),"record outside file range")
      .record = rec-1
      .read_line
   end

   move_to_record_external(rec)
   ! Move to the requested record "rec" in the input file.
   ! Remember: .record is the last processed record.
      INT :: rec
      ENSURE(rec>=0,"record number must be non-negative")
      .update_system_info
      if (rec<(.record+1)) then
         do
            backspace(unit=.unit,iostat=.io_status)
            DIE_IF(.io_status>0,"backspace error")
            .record = .record-1
            .io_status = 0
            .update_system_info
            if (rec==(.record+1)) exit
         end
      else if (rec>(.record+1)) then
         do
            read(unit=.unit,fmt="()",iostat=.io_status)
            DIE_IF(.io_status>0,"read error")
            .record = .record + 1
            .update_system_info
            if (rec==(.record+1)) exit
         end
      end
      .read_line
   end

!  **************************
!  Data input type operations
!  **************************

   get_next_item(word) 
   ! Get the next item in the file
      STR :: word
      .update_line
      word = " "
      RETURN_IF(.end_of_file AND .ignore_end_of_file)
      RETURN_IF(.reverted(reset=FALSE))
      .buffer.get(word)
      .update_system_info
   end

  read_str(word) [leaky]
  ! Read a str into "word"
    STR :: word
    ENSURE(.action=="read","file does not have read action!")
    .update_line
    word = " "
    RETURN_IF(.end_of_file AND .ignore_end_of_file)
    RETURN_IF(.reverted(reset=FALSE))
    .buffer.get(word)
    .update_system_info
  end

  read_chr(chr) 
  ! Read a character into "chr"
    CHR :: chr
    STR :: word
    ENSURE(.action=="read","file does not have read action!")
    .read_str(word)
    if (len_trim(word)>1) then
      DIE("Expecting 1 character, not this: "// word.trim)
    end
    chr = word
  end

   read_dbl_quantity(value) 
   ! Read a dbl quantity into "value". Will convert the value of the quantity
   ! from atomic units, if followed by a unit specifier.
      DBL :: value
      STR :: units
      BIN :: known_unit
      ENSURE(.action=="read","file does not have read action!")
      .read_dbl(value)
      .ignore_end_of_file = TRUE
      .read_str(units)                         ! Read possible unit string
      .ignore_end_of_file = FALSE              ! Allow for possible end of file
      if (.end_of_file) then
         known_unit = FALSE                    ! No units string
      else
         known_unit = units.is_known_unit      ! If unknown unit, move back
         if (NOT known_unit) .move_to_previous_item 
      end
      if (known_unit) then
         value.convert_from(units)             ! Convert from known units
      else if (.default_units/=" ") then
         value.convert_from(.default_units)    ! Convert from assumed default units
         .default_units = " "
      end
   end

  read_dbl(value) 
  ! Read a dbl into "value"
    DBL :: value
    ENSURE(.action=="read","file does not have read action!")
    .update_line
    value = ZERO
    RETURN_IF(.end_of_file AND .ignore_end_of_file)
    RETURN_IF(.reverted(reset=FALSE))
    .buffer.get(value)
    .update_system_info
  end

  read_formatted_dbl(value,format) 
  ! Read a formatted dbl into "value". Does not check the end of line!
    DBL :: value
    CHR(*), IN :: format
    ENSURE(.action=="read","file does not have read action!")
    .update_line
    value = ZERO
    RETURN_IF(.end_of_file AND .ignore_end_of_file)
    RETURN_IF(.reverted(reset=FALSE))
    .buffer.get(value,format)
    .update_system_info
  end

   read_cdbl(value) 
   ! Read a cdbl into "value"
      CDBL :: value
      DBL :: real,imag
      ENSURE(.action=="read","file does not have read action!")
      .update_line
      RETURN_IF(.end_of_file AND .ignore_end_of_file)
      RETURN_IF(.reverted(reset=FALSE))
      .buffer.get(real)
      .update_system_info
      .update_line
      DIE_IF(.end_of_file,"imaginary part expected but file has ended")
      DIE_IF(.reverted,   "imaginary part expected but internal file has ended")
      .buffer.get(imag)
      .update_system_info
      value = cmplx(real,imag)
   end

   read_int(value) 
   ! Read an integer into "value"
      INT :: value
      ENSURE(.action=="read","file does not have read action!")
      .update_line
      RETURN_IF(.end_of_file AND .ignore_end_of_file)
      RETURN_IF(.reverted(reset=FALSE))
      .buffer.get(value)
      .update_system_info
   end

   read_bin(value) 
   ! Read a logical into "value"
      BIN :: value
      ENSURE(.action=="read","file does not have read action!")
      .update_line
      RETURN_IF(.end_of_file AND .ignore_end_of_file)
      RETURN_IF(.reverted(reset=FALSE))
      .buffer.get(value)
      .update_system_info
   end

   read_binvec(v) 
   ! Read in a BIN vector sequentially. Line breaks are not significant.
      BINVEC :: v
      INT :: dim,i
      dim = size(v)
      do i = 1,dim
         .read_bin(v(i))
      end
   end

   list_length result (res) [leaky]
   ! Return the size of the list, by reading the input until an 
   ! "end" token is found. Line breaks are not significant. 
      INT :: res
      INT :: line,item
      STR :: word
      .read(word)
      ENSURE(word=="{","list does not begin with {")
      line = .line_number
      item = .previous_line_item
      res = 0
      do
         .read(word)
         if (word=="end") exit 
         if (word=="}") exit 
         res = res+1
      end 
      .move_to_line(line)
      .move_to_line_item(item)
   end

   read_binvec_ptr(v) [leaky]
   ! Read in a BIN vector pointer "v" sequentially. Line breaks are not
   ! significant.  The "v" vector pointer in created to be the right size.
      BINVEC* :: v
      INT :: dim
      dim = .list_length
      v.create(dim)
      .skip_next_item  ! Remember to read "{" token
      .read_binvec(v)
      .skip_next_item  ! Remember to read "}" token
   end

   read_strvec(v) 
   ! Read in an string vector sequentially. Line breaks are not significant.
      STRVEC :: v
      INT :: dim,i
      dim = size(v)
      do i = 1,dim
         .read_str(v(i))
      end
   end

   read_strvec_ptr(v) [leaky]
   ! Read in a string vector pointer "v" sequentially. Line breaks are not
   ! significant.  The "v" vector pointer in created to be the right size.
      STRVEC* :: v
      INT :: dim
      dim = .list_length
      v.create(dim)
      .skip_next_item  ! Remember to read "{" token
      .read_strvec(v)
      .skip_next_item  ! Remember to read "}" token
   end

   read_ivec(v) 
   ! Read in an integer vector sequentially. Line breaks are not significant.
      IVEC :: v
      INT :: dim,i
      dim = size(v)
      do i = 1,dim
         .read_int(v(i))
      end
   end

   read_ivec_ptr(v) [leaky]
   ! Read in a integer vector pointer "v" sequentially. Line breaks are not
   ! significant.  The "v" vector pointer in created to be the right size.
      IVEC* :: v
      INT :: dim
      dim = .list_length
      v.create(dim)
      .skip_next_item  ! Remember to read "{" token
      .read_ivec(v)
      .skip_next_item  ! Remember to read "}" token
   end

   read_vec_quantity(v) 
   ! Read in a vector sequentially. Line breaks are not significant.
      VEC :: v
      STR :: units
      BIN :: known_unit
      .read_vec(v)
      .ignore_end_of_file = TRUE
      .read_str(units)                      ! Read possible unit string
      .ignore_end_of_file = FALSE           ! Allow for possible end of file
      if (.end_of_file) then
         known_unit = FALSE                 ! No units string
      else
         known_unit = units.is_known_unit   ! If unknown unit, move back
         if (NOT known_unit) .move_to_previous_item 
      end
      if (known_unit) then
         v.convert_from(units)              ! Convert from known units
      else if (.default_units/=" ") then
         v.convert_from(.default_units)     ! Convert from assumed default units
         .default_units = " "
      end
   end

   read_vec(v) 
   ! Read in a vector sequentially. Line breaks are not significant.
      VEC :: v
      INT :: dim,i
      dim = size(v)
      do i = 1,dim
         .read_dbl(v(i))
      end
   end

   read_vec_ptr(v) [leaky]
   ! Read in a vector pointer "v" sequentially. Line breaks are not significant.
   ! The "v" vector pointer in created to be the right size.
      VEC* :: v
      INT :: dim
      dim = .list_length
      v.create(dim)
      .skip_next_item  ! Remember to read "{" token
      .read_vec(v)
      .skip_next_item  ! Remember to read "}" token
   end

   read_vec_pair(v1,v2) 
   ! Read in a pair of vectors sequentially, alternating. Line breaks are 
   ! not significant.
      VEC :: v1,v2
      INT :: dim,i
      ENSURE(size(v1)==size(v2),"incompatible vectors")
      dim = size(v1)
      do i = 1,dim
         .read_dbl(v1(i))
         .read_dbl(v2(i))
      end
   end

   read_cvec(v) 
   ! Read in a complex vector sequentially. Line breaks are not significant.
      CVEC :: v
      INT :: dim,i
      dim = size(v)
      do i = 1,dim
         .read_cdbl(v(i))
      end
   end

   read_cvec_ptr(v) [leaky]
   ! Read in a complex vector pointer "v" sequentially. Line breaks are not
   ! significant.  The "v" vector pointer in created to be the right size.
      CVEC* :: v
      INT :: dim
      dim = .list_length
      ENSURE(dim.is_even,"vector must have even number of elements")
      dim = dim/2
      v.create(dim)
      .skip_next_item  ! Remember to read "{" token
      .read_cvec(v)
      .skip_next_item  ! Remember to read "}" token
   end

   read_mat_quantity(m,order) 
   ! Read in a matrix sequentially by row (default) or by column.
   ! If a units string appears after the matrix, the elements are
   ! converted into atomic units or generic units.
   ! Line breaks are not significant.
      MAT :: m
      STR(*), optional :: order
      STR :: units
      BIN :: known_unit
      .read_mat(m,order)
      .ignore_end_of_file = TRUE
      .read_str(units)                      ! Read possible unit string
      .ignore_end_of_file = FALSE           ! Allow for possible end of file
      if (.end_of_file) then
         known_unit = FALSE                 ! No units string
      else
         known_unit = units.is_known_unit   ! If unknown unit, move back
         if (NOT known_unit) .move_to_previous_item 
      end
      if (known_unit) then
         m.convert_from(units)              ! Convert from known units
      else if (.default_units/=" ") then
         m.convert_from(.default_units)     ! Convert from assumed default units
         .default_units = " "
      end
   end

   read_mat(m,order) 
   ! Read in a complex matrix sequentially by row (default) or by column.
   ! Line breaks are not significant.
      MAT :: m
      STR(*), optional :: order
      INT :: dim1,dim2,i,j
      STR :: print_order
      dim1 = size(m,1)
      dim2 = size(m,2)
      print_order = "by_row"
      if (present(order)) print_order = order
      select case (print_order)
         case ("by_column","column_major")
            do j = 1,dim2
            do i = 1,dim1
              .read_dbl(m(i,j))
            end
            end
         case ("by_row","row_major")
            do i = 1,dim1
            do j = 1,dim2
              .read_dbl(m(i,j))
            end
            end
         case default
            DIE("unknown print order, "//print_order.trim)
      end
   end

   read_mat3(mx) 
   ! Read a MAT3 from the input buffer flat style
     MAT3 :: mx
     INT :: a,b,c,aub,bub,cub,tmp
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           .read_int(tmp)
           .read_int(tmp)
           .read_int(tmp)
           .read_dbl(mx(a,b,c))
         end
       end
     end
   end

   read_mat4(mx) 
   ! Read a MAT4 from the input buffer flat style
     MAT4 :: mx
     INT :: a,b,c,d,aub,bub,cub,dub,tmp
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,3)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     WARN_IF(dub==0,"zero sized 4th dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           do d=1,dub
             .read_int(tmp)
             .read_int(tmp)
             .read_int(tmp)
             .read_int(tmp)
             .read_dbl(mx(a,b,c,d))
           end
         end
       end
     end
   end

  read_formatted_mat(m,format,items_per_line) 
  ! Read a formatted matrix "m" with fortran "format" and a given
  ! number of "items_per_line".
    MAT, OUT :: m
    CHR(*), IN :: format
    INT, IN :: items_per_line
    INT :: i,j,d,count
    .buffer.pos = 0
    d = size(m,1)
    count=0
    do i=1,d
      do j=1,d
        .read_formatted_dbl(m(i,j),format)
        count = count + 1
         if (count==items_per_line) then
           do
              .read_line
              if (.buffer.not_empty) exit
           end
           count=0
         end
      end
    end
  end

  read_cadpac_mat(m)
  ! Read in a matrix produced by the constraint part of cadpac.
    IN :: self
    MAT, OUT :: m
    .read_formatted_mat(m,"5D16.8",5)
  end

   read_cmat(m,order)
   ! Read in a complex matrix sequentially by row (default) or by column.
   ! Line breaks are not significant.
      CMAT :: m
      STR, optional :: order
      INT :: dim1,dim2,i,j
      STR :: print_order
      dim1 = size(m,1)
      dim2 = size(m,2)
      print_order = "by_row"
      if (present(order)) print_order = order
      select case (print_order)
         case ("by_column","column_major")
            do j = 1,dim2
            do i = 1,dim1
              .read_cdbl(m(i,j))
            end
            end
         case ("by_row","row_major")
            do i = 1,dim1
            do j = 1,dim2
              .read_cdbl(m(i,j))
            end
            end
         case default
            DIE("unknown print order, "//print_order.trim)
      end
   end

   read_cmat3(mx)
   ! Read a CMAT3 from the input buffer flat style
     CMAT3 :: mx
     INT :: a,b,c,aub,bub,cub,tmp
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           .read_int(tmp)
           .read_int(tmp)
           .read_int(tmp)
           .read_cdbl(mx(a,b,c))
         end
       end
     end
   end

   read_cmat4(mx)
   ! Read a CMAT4 from the input buffer flat style
     CMAT4 :: mx
     INT :: a,b,c,d,aub,bub,cub,dub,tmp
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,4)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     WARN_IF(dub==0,"zero sized 4th dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           do d=1,dub
             .read_int(tmp)
             .read_int(tmp)
             .read_int(tmp)
             .read_int(tmp)
             .read_cdbl(mx(a,b,c,d))
           end
         end
       end
     end
   end

   read_cmat5(mx)
   ! Read a CMAT5 from the input buffer flat style
     CMAT5 :: mx
     INT :: a,b,c,d,e,aub,bub,cub,dub,eub,tmp
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,4)
     eub=size(mx,5)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     WARN_IF(dub==0,"zero sized 4th dimension!")
     WARN_IF(eub==0,"zero sized 5th dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           do d=1,dub
             do e=1,eub
               .read_int(tmp)
               .read_int(tmp)
               .read_int(tmp)
               .read_int(tmp)
               .read_int(tmp)
               .read_cdbl(mx(a,b,c,d,e))
             end
           end
         end
       end
     end
   end

  next_str result(word) [leaky]
  ! Read a str from the input file and return it
    STR :: word
    .read_str(word)
  end

  next_dbl result(value)
  ! Read a dbl from the input file and return it
    DBL :: value
    .read_dbl(value)
  end

  next_cdbl result(value)
  ! Read a cdbl from the input file and return it
    CDBL :: value
    .read_cdbl(value)
  end

  next_int result(value)
  ! Read a integer from the input file and return it
    INT :: value
    .read_int(value)
  end

  next_bin result(value)
  ! Read a logical from the input file and return it
    BIN :: value
    .read_bin(value)
  end

  next_chr result(chr)
  ! Read a character from the input file and return it
    CHR :: chr
    .read_chr(chr)
  end

  next_formatted_dbl(format) result(value)
  ! Read a formatted dbl from the input file and return it.
  ! Does not check the end of line!
    DBL :: value
    CHR(*), IN :: format
    .read_formatted_dbl(value,format)
  end

!  ********************
!  Data output routines
!  ********************

   put_margin
   ! Put a margin into the buffer of the output object
      .update_system_info
      .buffer.put(repeat(" ",.margin))
      .update_system_info
   end

   flush
   ! Flush the buffer to the output file
      UNITNUMBER :: unitnumber
      ENSURE(.is_open,"file is not open!")
      ENSURE(.action=="write","file does not have write action!")
      .update_system_info
      write(.unit,'(a)') trim( .buffer_str )
      unitnumber.unit = .unit
      unitnumber.flush_buffer
      .buffer.clear
      .put_margin
      .record = .record + 1
      .update_system_info
   end

   flush(times)
   ! Flush the buffer multiple times to get extra carriage returns
     INT :: times
     INT :: i
     do i=1,times
        .flush
     end
   end

   tab(dbl_fields,int_fields,bin_fields,width)
   ! Tab across the specified number of fields in the output buffer
   ! "dbl_fields", "int_fields" and "bin_fields" refer to the number of
   ! dbl, integer and logical fields to tab; "width" is the width of spaces
   ! to tab.
      INT, optional :: dbl_fields,int_fields,bin_fields,width
      .update_system_info
      if (present(dbl_fields)) &
         .buffer.put(repeat(repeat(" ",.dbl_width),dbl_fields))
      if (present(int_fields)) &
         .buffer.put(repeat(repeat(" ",.int_width),int_fields))
      if (present(bin_fields)) &
         .buffer.put(repeat(repeat(" ",.int_width),bin_fields))
      if (present(width)) &
         .buffer.put(repeat(" ",width))
      .update_system_info
   end

   dash(dbl_fields,int_fields,bin_fields,width)
   ! Put a dashed line into the buffer. "dbl_fields", "int_fields" and
   ! "bin_fields" refer to the number of dbl, integer and logical fields
   ! to draw the line over; "width" is the width of characters to draw the
   ! dashed line.
      INT, optional :: dbl_fields,int_fields,bin_fields,width
      .put_dash(dbl_fields,int_fields,bin_fields,width,flush=1)
   end

   put_dash(dbl_fields,int_fields,bin_fields,width,flush)
   ! Put a dashed line into the buffer. "dbl_fields", "int_fields" and
   ! "bin_fields" refer to the number of dbl, integer and logical fields
   ! to draw the line over; "width" is the width of characters to draw the
   ! dashed line.
      INT, optional :: dbl_fields,int_fields,bin_fields,width,flush
      .update_system_info
      if (present(dbl_fields)) &
         .buffer.put(repeat(repeat("-",.dbl_width),dbl_fields))
      if (present(int_fields)) &
         .buffer.put(repeat(repeat("-",.int_width),int_fields))
      if (present(bin_fields)) &
         .buffer.put(repeat(repeat("-",.int_width),bin_fields))
      if (present(width)) &
         .buffer.put(repeat("-",width))
      .update_system_info
      if (present(flush)) .flush(flush)
   end

   show_str(pretext,string,int_width)
   ! Put a formatted STR into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      CHR(*) :: string
      BIN, optional :: int_width
      .put_text(pretext)
      .put_str(string,int_width,flush=1)
   end

   show_int(pretext,value,dbl_width)
   ! Put a formatted INT into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      BIN, optional :: dbl_width
      INT :: value
      .put_text(pretext)
      .put(value,dbl_width,flush=1)
   end

   show_bin(pretext,value,dbl_width)
   ! Put a formatted BIN into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      BIN, optional :: dbl_width
      BIN :: value
      .put_text(pretext)
      .put(value,dbl_width,flush=1)
   end

   show_dbl_1(pretext,value)
   ! Put a formatted DBL into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      DBL :: value
      .put_text(pretext)
      .put(value,flush=1)
   end

   show_dbl_3(pretext,val1,val2,val3)
   ! Put a formatted DBL's into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      DBL :: val1,val2,val3
      .put_text(pretext)
      .put(val1)
      .put(val2)
      .put(val3,flush=1)
   end

   show_ivec(pretext,value)
   ! Put a formatted INTVEC "value" into the output buffer with descriptive
   ! "pretext".
      CHR(*) :: pretext
      IVEC :: value
      BIN :: labels
      .put_text(pretext)
      labels = .labels
      .set_labels(FALSE)
      .put(value)
      .set_labels(labels)
      .flush
   end

   show_vec(pretext,value)
   ! Put a formatted DBL "value" into the output buffer with descriptive
   ! "pretext".
      CHR(*) :: pretext
      VEC :: value
      BIN :: labels
      .put_text(pretext)
      labels = .labels
      .set_labels(FALSE)
      .put(value)
      .set_labels(labels)
      .flush
   end

   text(string,dbl_width,int_width,flush)
   ! Put text into the output buffer as is and flush,
   ! unless an explicit flush is present
      CHR(*) :: string
      BIN, optional :: dbl_width,int_width
      INT, optional :: flush
      if (present(flush)) then
         .put_text(string,dbl_width,int_width,flush)
      else
         .put_text(string,dbl_width,int_width,flush=1)
      end
   end

   put_text(string,dbl_width,int_width,flush)
   ! Put text into the output buffer as is.
      CHR(*) :: string
      BIN, optional :: dbl_width,int_width
      INT, optional :: flush
      CHR( .int_width ) :: int_string
      CHR( .dbl_width ) :: dbl_string
      .update_system_info
      if (present(dbl_width) AND (len(string) <= .dbl_width )) then
        dbl_string = string
        .buffer.put( dbl_string )
      else if (present(int_width) AND (len(string) <= .int_width )) then
        int_string = string
        .buffer.put( int_string )
      else
        .buffer.put( string )
      end
      .update_system_info
      if (present(flush)) .flush(flush)
   end

   put_str(string,int_width,flush)
   ! Put a formatted STR into the output buffer; if too big, put as is.
   ! if present and TRUE, "int_width" says to use field width of int_width
   ! if present, flush is how many times to flush the buffer.
      CHR(*) :: string
      INT, optional :: flush
      BIN, optional :: int_width
      STR :: form
      INT :: wid
      .update_system_info
      wid = .dbl_width
      if (present(int_width)) wid = .int_width
      if (len_trim(string)>wid) then
         .buffer.put(trim(string))
      else if (len_trim(string)/=0) then
         form = "a" // trim( wid.to_str)
         .buffer.put(trim(string),form)
      end
      .update_system_info
      if (present(flush)) .flush(flush)
   end

   put_unit(value,units)
   ! Put a formatted value and its units into the output buffer.
     INT, IN :: value
     STR, IN :: units
     STR :: format
     .update_system_info
     format = .format_for_int( .nice_field_width_for(value) )
     .buffer.put(value,format)
     .put_text( " " // units.trim)
     if (value /= 1) .put_text("s")
   end

   put_int(value,dbl_width,flush)
   ! Put a formatted integer into the output buffer; the field width used is
   ! int_width, usually the length of the nondecimal part of a formatted DBL
   ! number.
   ! Can override the width and use dbl_width if "dbl_width" is set to TRUE.
      INT :: value
      INT, optional :: flush
      BIN, optional :: dbl_width
      STR :: format
      .update_system_info
      format = .format_for_int( .int_width)
      if (present(dbl_width)) then
        if (dbl_width) format = .format_for_int( .dbl_width)
      end
      .buffer.put(value,format)
      .update_system_info
      if (present(flush)) .flush(flush)
   end

   put_int_with_zeros(int,width,flush)
     INT, IN :: int, width
     INT, optional :: flush
     INT :: int_width
     STR :: format
     .update_system_info
     int_width = .nice_field_width_for(int)
     if (int<0) then
       .buffer.put("-")
       format = .format_for_int(int_width-1)
     else
       format = .format_for_int(int_width)
     end
     .buffer.put(repeat("0",width-int_width))
     .buffer.put(abs(int),format)
     .update_system_info
     if (present(flush)) .flush(flush)
   end

   put_bin(value,dbl_width,flush)
   ! Put a formatted logical into the output buffer; can specify the width of
   ! the field if desired. Otherwise, the field with used is int_width, or
   ! the length of the nondecimal part of a formatted DBL number
      BIN :: value
      INT, optional :: flush
      BIN, optional :: dbl_width
      STR :: format
      .update_system_info
      format = .format_for_bin( .int_width)
      if (present(dbl_width)) then
        if (dbl_width) format = .format_for_bin( .dbl_width)
      end
      .buffer.put(value,format)
      .update_system_info
      if (present(flush)) .flush(flush)
   end

   put_dbl(value,flush)
   ! Put a formatted DBL into the output buffer
   ! The field with used is int_width, or
   ! the length of the nondecimal part of a formatted DBL number
      DBL :: value
      STR :: format
      INT, optional :: flush
      .update_system_info
      format = .format_for_dbl( .dbl_style, .dbl_width, .dbl_precision)
      .buffer.put(value,format)
      .update_system_info
      if (present(flush)) .flush(flush)
   end

   put_cdbl(value,flush)
   ! Put a formatted CDBL into the output buffer
   ! The field with used is int_width, or
   ! the length of the nondecimal part of a formatted DBL number
      CDBL :: value
      STR :: format
      INT, optional :: flush
      .update_system_info
      format = .format_for_dbl( .dbl_style, .dbl_width, .dbl_precision)
      .buffer.put(value,format)
      .update_system_info
      if (present(flush)) .flush(flush)
   end

   put_ivec(vec,format)
   ! Put a formatted integer vector into the output buffer
      IVEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_ivec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_ivec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_ivec_by_column(vec)
   ! Put a formatted integer vector into the output buffer
      IVEC :: vec
      INT :: dim,i
      dim = size(vec)
      do i = 1,dim
         if (.labels_used) then
            .put_int(i)
         end
         .put_int(vec(i),flush=1)
      end
   end

   put_ivec_by_row(vec)
   ! Put a formatted integer vector into the output buffer
      IVEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      dim = size(vec)
      fields = .fields
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         if (.labels_used) then
!           .tab(int_fields=1)
            do i = f,l
               .put_int(i)
            end
            .flush(2)
!           .tab(int_fields=1)
         end
         do i = f,l
            .put_int(vec(i))
         end
         .flush
      end
   end

   put_strvec(vec,format)
   ! Put a formatted dbl vector into the output buffer
      STRVEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_strvec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_strvec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_strvec_by_column(vec)
   ! Put a formatted integer vector into the output buffer
      STRVEC :: vec
      INT :: dim,i
      dim = size(vec)
      do i = 1,dim
         if (.labels_used) then
            .put_int(i)
         end
         .put(vec(i))
         .flush
      end
   end

   put_strvec_by_row(vec)
   ! Put a formatted string vector into the output buffer
      STRVEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      dim = size(vec)
      fields = .fields
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         if (.labels_used) then
!           .tab(dbl_fields=1)
            do i = f,l
               .put_int(i,dbl_width=TRUE)
            end
            .flush(2)
!           .tab(dbl_fields=1)
         end
         do i = f,l
            .put_str(vec(i))
         end
         .flush
      end
   end

   put_vec(vec,format)
   ! Put a formatted dbl vector into the output buffer
      VEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_vec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_vec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_vec_by_column(vec)
   ! Put a formatted integer vector into the output buffer
      VEC :: vec
      INT :: dim,i
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      do i = 1,dim
         if (.labels_used) then
!           .put_int(i,dbl_width=TRUE)
            .put_int(i)
         end
         .put(vec(i),flush=1)
      end
   end

   put_vec_by_row(vec)
   ! Put a formatted DBL vector into the output buffer
      VEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      fields = .fields
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
!         if (block>1) .flush
         if (.labels_used) then
!           .tab(int_fields=1)
            do i = f,l
               .put_int(i,dbl_width=TRUE)
            end
            .flush(2)
!           .tab(int_fields=1)
         end
         do i = f,l
            .put(vec(i))
         end
         .flush
      end
   end

   put_cvec(vec,format)
   ! Put a formatted dbl vector into the output buffer
      CVEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_cvec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_cvec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_cvec_by_column(vec)
   ! Put a formatted complex vector into the output buffer
      CVEC :: vec
      INT :: dim,i
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      do i = 1,dim
         if (.labels_used) then
            .put_int(i,dbl_width=TRUE)
         end
         .put(vec(i),flush=1)
      end
   end

   put_cvec_by_row(vec)
   ! Put a formatted DBL vector into the output buffer
      CVEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      fields = .fields/2
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         if (.labels_used) then
!           .tab(int_fields=1)
            do i = f,l
               .tab(dbl_fields=1)
               .put_int(i,dbl_width=TRUE)
            end
            .flush(2)
!           .tab(int_fields=1)
         end
         do i = f,l
            .put(vec(i))
         end
         .flush
      end
   end

   put_imat(mx,order)
   ! Put a formatted integer matrix into the output buffer
   ! If "order" is present use unformatted output suitable for ASCII archive
      IMAT :: mx
      CHR(*), optional :: order
      INT :: i,j,block,nb,f,l,dim1,dim2,fields
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      fields = .fields
      if (NOT present(order)) then     ! formatted output
         nb = (dim2-0.1)/fields+1
         do block = 1,nb
            f = 1+fields*(block-1)
            l = min(f+fields-1,dim2)
            if (block>1) .flush
            if (.labels_used) then
               .tab(int_fields=1)
               do j = f,l
                  .put_int(j)
               end
               .flush(2)
            end
            do i = 1,dim1
               if (.labels_used)     .put_int(i)
               if (.labels_not_used) .tab(int_fields=1)
               do j = f,l
                  .put_int(mx(i,j))
               end
               .flush
            end
         end
      else                             ! unformatted output
         select case (order)
            case ("by_column","column_wise","transpose")
               do j = 1,dim2
               do i = 1,dim1
                  .put_int(mx(i,j))
                  if(mod(i,fields)==0) .flush
               end
               .flush
               end
            case ("by_row","row_wise","normal")
               do i = 1,dim1
               do j = 1,dim2
                  .put_int(mx(i,j))
                  if(mod(j,fields)==0) .flush
               end
               .flush
               end
            case default
               DIE("unknown print order, "// order.trim)
         end
      end
   end

   put_mat(mx,order)
   ! Put a formatted DBL matrix into the output buffer
   ! If "order" is present use unformatted output suitable for ASCII archive
      MAT :: mx
      STR, optional :: order
      INT :: i,j,block,nb,f,l,dim1,dim2,fields
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      fields = .fields
      if (NOT present(order)) then
         nb = (dim2-0.1)/fields+1
         do block = 1,nb
            f = 1+fields*(block-1)
            l = min(f+fields-1,dim2)
            if (block>1) .flush
            if (.labels_used) then
               .tab(int_fields=1)
               do j = f,l
                  .put_int(j,dbl_width=TRUE)
               end
               .flush(2)
            end
            do i = 1,dim1
               if (.labels_used)     .put_int(i)
               if (.labels_not_used) .tab(int_fields=1)
               do j = f,l
                  .put_dbl(mx(i,j))
               end
               .flush
            end
         end
      else
         select case (order)
            case ("by_column","column_wise","transpose"); .put_mat_by_column(mx)
            case ("by_row","row_wise","normal");          .put_mat_by_row(mx)
            case default
               DIE("unknown print order, "// order.trim)
         end
      end
   end

   put_mat_by_column(mx)
   ! Put a DBL matrix into the output buffer by column, without labels
      MAT :: mx
      INT :: i,j,dim1,dim2
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      do j = 1,dim2
      do i = 1,dim1
         .put_dbl(mx(i,j))
         if(mod(i,.fields)==0) .flush
      end
      .flush
      end
   end

   put_mat_by_row(mx)
   ! Put a DBL matrix into the output buffer by row, without labels
      MAT :: mx
      INT :: i,j,dim1,dim2
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      do i = 1,dim1
      do j = 1,dim2
         .put_dbl(mx(i,j))
         if(mod(j,.fields)==0) .flush
      end
      .flush
      end
   end

   put_formatted_mat(mx,form)
   ! Put out a matrix suitable to be read in by other programs.
   ! Will overwrite the current buffer.
     MAT, IN :: mx
     CHR(*), IN :: form
     INT :: columns,first,last,i,j,nbasis,count,old_margin
     STR :: forma,formb
     .update_system_info
     i = form.scan("FfEe")
     form.get_next_item_position(first,last)
     DIE_IF( i==0, "incorrect format specification")
     forma=" "
     forma(1:i-first)=form(first:i-1)
     DIE_IF( forma.is_not_int, "incorrect format specification")
     columns = forma.to_int
     formb=" "
     formb(1:last-i+1) = form(i:last)
     .buffer.pos = 0
     .update_system_info
     old_margin = .margin
     .margin = 0
     nbasis=size(mx,1)
     count=0
     do i=1,nbasis
       do j=1,nbasis
         .buffer.put(mx(i,j), formb.trim)
         count=count+1
         if (count==columns) then
           .flush
           count=0
         end
       end
     end
     .update_system_info
     if (NOT count == 0) .flush
     .margin = old_margin
   end

   put_cmat(mx,order)
   ! Put a formatted CDBL matrix into the output buffer
   ! If "order" is present use unformatted output suitable for ASCII archive
      CMAT :: mx
      CHR(*), optional :: order
      INT :: i,j,block,nb,f,l,dim1,dim2,fields
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      fields = .fields/2
      if (NOT present(order)) then
         nb = (dim2-0.1)/fields+1
         do block = 1,nb
            f = 1+fields*(block-1)
            l = min(f+fields-1,dim2)
            if (block>1) .flush
            if (.labels_used) then
               .tab(int_fields=1)
               do j = f,l
                  .tab(dbl_fields=1)
                  .put_int(j,dbl_width=TRUE)
               end
               .flush(2)
            end
            do i = 1,dim1
               if (.labels_used)     .put_int(i)
               if (.labels_not_used) .tab(int_fields=1)
               do j = f,l
                  .put(mx(i,j))
               end
               .flush
            end
         end
      else
         select case (order)
            case ("by_column","column_wise","transpose")
               do j = 1,dim2
               do i = 1,dim1
                  .put(mx(i,j))
                  if(mod(i,fields)==0) .flush
               end
               .flush
               end
            case ("by_row","row_wise","normal")
               do i = 1,dim1
               do j = 1,dim2
                  .put(mx(i,j))
                 if(mod(j,fields)==0) .flush
               end
               .flush
               end
            case default
               DIE("unknown print order, "// order.trim)
         end
      end
   end

   put_mat3(mx)
   ! Put a MAT3 into the output buffer flat style
     MAT3 :: mx
     INT :: a,b,c,aub,bub,cub
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           .put(a)
           .put(b)
           .put(c)
           .put_dbl(mx(a,b,c),flush=1)
         end
       end
     end
   end

   put_mat4(mx)
   ! Put a MAT4 into the output buffer flat style
     MAT4 :: mx
     INT :: a,b,c,d,aub,bub,cub,dub
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,4)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     WARN_IF(dub==0,"zero sized 4th dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           do d=1,dub
             .put(a)
             .put(b)
             .put(c)
             .put(d)
             .put_dbl(mx(a,b,c,d),flush=1)
           end
         end
       end
     end
   end

   put_cmat3(mx)
   ! Put a MAT3 into the output buffer flat style
     CMAT3 :: mx
     INT :: a,b,c,aub,bub,cub
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           .put(a)
           .put(b)
           .put(c)
           .put(mx(a,b,c),flush=1)
         end
       end
     end
   end

   put_cmat4(mx)
   ! Put a CMAT4 into the output buffer flat style
     CMAT4 :: mx
     INT :: a,b,c,d,aub,bub,cub,dub
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,4)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     WARN_IF(dub==0,"zero sized 4th dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           do d=1,dub
             .put(a)
             .put(b)
             .put(c)
             .put(d)
             .put(mx(a,b,c,d),flush=1)
           end
         end
       end
     end
   end

   put_cmat5(mx)
   ! Put a CMAT5 into the output buffer flat style
     CMAT5 :: mx
     INT :: a,b,c,d,e,aub,bub,cub,dub,eub
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,4)
     eub=size(mx,5)
     do a=1,aub
     do b=1,bub
     do c=1,cub
     do d=1,dub
     do e=1,eub
        .put(a)
        .put(b)
        .put(c)
        .put(d)
        .put(e)
        .put(mx(a,b,c,d,e),flush=1)
     end
     end
     end
     end
     end
   end

   put_gaussian(g)
   ! Output gaussian information
      GAUSSIAN :: g
      .flush
      .show("L quantum number = ", g.l)
      .show("Position         = ", g.pos(1), g.pos(2), g.pos(3))
      .show("Exponent         = ", g.ex)
   end

   put_gaussian2(g)
   ! Output gaussian information
      GAUSSIAN2 :: g
      .flush
      .put_text("Shell a:\n")
      .show("L quantum number = ", g.l_a)
      .show("Position         = ", g.pos_a(1), g.pos_a(2), g.pos_a(3))
      .show("Exponent         = ", g.ex_a)
      .put_text("Shell b:\n")
      .show("L quantum number = ", g.l_b)
      .show("Position         = ", g.pos_b(1), g.pos_b(2), g.pos_b(3))
      .show("Exponent         = ", g.ex_b)
   end

  put_opvec(vec,format)
  ! Outputs the opvec
    OPVEC, IN :: vec
    CHR(*), optional :: format
    if (associated( vec.restricted)) then
      .flush
      .put_text("restricted part:",flush=2)
      .put( vec.restricted,format)
    end
    if (associated( vec.alpha)) then
      .flush
      .put_text("alpha part:",flush=2)
      .put( vec.alpha,format)
    end
    if (associated( vec.beta)) then
      .flush
      .put_text("beta part:",flush=2)
      .put( vec.beta,format)
    end
    if (associated( vec.general)) then
      .flush
      .put_text("general part:",flush=2)
      .put( vec.general,format)
    end
  end

  put_opmat(mat,order)
  ! Outputs the opmat
    OPMAT, IN :: mat
    CHR(*), optional :: order
    if (associated( mat.restricted)) then
      .flush
      .put_text("restricted part:",flush=2)
      .put( mat.restricted,order)
    end
    if (associated( mat.alpha)) then
      .flush
      .put_text("alpha part:",flush=2)
      .put( mat.alpha,order)
    end
    if (associated( mat.beta)) then
      .flush
      .put_text("beta part:",flush=2)
      .put( mat.beta,order)
    end
    if (associated( mat.general)) then
      .flush
      .put_text("general part:",flush=2)
      .put( mat.general,order)
    end
    if (associated( mat.restricted_complex)) then
      .flush
      .put_text("complex restricted part:",flush=2)
      .put( mat.restricted_complex,order)
    end
    if (associated( mat.alpha_complex)) then
      .flush
      .put_text("complex alpha part:",flush=2)
      .put( mat.alpha_complex,order)
    end
    if (associated( mat.beta_complex)) then
      .flush
      .put_text("beta part:",flush=2)
      .put( mat.beta_complex,order)
    end
    if (associated( mat.general_complex)) then
      .flush
      .put_text("complex general part:",flush=2)
      .put( mat.general_complex,order)
    end
  end

!  ****************
!  Output self info
!  ****************

   put_info
   ! Put all the available molecule information on file "out"
      stdout.show("Name       =",.name)
      stdout.show("I/O action =",.action)
      stdout.show("Unit       =",.unit)
      stdout.show("Line       =",.record)
      stdout.show("Buffer     =",trim(.buffer.buffer_str))
      stdout.show("Cursor pos =",trim(.buffer.cursor_pointer))
   end

!  ***************
!  Set fmt methods
!  ***************

   set_default_units(units)
   ! Set the .default_units to "units".
      STR(*) :: units
      ENSURE(units==" " OR units.is_known_unit,"Unknown units!")
      .default_units = units
   end

   set_labels(labels)
   ! Set whether to use numbered labels on matrix or vector output
      BIN :: labels
      .labels = labels
   end

   set_margin(margin)
   ! Set the width of the margin in the buffer. Takes effect at the next
   ! output line
      INT :: margin
      ENSURE(margin>=0,"margin less than zero")
      ENSURE(margin<=STR_SIZE,"margin too large")
      ENSURE(.buffer.pos<=.margin,"set margin only on empty buffers")
      .update_system_info
      .margin = margin
      .buffer.clear
      .put_margin
   end

!  ************************
!  Inherited dblfmt methods
!  ************************

   set_default_format
   ! Set the default settings for the DBL formatting object
   ! Extra functions added compared to inherited code
      .labels        = TEXTFILE_USE_LABELS
      .margin        = TEXTFILE_MARGIN_WIDTH
      .fields        = TEXTFILE_NO_OF_FIELDS
      .int_width     = TEXTFILE_INT_WIDTH
      .dbl_width     = TEXTFILE_DBL_WIDTH
      .dbl_precision = TEXTFILE_PRECISION
      .dbl_style     = TEXTFILE_DBL_STYLE
   end

   set_page_width(width)
   ! Set the default number of fields to fit in printer page
      INT, IN :: width
      INT :: fields
      fields=floor(real(width - .margin,kind=DBL_KIND) / .dbl_width)
      .set_fields(fields)
   end

   set_int_width(width)
   ! Set the width of an integer in the format object
      INT :: width
      ENSURE(width>=0,"width less than zero")
      .int_width = width
   end

   set_dbl_width(width)
   ! Set the width in the dblfmt format object
      INT :: width
      ENSURE(width>=0,"width less than zero")
      ENSURE(width>=.dbl_precision,"width smaller than precision")
      .dbl_width = width
   end

   set_fields(fields)
   ! Set the number of fields in the dblfmt format object
      INT :: fields
      ENSURE(fields>=1,"not enough fields")
      .fields = fields
   end

   set_dbl_precision(precision)
   ! Set the precision required in the dblfmt format object
      INT :: precision
      INT :: w
      ENSURE(precision>=0,"precision less than zero")
      ENSURE(precision<=.dbl_width,"precision greater than field width")
      w = .int_width - (.dbl_width-.dbl_precision-1)
      WARN_IF(w>0,"width may be too small")
      .dbl_precision = precision
   end

   set_dbl_style(dbl_style)
   ! Set the fortran format style string in the dblfmt format object
      CHR(*) :: dbl_style
      CHR(2) :: style
      style = adjustl(dbl_style)
      if (style/="f" AND style/="d" AND style/="e" AND style/="en" AND style/="es") &
         DIE("unrecognized style, "//style)
      .dbl_style = style
   end

   nice_field_width_for(num) result (res) [private]
   ! Return the field width that would look nice
     INT :: res
     INT, IN :: num
     DBL :: temp
     res=0
     if (num<0) res=res+1
     temp=abs(num)
     do
       res=res+1
       temp=temp/10
       if (temp < 1.0d0) exit
     end
   end

   format_for_dbl(style,width,precision) result (res) [private]
   ! Format for a DBL string
      STR :: res
      STR, IN :: style
      INT, IN :: width,precision
      res = trim(style) // trim( width.to_str) // "." // trim( precision.to_str)
   end

   format_for_int(width) result (res) [private]
   ! Format for a INT string
      STR :: res
      INT, IN :: width
      res = "i" // trim( width.to_str)
   end

   format_for_bin(width) result (res) [private]
   ! Format for a INT string
      STR :: res
      INT, IN :: width
      res = "l" // trim( width.to_str)
   end

!  ***************
!  Inquiry methods
!  ***************

   exists result(res)
   ! Returns true if the file exists on the file system
      BIN :: res
      .update_system_info
      inquire(file=.name,exist=res)
   end

   does_not_exist result(res)
   ! Returns true if the file does *not* exist on the file system
      BIN :: res
      res = NOT (.exists)
   end

   is_open result(res)
   ! Returns true if the file has been opened
      BIN :: res
      ! inquire(unit=.unit,opened=res)
      .update_system_info
      inquire(file=.name,opened=res)
   end

   is_not_open result(res)
   ! Returns true if the file has *not* been opened
      BIN :: res
      res = NOT (.is_open)
   end

   unit_used result(res)
   ! Returns true if the file unit is in use
      BIN :: res
      .update_system_info
      inquire(unit=.unit,opened=res)
   end

   unit_not_used result(res)
   ! Returns true if the file unit is *not* in use
      BIN :: res
      .update_system_info
      inquire(unit=.unit,opened=res)
      res = NOT res
   end

   next_line_item result (res)
   ! Return the index of the next item to be processed on the line
      INT :: res
      res = .buffer.next_item
   end

   previous_line_item  result (res)
   ! Return the index of the previous item to be processed on the line
      INT :: res
      res = .buffer.item
   end

   last_line_item  result (res)
   ! Return the index of the final item on the line
      INT :: res
      res = .buffer.n_items
   end

   n_line_items result (res)
   ! Return the number of items on the line
      INT :: res
      res = .buffer.n_items
   end

   position result(res)
   ! Return record position of the file
      INT :: res
      res = .record
   end

   line_number result(res)
   ! Return the input file line number which is being processed
      INT :: res
      res = .record
   end

   buffer_str result(res)
   ! Put a string into the buffer
      BSTR :: res
      res = .buffer.buffer_str
   end

   end_of_file result(res)
   ! See if .io_status>1, indicating the end of file has been found. 
   ! This also covers the case when an internal file has ended, where
   ! .io_status==2 (i.e. a soft ending).
   ! If .io_status=2 then an internal file has ended (i.e. a soft ending),
   ! so the current file cursor is moved back one item pre-emptively.
      BIN :: res
      res = .io_status>0
    ! if (.io_status==2) then
    !    .io_status = 0
    !    .move_to_previous_item
    ! end
   end

   reverted(reset) result(res)
   ! See if .io_status==2, indicating an internal file has ended (i.e. a soft ending).
   ! NOTE: Unless the "reset" variable is present and FALSE, the .io_status variable 
   ! is reset by default. So if you want the soft ending to be detectable by later
   ! routines, you must call this routine with "reset=FALSE".
      BIN, optional :: reset
      BIN :: res
      BIN :: reset_io_status
      reset_io_status = TRUE
      if (present(reset)) reset_io_status = reset
      res = .io_status==2
      if (reset_io_status) .io_status = 0
   end

   at_end_of_file result(res)
   ! Read a line into the buffer from the input file and see
   ! if it is at the end of file. This is an explicit test,
   ! not just a viewing of ".io_status".
      INT :: fail
      BIN :: res
      BSTR :: string
      ENSURE(.action=="read","file does not have read status")
      .update_system_info
      fail = 2
      read(unit=.unit,fmt="(a)",end=20,err=10) string
      fail = fail-1
20    fail = fail-1
10    continue
      select case (fail)
        case (0)
          res = FALSE
          backspace(unit=.unit,iostat=.io_status)
          DIE_IF(.io_status>0,"backspace error")
        case (1)
          res = TRUE
        case (2)
          DIE("unknown read error")
      end
      .update_system_info
   end

   labels_used result(res)
   ! Return true if labels are used on matrix output
      BIN :: res
      res = .labels
   end

   labels_not_used result(res)
   ! Return true if labels are not used on matrix output
      BIN :: res
      res = NOT (.labels)
   end

  buffer_not_exhausted result (res)
  ! Return whether the buffer is exhausted
    BIN :: res
      res = .buffer.not_exhausted
  end

! ***************
! System routines
! ***************

  update_system_info
  ! Lets the system know info about the file being read, in case of error.
    tonto.io_file_name   = .name
    tonto.io_file_action = .action
    tonto.io_file_record = .record
    tonto.io_file_buffer = .buffer.buffer_str
    tonto.io_file_pos    = .buffer.pos
  end

end
