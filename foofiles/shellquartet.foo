!-------------------------------------------------------------------------------
!
! SHELLQUARTET : A pair of gaussian SHELLPAIR's.
!
! This is used mainly for integrals, and differs from shell4 in that each
! SHELLPAIR of the quartet contains precalculated integral information.
! (It is up to you to precalculate all this information!)
!
! The electron repulsion integral code uses: 
!
! Lindh, Ryu and Liu, J. Chem. Phys 95(8) 5889-5897.
!
! (c) Dylan Jayatilaka, October 2000
! (c) Daniel Grimwood, March 1998
!
! $Id$
!-------------------------------------------------------------------------------

module SHELLQUARTET

  use TYPES
  use SYSTEM
  use INT
  use IVEC
  use IMAT
  use IMAT3, ONLY:create_,destroy_
  use VEC
  use MAT, ONLY:create_,destroy_
  use MAT3, ONLY:create_,destroy_
  use MAT4, ONLY:create_,destroy_
  use TEXTFILE
  use RYS
  use GAUSSIAN4
  use SHELL1
  use SHELL2
  use SHELLPAIR

  implicit none

#include "macros"
#include "shellquartet.int"

contains

  create [leaky]
  ! Create the object, but not its component pairs.
    PTR :: self
    nullify(self)
    allocate(self)
    ADD_MEM(SHELLQUARTET_SIZE)
    .nullify_ptr_part
  end

  destroy [leaky]
  ! Destroy a shell4 object.
    PTR :: self
    if (associated(self)) then
      .destroy_ptr_part
      DELETE_MEM(SHELLQUARTET_SIZE)
      deallocate(self)
    end
  end

  created result(res)
  ! Returns true if self has been created
    PTR :: self
    BIN :: res
    res = associated(self)
  end

  destroyed result(res)
  ! Returns true if self has *not* been created
    PTR :: self
    BIN :: res
    res = NOT associated(self)
  end

  nullify_ptr_part
  ! Nullify the pointer parts of self
    nullify(.ab)
    nullify(.cd)
  end

  nullify_ab
  ! Nullify the "ab" pointer part
    nullify(.ab)
  end

  nullify_cd
  ! Nullify the "cd" pointer part
    nullify(.cd)
  end

  destroy_ptr_part [leaky]
  ! Destroy the pointer parts of self
    .ab.destroy
    .cd.destroy
  end

  destroy_ab [leaky]
  ! Destroy the "ab" shellpair pointer parts of self
    .ab.destroy
  end

  destroy_cd [leaky]
  ! Destroy the "cd" shellpair pointer parts of self
    .cd.destroy
  end

  set(ab,cd) [leaky]
  ! Copy the shellquartet from "ab" and "cd" shellpair objects
    SHELLPAIR, TARGET :: ab,cd
    .ab => ab
    .cd => cd
  end

  set_pair_ab(ab) [leaky]
  ! Set only the "ab" shellpair into the shellquartet
    SHELLPAIR, TARGET :: ab
    .ab => ab
  end

  set_pair_cd(cd) [leaky]
  ! Set only the "cd" shellpair into the shellquartet
    SHELLPAIR, TARGET :: cd
    .cd => cd
  end

  unnormalize
  ! Unnormalize each shell in this shell quartet
    .ab.unnormalize
    .cd.unnormalize
  end

  max_k_ab result(res) [private]
  ! Returns the maximum value of the contraction coefficient prefactor
  ! for the "ab" shell
    DBL :: res
    res = maxval(.ab.cc_prefactor)
  end

  max_k_cd result(res) [private]
  ! Returns the maximum value of the contraction coefficient prefactor
  ! for the "cd" shell
    DBL :: res
    res = maxval(.cd.cc_prefactor)
  end

  skip_ERI result (res)
  ! Whether the ERI block will be less than a cutoff value.
    BIN :: res
    DBL :: max_ab,max_cd
    max_ab = .max_k_ab
    max_cd = .max_k_cd
    if (max_ab*max_cd > SHELL4_ERI_CUTOFF) then
      res = FALSE
    else
      res = TRUE
    end
  end

!  ****************************
!  Roland Lindh-style integrals
!  ****************************

  get_ERI(abcd)
  ! The main routine to produce the block (ab|cd)
  ! (uses the transfer equation to make (ab|cd) from (es|fs))
  ! The routines are now all specialised, they will break if you use the wrong
  ! one.  Best to just use this main routine.
    IN :: self
    MAT4, OUT :: abcd
    INT :: n_e,n_f,opt,maxl
    maxl = max(.ab.l_max,.cd.l_max)
    n_e = .ab.l_sum
    n_f = .cd.l_sum
    select case (maxl)
      case (0)                                              ! max is s function
        .make_ssss(abcd)
      case (1)                                              ! max is p function
        if (n_e==0) opt = 1
        if (n_e==1) opt = 4
        if (n_e==2) opt = 7
        if (n_f==1) opt = opt + 1
        if (n_f==2) opt = opt + 2
        select case (opt)
          case (9); .make_pppp(abcd)
          case (8); .make_ppps(abcd)
          case (7); .make_ppss(abcd)
          case (6); .make_pspp(abcd)
          case (5); .make_psps(abcd)
          case (4); .make_psss(abcd)
          case (3); .make_sspp(abcd)
          case (2); .make_ssps(abcd)
        end
      case default                                          ! general
        if (n_e == 0) then;      .make_sscd(abcd)
        else if (n_f == 0) then; .make_abss(abcd)
        else;                    .make_abcd(abcd)
        end
    end
  end

  make_abcd(abcd) [private]
  ! Makes the (ab|cd) integrals, summed over the primitives
  ! This is the general purpose routine.
    IN :: self
    MAT4, OUT :: abcd
    MAT3* :: escd
    MAT* :: esfs
    INT :: n_e,n_f,eub,fub
    nullify(esfs)
    nullify(escd)
    n_e = .ab.l_sum
    n_f = .cd.l_sum
    eub = n_e.n_comp_sum - (.ab.l_max-1).n_comp_sum
    fub = n_f.n_comp_sum - (.cd.l_max-1).n_comp_sum
    esfs.create(eub,fub)
    .make_esfs(esfs)
    escd.create(eub, .cd.a.n_comp, .cd.b.n_comp)
    .transfer(esfs,escd)
    .transfer(escd,abcd)
    escd.destroy
    esfs.destroy
    .to_normalize(abcd)
  end

  make_esfs(esfs) [private]
  ! Makes the initial (es|fs) integrals, summed over the primitives
    IN :: self
    MAT, OUT:: esfs
    MAT4* :: Ix,Iy,Iz
    INT :: nroots,dim1,dim2,n_cc
    DBL :: norma,normb,norm,zinv,rho,einv,b_r2ab,rho_zinv,rho_einv
    dim1 = .ab.l_sum + 1
    dim2 = .cd.l_sum + 1
    nroots = (dim1+dim2)/2
    n_cc = .ab.n_gaussian_pairs * .cd.n_gaussian_pairs
    Ix.create(nroots,n_cc,dim1,dim2)
    Iy.create(nroots,n_cc,dim1,dim2)
    Iz.create(nroots,n_cc,dim1,dim2)
    .form_2d_ints(Ix,Iy,Iz)
    .form_esfs(esfs,Ix,Iy,Iz)
    Iz.destroy
    Iy.destroy
    Ix.destroy
  end

  form_2d_ints(Ixa,Iya,Iza) [private]
  ! Forms the two dimentional integrals
    IN :: self
    MAT4, target, OUT :: Ixa,Iya,Iza
    MAT* :: Ix,Iy,Iz
    INT :: n_e,n_f,dim1,dim2,nroots,ab,cd,i
    DBL :: zeta,zinv,eta,einv,ab_prefac,cd_prefac
    DBL :: norm,xx,rho,rho_zinv,rho_einv
    DBL :: Px,Py,Pz,Qx,Qy,Qz,QPx,QPy,QPz,QCx,QCy,QCz,PAx,PAy,PAz
    INT :: e,f,e1,f1,fp1,ep1,n
    DBL :: t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb,f1_cf,e1_ce
    DBL :: ce,cf,bb,ce1
    DBL :: Ix12,Iy12,Iz12,Ix21,Iy21,Iz21
    DBL :: Ix1f1,Iy1f1,Iz1f1,Ix1f,Iy1f,Iz1f,Ix1fp1,Iy1fp1,Iz1fp1
    DBL :: Ix2f1,Iy2f1,Iz2f1,Ix2f,Iy2f,Iz2f,Ix2fp1,Iy2fp1,Iz2fp1
    DBL :: Ix22n,Iy22n,Iz22n
    DBL :: Ixe11,Iye11,Ize11,Ixe1,Iye1,Ize1,Ixep11,Iyep11,Izep11
    DBL :: Ixef,Iyef,Izef,Ixef1,Iyef1,Izef1
    RYS* :: rys
    n_e = .ab.l_sum
    n_f = .cd.l_sum
    dim1  = n_e + 1
    dim2  = n_f + 1
    nroots = (dim1+dim2)/2
    rys.create(nroots)
    i = 0
    do ab = 1,.ab.n_gaussian_pairs
      zeta = .ab.exponent_sum(ab)
      zinv = .ab.exponent_inv(ab)
      ab_prefac = .ab.cc_prefactor(ab)
      Px  = .ab.pair_center(1,ab)
      Py  = .ab.pair_center(2,ab)
      Pz  = .ab.pair_center(3,ab)
      PAx = .ab.center_diff(1,ab)
      PAy = .ab.center_diff(2,ab)
      PAz = .ab.center_diff(3,ab)
      do cd = 1,.cd.n_gaussian_pairs
        i = i + 1                                            ! contraction quartet index
        eta  = .cd.exponent_sum(cd)
        einv = .cd.exponent_inv(cd)
        cd_prefac = .cd.cc_prefactor(cd)
        Qx  = .cd.pair_center(1,cd)
        Qy  = .cd.pair_center(2,cd)
        Qz  = .cd.pair_center(3,cd)
        QCx = .cd.center_diff(1,cd)
        QCy = .cd.center_diff(2,cd)
        QCz = .cd.center_diff(3,cd)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        rho_zinv = rho * zinv
        rho_einv = rho * einv
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        rys.w(:) = rys.w(:) * norm
        half_zinv = HALF * zinv
        !
        if (n_f/=1) then                                     ! ab|cd integrals
          half_einv = HALF * einv
          do n=1,nroots
            Ix => Ixa(n,i,:,:)
            Iy => Iya(n,i,:,:)
            Iz => Iza(n,i,:,:)
            Ix(1,1) = ONE
            Iy(1,1) = ONE
            Iz(1,1) = ONE
            t2    = rys.r(n)
            t2_rz = t2 * rho_zinv
            t2_re = t2 * rho_einv
            bb    = t2_rz * half_einv
            cf    = (ONE - t2_re) * half_einv
            ce    = (ONE - t2_rz) * half_zinv
            Ix12 = QCx - t2_re * QPx
            Iy12 = QCy - t2_re * QPy
            Iz12 = QCz - t2_re * QPz
            Ix21 = PAx + t2_rz * QPx
            Iy21 = PAy + t2_rz * QPy
            Iz21 = PAz + t2_rz * QPz
            Ix22n = Ix12 * Ix21 + bb
            Iy22n = Iy12 * Iy21 + bb
            Iz22n = Iz12 * Iz21 + bb
            Ix(1,2) = Ix12; Iy(1,2) = Iy12; Iz(1,2) = Iz12
            Ix(2,1) = Ix21; Iy(2,1) = Iy21; Iz(2,1) = Iz21
            Ix(2,2) = Ix22n; Iy(2,2) = Iy22n; Iz(2,2) = Iz22n
            Ix1f  = Ix12; Iy1f  = Iy12; Iz1f  = Iz12
            Ix1f1 = ONE;   Iy1f1 = ONE;   Iz1f1 = ONE
            do f = 2,n_f
              fp1 = f + 1
              f1_cf = (f-1)*cf
              Ix1fp1 = Ix12 * Ix1f + f1_cf * Ix1f1
              Iy1fp1 = Iy12 * Iy1f + f1_cf * Iy1f1
              Iz1fp1 = Iz12 * Iz1f + f1_cf * Iz1f1
              Ix(1,fp1) = Ix1fp1; Iy(1,fp1) = Iy1fp1; Iz(1,fp1) = Iz1fp1
              Ix1f1 = Ix1f;   Iy1f1 = Iy1f;   Iz1f1 = Iz1f
              Ix1f  = Ix1fp1; Iy1f  = Iy1fp1; Iz1f  = Iz1fp1
            end
            Ixe1  = Ix21; Iye1  = Iy21; Ize1  = Iz21
            Ixe11 = ONE;   Iye11 = ONE;   Ize11 = ONE
            do e = 2, n_e
              ep1 = e + 1
              e1_ce = (e-1) * ce
              Ixep11 = Ix21 * Ixe1 + e1_ce * Ixe11
              Iyep11 = Iy21 * Iye1 + e1_ce * Iye11
              Izep11 = Iz21 * Ize1 + e1_ce * Ize11
              Ix(ep1,1) = Ixep11; Iy(ep1,1) = Iyep11; Iz(ep1,1) = Izep11
              Ixe11 = Ixe1;   Iye11 = Iye1;   Ize11 = Ize1
              Ixe1  = Ixep11; Iye1  = Iyep11; Ize1  = Izep11
            end
            Ix2f  = Ix22n; Iy2f  = Iy22n; Iz2f  = Iz22n
            Ix2f1 = Ix21; Iy2f1 = Iy21; Iz2f1 = Iz21
            do f=2,n_f
              fp1 = f + 1
              f1_cf = (f-1)*cf
              Ix2fp1 = Ix12 * Ix2f + f1_cf * Ix2f1 + bb * Ix(1,f)
              Iy2fp1 = Iy12 * Iy2f + f1_cf * Iy2f1 + bb * Iy(1,f)
              Iz2fp1 = Iz12 * Iz2f + f1_cf * Iz2f1 + bb * Iz(1,f)
              Ix(2,fp1) = Ix2fp1; Iy(2,fp1) = Iy2fp1; Iz(2,fp1) = Iz2fp1
              Ix2f1 = Ix2f;   Iy2f1 = Iy2f;   Iz2f1 = Iz2f
              Ix2f  = Ix2fp1; Iy2f  = Iy2fp1; Iz2f  = Iz2fp1
            end
            do e = 2, n_e
              e1  =e - 1
              ep1 =e + 1
              ce1 =e1 * ce
              Ixef1 = Ix(e,1); Iyef1 = Iy(e,1); Izef1 = Iz(e,1)
              do f=2, n_f+1
                f1_bb = (f-1)*bb
                Ixef  = Ix(e,f); Iyef  = Iy(e,f); Izef  = Iz(e,f)
                Ix(ep1,f) = Ix21*Ixef + ce1*Ix(e1,f) + f1_bb*Ixef1
                Iy(ep1,f) = Iy21*Iyef + ce1*Iy(e1,f) + f1_bb*Iyef1
                Iz(ep1,f) = Iz21*Izef + ce1*Iz(e1,f) + f1_bb*Izef1
                Ixef1 = Ixef;   Iyef1 = Iyef;   Izef1 = Izef
              end
            end
            Iz(:,:) = rys.w(n) * Iz(:,:)    ! Merge the weights into Iz.
          end
        else                                              ! ab|ps integrals
          do n=1,nroots
            Ix => Ixa(n,i,:,:)
            Iy => Iya(n,i,:,:)
            Iz => Iza(n,i,:,:)
            Ix(1,1) = ONE
            Iy(1,1) = ONE
            Iz(1,1) = ONE
            t2    = rys.r(n)
            t2_rz = t2 * rho_zinv
            t2_re = t2 * rho_einv
            bb    = t2_re * half_zinv
            ce    = (ONE - t2_rz) * half_zinv
            Ix12 = QCx - t2_re * QPx
            Iy12 = QCy - t2_re * QPy
            Iz12 = QCz - t2_re * QPz
            Ix21 = PAx + t2_rz * QPx
            Iy21 = PAy + t2_rz * QPy
            Iz21 = PAz + t2_rz * QPz
            Ix(1,2) = Ix12; Iy(1,2) = Iy12; Iz(1,2) = Iz12
            Ix(2,1) = Ix21; Iy(2,1) = Iy21; Iz(2,1) = Iz21
            Ix(2,2) = Ix12 * Ix21 + bb
            Iy(2,2) = Iy12 * Iy21 + bb
            Iz(2,2) = Iz12 * Iz21 + bb
            do e = 2, n_e
              e1  =e - 1
              ep1 =e + 1
              ce1 = e1 * ce
              Ix(ep1,1) = Ix21 * Ix(e,1) + ce1 * Ix(e1,1)
              Iy(ep1,1) = Iy21 * Iy(e,1) + ce1 * Iy(e1,1)
              Iz(ep1,1) = Iz21 * Iz(e,1) + ce1 * Iz(e1,1)
              do f1=1, n_f
                f = f1 + 1
                f1_bb = f1*bb
                Ix(ep1,f) = Ix21*Ix(e,f) + ce1*Ix(e1,f) + f1_bb*Ix(e,f1)
                Iy(ep1,f) = Iy21*Iy(e,f) + ce1*Iy(e1,f) + f1_bb*Iy(e,f1)
                Iz(ep1,f) = Iz21*Iz(e,f) + ce1*Iz(e1,f) + f1_bb*Iz(e,f1)
              end
            end
            Iz(:,:) = rys.w(n) * Iz(:,:)    ! Merge the weights into Iz.
          end
        end
      end     ! end loops over gaussian contractions
    end
    rys.destroy
  end

  form_esfs(esfs,Ix,Iy,Iz) [private]
  ! Forms (es|fs) from the two dimensional integrals for a single
  ! set of primitives
    IN :: self
    MAT, OUT :: esfs
    MAT4, IN :: Ix,Iy,Iz
    INT :: nroots,n_cc,dime,dimf,n_e,n_f,eub,fub
    IVEC* :: e_x,e_y,e_z,f_x,f_y,f_z
    IMAT* :: e_powers,f_powers,indexe,indexf
    INT :: e,f,zf,yf,xf,ze,ye,xe,dime1,dimf1,iie,iif,opt
    MAT4* :: Ief
    MAT3* :: I1
    nroots = size(Ix,1)
    n_cc   = size(Ix,2)
    dime   = size(Ix,3)
    dimf   = size(Ix,4)
    eub = size(esfs,1)
    fub = size(esfs,2)
    n_e = .ab.l_sum
    n_f = .cd.l_sum
    e_powers.create(eub,3)
    f_powers.create(fub,3)
    e_x => e_powers(:,1); e_y => e_powers(:,2); e_z => e_powers(:,3)
    f_x => f_powers(:,1); f_y => f_powers(:,2); f_z => f_powers(:,3)
    .ab.l_max.make_gaussian_xyz_indices(e_x,e_y,e_z,n_e)
    .cd.l_max.make_gaussian_xyz_indices(f_x,f_y,f_z,n_f)
    opt = 0
    if (.ab.l_min > 1) opt = opt + 1
    if (.cd.l_min > 1) opt = opt + 2
    select case (opt)
      case (0)
        ! This version does not use the reduced multiplication scheme.
        do f=1,fub
          xf = f_x(f);    yf = f_y(f);    zf = f_z(f)
          do e=1,eub
            xe = e_x(e);    ye = e_y(e);    ze = e_z(e)
            esfs(e,f) = sum(Ix(:,:,xe,xf) * Iy(:,:,ye,yf) * Iz(:,:,ze,zf))
          end
        end
      case (1)
        ! Apply the reduced multiplication scheme to merge the Iy and Iz 2d
        ! integrals into a single matrix (upper triangle).
        dime1 = dime+1
        I1.create(nroots,n_cc,dime*dime1/2)
        indexe.create(dime,dime) ! map ye,ze to iie
        iie = 0
        do ze=1,dime
          do ye=1,dime1-ze
            iie = iie + 1
            indexe(ye,ze) = iie
          end
        end
        do f=1,fub
          xf = f_x(f);    yf = f_y(f);    zf = f_z(f)
          iie = 0
          do ze=1,dime
            do ye=1,dime1-ze
              iie = iie + 1
              I1(:,:,iie) = Iy(:,:,ye,yf) * Iz(:,:,ze,zf)
            end
          end
          ! Now add in the Ix 2d integrals and sum over nroots
          do e=1,eub
            iie = indexe(e_y(e),e_z(e))
            esfs(e,f) = sum(Ix(:,:,e_x(e),xf) * I1(:,:,iie))
          end
        end
        indexe.destroy
        I1.destroy
      case (2)
        dimf1 = dimf+1
        I1.create(nroots,n_cc,dimf*dimf1/2)
        indexf.create(dimf,dimf)
        iif = 0
        do zf=1,dimf
          do yf=1,dimf1-zf
            iif = iif + 1
            indexf(yf,zf) = iif
          end
        end
        do e=1,eub
          xe = e_x(e);    ye = e_y(e);    ze = e_z(e)
          iif = 0
          do zf=1,dimf
            do yf=1,dimf1-zf
              iif = iif + 1
              I1(:,:,iif) = Iy(:,:,ye,yf) * Iz(:,:,ze,zf)
            end
          end
          ! Now add in the Ix 2d integrals and sum over nroots
          do f=1,fub
            iif = indexf(f_y(f),f_z(f))
            esfs(e,f) = sum(Ix(:,:,xe,f_x(f)) * I1(:,:,iif))
          end
        end
        indexf.destroy
        I1.destroy
      case (3)
        dime1=dime+1
        dimf1=dimf+1
        Ief.create(nroots,n_cc,dime*dime1/2,dimf*dimf1/2)
        indexf.create(dimf,dimf) ! map yf,zf to iif
        indexe.create(dime,dime) ! map ye,ze to iie
        iie = 0
        do ze=1,dime
          do ye=1,dime1-ze
            iie = iie + 1
            indexe(ye,ze) = iie
          end
        end
        ! Apply reduced multiplication scheme to Iy and Iz, store in triangle.
        iif = 0
        do zf=1,dimf
          do yf=1,dimf1-zf
            iif = iif + 1
            indexf(yf,zf) = iif
            iie = 0
            do ze=1,dime
              do ye=1,dime1-ze
                iie = iie + 1
                Ief(:,:,iie,iif) = Iy(:,:,ye,yf) * Iz(:,:,ze,zf)
              end
            end
          end
        end
        ! Now add in the Ix 2d integrals and sum over nroots
        do f=1,fub
          xf = f_x(f)
          iif = indexf(f_y(f),f_z(f))
          do e=1,eub
            iie = indexe(e_y(e),e_z(e))
            esfs(e,f) = sum(Ix(:,:,e_x(e),xf) * Ief(:,:,iie,iif))
          end
        end
        Ief.destroy
        indexf.destroy
        indexe.destroy
    end
    e_powers.destroy
    f_powers.destroy
  end

  make_pppp(abcd) [private]
  ! Make the (pp|pp) integrals, summed over the primitives
    IN :: self
    MAT4, target :: abcd
    MAT* :: Iab
    RYS* :: rys
    INT :: ab,cd,nroots,n
    DBL :: zeta,eta,xx,norm,zinv,rho,einv,rho_zinv,rho_einv
    DBL :: ab_prefac,cd_prefac,Px,Py,Pz,Qx,Qy,Qz
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,QCx,QCy,QCz
    DBL :: ce,cf,bb,bb_2,t2,t2_rz,t2_re,w,half_zinv,half_einv
    DBL :: Ix12,Ix13,Ix21,Ix22,Ix23,Ix31,Ix32,Ix33
    DBL :: Iy12,Iy13,Iy21,Iy22,Iy23,Iy31,Iy32,Iy33
    DBL :: Iz12,Iz13,Iz21,Iz22,Iz23,Iz31,Iz32,Iz33
    DBL :: px__px_,py__px_,pz__px_
    DBL :: px__py_,py__py_,pz__py_
    DBL :: px__pz_,py__pz_,pz__pz_
    DBL :: px__dxx,py__dxx,pz__dxx
    DBL :: px__dyy,py__dyy,pz__dyy
    DBL :: px__dzz,py__dzz,pz__dzz
    DBL :: px__dxy,py__dxy,pz__dxy
    DBL :: px__dxz,py__dxz,pz__dxz
    DBL :: px__dyz,py__dyz,pz__dyz
    DBL :: dxx_px_,dyy_px_,dzz_px_,dxy_px_,dxz_px_,dyz_px_
    DBL :: dxx_py_,dyy_py_,dzz_py_,dxy_py_,dxz_py_,dyz_py_
    DBL :: dxx_pz_,dyy_pz_,dzz_pz_,dxy_pz_,dxz_pz_,dyz_pz_
    DBL :: dxx_dxx,dyy_dxx,dzz_dxx,dxy_dxx,dxz_dxx,dyz_dxx
    DBL :: dxx_dyy,dyy_dyy,dzz_dyy,dxy_dyy,dxz_dyy,dyz_dyy
    DBL :: dxx_dzz,dyy_dzz,dzz_dzz,dxy_dzz,dxz_dzz,dyz_dzz
    DBL :: dxx_dxy,dyy_dxy,dzz_dxy,dxy_dxy,dxz_dxy,dyz_dxy
    DBL :: dxx_dxz,dyy_dxz,dzz_dxz,dxy_dxz,dxz_dxz,dyz_dxz
    DBL :: dxx_dyz,dyy_dyz,dzz_dyz,dxy_dyz,dxz_dyz,dyz_dyz
    DBL :: Iy12_Iz21,Iy12_Iz12,Iy13_Iz21,Iy21_Iz21,Iy21_Iz22
    DBL :: Iy21_Iz12,Iy31_Iz12,Iy21_Iz13,Iy12_Iz31,Iy12_Iz22
    DBL :: Iy22_Iz12,Iy22_Iz21
    DBL :: Iy12_w, Iy21_w, Iy22_w, Iy13_w, Iy31_w, Iy32_w, Iy23_w
    DBL :: px_,py_,pz_,dxx_,dyy_,dzz_,dxy_,dxz_,dyz_
    DBL :: BAx,BAy,BAz,DCx,DCy,DCz
    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    dxx_px_ = ZERO; dyy_px_ = ZERO; dzz_px_ = ZERO
    dxy_px_ = ZERO; dxz_px_ = ZERO; dyz_px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    dxx_py_ = ZERO; dyy_py_ = ZERO; dzz_py_ = ZERO
    dxy_py_ = ZERO; dxz_py_ = ZERO; dyz_py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    dxx_pz_ = ZERO; dyy_pz_ = ZERO; dzz_pz_ = ZERO
    dxy_pz_ = ZERO; dxz_pz_ = ZERO; dyz_pz_ = ZERO
    px__dxx = ZERO; py__dxx = ZERO; pz__dxx = ZERO
    dxx_dxx = ZERO; dyy_dxx = ZERO; dzz_dxx = ZERO
    dxy_dxx = ZERO; dxz_dxx = ZERO; dyz_dxx = ZERO
    px__dyy = ZERO; py__dyy = ZERO; pz__dyy = ZERO
    dxx_dyy = ZERO; dyy_dyy = ZERO; dzz_dyy = ZERO
    dxy_dyy = ZERO; dxz_dyy = ZERO; dyz_dyy = ZERO
    px__dzz = ZERO; py__dzz = ZERO; pz__dzz = ZERO
    dxx_dzz = ZERO; dyy_dzz = ZERO; dzz_dzz = ZERO
    dxy_dzz = ZERO; dxz_dzz = ZERO; dyz_dzz = ZERO
    px__dxy = ZERO; py__dxy = ZERO; pz__dxy = ZERO
    dxx_dxy = ZERO; dyy_dxy = ZERO; dzz_dxy = ZERO
    dxy_dxy = ZERO; dxz_dxy = ZERO; dyz_dxy = ZERO
    px__dxz = ZERO; py__dxz = ZERO; pz__dxz = ZERO
    dxx_dxz = ZERO; dyy_dxz = ZERO; dzz_dxz = ZERO
    dxy_dxz = ZERO; dxz_dxz = ZERO; dyz_dxz = ZERO
    px__dyz = ZERO; py__dyz = ZERO; pz__dyz = ZERO
    dxx_dyz = ZERO; dyy_dyz = ZERO; dzz_dyz = ZERO
    dxy_dyy = ZERO; dxz_dyy = ZERO; dyz_dyy = ZERO
    dxy_dyz = ZERO; dxz_dyz = ZERO; dyz_dyz = ZERO
    nroots = 3
    rys.create(nroots)
    do ab = 1,.ab.n_gaussian_pairs
      zeta = .ab.exponent_sum(ab)
      zinv = .ab.exponent_inv(ab)
      ab_prefac = .ab.cc_prefactor(ab)
      Px  = .ab.pair_center(1,ab)
      Py  = .ab.pair_center(2,ab)
      Pz  = .ab.pair_center(3,ab)
      PAx = .ab.center_diff(1,ab)
      PAy = .ab.center_diff(2,ab)
      PAz = .ab.center_diff(3,ab)
      do cd = 1,.cd.n_gaussian_pairs
        eta  = .cd.exponent_sum(cd)
        einv = .cd.exponent_inv(cd)
        cd_prefac = .cd.cc_prefactor(cd)
        Qx  = .cd.pair_center(1,cd)
        Qy  = .cd.pair_center(2,cd)
        Qz  = .cd.pair_center(3,cd)
        QCx = .cd.center_diff(1,cd)
        QCy = .cd.center_diff(2,cd)
        QCz = .cd.center_diff(3,cd)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        rho_zinv = rho * zinv
        rho_einv = rho * einv
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        half_zinv = HALF * zinv
        half_einv = HALF * einv
        do n=1,nroots
          t2    = rys.r(n)
          w     = rys.w(n) * norm
          t2_rz = t2 * rho_zinv
          t2_re = t2 * rho_einv
          bb    = t2_rz * half_einv
          bb_2  = 2*bb
          cf    = (ONE - t2_re) * half_einv
          ce    = (ONE - t2_rz) * half_zinv
          Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
          Iy12 = QCy - t2_re * QPy
          Iz12 = QCz - t2_re * QPz
          Ix21 = PAx + t2_rz * QPx
          Iy21 = PAy + t2_rz * QPy
          Iz21 = PAz + t2_rz * QPz
          Ix22 = Ix12 * Ix21 + bb
          Iy22 = Iy12 * Iy21 + bb
          Iz22 = Iz12 * Iz21 + bb
          Ix13 = Ix12 * Ix12 + cf
          Iy13 = Iy12 * Iy12 + cf
          Iz13 = Iz12 * Iz12 + cf
          Ix31 = Ix21 * Ix21 + ce
          Iy31 = Iy21 * Iy21 + ce
          Iz31 = Iz21 * Iz21 + ce
          Ix23 = Ix12 * Ix22 + cf * Ix21 + bb * Ix12
          Iy23 = Iy12 * Iy22 + cf * Iy21 + bb * Iy12
          Iz23 = Iz12 * Iz22 + cf * Iz21 + bb * Iz12
          Ix32 = Ix21 * Ix22 + ce * Ix12 + bb * Ix21
          Iy32 = Iy21 * Iy22 + ce * Iy12 + bb * Iy21
          Iz32 = Iz21 * Iz22 + ce * Iz12 + bb * Iz21
          Ix33 = Ix21 * Ix23 + ce * Ix13 + bb_2 * Ix22
          Iy33 = Iy21 * Iy23 + ce * Iy13 + bb_2 * Iy22
          Iz33 = Iz21 * Iz23 + ce * Iz13 + bb_2 * Iz22
          !
          Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
          Iz31 = Iz31 * w
          Iz12 = Iz12 * w
          Iz22 = Iz22 * w
          Iz32 = Iz32 * w
          Iz13 = Iz13 * w
          Iz23 = Iz23 * w
          Iz33 = Iz33 * w
          Iy12_Iz21 = Iy12 * Iz21
          Iy12_Iz12 = Iy12 * Iz12
          Iy12_Iz22 = Iy12 * Iz22
          Iy12_Iz31 = Iy12 * Iz31
          Iy13_Iz21 = Iy13 * Iz21
          Iy21_Iz21 = Iy21 * Iz21
          Iy21_Iz22 = Iy21 * Iz22
          Iy21_Iz12 = Iy21 * Iz12
          Iy21_Iz13 = Iy21 * Iz13
          Iy31_Iz12 = Iy31 * Iz12
          Iy22_Iz12 = Iy22 * Iz12
          Iy22_Iz21 = Iy22 * Iz21
          Iy12_w    = Iy12 * w
          Iy21_w    = Iy21 * w
          Iy22_w    = Iy22 * w
          Iy13_w    = Iy13 * w
          Iy31_w    = Iy31 * w
          Iy32_w    = Iy32 * w
          Iy23_w    = Iy23 * w
          !
          px__px_ = px__px_ + Ix22 * w     !  combine 2d ints.
          py__px_ = py__px_ + Ix12 * Iy21_w
          pz__px_ = pz__px_ + Ix12 * Iz21
          dxx_px_ = dxx_px_ + Ix32 * w
          dyy_px_ = dyy_px_ + Ix12 * Iy31_w
          dzz_px_ = dzz_px_ + Ix12 * Iz31
          dxy_px_ = dxy_px_ + Ix22 * Iy21_w
          dxz_px_ = dxz_px_ + Ix22 * Iz21
          dyz_px_ = dyz_px_ + Ix12 * Iy21_Iz21
          px__py_ = px__py_ + Ix21 * Iy12_w
          py__py_ = py__py_ + Iy22_w
          pz__py_ = pz__py_ + Iy12_Iz21
          dxx_py_ = dxx_py_ + Ix31 * Iy12_w
          dyy_py_ = dyy_py_ + Iy32_w
          dzz_py_ = dzz_py_ + Iy12_Iz31
          dxy_py_ = dxy_py_ + Ix21 * Iy22_w
          dxz_py_ = dxz_py_ + Ix21 * Iy12_Iz21
          dyz_py_ = dyz_py_ + Iy22_Iz21
          px__pz_ = px__pz_ + Ix21 * Iz12
          py__pz_ = py__pz_ + Iy21_Iz12
          pz__pz_ = pz__pz_ + Iz22
          dxx_pz_ = dxx_pz_ + Ix31 * Iz12
          dyy_pz_ = dyy_pz_ + Iy31_Iz12
          dzz_pz_ = dzz_pz_ + Iz32
          dxy_pz_ = dxy_pz_ + Ix21 * Iy21_Iz12
          dxz_pz_ = dxz_pz_ + Ix21 * Iz22
          dyz_pz_ = dyz_pz_ + Iy21_Iz22
          px__dxx = px__dxx + Ix23 * w
          py__dxx = py__dxx + Ix13 * Iy21_w
          pz__dxx = pz__dxx + Ix13 * Iz21
          dxx_dxx = dxx_dxx + Ix33 * w
          dyy_dxx = dyy_dxx + Ix13 * Iy31_w
          dzz_dxx = dzz_dxx + Ix13 * Iz31
          dxy_dxx = dxy_dxx + Ix23 * Iy21_w
          dxz_dxx = dxz_dxx + Ix23 * Iz21
          dyz_dxx = dyz_dxx + Ix13 * Iy21_Iz21
          px__dyy = px__dyy + Ix21 * Iy13_w
          py__dyy = py__dyy + Iy23_w
          pz__dyy = pz__dyy + Iy13_Iz21
          dxx_dyy = dxx_dyy + Ix31 * Iy13_w
          dyy_dyy = dyy_dyy + Iy33 * w
          dzz_dyy = dzz_dyy + Iy13 * Iz31
          dxy_dyy = dxy_dyy + Ix21 * Iy23_w
          dxz_dyy = dxz_dyy + Ix21 * Iy13_Iz21
          dyz_dyy = dyz_dyy + Iy23 * Iz21
          px__dzz = px__dzz + Ix21 * Iz13
          py__dzz = py__dzz + Iy21_Iz13
          pz__dzz = pz__dzz + Iz23
          dxx_dzz = dxx_dzz + Ix31 * Iz13
          dyy_dzz = dyy_dzz + Iy31 * Iz13
          dzz_dzz = dzz_dzz + Iz33
          dxy_dzz = dxy_dzz + Ix21 * Iy21_Iz13
          dxz_dzz = dxz_dzz + Ix21 * Iz23
          dyz_dzz = dyz_dzz + Iy21 * Iz23
          px__dxy = px__dxy + Ix22 * Iy12_w
          py__dxy = py__dxy + Ix12 * Iy22_w
          pz__dxy = pz__dxy + Ix12 * Iy12_Iz21
          dxx_dxy = dxx_dxy + Ix32 * Iy12_w
          dyy_dxy = dyy_dxy + Ix12 * Iy32_w
          dzz_dxy = dzz_dxy + Ix12 * Iy12_Iz31
          dxy_dxy = dxy_dxy + Ix22 * Iy22_w
          dxz_dxy = dxz_dxy + Ix22 * Iy12_Iz21
          dyz_dxy = dyz_dxy + Ix12 * Iy22_Iz21
          px__dxz = px__dxz + Ix22 * Iz12
          py__dxz = py__dxz + Ix12 * Iy21_Iz12
          pz__dxz = pz__dxz + Ix12 * Iz22
          dxx_dxz = dxx_dxz + Ix32 * Iz12
          dyy_dxz = dyy_dxz + Ix12 * Iy31_Iz12
          dzz_dxz = dzz_dxz + Ix12 * Iz32
          dxy_dxz = dxy_dxz + Ix22 * Iy21_Iz12
          dxz_dxz = dxz_dxz + Ix22 * Iz22
          dyz_dxz = dyz_dxz + Ix12 * Iy21_Iz22
          px__dyz = px__dyz + Ix21 * Iy12_Iz12
          py__dyz = py__dyz + Iy22_Iz12
          pz__dyz = pz__dyz + Iy12_Iz22
          dxx_dyz = dxx_dyz + Ix31 * Iy12_Iz12
          dyy_dyz = dyy_dyz + Iy32 * Iz12
          dzz_dyz = dzz_dyz + Iy12 * Iz32
          dxy_dyz = dxy_dyz + Ix21 * Iy22_Iz12
          dxz_dyz = dxz_dyz + Ix21 * Iy12_Iz22
          dyz_dyz = dyz_dyz + Iy22 * Iz22
        end
      end
    end
    rys.destroy
    ! Transfer equations
    BAx = .ab.b.pos(1) - .ab.a.pos(1)
    BAy = .ab.b.pos(2) - .ab.a.pos(2)
    BAz = .ab.b.pos(3) - .ab.a.pos(3)
    DCx = .cd.b.pos(1) - .cd.a.pos(1)
    DCy = .cd.b.pos(2) - .cd.a.pos(2)
    DCz = .cd.b.pos(3) - .cd.a.pos(3)
    px_  = px__dxx + DCx * px__px_
    py_  = py__dxx + DCx * py__px_
    pz_  = pz__dxx + DCx * pz__px_
    dxx_ = dxx_dxx + DCx * dxx_px_
    dyy_ = dyy_dxx + DCx * dyy_px_
    dzz_ = dzz_dxx + DCx * dzz_px_
    dxy_ = dxy_dxx + DCx * dxy_px_
    dxz_ = dxz_dxx + DCx * dxz_px_
    dyz_ = dyz_dxx + DCx * dyz_px_
    Iab => abcd(:,:,1,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
    !
    px_  = px__dxy + DCy * px__px_
    py_  = py__dxy + DCy * py__px_
    pz_  = pz__dxy + DCy * pz__px_
    dxx_ = dxx_dxy + DCy * dxx_px_
    dyy_ = dyy_dxy + DCy * dyy_px_
    dzz_ = dzz_dxy + DCy * dzz_px_
    dxy_ = dxy_dxy + DCy * dxy_px_
    dxz_ = dxz_dxy + DCy * dxz_px_
    dyz_ = dyz_dxy + DCy * dyz_px_
    Iab => abcd(:,:,2,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
    !
    px_  = px__dxz + DCz * px__px_
    py_  = py__dxz + DCz * py__px_
    pz_  = pz__dxz + DCz * pz__px_
    dxx_ = dxx_dxz + DCz * dxx_px_
    dyy_ = dyy_dxz + DCz * dyy_px_
    dzz_ = dzz_dxz + DCz * dzz_px_
    dxy_ = dxy_dxz + DCz * dxy_px_
    dxz_ = dxz_dxz + DCz * dxz_px_
    dyz_ = dyz_dxz + DCz * dyz_px_
    Iab => abcd(:,:,3,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
    !
    px_  = px__dxy + DCx * px__py_
    py_  = py__dxy + DCx * py__py_
    pz_  = pz__dxy + DCx * pz__py_
    dxx_ = dxx_dxy + DCx * dxx_py_
    dyy_ = dyy_dxy + DCx * dyy_py_
    dzz_ = dzz_dxy + DCx * dzz_py_
    dxy_ = dxy_dxy + DCx * dxy_py_
    dxz_ = dxz_dxy + DCx * dxz_py_
    dyz_ = dyz_dxy + DCx * dyz_py_
    Iab => abcd(:,:,1,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
    !
    px_  = px__dyy + DCy * px__py_
    py_  = py__dyy + DCy * py__py_
    pz_  = pz__dyy + DCy * pz__py_
    dxx_ = dxx_dyy + DCy * dxx_py_
    dyy_ = dyy_dyy + DCy * dyy_py_
    dzz_ = dzz_dyy + DCy * dzz_py_
    dxy_ = dxy_dyy + DCy * dxy_py_
    dxz_ = dxz_dyy + DCy * dxz_py_
    dyz_ = dyz_dyy + DCy * dyz_py_
    Iab => abcd(:,:,2,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
    !
    px_  = px__dyz + DCz * px__py_
    py_  = py__dyz + DCz * py__py_
    pz_  = pz__dyz + DCz * pz__py_
    dxx_ = dxx_dyz + DCz * dxx_py_
    dyy_ = dyy_dyz + DCz * dyy_py_
    dzz_ = dzz_dyz + DCz * dzz_py_
    dxy_ = dxy_dyz + DCz * dxy_py_
    dxz_ = dxz_dyz + DCz * dxz_py_
    dyz_ = dyz_dyz + DCz * dyz_py_
    Iab => abcd(:,:,3,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
    !
    px_  = px__dxz + DCx * px__pz_
    py_  = py__dxz + DCx * py__pz_
    pz_  = pz__dxz + DCx * pz__pz_
    dxx_ = dxx_dxz + DCx * dxx_pz_
    dyy_ = dyy_dxz + DCx * dyy_pz_
    dzz_ = dzz_dxz + DCx * dzz_pz_
    dxy_ = dxy_dxz + DCx * dxy_pz_
    dxz_ = dxz_dxz + DCx * dxz_pz_
    dyz_ = dyz_dxz + DCx * dyz_pz_
    Iab => abcd(:,:,1,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
    !
    px_  = px__dyz + DCy * px__pz_
    py_  = py__dyz + DCy * py__pz_
    pz_  = pz__dyz + DCy * pz__pz_
    dxx_ = dxx_dyz + DCy * dxx_pz_
    dyy_ = dyy_dyz + DCy * dyy_pz_
    dzz_ = dzz_dyz + DCy * dzz_pz_
    dxy_ = dxy_dyz + DCy * dxy_pz_
    dxz_ = dxz_dyz + DCy * dxz_pz_
    dyz_ = dyz_dyz + DCy * dyz_pz_
    Iab => abcd(:,:,2,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
    !
    px_  = px__dzz + DCz * px__pz_
    py_  = py__dzz + DCz * py__pz_
    pz_  = pz__dzz + DCz * pz__pz_
    dxx_ = dxx_dzz + DCz * dxx_pz_
    dyy_ = dyy_dzz + DCz * dyy_pz_
    dzz_ = dzz_dzz + DCz * dzz_pz_
    dxy_ = dxy_dzz + DCz * dxy_pz_
    dxz_ = dxz_dzz + DCz * dxz_pz_
    dyz_ = dyz_dzz + DCz * dyz_pz_
    Iab => abcd(:,:,3,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
  end

  make_ppps(abcd) [private]
  ! Make the (pp|ps) integrals, summed over the primitives
    IN :: self
    MAT4, target :: abcd
    MAT3* :: Iabf
    RYS* :: rys
    INT :: ab,cd,nroots,n
    DBL :: zeta,zinv,eta,einv,ab_prefac,cd_prefac
    DBL :: norm,rho,xx,rho_zinv,rho_einv
    DBL :: Px,Py,Pz,Qx,Qy,Qz
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,QCx,QCy,QCz
    DBL :: ce,bb,t2,t2_rz,t2_re,w,half_zinv,half_einv
    DBL :: Ix12,Ix21,Ix22,Ix31,Ix32
    DBL :: Iy12,Iy21,Iy22,Iy31,Iy32
    DBL :: Iz12,Iz21,Iz22,Iz31,Iz32
    DBL :: px__px_,py__px_,pz__px_
    DBL :: px__py_,py__py_,pz__py_
    DBL :: px__pz_,py__pz_,pz__pz_
    DBL :: dxx_px_,dyy_px_,dzz_px_,dxy_px_,dxz_px_,dyz_px_
    DBL :: dxx_py_,dyy_py_,dzz_py_,dxy_py_,dxz_py_,dyz_py_
    DBL :: dxx_pz_,dyy_pz_,dzz_pz_,dxy_pz_,dxz_pz_,dyz_pz_
    DBL :: Iy12_Iz21,Iy12_Iz12,Iy21_Iz21,Iy21_Iz22
    DBL :: Iy21_Iz12,Iy31_Iz12,Iy12_Iz31,Iy12_Iz22
    DBL :: Iy22_Iz12,Iy22_Iz21
    DBL :: Iy12_w, Iy21_w, Iy22_w, Iy31_w, Iy32_w
    DBL :: BAx,BAy,BAz
    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    dxx_px_ = ZERO; dyy_px_ = ZERO; dzz_px_ = ZERO
    dxy_px_ = ZERO; dxz_px_ = ZERO; dyz_px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    dxx_py_ = ZERO; dyy_py_ = ZERO; dzz_py_ = ZERO
    dxy_py_ = ZERO; dxz_py_ = ZERO; dyz_py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    dxx_pz_ = ZERO; dyy_pz_ = ZERO; dzz_pz_ = ZERO
    dxy_pz_ = ZERO; dxz_pz_ = ZERO; dyz_pz_ = ZERO
    nroots = (.ab.l_sum+.cd.l_sum+2)/2
    rys.create(nroots)
    do ab = 1,.ab.n_gaussian_pairs
      zeta = .ab.exponent_sum(ab)
      zinv = .ab.exponent_inv(ab)
      ab_prefac = .ab.cc_prefactor(ab)
      Px  = .ab.pair_center(1,ab)
      Py  = .ab.pair_center(2,ab)
      Pz  = .ab.pair_center(3,ab)
      PAx = .ab.center_diff(1,ab)
      PAy = .ab.center_diff(2,ab)
      PAz = .ab.center_diff(3,ab)
      do cd = 1,.cd.n_gaussian_pairs
        eta  = .cd.exponent_sum(cd)
        einv = .cd.exponent_inv(cd)
        cd_prefac = .cd.cc_prefactor(cd)
        Qx  = .cd.pair_center(1,cd)
        Qy  = .cd.pair_center(2,cd)
        Qz  = .cd.pair_center(3,cd)
        QCx = .cd.center_diff(1,cd)
        QCy = .cd.center_diff(2,cd)
        QCz = .cd.center_diff(3,cd)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        rho_zinv = rho * zinv
        rho_einv = rho * einv
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        half_zinv = HALF * zinv
        half_einv = HALF * einv
        do n=1,nroots
          t2    = rys.r(n)
          w     = rys.w(n) * norm
          t2_rz = t2 * rho_zinv
          t2_re = t2 * rho_einv
          bb    = t2_rz * half_einv
          ce    = (ONE - t2_rz) * half_zinv
          Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
          Iy12 = QCy - t2_re * QPy
          Iz12 = QCz - t2_re * QPz
          Ix21 = PAx + t2_rz * QPx
          Iy21 = PAy + t2_rz * QPy
          Iz21 = PAz + t2_rz * QPz
          Ix22 = Ix12 * Ix21 + bb
          Iy22 = Iy12 * Iy21 + bb
          Iz22 = Iz12 * Iz21 + bb
          Ix31 = Ix21 * Ix21 + ce
          Iy31 = Iy21 * Iy21 + ce
          Iz31 = Iz21 * Iz21 + ce
          Ix32 = Ix21 * Ix22 + ce * Ix12 + bb * Ix21
          Iy32 = Iy21 * Iy22 + ce * Iy12 + bb * Iy21
          Iz32 = Iz21 * Iz22 + ce * Iz12 + bb * Iz21
          !
          Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
          Iz31 = Iz31 * w
          Iz12 = Iz12 * w
          Iz22 = Iz22 * w
          Iz32 = Iz32 * w
          Iy12_Iz21 = Iy12 * Iz21
          Iy12_Iz12 = Iy12 * Iz12
          Iy12_Iz22 = Iy12 * Iz22
          Iy12_Iz31 = Iy12 * Iz31
          Iy21_Iz21 = Iy21 * Iz21
          Iy21_Iz22 = Iy21 * Iz22
          Iy21_Iz12 = Iy21 * Iz12
          Iy31_Iz12 = Iy31 * Iz12
          Iy22_Iz12 = Iy22 * Iz12
          Iy22_Iz21 = Iy22 * Iz21
          Iy12_w    = Iy12 * w
          Iy21_w    = Iy21 * w
          Iy22_w    = Iy22 * w
          Iy31_w    = Iy31 * w
          Iy32_w    = Iy32 * w
          !
          px__px_ = px__px_ + Ix22 * w         ! combine 2d ints.
          py__px_ = py__px_ + Ix12 * Iy21_w
          pz__px_ = pz__px_ + Ix12 * Iz21
          dxx_px_ = dxx_px_ + Ix32 * w
          dyy_px_ = dyy_px_ + Ix12 * Iy31_w
          dzz_px_ = dzz_px_ + Ix12 * Iz31
          dxy_px_ = dxy_px_ + Ix22 * Iy21_w
          dxz_px_ = dxz_px_ + Ix22 * Iz21
          dyz_px_ = dyz_px_ + Ix12 * Iy21_Iz21
          px__py_ = px__py_ + Ix21 * Iy12_w
          py__py_ = py__py_ + Iy22_w
          pz__py_ = pz__py_ + Iy12_Iz21
          dxx_py_ = dxx_py_ + Ix31 * Iy12_w
          dyy_py_ = dyy_py_ + Iy32_w
          dzz_py_ = dzz_py_ + Iy12_Iz31
          dxy_py_ = dxy_py_ + Ix21 * Iy22_w
          dxz_py_ = dxz_py_ + Ix21 * Iy12_Iz21
          dyz_py_ = dyz_py_ + Iy22_Iz21
          px__pz_ = px__pz_ + Ix21 * Iz12
          py__pz_ = py__pz_ + Iy21_Iz12
          pz__pz_ = pz__pz_ + Iz22
          dxx_pz_ = dxx_pz_ + Ix31 * Iz12
          dyy_pz_ = dyy_pz_ + Iy31_Iz12
          dzz_pz_ = dzz_pz_ + Iz32
          dxy_pz_ = dxy_pz_ + Ix21 * Iy21_Iz12
          dxz_pz_ = dxz_pz_ + Ix21 * Iz22
          dyz_pz_ = dyz_pz_ + Iy21_Iz22
        end
      end
    end
    rys.destroy
    if (.cd.a.l==0) then; Iabf => abcd(:,:,1,:)
    else;                 Iabf => abcd(:,:,:,1) ! .b.l==0
    end
    ! Transfer equations
    BAx = .ab.b.pos(1) - .ab.a.pos(1)
    BAy = .ab.b.pos(2) - .ab.a.pos(2)
    BAz = .ab.b.pos(3) - .ab.a.pos(3)
    Iabf(1,1,1) = dxx_px_ + BAx * px__px_
    Iabf(1,1,2) = dxx_py_ + BAx * px__py_
    Iabf(1,1,3) = dxx_pz_ + BAx * px__pz_
    Iabf(2,1,1) = dxy_px_ + BAy * px__px_
    Iabf(2,1,2) = dxy_py_ + BAy * px__py_
    Iabf(2,1,3) = dxy_pz_ + BAy * px__pz_
    Iabf(3,1,1) = dxz_px_ + BAz * px__px_
    Iabf(3,1,2) = dxz_py_ + BAz * px__py_
    Iabf(3,1,3) = dxz_pz_ + BAz * px__pz_
    Iabf(1,2,1) = dxy_px_ + BAx * py__px_
    Iabf(1,2,2) = dxy_py_ + BAx * py__py_
    Iabf(1,2,3) = dxy_pz_ + BAx * py__pz_
    Iabf(2,2,1) = dyy_px_ + BAy * py__px_
    Iabf(2,2,2) = dyy_py_ + BAy * py__py_
    Iabf(2,2,3) = dyy_pz_ + BAy * py__pz_
    Iabf(3,2,1) = dyz_px_ + BAz * py__px_
    Iabf(3,2,2) = dyz_py_ + BAz * py__py_
    Iabf(3,2,3) = dyz_pz_ + BAz * py__pz_
    Iabf(1,3,1) = dxz_px_ + BAx * pz__px_
    Iabf(1,3,2) = dxz_py_ + BAx * pz__py_
    Iabf(1,3,3) = dxz_pz_ + BAx * pz__pz_
    Iabf(2,3,1) = dyz_px_ + BAy * pz__px_
    Iabf(2,3,2) = dyz_py_ + BAy * pz__py_
    Iabf(2,3,3) = dyz_pz_ + BAy * pz__pz_
    Iabf(3,3,1) = dzz_px_ + BAz * pz__px_
    Iabf(3,3,2) = dzz_py_ + BAz * pz__py_
    Iabf(3,3,3) = dzz_pz_ + BAz * pz__pz_
  end

  make_pspp(abcd) [private]
  ! Make the (ps|pp) integrals, summed over the primitives
    IN :: self
    MAT4, target :: abcd
    MAT3* :: Iabf
    RYS* :: rys
    INT :: ab,cd,nroots,n
    DBL :: zeta,zinv,eta,einv,ab_prefac,cd_prefac
    DBL :: norm,xx,rho,rho_zinv,rho_einv
    DBL :: Px,Py,Pz,Qx,Qy,Qz,QPx,QPy,QPz,PAx,PAy,PAz,QCx,QCy,QCz
    DBL :: cf,bb,t2,t2_rz,t2_re,w,half_zinv,half_einv
    DBL :: Ix12,Ix13,Ix21,Ix22,Ix23
    DBL :: Iy12,Iy13,Iy21,Iy22,Iy23
    DBL :: Iz12,Iz13,Iz21,Iz22,Iz23
    DBL :: px__px_,py__px_,pz__px_
    DBL :: px__py_,py__py_,pz__py_
    DBL :: px__pz_,py__pz_,pz__pz_
    DBL :: px__dxx,py__dxx,pz__dxx
    DBL :: px__dyy,py__dyy,pz__dyy
    DBL :: px__dzz,py__dzz,pz__dzz
    DBL :: px__dxy,py__dxy,pz__dxy
    DBL :: px__dxz,py__dxz,pz__dxz
    DBL :: px__dyz,py__dyz,pz__dyz
    DBL :: Iy12_Iz21,Iy12_Iz12,Iy13_Iz21,Iy21_Iz21,Iy21_Iz22
    DBL :: Iy21_Iz12,Iy21_Iz13,Iy12_Iz22
    DBL :: Iy22_Iz12,Iy22_Iz21
    DBL :: Iy12_w, Iy21_w, Iy22_w, Iy13_w, Iy23_w
    DBL :: DCx,DCy,DCz
    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    px__dxx = ZERO; py__dxx = ZERO; pz__dxx = ZERO
    px__dyy = ZERO; py__dyy = ZERO; pz__dyy = ZERO
    px__dzz = ZERO; py__dzz = ZERO; pz__dzz = ZERO
    px__dxy = ZERO; py__dxy = ZERO; pz__dxy = ZERO
    px__dxz = ZERO; py__dxz = ZERO; pz__dxz = ZERO
    px__dyz = ZERO; py__dyz = ZERO; pz__dyz = ZERO
    nroots = (.ab.l_sum+.cd.l_sum+2)/2
    rys.create(nroots)
    do ab = 1,.ab.n_gaussian_pairs
      zeta = .ab.exponent_sum(ab)
      zinv = .ab.exponent_inv(ab)
      ab_prefac = .ab.cc_prefactor(ab)
      Px  = .ab.pair_center(1,ab)
      Py  = .ab.pair_center(2,ab)
      Pz  = .ab.pair_center(3,ab)
      PAx = .ab.center_diff(1,ab)
      PAy = .ab.center_diff(2,ab)
      PAz = .ab.center_diff(3,ab)
      do cd = 1,.cd.n_gaussian_pairs
        eta  = .cd.exponent_sum(cd)
        einv = .cd.exponent_inv(cd)
        cd_prefac = .cd.cc_prefactor(cd)
        Qx  = .cd.pair_center(1,cd)
        Qy  = .cd.pair_center(2,cd)
        Qz  = .cd.pair_center(3,cd)
        QCx = .cd.center_diff(1,cd)
        QCy = .cd.center_diff(2,cd)
        QCz = .cd.center_diff(3,cd)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        rho_zinv = rho * zinv
        rho_einv = rho * einv
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        half_zinv = HALF * zinv
        half_einv = HALF * einv
        do n=1,nroots
          t2    = rys.r(n)
          w     = rys.w(n) * norm
          t2_rz = t2 * rho_zinv
          t2_re = t2 * rho_einv
          bb    = t2_rz * half_einv
          cf    = (ONE - t2_re) * half_einv
          Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
          Iy12 = QCy - t2_re * QPy
          Iz12 = QCz - t2_re * QPz
          Ix21 = PAx + t2_rz * QPx
          Iy21 = PAy + t2_rz * QPy
          Iz21 = PAz + t2_rz * QPz
          Ix22 = Ix12 * Ix21 + bb
          Iy22 = Iy12 * Iy21 + bb
          Iz22 = Iz12 * Iz21 + bb
          Ix13 = Ix12 * Ix12 + cf
          Iy13 = Iy12 * Iy12 + cf
          Iz13 = Iz12 * Iz12 + cf
          Ix23 = Ix12 * Ix22 + cf * Ix21 + bb * Ix12
          Iy23 = Iy12 * Iy22 + cf * Iy21 + bb * Iy12
          Iz23 = Iz12 * Iz22 + cf * Iz21 + bb * Iz12
          !
          Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
          Iz12 = Iz12 * w
          Iz22 = Iz22 * w
          Iz13 = Iz13 * w
          Iz23 = Iz23 * w
          Iy12_Iz21 = Iy12 * Iz21
          Iy12_Iz12 = Iy12 * Iz12
          Iy12_Iz22 = Iy12 * Iz22
          Iy13_Iz21 = Iy13 * Iz21
          Iy21_Iz21 = Iy21 * Iz21
          Iy21_Iz22 = Iy21 * Iz22
          Iy21_Iz12 = Iy21 * Iz12
          Iy21_Iz13 = Iy21 * Iz13
          Iy22_Iz12 = Iy22 * Iz12
          Iy22_Iz21 = Iy22 * Iz21
          Iy12_w    = Iy12 * w
          Iy21_w    = Iy21 * w
          Iy22_w    = Iy22 * w
          Iy13_w    = Iy13 * w
          Iy23_w    = Iy23 * w
          !
          px__px_ = px__px_ + Ix22 * w     ! combine 2d ints.
          py__px_ = py__px_ + Ix12 * Iy21_w
          pz__px_ = pz__px_ + Ix12 * Iz21
          px__py_ = px__py_ + Ix21 * Iy12_w
          py__py_ = py__py_ + Iy22_w
          pz__py_ = pz__py_ + Iy12_Iz21
          px__pz_ = px__pz_ + Ix21 * Iz12
          py__pz_ = py__pz_ + Iy21_Iz12
          pz__pz_ = pz__pz_ + Iz22
          px__dxx = px__dxx + Ix23 * w
          py__dxx = py__dxx + Ix13 * Iy21_w
          pz__dxx = pz__dxx + Ix13 * Iz21
          px__dyy = px__dyy + Ix21 * Iy13_w
          py__dyy = py__dyy + Iy23_w
          pz__dyy = pz__dyy + Iy13_Iz21
          px__dzz = px__dzz + Ix21 * Iz13
          py__dzz = py__dzz + Iy21_Iz13
          pz__dzz = pz__dzz + Iz23
          px__dxy = px__dxy + Ix22 * Iy12_w
          py__dxy = py__dxy + Ix12 * Iy22_w
          pz__dxy = pz__dxy + Ix12 * Iy12_Iz21
          px__dxz = px__dxz + Ix22 * Iz12
          py__dxz = py__dxz + Ix12 * Iy21_Iz12
          pz__dxz = pz__dxz + Ix12 * Iz22
          px__dyz = px__dyz + Ix21 * Iy12_Iz12
          py__dyz = py__dyz + Iy22_Iz12
          pz__dyz = pz__dyz + Iy12_Iz22
        end
      end
    end
    rys.destroy
    !
    if (.ab.a.l==0) then; Iabf => abcd(1,:,:,:)
    else;                 Iabf => abcd(:,1,:,:) ! .b.l==0
    end
    ! Transfer equations
    DCx = .cd.b.pos(1) - .cd.a.pos(1)
    DCy = .cd.b.pos(2) - .cd.a.pos(2)
    DCz = .cd.b.pos(3) - .cd.a.pos(3)
    Iabf(1,1,1) = px__dxx + DCx * px__px_
    Iabf(2,1,1) = py__dxx + DCx * py__px_
    Iabf(3,1,1) = pz__dxx + DCx * pz__px_
    Iabf(1,2,1) = px__dxy + DCy * px__px_
    Iabf(2,2,1) = py__dxy + DCy * py__px_
    Iabf(3,2,1) = pz__dxy + DCy * pz__px_
    Iabf(1,3,1) = px__dxz + DCz * px__px_
    Iabf(2,3,1) = py__dxz + DCz * py__px_
    Iabf(3,3,1) = pz__dxz + DCz * pz__px_
    Iabf(1,1,2) = px__dxy + DCx * px__py_
    Iabf(2,1,2) = py__dxy + DCx * py__py_
    Iabf(3,1,2) = pz__dxy + DCx * pz__py_
    Iabf(1,2,2) = px__dyy + DCy * px__py_
    Iabf(2,2,2) = py__dyy + DCy * py__py_
    Iabf(3,2,2) = pz__dyy + DCy * pz__py_
    Iabf(1,3,2) = px__dyz + DCz * px__py_
    Iabf(2,3,2) = py__dyz + DCz * py__py_
    Iabf(3,3,2) = pz__dyz + DCz * pz__py_
    Iabf(1,1,3) = px__dxz + DCx * px__pz_
    Iabf(2,1,3) = py__dxz + DCx * py__pz_
    Iabf(3,1,3) = pz__dxz + DCx * pz__pz_
    Iabf(1,2,3) = px__dyz + DCy * px__pz_
    Iabf(2,2,3) = py__dyz + DCy * py__pz_
    Iabf(3,2,3) = pz__dyz + DCy * pz__pz_
    Iabf(1,3,3) = px__dzz + DCz * px__pz_
    Iabf(2,3,3) = py__dzz + DCz * py__pz_
    Iabf(3,3,3) = pz__dzz + DCz * pz__pz_
  end

  make_psps(abcd) [private]
  ! Makes the (ps|ps) integrals, summed over the primitives
  ! Does ps|ps, ps|sp, sp|ps, sp|sp.
    IN :: self
    MAT4, OUT:: abcd
    MAT*:: psps
    RYS* :: rys
    INT :: ab,cd,n
    DBL :: zeta,eta,xx,zinv,rho,einv,norm,half_zinv
    DBL :: ab_prefac,cd_prefac,rho_zinv,rho_einv
    DBL :: Px,Py,Pz,Qx,Qy,Qz
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,PAx,PAy,PAz
    DBL :: root,tmp2,tmp3,tmp4,weight,b_r2ab
    DBL :: Iz11,Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22
    rys.create(2)
    psps.create(3,3)
    psps=ZERO
    do ab = 1,.ab.n_gaussian_pairs
      zeta = .ab.exponent_sum(ab)
      zinv = .ab.exponent_inv(ab)
      ab_prefac = .ab.cc_prefactor(ab)
      Px  = .ab.pair_center(1,ab)
      Py  = .ab.pair_center(2,ab)
      Pz  = .ab.pair_center(3,ab)
      PAx = .ab.center_diff(1,ab)
      PAy = .ab.center_diff(2,ab)
      PAz = .ab.center_diff(3,ab)
      do cd = 1,.cd.n_gaussian_pairs
        eta  = .cd.exponent_sum(cd)
        einv = .cd.exponent_inv(cd)
        cd_prefac = .cd.cc_prefactor(cd)
        Qx  = .cd.pair_center(1,cd)
        Qy  = .cd.pair_center(2,cd)
        Qz  = .cd.pair_center(3,cd)
        QCx = .cd.center_diff(1,cd)
        QCy = .cd.center_diff(2,cd)
        QCz = .cd.center_diff(3,cd)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        rho_zinv = rho * zinv
        rho_einv = rho * einv
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        half_zinv = HALF * zinv
        do n=1,2
          root = rys.r(n)
          tmp2 = root * rho_zinv
          tmp3 = root * rho_einv
          tmp4 = tmp3 * half_zinv
          Ix12 = QCx - tmp3 * QPx
          Iy12 = QCy - tmp3 * QPy
          Iz12 = QCz - tmp3 * QPz
          Ix21 = PAx + tmp2 * QPx
          Iy21 = PAy + tmp2 * QPy
          Iz21 = PAz + tmp2 * QPz
          Ix22 = Ix12 * Ix21 + tmp4
          Iy22 = Iy12 * Iy21 + tmp4
          Iz22 = Iz12 * Iz21 + tmp4
          weight = rys.w(n) * norm       ! Merge the wieghts and
          Iz11 =        weight           ! normalization into Iz.
          Iz12 = Iz12 * weight
          Iz21 = Iz21 * weight
          Iz22 = Iz22 * weight
          psps(1,1) = psps(1,1) + (Ix22        * Iz11)
          psps(2,1) = psps(2,1) + (Ix12 * Iy21 * Iz11)
          psps(3,1) = psps(3,1) + (Ix12        * Iz21)
          psps(1,2) = psps(1,2) + (Ix21 * Iy12 * Iz11)
          psps(2,2) = psps(2,2) + (       Iy22 * Iz11)
          psps(3,2) = psps(3,2) + (       Iy12 * Iz21)
          psps(1,3) = psps(1,3) + (Ix21        * Iz12)
          psps(2,3) = psps(2,3) + (       Iy21 * Iz12)
          psps(3,3) = psps(3,3) + (              Iz22)
        end
      end
    end
    rys.destroy
    if (.ab.a.l == 1) then
      if (.cd.a.l ==1) then; abcd(:,1,:,1) = psps
      else;                  abcd(:,1,1,:) = psps
      end
    else
      if (.cd.a.l ==1) then; abcd(1,:,:,1) = psps
      else;                  abcd(1,:,1,:) = psps
      end
    end
    psps.destroy
  end

  make_abss(abcd) [private]
  ! Makes the (ab|ss) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT :: abcd
    VEC* :: esss,esssadd
    MAT* :: Ix,Iy,Iz,Iyz
    RYS* :: rys
    SHELL2* :: sh
    DBL :: zeta,zinv,eta,einv,ab_prefac,cd_prefac
    DBL :: norm,rho,xx,rho_zinv,rho_einv,half_zinv,half_einv
    INT :: ab,cd,n_e,nroots,eub,dim,maxl,minl
    DBL :: Qx,Qy,Qz,Px,Py,Pz,QPx,QPy,QPz,PAx,PAy,PAz
    IMAT* :: e_powers
    IVEC* :: ex,ey,ez
    DBL :: rzt,ce1,rzthze
    INT :: ep1,n
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3
    DBL :: Ixe,Ixe1,Iye,Iye1,Ize,Ize1,Ixep1,Iyep1,Izep1
    n_e = .ab.l_sum
    maxl = .ab.l_max
    minl = .ab.l_min
    dim = n_e + 1
    eub = n_e.n_comp_sum - (maxl-1).n_comp_sum
    nroots = (n_e + 2) / 2
    esss.create(eub)
    rys.create(nroots)
    Ix.create(nroots,dim)
    Iy.create(nroots,dim)
    Iz.create(nroots,dim)
    Iyz.create(nroots,dim*(dim+1)/2)
    esssadd.create(eub)
    e_powers.create(eub,3)
    ex => e_powers(:,1)
    ey => e_powers(:,2)
    ez => e_powers(:,3)
    maxl.make_gaussian_xyz_indices(ex,ey,ez,n_e)
    esss = ZERO
    do ab = 1,.ab.n_gaussian_pairs
      zeta = .ab.exponent_sum(ab)
      zinv = .ab.exponent_inv(ab)
      ab_prefac = .ab.cc_prefactor(ab)
      Px  = .ab.pair_center(1,ab)
      Py  = .ab.pair_center(2,ab)
      Pz  = .ab.pair_center(3,ab)
      PAx = .ab.center_diff(1,ab)
      PAy = .ab.center_diff(2,ab)
      PAz = .ab.center_diff(3,ab)
      do cd = 1,.cd.n_gaussian_pairs
        eta  = .cd.exponent_sum(cd)
        einv = .cd.exponent_inv(cd)
        cd_prefac = .cd.cc_prefactor(cd)
        Qx  = .cd.pair_center(1,cd)
        Qy  = .cd.pair_center(2,cd)
        Qz  = .cd.pair_center(3,cd)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        rho_zinv = rho * zinv
        rho_einv = rho * einv
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        rys.w(:) = rys.w(:) * norm
        half_zinv = HALF * zinv
        half_einv = HALF * einv
        do n=1,nroots
          rzt      = rys.r(n) * rho_zinv
          rzthze   = (ONE - rzt) * half_zinv
          Ix2 = PAx + rzt * QPx
          Iy2 = PAy + rzt * QPy
          Iz2 = PAz + rzt * QPz
          Ix3 = Ix2 * Ix2 + rzthze
          Iy3 = Iy2 * Iy2 + rzthze
          Iz3 = Iz2 * Iz2 + rzthze
          Ix(n,1) = ONE; Iy(n,1) = ONE; Iz(n,1) = ONE
          Ix(n,2) = Ix2; Iy(n,2) = Iy2; Iz(n,2) = Iz2
          Ix(n,3) = Ix3; Iy(n,3) = Iy3; Iz(n,3) = Iz3
          Ixe  = Ix3;   Iye  = Iy3;   Ize  = Iz3
          Ixe1 = Ix2;   Iye1 = Iy2;   Ize1 = Iz2
          do ep1 = 4, n_e+1
            ce1 = (ep1-2) * rzthze
            Ixep1 = Ix2 * Ixe + ce1 * Ixe1
            Iyep1 = Iy2 * Iye + ce1 * Iye1
            Izep1 = Iz2 * Ize + ce1 * Ize1
            Ix(n,ep1) = Ixep1;   Iy(n,ep1) = Iyep1;   Iz(n,ep1) = Izep1;
            Ixe1 = Ixe;   Iye1 = Iye;   Ize1 = Ize    ! for next iteration
            Ixe = Ixep1;  Iye = Iyep1;  Ize = Izep1   ! for next iteration
          end
        end
        .form_esfs_0(Ix,Iy,Iz,Iyz,rys.w,esssadd,ex,ey,ez,dim,eub,minl)
        esss = esss + esssadd
      end
    end
    e_powers.destroy
    esssadd.destroy
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rys.destroy
    ! Transfer equation
    sh.create(.ab.a,.ab.b)
    sh.transfer(esss,abcd(:,:,1,1))
    sh.destroy
    esss.destroy
    .to_normalize(abcd)
  end

  make_sscd(abcd) [private]
  ! Makes the (ss|cd) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT:: abcd
    VEC* :: ssfs,ssfsadd
    MAT* :: Ix,Iy,Iz
    MAT* :: Iyz
    SHELL2* :: sh
    RYS* :: rys
    DBL :: zeta,zinv,eta,einv,rho,xx
    INT :: ab,cd,n_f,nroots,fub,dim,maxl,minl
    DBL :: ab_prefac,cd_prefac,norm,rho_einv,half_einv
    DBL :: Px,Py,Pz,Qx,Qy,Qz,QPx,QPy,QPz,QCx,QCy,QCz
    IMAT* :: f_powers
    IVEC* :: fx,fy,fz
    DBL :: ret,cf1,rethen
    INT :: fp1,n
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3
    DBL :: Ixf,Ixf1,Iyf,Iyf1,Izf,Izf1,Ixfp1,Iyfp1,Izfp1
    n_f  = .cd.l_sum
    maxl = .cd.l_max
    minl = .cd.l_min
    dim = n_f+1
    fub = n_f.n_comp_sum - (maxl-1).n_comp_sum
    nroots = (n_f + 2)/2
    ssfs.create(fub)
    rys.create(nroots)
    Ix.create(nroots,dim)
    Iy.create(nroots,dim)
    Iz.create(nroots,dim)
    Iyz.create(nroots,dim*(dim+1)/2)
    ssfsadd.create(fub)
    f_powers.create(fub,3)
    fx => f_powers(:,1)
    fy => f_powers(:,2)
    fz => f_powers(:,3)
    maxl.make_gaussian_xyz_indices(fx,fy,fz,n_f)
    ssfs=ZERO
    do cd = 1,.cd.n_gaussian_pairs
      eta  = .cd.exponent_sum(cd)
      einv = .cd.exponent_inv(cd)
      cd_prefac = .cd.cc_prefactor(cd)
      Qx  = .cd.pair_center(1,cd)
      Qy  = .cd.pair_center(2,cd)
      Qz  = .cd.pair_center(3,cd)
      QCx = .cd.center_diff(1,cd)
      QCy = .cd.center_diff(2,cd)
      QCz = .cd.center_diff(3,cd)
      do ab = 1,.ab.n_gaussian_pairs
        zeta = .ab.exponent_sum(ab)
        zinv = .ab.exponent_inv(ab)
        ab_prefac = .ab.cc_prefactor(ab)
        Px  = .ab.pair_center(1,ab)
        Py  = .ab.pair_center(2,ab)
        Pz  = .ab.pair_center(3,ab)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        rho_einv = rho * einv
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        rys.w(:) = rys.w(:) * norm
        half_einv = HALF * einv
        do n=1,nroots
          ret     = rys.r(n) * rho_einv
          rethen  = (ONE - ret) * half_einv
          Ix2 = QCx - ret * QPx
          Iy2 = QCy - ret * QPy
          Iz2 = QCz - ret * QPz
          Ix3 = Ix2 * Ix2 + rethen
          Iy3 = Iy2 * Iy2 + rethen
          Iz3 = Iz2 * Iz2 + rethen
          Ix(n,1) = ONE; Iy(n,1) = ONE; Iz(n,1) = ONE
          Ix(n,2) = Ix2; Iy(n,2) = Iy2; Iz(n,2) = Iz2
          Ix(n,3) = Ix3; Iy(n,3) = Iy3; Iz(n,3) = Iz3
          Ixf  = Ix3;   Iyf  = Iy3;   Izf  = Iz3
          Ixf1 = Ix2;   Iyf1 = Iy2;   Izf1 = Iz2
          do fp1 = 4, n_f+1
            cf1 = (fp1-2) * rethen
            Ixfp1 = Ix2 * Ixf + cf1 * Ixf1
            Iyfp1 = Iy2 * Iyf + cf1 * Iyf1
            Izfp1 = Iz2 * Izf + cf1 * Izf1
            Ix(n,fp1) = Ixfp1;   Iy(n,fp1) = Iyfp1;   Iz(n,fp1) = Izfp1;
            Ixf1 = Ixf;   Iyf1 = Iyf;   Izf1 = Izf    ! for next iteration
            Ixf = Ixfp1;  Iyf = Iyfp1;  Izf = Izfp1   ! for next iteration
          end
        end
        .form_esfs_0(Ix,Iy,Iz,Iyz,rys.w,ssfsadd,fx,fy,fz,dim,fub,minl)
        ssfs = ssfs + ssfsadd
      end
    end
    f_powers.destroy
    ssfsadd.destroy
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rys.destroy
    ! Transfer equation
    sh.create(.cd.a,.cd.b)
    sh.transfer(ssfs,abcd(1,1,:,:))
    sh.destroy
    ssfs.destroy
    .to_normalize(abcd)
  end

  form_esfs_0(Ix,Iy,Iz,Iyz,weights,esfsadd,xx,yy,zz,dim,fub,minl) [private]
  ! Forms (es|fs) from the two dimensional integrals for a single
  ! set of primitives, where e = 0 or f = 0.
    IN :: self
    MAT, target :: Ix,Iy,Iz,Iyz
    VEC, IN :: weights
    VEC, OUT :: esfsadd
    IVEC :: xx,yy,zz
    INT, IN :: dim,fub,minl
    INT :: f,x,y,z,dim1,dim2,ii
    VEC* :: Izz
    ! Apply the reduced multiplication scheme to merge the Iy and Iz 2d
    ! integrals into a single matrix (upper triangle).
    if (minl > 2) then
      dim1 = dim+1
      dim2 = 2*dim1+1
      ii = 0
      do z=1,dim
        Izz => Iz(:,z)
        Izz(:) = Izz(:) * weights(:)  ! Merge the weights into Iz.
        do y=1,dim1-z
          ii = ii + 1
          Iyz(:,ii) = Izz * Iy(:,y)
        end
      end
      do f=1,fub
        x  = xx(f);  y = yy(f);  z = zz(f)
         ii = -dim1 + z*(dim2-z)/2 + y
        esfsadd(f)=sum(Ix(:,x) * Iyz(:,ii))
      end
    else
      do z=1,dim
        Izz => Iz(:,z)
        Izz(:) = Izz(:) * weights(:)  ! Merge the weights into Iz.
      end
      do f=1,fub
        x  = xx(f);  y = yy(f);  z = zz(f)
        esfsadd(f)=sum(Ix(:,x) * Iy(:,y) * Iz(:,z))
      end
    end
  end

  make_ppss(abcd) [private]
  ! Creates the initial (pp|ss) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT:: abcd
    RYS* :: rys
    DBL :: zeta,zinv,eta,einv,rho,xx
    DBL :: ab_prefac,cd_prefac,norm,rho_zinv,half_zinv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,QPx,QPy,QPz,PAx,PAy,PAz
    DBL :: rzt,rzthze
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,w
    DBL :: px_s,py_s,pz_s,dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyx_s
    DBL :: BAx,BAy,BAz
    INT :: ab,cd,n
    px_s  = ZERO; py_s  = ZERO; pz_s  = ZERO
    dxx_s = ZERO; dyy_s = ZERO; dzz_s = ZERO
    dxy_s = ZERO; dxz_s = ZERO; dyx_s = ZERO
    rys.create(2)               ! nroots = 2
    do ab = 1,.ab.n_gaussian_pairs
      zeta = .ab.exponent_sum(ab)
      zinv = .ab.exponent_inv(ab)
      ab_prefac = .ab.cc_prefactor(ab)
      Px  = .ab.pair_center(1,ab)
      Py  = .ab.pair_center(2,ab)
      Pz  = .ab.pair_center(3,ab)
      PAx = .ab.center_diff(1,ab)
      PAy = .ab.center_diff(2,ab)
      PAz = .ab.center_diff(3,ab)
      do cd = 1,.cd.n_gaussian_pairs
        eta  = .cd.exponent_sum(cd)
        einv = .cd.exponent_inv(cd)
        cd_prefac = .cd.cc_prefactor(cd)
        Qx  = .cd.pair_center(1,cd)
        Qy  = .cd.pair_center(2,cd)
        Qz  = .cd.pair_center(3,cd)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        rho_zinv = rho * zinv
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        half_zinv = HALF * zinv
        do n=1,2
          rzt    = rys.r(n) * rho_zinv
          rzthze = (ONE - rzt) * half_zinv
          Ix2 = PAx + rzt * QPx
          Iy2 = PAy + rzt * QPy
          Iz2 = PAz + rzt * QPz
          Ix3 = Ix2 * Ix2 + rzthze
          Iy3 = Iy2 * Iy2 + rzthze
          Iz3 = Iz2 * Iz2 + rzthze
          w = rys.w(n) * norm
          Iz2 = Iz2 * w
          Iz3 = Iz3 * w
          px_s  = px_s  + (Ix2 *         w)
          py_s  = py_s  + (      Iy2 *   w)
          pz_s  = pz_s  + (            Iz2)
          dxx_s = dxx_s + (Ix3 *         w)
          dyy_s = dyy_s + (      Iy3 *   w)
          dzz_s = dzz_s + (            Iz3)
          dxy_s = dxy_s + (Ix2 * Iy2 *   w)
          dxz_s = dxz_s + (Ix2 *       Iz2)
          dyx_s = dyx_s + (      Iy2 * Iz2)
        end
      end
    end
    rys.destroy
    ! Transfer equation.
    BAx = .ab.b.pos(1) - .ab.a.pos(1)
    BAy = .ab.b.pos(2) - .ab.a.pos(2)
    BAz = .ab.b.pos(3) - .ab.a.pos(3)
    abcd(1,1,1,1) = dxx_s + BAx * px_s
    abcd(1,2,1,1) = dxy_s + BAx * py_s
    abcd(1,3,1,1) = dxz_s + BAx * pz_s
    abcd(2,1,1,1) = dxy_s + BAy * px_s
    abcd(2,2,1,1) = dyy_s + BAy * py_s
    abcd(2,3,1,1) = dyx_s + BAy * pz_s
    abcd(3,1,1,1) = dxz_s + BAz * px_s
    abcd(3,2,1,1) = dyx_s + BAz * py_s
    abcd(3,3,1,1) = dzz_s + BAz * pz_s
  end

  make_sspp(abcd) [private]
  ! Creates the (ss|pp) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT:: abcd
    RYS* :: rys
    DBL :: zeta,zinv,eta,einv,rho,xx
    DBL :: ab_prefac,cd_prefac,norm,rho_einv,half_einv
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz
    DBL :: Qx,Qy,Qz,Px,Py,Pz
    DBL :: ret,rethen
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,w
    DBL :: px_s,py_s,pz_s,dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s
    DBL :: DCx,DCy,DCz
    INT :: ab,cd,n
    px_s  = ZERO; py_s  = ZERO; pz_s  = ZERO
    dxx_s = ZERO; dyy_s = ZERO; dzz_s = ZERO
    dxy_s = ZERO; dxz_s = ZERO; dyz_s = ZERO
    rys.create(2)               ! nroots = 2
    do cd = 1,.cd.n_gaussian_pairs
      eta  = .cd.exponent_sum(cd)
      einv = .cd.exponent_inv(cd)
      cd_prefac = .cd.cc_prefactor(cd)
      Qx  = .cd.pair_center(1,cd)
      Qy  = .cd.pair_center(2,cd)
      Qz  = .cd.pair_center(3,cd)
      QCx = .cd.center_diff(1,cd)
      QCy = .cd.center_diff(2,cd)
      QCz = .cd.center_diff(3,cd)
      do ab = 1,.ab.n_gaussian_pairs
        zeta = .ab.exponent_sum(ab)
        zinv = .ab.exponent_inv(ab)
        ab_prefac = .ab.cc_prefactor(ab)
        Px  = .ab.pair_center(1,ab)
        Py  = .ab.pair_center(2,ab)
        Pz  = .ab.pair_center(3,ab)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        rho_einv = rho * einv
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        half_einv = HALF * einv
        do n=1,2
          ret     = rys.r(n) * rho_einv
          rethen  = (ONE - ret) * half_einv
          Ix2 = QCx - ret * QPx
          Iy2 = QCy - ret * QPy
          Iz2 = QCz - ret * QPz
          Ix3 = Ix2 * Ix2 + rethen
          Iy3 = Iy2 * Iy2 + rethen
          Iz3 = Iz2 * Iz2 + rethen
          w = rys.w(n) * norm
          Iz2 = Iz2 * w
          Iz3 = Iz3 * w
          px_s  = px_s  + (Ix2 *         w)
          py_s  = py_s  + (      Iy2 *   w)
          pz_s  = pz_s  + (            Iz2)
          dxx_s = dxx_s + (Ix3 *         w)
          dyy_s = dyy_s + (      Iy3 *   w)
          dzz_s = dzz_s + (            Iz3)
          dxy_s = dxy_s + (Ix2 * Iy2 *   w)
          dxz_s = dxz_s + (Ix2 *       Iz2)
          dyz_s = dyz_s + (      Iy2 * Iz2)
        end
      end
    end
    rys.destroy
    ! Transfer equation.
    DCx = .cd.b.pos(1) - .cd.a.pos(1)
    DCy = .cd.b.pos(2) - .cd.a.pos(2)
    DCz = .cd.b.pos(3) - .cd.a.pos(3)
    abcd(1,1,1,1) = dxx_s + DCx * px_s
    abcd(1,1,1,2) = dxy_s + DCx * py_s
    abcd(1,1,1,3) = dxz_s + DCx * pz_s
    abcd(1,1,2,1) = dxy_s + DCy * px_s
    abcd(1,1,2,2) = dyy_s + DCy * py_s
    abcd(1,1,2,3) = dyz_s + DCy * pz_s
    abcd(1,1,3,1) = dxz_s + DCz * px_s
    abcd(1,1,3,2) = dyz_s + DCz * py_s
    abcd(1,1,3,3) = dzz_s + DCz * pz_s
  end

  make_psss(abcd) [private]
  ! Creates the initial (ps|ss) or (sp|ss) integrals, summed over the
  ! primitives.
    IN :: self
    MAT4, OUT :: abcd
    RYS* :: rys
    DBL :: zeta,zinv,eta,rho,xx,rho_zinv
    INT :: ab,cd
    DBL :: ab_prefac,cd_prefac,norm,rzt
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz
    DBL :: Qx,Qy,Qz,Px,Py,Pz
    DBL :: psss1,psss2,psss3
    psss1 = ZERO
    psss2 = ZERO
    psss3 = ZERO
    rys.create(1)
    do ab = 1,.ab.n_gaussian_pairs
      zeta = .ab.exponent_sum(ab)
      zinv = .ab.exponent_inv(ab)
      ab_prefac = .ab.cc_prefactor(ab)
      Px  = .ab.pair_center(1,ab)
      Py  = .ab.pair_center(2,ab)
      Pz  = .ab.pair_center(3,ab)
      PAx = .ab.center_diff(1,ab)
      PAy = .ab.center_diff(2,ab)
      PAz = .ab.center_diff(3,ab)
      do cd = 1,.cd.n_gaussian_pairs
        eta  = .cd.exponent_sum(cd)
        cd_prefac = .cd.cc_prefactor(cd)
        Qx  = .cd.pair_center(1,cd)
        Qy  = .cd.pair_center(2,cd)
        Qz  = .cd.pair_center(3,cd)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        rho_zinv = rho * zinv
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        rzt = rys.r(1) * rho_zinv
        norm = norm * rys.w(1)
        psss1 = psss1 + norm * (PAx + rzt * QPx)
        psss2 = psss2 + norm * (PAy + rzt * QPy)
        psss3 = psss3 + norm * (PAz + rzt * QPz)
      end
    end
    rys.destroy
    abcd(1,1,1,1) = psss1
    if (.ab.a.l == 1) then     ! psss
      abcd(2,1,1,1) = psss2
      abcd(3,1,1,1) = psss3
    else                       ! spss
      abcd(1,2,1,1) = psss2
      abcd(1,3,1,1) = psss3
    end
  end

  make_ssps(abcd) [private]
  ! Creates the (ss|ps) or (ss|sp) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT:: abcd
    RYS* :: rys
    DBL :: zeta,eta,einv,rho,xx,ret
    INT :: ab,cd
    DBL :: ab_prefac,cd_prefac,norm,rho_einv
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz
    DBL :: Qx,Qy,Qz,Px,Py,Pz
    DBL :: ssps1,ssps2,ssps3
    ssps1=ZERO
    ssps2=ZERO
    ssps3=ZERO
    rys.create(1)
    do cd = 1,.cd.n_gaussian_pairs
      eta  = .cd.exponent_sum(cd)
      einv = .cd.exponent_inv(cd)
      cd_prefac = .cd.cc_prefactor(cd)
      Qx  = .cd.pair_center(1,cd)
      Qy  = .cd.pair_center(2,cd)
      Qz  = .cd.pair_center(3,cd)
      QCx = .cd.center_diff(1,cd)
      QCy = .cd.center_diff(2,cd)
      QCz = .cd.center_diff(3,cd)
      do ab = 1,.ab.n_gaussian_pairs
        zeta = .ab.exponent_sum(ab)
        ab_prefac = .ab.cc_prefactor(ab)
        Px  = .ab.pair_center(1,ab)
        Py  = .ab.pair_center(2,ab)
        Pz  = .ab.pair_center(3,ab)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        rho_einv = rho * einv
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        ret = rys.r(1) * rho_einv
        norm = norm * rys.w(1)
        ssps1 = ssps1 + norm * (QCx - ret * QPx)
        ssps2 = ssps2 + norm * (QCy - ret * QPy)
        ssps3 = ssps3 + norm * (QCz - ret * QPz)
      end
    end
    rys.destroy
    abcd(1,1,1,1) = ssps1
    if (.cd.a.l == 1) then        ! ssps
      abcd(1,1,2,1) = ssps2
      abcd(1,1,3,1) = ssps3
    else                          ! sssp
      abcd(1,1,1,2) = ssps2
      abcd(1,1,1,3) = ssps3
    end
  end

  make_ssss(abcd) [private]
  ! Creates the (ss|ss) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT :: abcd
    DBL :: ssss
    RYS* :: rys
    DBL :: zeta,eta,rho,xx
    INT :: ab,cd
    DBL :: ab_prefac,cd_prefac,norm
    DBL :: Qx,Qy,Qz,Px,Py,Pz,QPx,QPy,QPz
    ssss = ZERO
    rys.create(1)
    do cd = 1,.cd.n_gaussian_pairs
      eta  = .cd.exponent_sum(cd)
      cd_prefac = .cd.cc_prefactor(cd)
      Qx  = .cd.pair_center(1,cd)
      Qy  = .cd.pair_center(2,cd)
      Qz  = .cd.pair_center(3,cd)
      do ab = 1,.ab.n_gaussian_pairs
        zeta = .ab.exponent_sum(ab)
        ab_prefac = .ab.cc_prefactor(ab)
        Px  = .ab.pair_center(1,ab)
        Py  = .ab.pair_center(2,ab)
        Pz  = .ab.pair_center(3,ab)
        QPx = Qx - Px
        QPy = Qy - Py
        QPz = Qz - Pz
        rho = zeta * eta / (zeta + eta)
        xx = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
        norm = ab_prefac * cd_prefac * sqrt(rho)
        rys.get_weights(xx)
        ssss = ssss + norm * rys.w(1)
      end
    end
    rys.destroy
    abcd = ssss
  end

  transfer(esfs,escd)
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    if (.cd.a.l > .cd.b.l) then
      .transfer_l_c_highest(esfs,escd)
    else
      .transfer_l_d_highest(esfs,escd)
    end
  end

  transfer(escd,abcd)
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    if (.ab.a.l > .ab.b.l) then
      .transfer_l_a_highest(escd,abcd)
    else
      .transfer_l_b_highest(escd,abcd)
    end
  end

  transfer_l_c_highest(esfs,escd) [private]
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    MAT3* :: int_new,int_old
    IMAT* :: components,components_c,components_d
    IMAT3* :: index_c,index_d
    IVEC* :: comp_to_use,component_to_use
    VEC(3) :: CD
    INT :: c,d,c1,c2,c3,d1,ld,cub,dub
    INT :: cx,cy,cz,dx,dy,dz,j,n_f,clb,dlb,tmp,e,eub
    DBL :: CDi,CDx,CDy,CDz,esfs_ec

    select case (.cd.b.l)
      case (0)
        escd(:,:,1)=esfs

      case (1)
        clb = (.cd.a.l-1).n_comp_sum
        eub = (.ab.l_sum).n_comp_sum - (.ab.l_max-1).n_comp_sum
        CD   = .cd.a.pos - .cd.b.pos
        n_f  = .cd.l_sum
        cub  = .cd.a.n_comp

        components.create(3, n_f.n_comp_sum - clb)
        index_c.create(0,n_f,0,n_f,0,n_f)
        .cd.a.l.make_gaussian_xyz_powers(components,n_f,index_c)

        CDx = CD(1); CDy = CD(2); CDz = CD(3)
        do c = 1, cub
          cx = components(1,c)
          cy = components(2,c)
          cz = components(3,c)
          c1 = index_c(cx+1,cy,cz)
          c2 = index_c(cx,cy+1,cz)
          c3 = index_c(cx,cy,cz+1)
          do e = 1, eub
            esfs_ec = esfs(e,c)
            escd(e,c,1) = esfs(e,c1) + CDx * esfs_ec
            escd(e,c,2) = esfs(e,c2) + CDy * esfs_ec
            escd(e,c,3) = esfs(e,c3) + CDz * esfs_ec
          end
        end
        components.destroy
        index_c.destroy

      case default
        clb  = (.cd.a.l-1).n_comp_sum
        eub  = (.ab.l_sum).n_comp_sum - (.ab.l_max-1).n_comp_sum
        CD   = .cd.a.pos - .cd.b.pos
        n_f  = .cd.l_sum
        cub  = (n_f-1).n_comp_sum - clb

        index_c.create(0,n_f,0,n_f,0,n_f)
        index_d.create(0,n_f,0,n_f,0,n_f)
        components.create(3, n_f.n_comp_sum)
        comp_to_use.create( n_f.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_f,index_d,comp_to_use)
        .cd.a.l.make_gaussian_xyz_power_index(index_c,n_f)
        components_c => components(:,clb+1:)

        nullify(int_new)
        int_new.create(eub,cub,3)

        CDx = CD(1); CDy = CD(2); CDz = CD(3)
        do c = 1, cub
          cx = components_c(1,c)
          cy = components_c(2,c)
          cz = components_c(3,c)
          c1 = index_c(cx+1,cy,cz)
          c2 = index_c(cx,cy+1,cz)
          c3 = index_c(cx,cy,cz+1)
          do e = 1, eub
            esfs_ec = esfs(e,c)
            int_new(e,c,1) = esfs(e,c1) + CDx * esfs_ec
            int_new(e,c,2) = esfs(e,c2) + CDy * esfs_ec
            int_new(e,c,3) = esfs(e,c3) + CDz * esfs_ec
          end
        end

        do ld=2, .cd.b.l - 1
          dlb              = (ld-1).n_comp_sum
          dub              = ld.n_comp
          cub              = (n_f-ld).n_comp_sum - clb
          component_to_use => comp_to_use(dlb+1:dlb+dub)
          components_d     => components(:,dlb+1:dlb+dub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(eub,cub,dub)
          do d=1,dub
            dx = components_d(1,d)
            dy = components_d(2,d)
            dz = components_d(3,d)
            j=component_to_use(d)
            .subtract_from_component(dx,dy,dz,j)
            d1 = index_d(dx,dy,dz)
            CDi=CD(j)
            do c=1,cub
              cx = components_c(1,c)
              cy = components_c(2,c)
              cz = components_c(3,c)
              .add_to_component(cx,cy,cz,j)
              c1 = index_c(cx,cy,cz)
              do e=1,eub
                int_new(e,c,d)=int_old(e,c1,d1)+CDi*int_old(e,c,d1)
              end
            end
          end
          int_old.destroy
        end

        dlb              = (.cd.b.l-1).n_comp_sum
        dub              = .cd.b.n_comp
        cub              = .cd.a.n_comp
        component_to_use => comp_to_use(dlb+1:dlb+dub)
        components_d     => components(:,dlb+1:dlb+dub)
        int_old          => int_new
        do d=1,dub
          dx = components_d(1,d)
          dy = components_d(2,d)
          dz = components_d(3,d)
          j=component_to_use(d)
          .subtract_from_component(dx,dy,dz,j)
          d1 = index_d(dx,dy,dz)
          CDi=CD(j)
          do c=1,cub
            cx = components_c(1,c)
            cy = components_c(2,c)
            cz = components_c(3,c)
            .add_to_component(cx,cy,cz,j)
            c1 = index_c(cx,cy,cz)
            do e=1,eub
              escd(e,c,d)=int_old(e,c1,d1)+CDi*int_old(e,c,d1)
            end
          end
        end
        int_old.destroy
        index_c.destroy
        index_d.destroy
        components.destroy
        comp_to_use.destroy
    end
  end

  transfer_l_d_highest(esfs,escd) [private]
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    MAT3* :: int_new,int_old
    IMAT* :: components,components_c,components_d
    IMAT3* :: index_c,index_d
    IVEC* :: comp_to_use,component_to_use
    VEC(3) :: DC
    INT :: c,d,c1,d1,d2,d3,lc,cub,dub
    INT :: cx,cy,cz,dx,dy,dz,j,n_f,clb,dlb,tmp,e,eub
    DBL :: DCi,DCx,DCy,DCz,esfs_ed

    select case (.cd.a.l)
      case (0)
        escd(:,1,:)=esfs

      case (1)
        dlb = (.cd.b.l-1).n_comp_sum
        eub = (.ab.l_sum).n_comp_sum - (.ab.l_max-1).n_comp_sum
        DC   = .cd.b.pos - .cd.a.pos
        n_f  = .cd.l_sum
        dub  = .cd.b.n_comp

        components.create(3, n_f.n_comp_sum - dlb)
        index_d.create(0,n_f,0,n_f,0,n_f)
        .cd.b.l.make_gaussian_xyz_powers(components,n_f,index_d)

        DCx=DC(1); DCy=DC(2); DCz=DC(3)
        do d=1,dub
          dx = components(1,d)
          dy = components(2,d)
          dz = components(3,d)
          d1 = index_d(dx+1,dy,dz)
          d2 = index_d(dx,dy+1,dz)
          d3 = index_d(dx,dy,dz+1)
          do e=1,eub
            esfs_ed = esfs(e,d)
            escd(e,1,d)=esfs(e,d1)+DCx*esfs_ed
            escd(e,2,d)=esfs(e,d2)+DCy*esfs_ed
            escd(e,3,d)=esfs(e,d3)+DCz*esfs_ed
          end
        end
        components.destroy
        index_d.destroy

      case default
        dlb = (.cd.b.l-1).n_comp_sum
        eub = (.ab.l_sum).n_comp_sum - (.ab.l_max-1).n_comp_sum
        DC   = .cd.b.pos - .cd.a.pos
        n_f  = .cd.l_sum
        dub  = (n_f-1).n_comp_sum - dlb

        index_c.create(0,n_f,0,n_f,0,n_f)
        index_d.create(0,n_f,0,n_f,0,n_f)
        components.create(3, n_f.n_comp_sum)
        comp_to_use.create( n_f.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_f,index_c,comp_to_use)
        .cd.b.l.make_gaussian_xyz_power_index(index_d,n_f)
        components_d => components(:,dlb+1:)

        nullify(int_new)
        int_new.create(eub,dub,3)
        DCx=DC(1); DCy=DC(2); DCz=DC(3)
        do d=1,dub
          dx = components_d(1,d)
          dy = components_d(2,d)
          dz = components_d(3,d)
          d1 = index_d(dx+1,dy,dz)
          d2 = index_d(dx,dy+1,dz)
          d3 = index_d(dx,dy,dz+1)
          do e=1,eub
            esfs_ed = esfs(e,d)
            int_new(e,d,1)=esfs(e,d1)+DCx*esfs_ed
            int_new(e,d,2)=esfs(e,d2)+DCy*esfs_ed
            int_new(e,d,3)=esfs(e,d3)+DCz*esfs_ed
          end
        end
        do lc=2, .cd.a.l - 1
          clb              = (lc-1).n_comp_sum
          cub              = lc.n_comp
          dub              = (n_f-lc).n_comp_sum - dlb
          component_to_use => comp_to_use(clb+1:clb+cub)
          components_c     => components(:,clb+1:clb+cub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(eub,dub,cub)
          do c=1,cub
            cx = components_c(1,c)
            cy = components_c(2,c)
            cz = components_c(3,c)
            j=component_to_use(c)
            .subtract_from_component(cx,cy,cz,j)
            c1 = index_c(cx,cy,cz)
            DCi=DC(j)
            do d=1,dub
              dx = components_d(1,d)
              dy = components_d(2,d)
              dz = components_d(3,d)
              .add_to_component(dx,dy,dz,j)
              d1 = index_d(dx,dy,dz)
              do e=1,eub
                int_new(e,d,c)=int_old(e,d1,c1)+DCi*int_old(e,d,c1)
              end
            end
          end
          int_old.destroy
        end
        clb              = (.cd.a.l-1).n_comp_sum
        cub              = .cd.a.n_comp
        dub              = .cd.b.n_comp
        component_to_use => comp_to_use(clb+1:clb+cub)
        components_c     => components(:,clb+1:clb+cub)
        int_old          => int_new
        do c=1,cub
          cx = components_c(1,c)
          cy = components_c(2,c)
          cz = components_c(3,c)
          j=component_to_use(c)
          .subtract_from_component(cx,cy,cz,j)
          c1 = index_c(cx,cy,cz)
          DCi=DC(j)
          do d=1,dub
            dx = components_d(1,d)
            dy = components_d(2,d)
            dz = components_d(3,d)
            .add_to_component(dx,dy,dz,j)
            d1 = index_d(dx,dy,dz)
            do e=1,eub
              escd(e,c,d)=int_old(e,d1,c1)+DCi*int_old(e,d,c1)
            end
          end
        end
        int_old.destroy
        index_c.destroy
        index_d.destroy
        components.destroy
        comp_to_use.destroy
    end
  end

  transfer_l_a_highest(escd,abcd) [private]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    MAT4* :: int_new,int_old
    IMAT* :: components,components_a,components_b
    IMAT3* :: index_a,index_b
    VEC(3) :: AB
    INT :: a,b,c,d,a1,a2,a3,b1,lb,aub,bub,cub,dub
    INT :: ax,ay,az,bx,by,bz,j,n_e,alb,blb,tmp
    DBL :: ABi,ABx,ABy,ABz,escd_acd
    IVEC* :: comp_to_use,component_to_use

    select case (.ab.b.l)
      case (0)
        abcd(:,1,:,:)=escd

      case (1)
        alb = (.ab.a.l-1).n_comp_sum
        AB   = .ab.a.pos - .ab.b.pos
        n_e  = .ab.l_sum
        aub  = .ab.a.n_comp
        cub  = .cd.a.n_comp
        dub  = .cd.b.n_comp

        components.create(3, n_e.n_comp_sum - alb)
        index_a.create(0,n_e,0,n_e,0,n_e)
        .ab.a.l.make_gaussian_xyz_powers(components,n_e,index_a)

        ABx=AB(1); ABy=AB(2); ABz=AB(3)
        do a=1,aub
          ax = components(1,a)
          ay = components(2,a)
          az = components(3,a)
          a1 = index_a(ax+1,ay,az)
          a2 = index_a(ax,ay+1,az)
          a3 = index_a(ax,ay,az+1)
          do d=1,dub
            do c=1,cub
              escd_acd = escd(a,c,d)
              abcd(a,1,c,d)=escd(a1,c,d) + ABx * escd_acd
              abcd(a,2,c,d)=escd(a2,c,d) + ABy * escd_acd
              abcd(a,3,c,d)=escd(a3,c,d) + ABz * escd_acd
            end
          end
        end
        index_a.destroy
        components.destroy

      case default
        alb = (.ab.a.l-1).n_comp_sum
        AB   = .ab.a.pos - .ab.b.pos
        n_e  = .ab.l_sum
        aub  = (n_e-1).n_comp_sum - alb
        bub  = .ab.b.n_comp
        cub  = .cd.a.n_comp
        dub  = .cd.b.n_comp

        index_b.create(0,n_e,0,n_e,0,n_e)
        index_a.create(0,n_e,0,n_e,0,n_e)
        components.create(3, n_e.n_comp_sum)
        comp_to_use.create( n_e.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_e,index_b,comp_to_use)
        tmp=.ab.a.l; tmp.make_gaussian_xyz_power_index(index_a,n_e)
        components_a => components(:,alb+1:)

        nullify(int_new)
        int_new.create(dub,cub,bub,aub)
        ABx=AB(1); ABy=AB(2); ABz=AB(3)
        do a=1,aub
          ax = components_a(1,a)
          ay = components_a(2,a)
          az = components_a(3,a)
          a1 = index_a(ax+1,ay,az)
          a2 = index_a(ax,ay+1,az)
          a3 = index_a(ax,ay,az+1)
          do c=1,cub
            do d=1,dub
              escd_acd = escd(a,c,d)
              int_new(d,c,1,a)=escd(a1,c,d) + ABx * escd_acd
              int_new(d,c,2,a)=escd(a2,c,d) + ABy * escd_acd
              int_new(d,c,3,a)=escd(a3,c,d) + ABz * escd_acd
            end
          end
        end

        do lb=2, .ab.b.l - 1
          blb              = (lb-1).n_comp_sum
          bub              = lb.n_comp
          aub              = (n_e-lb).n_comp_sum - alb
          component_to_use => comp_to_use(blb+1:blb+bub)
          components_b     => components(:,blb+1:blb+bub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(dub,cub,bub,aub)
          do b=1,bub
            bx = components_b(1,b)
            by = components_b(2,b)
            bz = components_b(3,b)
            j = component_to_use(b)
            .subtract_from_component(bx,by,bz,j)
            b1 = index_b(bx,by,bz)
            ABi=AB(j)
            do a=1,aub
              ax = components_a(1,a)
              ay = components_a(2,a)
              az = components_a(3,a)
              .add_to_component(ax,ay,az,j)
              a1 = index_a(ax,ay,az)
              int_new(:,:,b,a)=int_old(:,:,b1,a1) + ABi * int_old(:,:,b1,a)
            end
          end
          int_old.destroy
        end

        blb              = (.ab.b.l-1).n_comp_sum
        bub              = .ab.b.n_comp
        aub              = .ab.a.n_comp
        component_to_use => comp_to_use(blb+1:blb+bub)
        components_b     => components(:,blb+1:blb+bub)
        int_old          => int_new
        do b=1,bub
          bx = components_b(1,b)
          by = components_b(2,b)
          bz = components_b(3,b)
          j = component_to_use(b)
          .subtract_from_component(bx,by,bz,j)
          b1 = index_b(bx,by,bz)
          ABi=AB(j)
          do a=1,aub
            ax = components_a(1,a)
            ay = components_a(2,a)
            az = components_a(3,a)
            .add_to_component(ax,ay,az,j)
            a1 = index_a(ax,ay,az)
            forall (c=1:cub, d=1:dub)
              abcd(a,b,c,d)=int_old(d,c,b1,a1) + ABi * int_old(d,c,b1,a)
            end
          end
        end
        int_old.destroy
        comp_to_use.destroy
        components.destroy
        index_a.destroy
        index_b.destroy
    end
  end

  transfer_l_b_highest(escd,abcd) [private]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    MAT4* :: int_new,int_old
    IMAT* :: components,components_a,components_b
    IMAT3* :: index_a,index_b
    VEC(3) :: BA
    INT :: a,b,c,d,a1,b1,b2,b3,la,aub,bub,cub,dub
    INT :: ax,ay,az,bx,by,bz,j,n_e,alb,blb,tmp
    DBL :: BAi,BAx,BAy,BAz,escd_bcd
    IVEC* :: comp_to_use,component_to_use

    select case (.ab.a.l)
      case (0)
        abcd(1,:,:,:)=escd

      case (1)
        blb = (.ab.b.l-1).n_comp_sum
        BA   = .ab.b.pos - .ab.a.pos
        n_e  = .ab.l_sum
        bub  = .ab.b.n_comp
        cub  = .cd.a.n_comp
        dub  = .cd.b.n_comp

        components.create(3, n_e.n_comp_sum - blb)
        index_b.create(0,n_e,0,n_e,0,n_e)
        .ab.b.l.make_gaussian_xyz_powers(components,n_e,index_b)

        BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
        do b = 1, bub
          bx = components(1,b)
          by = components(2,b)
          bz = components(3,b)
          b1 = index_b(bx+1,by,bz)
          b2 = index_b(bx,by+1,bz)
          b3 = index_b(bx,by,bz+1)
          do d = 1, dub
            do c = 1, cub
              escd_bcd = escd(b,c,d)
              abcd(1,b,c,d) = escd(b1,c,d) + BAx * escd_bcd
              abcd(2,b,c,d) = escd(b2,c,d) + BAy * escd_bcd
              abcd(3,b,c,d) = escd(b3,c,d) + BAz * escd_bcd
            end
          end
        end

        components.destroy
        index_b.destroy

      case default
        blb = (.ab.b.l-1).n_comp_sum
        BA   = .ab.b.pos - .ab.a.pos
        n_e  = .ab.l_sum
        bub  = (n_e-1).n_comp_sum - blb
        aub  = .ab.a.n_comp
        cub  = .cd.a.n_comp
        dub  = .cd.b.n_comp

        index_a.create(0,n_e,0,n_e,0,n_e)
        index_b.create(0,n_e,0,n_e,0,n_e)
        components.create(3, n_e.n_comp_sum)
        comp_to_use.create( n_e.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_e,index_a,comp_to_use)
        tmp=.ab.b.l; tmp.make_gaussian_xyz_power_index(index_b,n_e)
        components_b => components(:,blb+1:)

        nullify(int_new)
        int_new.create(dub,cub,bub,aub)

        BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
        do b = 1, bub
          bx = components_b(1,b)
          by = components_b(2,b)
          bz = components_b(3,b)
          b1 = index_b(bx+1,by,bz)
          b2 = index_b(bx,by+1,bz)
          b3 = index_b(bx,by,bz+1)
          do d = 1, dub
            do c = 1, cub
              escd_bcd = escd(b,c,d)
              int_new(d,c,b,1) = escd(b1,c,d) + BAx * escd_bcd
              int_new(d,c,b,2) = escd(b2,c,d) + BAy * escd_bcd
              int_new(d,c,b,3) = escd(b3,c,d) + BAz * escd_bcd
            end
          end
        end

        do la=2, .ab.a.l - 1
          alb              = (la-1).n_comp_sum
          aub              = la.n_comp
          bub              = (n_e-la).n_comp_sum - blb
          component_to_use => comp_to_use(alb+1:alb+aub)
          components_a     => components(:,alb+1:alb+aub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(dub,cub,bub,aub)
          do a=1,aub
            ax = components_a(1,a)
            ay = components_a(2,a)
            az = components_a(3,a)
            j=component_to_use(a)
            .subtract_from_component(ax,ay,az,j)
            a1 = index_a(ax,ay,az)
            BAi=BA(j)
            do b=1,bub
              bx = components_b(1,b)
              by = components_b(2,b)
              bz = components_b(3,b)
              .add_to_component(bx,by,bz,j)
              b1 = index_b(bx,by,bz)
              int_new(:,:,b,a)=int_old(:,:,b1,a1) + BAi * int_old(:,:,b,a1)
            end
          end
          int_old.destroy
        end

        alb              = (.ab.a.l-1).n_comp_sum
        aub              = .ab.a.n_comp
        bub              = .ab.b.n_comp
        component_to_use => comp_to_use(alb+1:alb+aub)
        components_a     => components(:,alb+1:alb+aub)
        int_old          => int_new
        do a=1,aub
          ax = components_a(1,a)
          ay = components_a(2,a)
          az = components_a(3,a)
          j = component_to_use(a)
          .subtract_from_component(ax,ay,az,j)
          a1 = index_a(ax,ay,az)
          BAi=BA(j)
          do b=1,bub
            bx = components_b(1,b)
            by = components_b(2,b)
            bz = components_b(3,b)
            .add_to_component(bx,by,bz,j)
            b1 = index_b(bx,by,bz)
            forall (c=1:cub, d=1:dub)
              abcd(a,b,c,d)=int_old(d,c,b1,a1) + BAi * int_old(d,c,b,a1)
            end
          end
        end
        int_old.destroy
        comp_to_use.destroy
        components.destroy
        index_b.destroy
        index_a.destroy
    end
  end

  add_to_component(x,y,z,j) [private]
  ! Adds one to the component specified by j.  Used by transfer equation.
  ! j=1 => x=x+1, j=2 => y=y+1, j=3 => z=z+1.
    INT, INOUT :: x,y,z
    INT, IN :: j
    select case(j)
      case (1); x = x + 1
      case (2); y = y + 1
      case (3); z = z + 1
    end
  end

  subtract_from_component(x,y,z,j) [private]
  ! Subtracts one from the component specified by j.  Used by transfer equation.
  ! j=1 => x=x-1, j=2 => y=y-1, j=3 => z=z-1.
    INT, INOUT :: x,y,z
    INT, IN :: j
    select case(j)
      case (1); x = x - 1
      case (2); y = y - 1
      case (3); z = z - 1
    end
  end

  to_normalize(abcd)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for the orbitals a, b, c and d.
    IN :: self
    MAT4, target :: abcd
    VEC* :: anorm,bnorm,cnorm,dnorm
    INT :: aub,bub,cub,dub,a,b,c,d,opt
    DBL :: normb,normc,normd
    MAT* :: ab_cd

    opt = 0
    if (.ab.l_max < 2) opt = opt + 1
    if (.cd.l_max < 2) opt = opt + 2
    select case (opt)
      case (0)                                      ! The general routine.
        aub=.ab.a.n_comp
        bub=.ab.b.n_comp
        cub=.cd.a.n_comp
        dub=.cd.b.n_comp
        anorm.create(aub);   anorm.normalizing_factors( .ab.a.l )
        bnorm.create(bub);   bnorm.normalizing_factors( .ab.b.l )
        cnorm.create(cub);   cnorm.normalizing_factors( .cd.a.l )
        dnorm.create(dub);   dnorm.normalizing_factors( .cd.b.l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            normc=normd*cnorm(c)
            ab_cd => abcd(:,:,c,d)
            do b=1,bub
              normb=normc*bnorm(b)
              ab_cd(:,b)=ab_cd(:,b)*normb*anorm(:)
            end
          end
        end
        anorm.destroy; bnorm.destroy; cnorm.destroy; dnorm.destroy
      case (1)                                      ! .ab.a.l , .ab.b.l either s or p
        cub = .cd.a.n_comp
        dub = .cd.b.n_comp
        cnorm.create(cub);   cnorm.normalizing_factors( .cd.a.l )
        dnorm.create(dub);   dnorm.normalizing_factors( .cd.b.l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            abcd(:,:,c,d)=abcd(:,:,c,d)*normd*cnorm(c)
          end
        end
        cnorm.destroy; dnorm.destroy
      case (2)                                      ! .cd.a.l , .cd.b.l either s or p
        aub = .ab.a.n_comp
        bub = .ab.b.n_comp
        anorm.create(aub);   anorm.normalizing_factors( .ab.a.l )
        bnorm.create(bub);   bnorm.normalizing_factors( .ab.b.l )
        do b=1,bub
          normb=bnorm(b)
          do a=1,aub
            abcd(a,b,:,:)=abcd(a,b,:,:)*normb*anorm(a)
          end
        end
        anorm.destroy; bnorm.destroy
      case (3)                      ! .ab.a.l , .ab.b.l , .cd.a.l , .cd.b.l all s or p
        ! do nothing
    end
  end

end
