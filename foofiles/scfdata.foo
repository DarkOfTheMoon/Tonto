!---------------------------------------------------------------------------
!
!  SCFDATA: Store SCF data and deal with iteration control ......
!
!  (c) Daniel Grimwood, 1998
!
! $Id$
!---------------------------------------------------------------------------
module SCFDATA

   use TYPES
   use SYSTEM
   use STR
   use DBL
   use TEXTFILE
   use VECDIIS
   use CRYSTAL

   implicit none

#  include "macros"
#  include "scfdata.int"

!   type scfdata_type
!
!   STR :: kind
!   ! The kind of SCF calculation to perform
!
!   STR :: initial_density
!   ! The kind of density matrix to start the SCF calc
!
!   STR :: initial_mos
!   ! The kind of initial MO's to start the SCF calc
!
!   DBL :: nuclear_energy
!   ! Nuclear repulsion energy for the associated molecule
!
!   DBL :: kinetic_energy
!   ! The kinetic energy for the associated molecule
!
!   DBL :: energy
!   ! The SCF energy for the associated molecule
!
!   DBL :: old_energy
!   ! The SCF energy from the previous SCF cycle
!
!   DBL :: difference
!   ! The change in the SCF energy between cycles
!
!   DBL :: convergence
!   ! A number which measures the convergnece of the SCF
!
!   DBL :: diis_convergence
!   ! A limit below which the DIIS is deemed converged
!
!   INT :: iteration
!   ! The interation count for the SCF procedure
!
!   INT :: lambda_iteration
!   ! Lambda iteration count for the x-ray SCF procedure
!
!   INT :: min_iterations
!   ! The minimum number of SCF iterations to perform
!
!   INT :: max_iterations
!   ! The maximum number of SCF iterations to perform
!
!   DBL :: lambda
!   ! The initial lambda value to use in an x-ray SCF procedure
!
!   DBL :: lambda_max
!   ! The maximum lambda value to use in an x-ray SCF procedure
!
!   DBL :: lambda_step
!   ! The value to step the lambda value between lambda cycles in an x-ray SCF calc
!
!   DBL :: F_chi2
!   ! Chi^2 agreement statistic for an x-ray SCF calc
!
!   DBL :: F_gof
!   ! Goodness-of-fit agreement statistic for x-ray SCF calc
!
!   DBL :: F_r_factor
!   ! R-factor agreement statistic for x-ray SCF calc
!
!   DBL :: F_weighted_r_factor
!   ! The weighted r-factor agreement statistic
!
!   BIN :: direct
!   ! True if udsing direct SCF
!
!   BIN :: using_diis
!   ! True if using DIIS
!
!   BIN :: using_damping
!   ! True if using damping
!
!   BIN :: using_level_shift
!   ! True if using level shifting
!
!   VECDIIS :: diis
!   ! For (fock matrix) diis extrapolation
!
!   INT :: damp_finish
!   ! Iteration when density matrix damping is turned off
!
!   DBL :: damp_factor
!   ! The damping factor to use
!
!   DBL :: level_shift
!   ! Value to level shift the virtual orbitals
!
!   INT :: level_shift_finish
!   ! Iteration when level shifting is turned off
!
!   BIN :: output
!   ! True if output is wanted
!
!   BIN :: nddo
!   ! Neglect of diatomic differential overlap
!
!   BIN :: nudo
!   ! Neglect of unconnected differential overlap
!
!   BIN :: using_bl_term
!   ! Switch on/off the B.L term (complex SCF reqd.)
!
!   BIN :: using_bs_term
!   ! Switch on/off the B.S term
!
!   BIN :: using_bs_t_term
!   ! Switch on/off the (B.S) T_e term
!
!   BIN :: using_aa_term
!   ! Switch on/off the A.A diamagnetic term
!
!   BIN :: using_1e_sl_term
!   ! Switch on/off the 1 electron S.L term
!
!   BIN :: using_1e_srxa_term
!   ! Switch on/off the 1 electron diamagnetic term
!
!   BIN :: using_1e_zora_term
!   ! Switch on/off the 1 electron ZORA terms
!
!   DBL :: sl_1e_factor
!   ! Factor to apply to the 1-electron S.L terms
!
!   BIN :: using_2e_sl_term
!   ! Switch on/off the 2 electron S.L terms
!
!   DBL :: sl_2e_factor
!   ! Factor to apply to the 2-electron S.L terms
!
!   DBL :: eri_limit
!   ! Cutoff for the two electron integrals
!
!   BIN :: using_variable_cutoff
!   ! Using a sliding ERI cutoff for the two electron integrals
!
!   VEC(3) :: quantization_axis DEFAULT(NULL)
!   ! Quantization axis for GCHF, if using initial MO's as a guess
!
!   end

contains

!  *******************
!  Allocation routines
!  *******************

  create
  ! Create space for an SCF type
    PTR :: self
    nullify(self)
    allocate(self)
    ADD_MEM(SCFDATA_SIZE)
    .nullify_ptr_part
    .set_default
  end

  destroy
  ! Destroy space for an SCF type
    PTR :: self
    if (.destroyed) return
    .destroy_ptr_part
    DELETE_MEM(SCFDATA_SIZE)
    deallocate(self)
  end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      .diis.nullify_ptr_part
   end

   destroy_ptr_part
   ! Destroy the pointer parts of self
      .diis.destroy_ptr_part
   end

   delete_diis_archives
   ! Delete the DIIS archives on disk
     .diis.delete_archives
   end

   cleanup_diis
   ! Delete the DIIS archives on disk, and restore the DIIS object so it can be
   ! reused.  Does not go back to the default DIIS parameters.
     .diis.cleanup
   end

!  ************
!  Set routines
!  ************
 
  set_default
  ! Set default SCF data 
    .kind               = " "       ! Purposely set blank so diis comes later
    .initial_density    = "core"
    .initial_mos        = " "
    .energy             = ZERO
    .nuclear_energy     = ZERO
    .kinetic_energy     = ZERO
    .old_energy         = ZERO
    .difference         = ZERO
    .convergence        = 0.000100d0
    .diis_convergence   = 0.010000d0
    .iteration          = 0
    .min_iterations     = 0
    .max_iterations     = 100
    .direct             = FALSE
    .lambda             = 0
    .lambda_max         = 0
    .lambda_step        = 1
    .lambda_iteration   = 0
    .F_chi2               = ZERO
    .F_gof                = ZERO
    .F_r_factor           = ZERO
    .F_weighted_r_factor  = ZERO
    .direct             = FALSE
    .using_diis         = TRUE
    .diis.set_default
    .using_damping      = TRUE
    .damp_finish        = DIIS_START
    .damp_factor        = 0.5d0
    .using_level_shift  = TRUE
    .level_shift        = 0.3d0
    .level_shift_finish = DIIS_START
    .output             = TRUE
    .nddo               = FALSE
    .nudo               = FALSE
    .using_bl_term      = TRUE
    .using_bs_term      = TRUE
    .using_bs_t_term    = TRUE
    .using_aa_term      = TRUE
    .using_1e_sl_term   = TRUE
    .using_1e_srxa_term = TRUE
    .using_2e_sl_term   = TRUE
    .using_1e_zora_term = FALSE
    .sl_1e_factor       = ONE
    .sl_2e_factor       = ONE
    .eri_limit          = SCFDATA_ERI_LIMIT
    .using_variable_cutoff = TRUE
    .quantization_axis = (/ ZERO, ZERO, ONE /)
  end
 
  set(nuclear_energy,energy,kinetic_energy)
  ! Set various parts of the scfdata type.
    DBL, IN, optional :: nuclear_energy,energy,kinetic_energy
    if (present(nuclear_energy))    .nuclear_energy = nuclear_energy
    if (present(energy))            .update_energy(energy)
    if (present(kinetic_energy))    .kinetic_energy = kinetic_energy 
  end

  set_stats(crystal)
  ! Set various statistical parts of the scfdata type from a "crystal" object
    CRYSTAL, IN :: crystal
    .F_chi2 = crystal.F_chi2
    .F_gof = crystal.F_goodness_of_fit
    .F_r_factor = crystal.F_r_factor
    .F_weighted_r_factor = crystal.F_weighted_r_factor
  end

  reset(nuclear_energy,energy,kinetic_energy)
  ! Reset SCF energy and iteration data , but don't change 
  ! nuclear_energy, convergence, direct, or max_it options
     DBL, IN, optional :: nuclear_energy,energy,kinetic_energy
    .energy               = ZERO
    .kinetic_energy       = ZERO
    .old_energy           = ZERO
    .difference           = ZERO
    .iteration            = 0
    .F_chi2               = ZERO
    .F_gof                = ZERO
    .F_r_factor           = ZERO
    .F_weighted_r_factor  = ZERO
    .set(nuclear_energy,energy,kinetic_energy)
    if (present(energy)) .difference = energy
  end

  update_lambda
  ! Increments lambda by lambda_step
    .lambda = .lambda + .lambda_step
    .lambda_iteration = .lambda_iteration + 1
    .iteration      = 0
  end

  update(energy,kinetic_energy)
  ! Update the SCF energy and/or chi2 and increment iteration.
    DBL, IN, optional :: energy,kinetic_energy
    .set(energy=energy,kinetic_energy=kinetic_energy)
    .iteration = .iteration+1
  end

  update_energy(energy)
  ! Update the current SCF energy and increment iteration.
    DBL, IN :: energy
    .old_energy = .energy
    .energy = energy 
    .difference = .energy - .old_energy
  end

  set_initial_energy(energy)
  ! Set the current SCF energy
    DBL, IN :: energy
    .old_energy = .energy
    .energy = energy
    .difference = .energy - .old_energy
  end
 
  set_diis_error(err)
  ! Set the DIIS error
    DBL, IN :: err
    .diis.error_length = err
  end

  spinorbital_kind(scf_kind) result(res)
  ! Return the kind of spinorbitals used in a particular "scf_kind"
  ! (i.e. for the fock_matrix and density_matrix, but not neccesarily the mo's)
    STR(*), optional :: scf_kind
    STR :: res
    STR :: kind
    kind = .kind
    if (present(scf_kind)) kind = scf_kind 
    select case (kind)
      case("rhf","restricted_hartree_fock");      res = "restricted"
      case("rohf", &
           "restricted_open_shell_hartree_fock"); res = "unrestricted"
      case("uhf","unrestricted_hartree_fock");    res = "unrestricted"
      case("ghf","general_hartree_fock");         res = "general"
      case("rchf","crhf", &
           "restricted_complex_hartree_fock", &
           "complex_restricted_hartree_fock");    res = "restricted_complex"
      case("uchf","cuhf", &
           "unrestricted_complex_hartree_fock", &
           "complex_unrestricted_hartree_fock");  res = "unrestricted_complex"
      case("gchf","cghf", &
           "general_complex_hartree_fock", &
           "complex_general_hartree_fock");       res = "general_complex"
      case("xray_rhf", &
           "xray_restricted_hartree_fock");       res = "restricted"
      case("xray_rks");                           res = "restricted"
      case("rdvpt","restricted_dvpt");            res = "restricted"
      case default; DIE("unknown scf kind")
    end
  end

  molecular_orbital_kind(scf_kind) result(res)
  ! Return the kind of spinorbitals used for the molecular orbitals in a
  ! particular "scf_kind"
    STR(*), optional :: scf_kind
    STR :: res
    STR :: kind
     kind = .kind
    if (present(scf_kind)) kind = scf_kind 
    select case (kind)
      case("rhf","restricted_hartree_fock");      res = "restricted"
      case("rohf", &
           "restricted_open_shell_hartree_fock"); res = "restricted"
      case("uhf","unrestricted_hartree_fock");    res = "unrestricted"
      case("ghf","general_hartree_fock");         res = "general"
      case("rchf","crhf", &
           "restricted_complex_hartree_fock", &
           "complex_restricted_hartree_fock");    res = "restricted_complex"
      case("uchf","cuhf", &
           "unrestricted_complex_hartree_fock", &
           "complex_unrestricted_hartree_fock");  res = "unrestricted_complex"
      case("gchf","cghf", &
           "general_complex_hartree_fock", &
           "complex_general_hartree_fock");       res = "general_complex"
      case("xray_rhf", &
           "xray_restricted_hartree_fock");       res = "restricted"
      case("xray_rks");                           res = "restricted"
      case("rdvpt","restricted_dvpt");            res = "restricted"
      case default; DIE("unknown scf kind")
    end
  end

   orbital_energy_kind(scf_kind) result(res)
   ! Return the kind of vectors used for the orbital energies in a
   ! particular "scf_kind"
      STR(*), optional :: scf_kind
      STR :: res
      res = .orbital_energies_kind(scf_kind)
   end

   orbital_energies_kind(scf_kind) result(res)
   ! Return the kind of vectors used for the orbital energies in a
   ! particular "scf_kind"
      STR(*), optional :: scf_kind
      STR :: res
      STR :: kind
      kind = .kind
      if (present(scf_kind)) kind = scf_kind 
      select case (kind)
         case("rhf","restricted_hartree_fock");             res = "restricted"
         case("rohf","restricted_open_shell_hartree_fock"); res = "restricted"
         case("uhf","unrestricted_hartree_fock");           res = "unrestricted"
         case("ghf","general_hartree_fock");                res = "general"
         case("rchf","crhf", &
              "restricted_complex_hartree_fock", &
              "complex_restricted_hartree_fock");           res = "restricted"
         case("uchf","cuhf", &
              "unrestricted_complex_hartree_fock", &
              "complex_unrestricted_hartree_fock");         res = "unrestricted"
         case("gchf","cghf", &
              "general_complex_hartree_fock", &
              "complex_general_hartree_fock");              res = "general"
         case("xray_rhf","xray_restricted_hartree_fock");   res = "restricted"
         case("xray_rks");                                  res = "restricted"
         case("rdvpt","restricted_dvpt");                   res = "restricted"
         case default; DIE("unknown scf kind")
      end
   end

   number_kind result(res)
   ! Return the kind of numbers used for a particular "kind" of scf calculation
      STR :: res
      select case (.kind)
         case("rhf","rohf","uhf","ghf");                   res = "real"
         case("rchf","uchf","gchf");                       res = "complex"
         case("restricted_hartree_fock");                  res = "real"
         case("restricted_open_shell_hartree_fock");       res = "real"
         case("unrestricted_hartree_fock");                res = "real"
         case("general_hartree_fock");                     res = "real"
         case("restricted_complex_hartree_fock");          res = "complex"
         case("unrestricted_complex_hartree_fock");        res = "complex"
         case("general_complex_hartree_fock");             res = "complex"
         case("xray_rhf","xray_restricted_hartree_fock");  res = "real"
         case("xray_rks");                                 res = "real"
         case("rdvpt","restricted_dvpt");                  res = "real"
         case default; DIE("unknown scf kind")
      end
   end

!  **************
!  Input routines
!  **************

   read(input)
      TEXTFILE, target, optional :: input
      TEXTFILE* :: in
      STR :: word
      if (present(input)) then; in => input
      else;                     in => stdin
      end
      .set_default
      in.read(word)
      ENSURE(word=="{","expecting open bracket symbol, {")
      read_loop : do
         in.read(word)
         word.to_lower_case
         select case (word)
            case("}");                      exit read_loop
            case("scf_kind=");              in.read(.kind)
            case("scf_type=");              in.read(.kind)
            case("kind=");                  in.read(.kind) 
            case("initial_guess=");         in.read(.initial_density)
            case("guess=");                 in.read(.initial_density)
            case("initial_density=");       in.read(.initial_density)
            case("initial_mos=");           in.read(.initial_mos)
            case("min_iterations=");        in.read(.min_iterations)
            case("min_it=");                in.read(.min_iterations)
            case("max_iterations=");        in.read(.max_iterations)
            case("max_it=");                in.read(.max_iterations)
            case("convergence=");           in.read(.convergence)
            case("converge=");              in.read(.convergence)
            case("direct=");                in.read(.direct)
            case("use_diis=");              in.read(.using_diis)
            case("diis=");                  in.read(.using_diis)
            case("diis_convergence=");      in.read(.diis_convergence)
            case("grad_convergence=");      in.read(.diis_convergence)
            case("diis_keep=");             .diis.set_keep( in.next_int)
            case("diis_start=");            .diis.set_start( in.next_int)
            case("use_damping=");           in.read(.using_damping)
            case("damp_finish=");           in.read(.damp_finish)
            case("damp_factor=");           in.read(.damp_factor)
            case("initial_lambda=");        in.read(.lambda)
            case("lambda_min=");            in.read(.lambda)
            case("lambda_max=");            in.read(.lambda_max)
            case("lambda_step=");           in.read(.lambda_step)
            case("use_level_shift=");       in.read(.using_level_shift)
            case("use_level_shifting=");    in.read(.using_level_shift)
            case("level_shift=");           in.read(.level_shift)
            case("level_shift_finish=");    in.read(.level_shift_finish)
            case("output=");                in.read(.output)
            case("nddo=");                  in.read(.nddo)
            case("nudo=");                  in.read(.nudo)
            case("use_b."//"l_term=");      in.read(.using_bl_term)
            case("use_b."//"s_term=");      in.read(.using_bs_term)
            case("use_b."//"s_t_term=");    in.read(.using_bs_t_term)
            case("use_a."//"a_term=");      in.read(.using_aa_term)
            case("use_1e_s."//"l_term=");   in.read(.using_1e_sl_term)
            case("use_1e_s."//"rxa_term="); in.read(.using_1e_srxa_term)
            case("use_2e_s."//"l_term=");   in.read(.using_2e_sl_term)
            case("use_1e_zora_term=");      in.read(.using_1e_zora_term)
            case("1e_s."//"l_factor=");     in.read(.sl_1e_factor)
            case("s."//"l_1e_factor=");     in.read(.sl_1e_factor)
            case("2e_s."//"l_factor=");     in.read(.sl_2e_factor)
            case("s."//"l_2e_factor=");     in.read(.sl_2e_factor)
            case("eri_cutoff=");            in.read(.eri_limit)
            case("eri_limit=");             in.read(.eri_limit)
            case("use_variable_cutoff=");   in.read(.using_variable_cutoff)
            case("use_auto_cutoff=");       in.read(.using_variable_cutoff)
            case("quantization_axis=");     in.read(.quantization_axis)
            case default;            DIE("unknown keyword, " // word.trim)
         end 
      end do read_loop
      ENSURE(.kind/="","no scf kind specified")
      ENSURE(.max_iterations>=.min_iterations,"max_it must be greater than min_it!")
      if (.initial_mos/=" ")   .initial_density = "--using MO's--"
      if (.using_1e_zora_term) .using_1e_sl_term = FALSE
      if (.using_1e_sl_term)   .using_1e_zora_term = FALSE
   end

!  *****
!  Tests
!  *****

   scf_done result(res)
   ! Return TRUE if the scf procedure is done
      BIN :: res
      res = (.converged OR .exceeded_max_it) AND .exceeded_min_it
   end

   scf_not_done result(res)
   ! Return TRUE if the scf procedure is *not*done
      BIN :: res
      res = NOT .scf_done
   end

   converged result(res)
   ! Return TRUE if the SCFDATA appears to be converged
      BIN :: res
      res = .diff_converged AND .diis_converged AND (.iteration>1)
   end

   diff_converged result(res)
   ! Return TRUE if the energy difference has converged
      BIN :: res
      res = abs(.difference) < .convergence 
   end

   diis_converged result(res)
   ! Return TRUE if the gradient/DIIS error has converged
      BIN :: res
      res = abs(.diis_error) < .diis_convergence
   end

   diis_error result(res)
   ! Return a numerical measure of the diis error
      DBL :: res
      res = .diis.error_length
   end

   exceeded_max_it result(res)
   ! Return TRUE if the SCFDATA has exceeded the maximum iterations
      BIN :: res
      res = .iteration >= .max_iterations
   end

   exceeded_min_it result(res)
   ! Return TRUE if the SCFDATA has exceeded the minimum iterations
      BIN :: res
      res = .iteration >= .min_iterations
   end

   exceeded_lambda_max result(res)
   ! Return TRUE if the SCFDATA has exceeded the maximum lambda
      BIN :: res
      res = .lambda > (ONE+TOL(10)) * .lambda_max
                         ! TOL(10) allows for roundoff errors
   end

  eri_cutoff result(res)
  ! Return a value to eliminate small integrals in direct SCF calculations
    DBL :: res,res1
    if (.using_variable_cutoff) then
      if (.iteration<1) then
         res = SCFDATA_INITIAL_ERI_LIMIT
      else
         if (.diis_error <= ZERO) then
           res1 = SCFDATA_INITIAL_ERI_LIMIT
         else
           res1 = min(SCFDATA_INITIAL_ERI_LIMIT,TEN**(log10(.diis_error**2)-8))
         end
         res = max(.eri_limit,res1)
      end
    else
      res = .eri_limit
    end
  end

!  **********************
!  DIIS tests. Be careful
!  **********************

   diis_used result(res)
   ! Return TRUE if DIIS extrapolation has *really* been used this iteration
   ! (The first time doesn't really count, see apply_diis below for that case) 
      BIN :: res
      if (NOT .using_diis) then
         res = FALSE
      else                   
         res = (.iteration > .diis.start) AND .diis.keep > 1
      end
   end

   diis_not_used result(res)
   ! Return TRUE if DIIS extrapolation has NOT really been used this iteration
   ! (The first time doesn't really count)
      BIN :: res
      res = NOT .diis_used
   end

   apply_diis result(res)
   ! Return TRUE if DIIS extrapolation must be, or has been applied this
   ! iteration
      BIN :: res
      if (NOT .using_diis) then; res = FALSE
      else;                      res = (.iteration >= .diis.start) AND .diis.keep > 1
      end
   end

   skip_diis result(res)
   ! Return TRUE if DIIS extrapolation must NOT be applied this iteration
      BIN :: res
      res = NOT .apply_diis
   end

   apply_damping result(res)
   ! Return TRUE if density matrix damping is to be applied this iteration
      BIN :: res
      res = .using_damping AND .iteration < .damp_finish
   end

   apply_level_shifting result(res)
   ! Return TRUE if level shifting must be applied this iteration
      BIN :: res
      res = .level_shift.is_not_zero &
            AND .using_level_shift AND .iteration < .level_shift_finish
   end

  fitting result(res)
  ! Return true if we are fitting the wavefunction.
    BIN :: res
    select case (.kind)
      case("xray_rhf","xray_restricted_hartree_fock");   res = TRUE
      case("xray_rks");                                  res = TRUE
      case default;                                      res = FALSE
    end
  end

!  ***************
!  Output routines
!  ***************

  put_banner
  ! Prints out the nuclear energy and initial guess energy.
    if (NOT .output) return
    stdout.flush
    stdout.text("***************")
    stdout.text("SCF calculation")
    stdout.text("***************")
    stdout.flush
    .put_summary
  end

  put_summary
  ! Prints out a summary of what is stored in the scfdata object.
    VEC(3) :: q
    BIN :: dbl_width
    dbl_width = TRUE
    stdout.show("SCF kind                  = ", .kind)
    stdout.show("Direct                    = ", .direct,dbl_width)
    stdout.show("Using variable cutoff     = ", .using_variable_cutoff,dbl_width)
    stdout.set_dbl_style("e")
    stdout.show("Integral cutoff           = ", .eri_limit)
    stdout.set_dbl_style("f")
    if (.nddo) &
    stdout.show("NDDO                      = ", .nddo,dbl_width)
    stdout.show("ZORA (1 electron) terms   = ", .using_1e_zora_term,dbl_width)
    stdout.flush
    stdout.text("Initial guess options:")
    stdout.flush
    stdout.show("Initial density           = ", .initial_density)
    stdout.show("Initial MO's              = ", .initial_mos)
    stdout.flush
    stdout.text("Initial guess energies:")
    stdout.flush
    stdout.show("Nuclear Energy            = ", .nuclear_energy)
    stdout.show("SCF Energy                = ", .energy)
    stdout.show("Kinetic Energy            = ", .kinetic_energy)
    stdout.flush
    stdout.text("SCF termination criteria:")
    stdout.flush
    stdout.show("Convergence               = ", .convergence)
    stdout.show("Gradient/DIIS convergence = ", .diis_convergence)
    stdout.show("Minimum iterations        = ", .min_iterations,dbl_width)
    stdout.show("Maximum iterations        = ", .max_iterations,dbl_width)
    stdout.flush
    stdout.text("Convergence acceleration options:")
    stdout.flush
    stdout.show("Using level shift         = ", .using_level_shift,dbl_width)
    if (.using_level_shift) then
    stdout.show("Level shift               = ", .level_shift)
    stdout.show("Level shift  quits at     = ", .level_shift_finish,dbl_width)
    end
    stdout.show("Using density damping     = ", .using_damping,dbl_width)
    if (.using_damping) then
    stdout.show("Damping factor            = ", .damp_factor)
    stdout.show("Damping quits at          = ", .damp_finish,dbl_width)
    end
    stdout.show("Using DIIS                = ", .using_diis,dbl_width)
    if (.using_diis) then
    stdout.show("DIIS archive root name    = ", .diis.archive.root_name)
    stdout.show("DIIS no. to keep          = ", .diis.keep,dbl_width)
    stdout.show("DIIS start iteration      = ", .diis.start,dbl_width)
    end
    if (.spinorbital_kind=="general_complex") then
      stdout.flush
      stdout.text("Magnetic/Relativistic terms:")
      stdout.flush
      q = .quantization_axis
      stdout.show("Quantization axis         = ", q(1),q(2),q(3))
      stdout.show("ZORA (1 electron) terms   = ", .using_1e_zora_term)
      stdout.show("Using B:L term            = ", .using_bl_term)
      stdout.show("Using B:S term            = ", .using_bs_term)
      stdout.show("Using B:S T term          = ", .using_bs_t_term)
      stdout.show("Using A:A term            = ", .using_aa_term)
      stdout.show("Using 1e S:L term         = ", .using_1e_sl_term)
      stdout.show("Using 1e S:(rxA) term     = ", .using_1e_srxa_term)
      stdout.show("Using 2e S:L term         = ", .using_2e_sl_term)
      stdout.show("Factor for 1e S:L term    = ", .sl_1e_factor)
      stdout.show("Factor for 2e S:L term    = ", .sl_2e_factor)
    end
    if (.fitting) then
      stdout.flush
      stdout.text("Experimental wavefunction parameters:")
      stdout.show("Lambda fitting parameter  = ", .lambda)
      stdout.show("Lambda max                = ", .lambda_max)
      stdout.show("Lambda step               = ", .lambda_step)
      .put_crystal
    end
    stdout.flush
  end

  put_table_head
  ! Prints out the table head for an SCF calculation
    INT :: fields
    if (NOT .output) return
    fields = 3
    if (.fitting)     fields = fields + 2
    stdout.dash(dbl_fields=fields,int_fields=1)
    stdout.put("Iter",int_width=TRUE)
    if (.fitting) then
      stdout.put("lambda")
      stdout.put("F_chi2")
    end
    stdout.put("Energy")
    stdout.put("Difference")
    stdout.put("Gradient/DIIS")
    stdout.flush
    stdout.dash(dbl_fields=fields,int_fields=1)
  end

  put_results
  ! Print out the results for the current iteration. This routine must be 
  ! compatible with put_banner. This routine must be called at iteration 0.
    INT :: fields
    BIN, save :: diis_converged,diff_converged,damping_on,damping_off
    BIN, save :: level_on,level_off,diis_on,diis_up
    STR :: info
    if (NOT .output) return
    ! This is the table head ...
    if (.iteration == 0) then
       if (.lambda_iteration < 1) .put_table_head
       diff_converged = FALSE
       diis_converged = FALSE
       damping_on = FALSE
       damping_off = FALSE
       level_on = FALSE
       level_off = FALSE
       diis_on = FALSE
       diis_up = FALSE
    end
    stdout.put(.iteration)
    fields = 3
    if (.fitting) then
       fields = fields + 2
       stdout.put(.lambda)
       stdout.put(.F_chi2)
    end
    ! This is the important info ...
    stdout.put(.energy)
    stdout.put(.difference)
    stdout.put(.diis_error)
    ! Margin notes ...
    if (.scf_not_done) then
       if (NOT diff_converged AND .diff_converged) then
          stdout.put_text(" *Difference has converged")
          diff_converged = TRUE
       else if (NOT diis_converged AND .diis_converged) then
          stdout.put_text(" *Gradient has converged")
          diis_converged = TRUE
       else 
          info = " "
          if ((.using_damping AND NOT damping_on AND .apply_damping)) then
             info = trim(info)//" *Damping on"
             damping_on = TRUE
          end
          if ((.using_level_shift AND NOT level_on AND .apply_level_shifting)) then
             info = trim(info)//" *Levelshift on"
             level_on = TRUE
          end
          if ((.using_diis AND NOT diis_on AND .apply_diis)) then
             info = trim(info)//" *DIIS on"
             diis_on = TRUE
          end
          if ((.using_damping AND NOT damping_off AND NOT .apply_damping)) then
             info = trim(info)//" *Damping off"
             damping_off = TRUE
          end
          if ((.using_level_shift AND NOT level_off AND NOT .apply_level_shifting)) then
             info = trim(info)//" *Levelshift off"
             level_off = TRUE
          end
          if ((.using_diis AND NOT diis_up AND .apply_diis AND .diis.n_vec==.diis.keep)) then
             info = trim(info)//" *DIIS subspace saturated"
             diis_up = TRUE
          end
          stdout.put_text(info)
       end
       stdout.flush
    ! This is the table foot ...
    else
       .put_table_foot
    end
  end

  put_table_foot
  ! Prints out the table foot for an SCF calculation, after convergence
  ! or not as the case may be
    INT :: fields
    if (NOT .output) return
    fields = 3
    if (.fitting)     fields = fields + 2
    stdout.flush
    stdout.dash(dbl_fields=fields,int_fields=1)
    if (.converged) then; stdout.text("* * * SCF has converged * * *",flush=1)
    else;                 stdout.text("* * * SCF has not converged * * *",flush=1)
    end
    stdout.dash(dbl_fields=fields,int_fields=1)
    .put_energy
    .put_kinetic_energy
    if (.fitting) .put_crystal
    stdout.dash(dbl_fields=fields,int_fields=1)
  end

  put_energy
  ! Prints out the SCF energy.
    stdout.show("SCF Energy               = ", .energy)
  end

  put_kinetic_energy
  ! Prints out the kinetic energy.
    stdout.show("Kinetic Energy           = ", .kinetic_energy)
  end

  put_crystal
  ! Prints out the crystal structure factor statistics.
    stdout.show("Chi^2 in F               = ", .F_chi2)
    stdout.show("Goodness of fit in F     = ", .F_gof)
    stdout.show("R factor in F            = ", .F_r_factor)
    stdout.show("Weighted R factor in F   = ", .F_weighted_r_factor)
  end

end 
