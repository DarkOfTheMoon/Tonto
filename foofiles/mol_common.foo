! $Id$
!-------------------------------------------------------------------------------
!
! MOL: these routines required by several modules in mol.
!
module MOL_COMMON

   use TYPES
   use ERROR
   use MM

   use STR
   use VEC
   use IVEC
   use MAT
   use CMAT

   use OPMAT
   use OPVEC
   use OUTPUT
   use ARCHIVE

   use SCFDATA
   use SHELL
   use SHELL1
   use SHELL2
   use SHELL4

   use PLOTGRID
   use DFTGRID
   use ATOMVEC
   use BASIS
   use BASISVEC
   use POINTGROUP
   use XTAL

   implicit none         

#  include "macros"
#  include "mol_common.int"

!  type mol_type
!     STR             :: name                    ! Name of molecule
!     INPUT, PTR      :: in                      ! Input file
!     OUTPUT, PTR     :: out                     ! Output file
!     VEC(3)          :: B_field                 ! Applied magnetic field in atomic units
!     VEC(3)          :: E_field                 ! Applied electric field in atomic units
!     XTAL, PTR       :: xtal                    ! Crystal symmetry of the enclosing crystal
!     POINTGROUP, PTR :: pointgroup              ! Pointgroup symmetry of the molecule
!     ATOMVEC, PTR    :: atom                    ! List of atoms
!     BASISVEC, PTR   :: basis                   ! List of basis sets
!     PLOTGRID, PTR       :: grid                ! An enclosing rectangular grid for the molecule, for plots
!     INT :: charge                              ! Electric charge molecule
!     INT :: mult                                ! Spin multiplicity of molecule
!     INT :: thermal_smearing_model              ! Thermal smearing model for ft integrals
!     INT :: n_e                                 ! No of electrons
!     INT :: n_a                                 ! No of alpha electrons
!     INT :: n_b                                 ! No of beta electrons
!     INT :: n_atom                              ! No of atoms
!     INT :: n_basis                             ! No of basis sets
!     INT :: n_shell                             ! Total number of shells in the molecular basis set
!     INT :: n_shell_pairs                       ! Total number of shell pairs in the molecular basis set
!     INT :: n_shell_quartets                    ! Total number of shell quartets in the molecular basis set
!     INT :: n_bf                                ! Total number of basis functions in the molecular basis set
!     INT :: n_prim                              ! Total number of primitives in the molecular basis set
!     IVEC, PTR    :: atom_for_shell             ! Atom index for molecular shell index array
!     IVEC, PTR    :: atom_shell_for_shell       ! Atom shell index for molecular shell index array
!     IVEC, PTR    :: first_shell_for_atom       ! First molecule shell index for an atom
!     IVEC, PTR    :: first_basis_fn_for_shell   ! First basis function for a given shell
!     IVEC, PTR    :: last_basis_fn_for_shell    ! Last basis function for a given shell
!     SCFDATA, PTR :: scfdata                    ! SCF data object
!     OPVEC, PTR   :: orbital_energies           ! The orbital energies
!     OPMAT, PTR   :: molecular_orbitals         ! The (real) molecular orbitals
!     OPMAT, PTR   :: density_matrix             ! The real density matrix
!     OPMAT, PTR   :: natural_orbitals           ! The natural orbitals
!     OPVEC, PTR   :: occupation                 ! The associated occupation numbers
!     OPMAT, PTR   :: fock_matrix                ! The real fock matrix
!     STR          :: partition_model            ! Model for partitioning fragments of the molecule
!     VEC, PTR     :: partition_factors          ! Partitioning factors for each atom
!  end 

contains

!  **************************
!  Create and destroy methods
!  **************************

   create 
   ! Create a molecule object
      PTR :: self
      allocate(self)
      .nullify_ptr_part
      .set_defaults
      std_mm.add(MOL_SIZE)
   end

   destroy 
   ! Destroy a molecule object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      deallocate(self)
      std_mm.delete(MOL_SIZE)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the molecule
      nullify(.in)
      nullify(.out)
      nullify(.xtal)
      nullify(.pointgroup)
      nullify(.atom)
      nullify(.basis)
      nullify(.grid)
      nullify(.dftgrid)
      nullify(.atom_for_shell)
      nullify(.atom_shell_for_shell)
      nullify(.first_shell_for_atom)
      nullify(.first_basis_fn_for_shell)
      nullify(.last_basis_fn_for_shell)
      nullify(.scfdata)
      nullify(.orbital_energies)
      nullify(.molecular_orbitals)
      nullify(.density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation)
      nullify(.fock_matrix)
      nullify(.partition_factors)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of a molecule object
      .in.destroy
      .out.destroy
      .xtal.destroy
      .pointgroup.destroy
      .atom.nullify_basis_part ! nullify this !
      .atom.destroy
      .basis.destroy
      .grid.destroy
      .dftgrid.destroy
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .scfdata.destroy
      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation.destroy
      .fock_matrix.destroy
      .partition_factors.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has not been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_defaults
   ! Set up a default molecule
      .B_field = ZERO
      .E_field = ZERO
      .charge = 0
      .partition_model = ""
      .mult = 1
      .thermal_smearing_model = 0
      .optimise_thermals = FALSE
      if ( .atom.created) then
        .mult = .atom.default_multiplicity
        .set_atom_info
      end
   end

   set_atom_info
   ! Set the associated atom information
      .n_atom = .no_of_atoms
      .n_e = .no_of_electrons
      .n_a = .no_of_alpha_electrons
      .n_b = .no_of_beta_electrons
   end

   resolve_basis_labels [leaky]
   ! Match the basis set labels for every atom with the actual atomic basis set.
   ! Also perform any initialization procedures to finalise all data objects
      if ( .basis.destroyed) return
      if ( .atom.destroyed) return
      if ( .atom.basis_not_all_labeled) return
      .atom.resolve_basis_labels(.basis)
      .n_basis = .no_of_basis_sets
      .set_basis_info
   end

   set_basis_info [leaky]
   ! Set the associated basis set information
      .n_basis = .no_of_basis_sets
      .n_bf = .no_of_basis_functions
      .n_prim = .no_of_primitives
      .n_shell = .no_of_shells
      .n_shell_pairs = .no_of_shell_pairs
      .n_shell_quartets = .no_of_shell_quartets
      .molecular_orbitals.create( .n_bf)
      .orbital_energies.create( .n_bf)
      .density_matrix.create( .n_bf)
      .natural_orbitals.create( .n_bf)
      .occupation.create( .n_bf)
      .fock_matrix.create( .n_bf)
      .make_shell_info
   end

   assign_natural_orbitals
   ! Assign the natural orbitals to be the molecular_orbitals 
      STR :: kind
      .natural_orbitals => .molecular_orbitals
      kind = .natural_orbitals.spinorbital_kind
      .occupation.create(kind)
      .occupation.zero
      select case ( .molecular_orbitals.spinorbital_kind)
         case ("restricted")
            .occupation%restricted(1:.n_a) = TWO
         case ("unrestricted")
            .occupation%alpha(1:.n_a) = ONE
            .occupation%beta(1:.n_b) = ONE
         case ("general")
            .occupation%general(1:.n_e) = ONE
         case ("restricted_complex")
            .occupation%restricted(1:.n_a) = TWO
         case ("unrestricted_complex")
            .occupation%alpha(1:.n_a) = ONE
            .occupation%beta(1:.n_b) = ONE
         case ("general_complex")
            .occupation%general(1:.n_e) = ONE
      end
   end

!  ***************************
!  ATOMVEC information methods
!  ***************************
 
   nuclear_energy result(res)
   ! Return the nuclear repulsion energy
      DBL :: res
      res = .atom.nuclear_energy
   end

   chemical_formula result(res)
   ! Return the chemical formula for the molecule, as a string, in alphabetical 
   ! order of elements
      STR :: res
      res = .atom.chemical_formula
   end

   centre_of_mass result(centre)
   ! Return the centre of mass
      VEC(3) :: centre
      centre = .atom.centre_of_mass
   end

   move_origin_to_centre_of_mass
   ! Move the origin to the centre of mass
      VEC(3) :: com
      INT :: a
      com = .atom.centre_of_mass
      do a = 1,.n_atom
         .atom(a)%pos = .atom(a)%pos - com
      end
   end

   molecular_weight result(res)
   ! Return the molceular weight
      DBL:: res
      res = .atom.molecular_weight
   end

   reduced_mass result(res)
   ! Return the reduced mass
      DBL:: res
      res = .atom.reduced_mass
   end

   centre_of_atoms result(centre)
   ! Return the centroid of the atom positions
      VEC(3) :: centre
      centre = .atom.centre_of_atoms
   end

   atom_index_from_pos(pos) result(res)
   ! Return the index of atom from its position "pos"
      VEC(3) :: pos
      INT :: res
      res = .atom.atom_index_from_pos(pos)
   end

!  ********************************
!  ATOMVEC shell extraction methods
!  ********************************

   get_shell(index,shell) [leaky]
   ! Get basis set shell "index" in "sh" 
      INT, IN :: index
      SHELL, OUT :: shell
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy( .atom(aa)%basis%shell(sa) )
   end

   get_shell1(index,shell) [leaky]
   ! Update the shell1 "shell".
      INT, IN :: index
      SHELL1, OUT :: shell
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy(shell=.atom(aa)%basis%shell(sa),pos=.atom(aa)%pos)
   end

   get_shell1(index,shell,fa,la) [leaky]
   ! Update the shell1 "shell".
      INT, IN :: index
      SHELL1, OUT :: shell
      INT, OUT :: fa,la
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)
      shell.copy(shell=.atom(aa)%basis%shell(sa),pos=.atom(aa)%pos)
   end

   get_shell_pair(index,shell,a,b) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: a,b
      INT :: aa,sa,bb,sb
      .get_shell_pair(index,a,b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy( .atom(aa)%basis%shell(sa), .atom(bb)%basis%shell(sb), &
                  .atom(aa)%pos, .atom(bb)%pos )
   end

   get_shell_pair(index,a,b,fa,la,fb,lb) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      INT, OUT :: a,b,fa,la,fb,lb
      .get_shell_pair(index,a,b)
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end

   get_shell_pair(index,shell,fa,la,fb,lb) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: fa,la,fb,lb
      INT :: a,b,aa,sa,bb,sb
      .get_shell_pair(index,a,b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy( .atom(aa)%basis%shell(sa), .atom(bb)%basis%shell(sb), &
                  .atom(aa)%pos, .atom(bb)%pos )
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end

   get_shell_pair(index,shell,a,b,fa,la,fb,lb) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: a,b,fa,la,fb,lb
      INT :: aa,sa,bb,sb
      .get_shell_pair(index,a,b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy( .atom(aa)%basis%shell(sa), .atom(bb)%basis%shell(sb), &
                  .atom(aa)%pos, .atom(bb)%pos )
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end

   get_shell_pair(index,shell,a,b,fa,la,fb,lb,atom_a,atom_b) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Plus the atoms the shells are located on, "atom_a" and "atom_b".
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: a,b,fa,la,fb,lb,atom_a,atom_b
      INT :: sa,sb
      .get_shell_pair(index,a,b)
      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy( .atom(atom_a)%basis%shell(sa), .atom(atom_b)%basis%shell(sb), &
                  .atom(atom_a)%pos, .atom(atom_b)%pos )
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end
 
   get_shell_pair(index,a,b)
     INT, IN :: index
     INT, OUT :: a,b
     a  = (1+sqrt(8.0d0*index-7.0d0))/2
     b  = index - a*(a-1)/2
   end

   get_shell_quartet(index,a,b,c,d)
   ! Get the indexes a,b,c,d of the quartet from the "index".
   ! Note that "index" will die at 365 shells for integer(4).
     INT, IN :: index
     INT, OUT :: a,b,c,d
     INT :: ab,cd
     ab = (1+sqrt(8.0d0*index-7.0d0))/2
     cd = index - ab*(ab-1)/2
     a  = (1+sqrt(8.0d0*ab-7.0d0))/2
     b  = ab - a*(a-1)/2
     c  = (1+sqrt(8.0d0*cd-7.0d0))/2
     d  = cd - c*(c-1)/2
   end

   get_shell_quartet(index,shell,a,b,c,d) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d
      INT :: aa,sa,bb,sb,cc,sc,dd,sd
      .get_shell_quartet(index,a,b,c,d)
      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy( .atom(aa)%basis%shell(sa), .atom(bb)%basis%shell(sb), &
                  .atom(cc)%basis%shell(sc), .atom(dd)%basis%shell(sd), &
                  .atom(aa)%pos, .atom(bb)%pos, .atom(cc)%pos, .atom(dd)%pos )
   end

   get_shell_quartet(index,shell,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld
      .get_shell_quartet(index,shell,a,b,c,d)
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)
   end

   get_shell_quartet(index,fa,la,fb,lb,fc,lc,fd,ld) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      INT, OUT :: fa,la,fb,lb,fc,lc,fd,ld
      INT :: a,b,c,d
      .get_shell_quartet(index,a,b,c,d)
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)
   end

   get_shell_quartet(index,shell,a,b,c,d,atom_a,atom_b,atom_c,atom_d) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Plus the atoms which the shells are on.
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d,atom_a,atom_b,atom_c,atom_d
      .get_shell_quartet(index,shell,a,b,c,d)
      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
      atom_c = .atom_for_shell(c)
      atom_d = .atom_for_shell(d)
   end

   make_contraction_matrix(cc_mat)
   ! Returns the matrix of complete contraction coefficients for each basis set
   ! Size of cc_mat is [.n_prim,.n_bf].
      MAT, OUT :: cc_mat
      INT :: a, bf_count, prim_count
      ENSURE(size(cc_mat,1)== .n_prim,"dimensions of contraction matrix not correct")
      ENSURE(size(cc_mat,2)== .n_bf,"dimensions of contraction matrix not correct")
      bf_count = 1
      prim_count = 1
      cc_mat.zero
      do a = 1, .n_atom
         cc_mat( prim_count : prim_count + .atom(a)%basis%n_prim - 1, bf_count : bf_count + .atom(a)%basis%n_bf - 1) &
                  = .atom(a)%basis.contraction_matrix
         prim_count = prim_count + .atom(a)%basis%n_prim
         bf_count = bf_count + .atom(a)%basis%n_bf
      end
   end
   

!  **********************
!  Make shell information
!  **********************

   make_shell_info [leaky]
   ! Define a vector of atom numbers corresponding to the molecule 
   ! basis set shell numbers; also define a vector of atom shell numbers 
   ! corresponding to the molecule basis set shell number
      .atom_for_shell       => .atom.atom_for_shell
      .atom_shell_for_shell => .atom.atom_shell_for_shell
      .first_shell_for_atom => .atom.first_shell_for_atom
      .atom.get_shell_limits(.first_basis_fn_for_shell, .last_basis_fn_for_shell)
   end

!  **********************
!  Density matrix methods
!  **********************

   make_scf_density_matrix(damp) [leaky]
   ! Make the density matrix from the molecular orbitals. If "damp" is present
   ! use it to damp the updated density matrix.
      BIN, optional :: damp
      BIN :: use_damping
      OPMAT, PTR :: D_old
      MAT, PTR :: MO,D,MOa,MOb,Da,Db
      CMAT, PTR :: CMO,CD,CMOa,CMOb,CDa,CDb
      ARCHIVE :: archive
      STR :: kind
      DBL :: mix
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .molecular_orbitals.created, "no molecular orbitals")
      if ( .scfdata.destroyed) then;                 use_damping = FALSE
      else if ( .density_matrix.all_destroyed) then; use_damping = FALSE
      else
         use_damping = .scfdata.use_damping
         if (present(damp)) use_damping = damp
      end
      D_old.create(.n_bf)
      if (use_damping) D_old.set_to(.density_matrix)
      if ( .scfdata.destroyed) then; kind = .molecular_orbitals.spinorbital_kind
      else;                          kind = .scfdata.spinorbital_kind
      end
      .density_matrix.destroy(kind)
      .density_matrix.create(kind)
      archive.set(.name,"density_matrix",kind)
      if ( .scfdata.destroyed) then; kind = .molecular_orbitals.guess_scf_kind
      else;                          kind = .scfdata%kind
      end
      select case (kind)
          case ("rhf","restricted_hartree_fock", &
                "xray_rhf","xray_constrained_restricted_hartree_fock", &
                "xray_fit","xray_constrained")
            DIE_IF(.mult/=1,"this is not a singlet state")
            MO => .molecular_orbitals%restricted(:,1:.n_a)
            D  => .density_matrix%restricted
            D.to_product(MO,MO,transpose_b=TRUE)
            D = TWO*D
         case ("rohf","restricted_open_shell_hartree_fock")
            MOa => .molecular_orbitals%restricted(:,1:.n_a)
            MOb => .molecular_orbitals%restricted(:,1:.n_b)
            Da => .density_matrix%alpha
            Db => .density_matrix%beta
            Da.to_product(MOa,MOa,transpose_b=TRUE)
            Db.to_product(MOb,MOb,transpose_b=TRUE)
         case ("uhf","unrestricted_hartree_fock")
            MOa => .molecular_orbitals%alpha(:,1:.n_a)
            MOb => .molecular_orbitals%beta(:,1:.n_b)
            Da => .density_matrix%alpha
            Db => .density_matrix%beta
            Da.to_product(MOa,MOa,transpose_b=TRUE)
            Db.to_product(MOb,MOb,transpose_b=TRUE)
         case ("ghf","general_hartree_fock")
            DIE_IF(.mult/=1,"this is not a singlet state")
            MO => .molecular_orbitals%general(:,1:.n_e)
            D =>  .density_matrix%general
            D.to_product(MO,MO,transpose_b=TRUE)
         case ("rchf","restricted_complex_hartree_fock")
            CMO => .molecular_orbitals%restricted_complex(:,1:.n_a)
            CD  => .density_matrix%restricted_complex
            CD.to_product(CMO,CMO,dagger_b=TRUE)
            CD = TWO*CD
         case ("uchf","unrestricted_complex_hartree_fock")
            CMOa => .molecular_orbitals%alpha_complex(:,1:.n_a)
            CMOb => .molecular_orbitals%beta_complex(:,1:.n_b)
            CDa => .density_matrix%alpha_complex
            CDb => .density_matrix%beta_complex
            CDa.to_product(CMOa,CMOa,dagger_b=TRUE)
            CDb.to_product(CMOb,CMOb,dagger_b=TRUE)
         case ("gchf","general_complex_hartree_fock")
            CMO => .molecular_orbitals%general_complex(:,1:.n_e)
            CD =>  .density_matrix%general_complex
            CD.to_product(CMO,CMO,dagger_b=TRUE)
      end
      if (use_damping) then
         mix = .scfdata%damp_factor
         select case (kind)
            case ("rhf","restricted_hartree_fock", &
                  "xray_rhf","xray_constrained_restricted_hartree_fock")
               D = (1-mix)*D + mix*D_old%restricted
            case ("rohf","restricted_open_shell_hartree_fock")
               Da = (1-mix)*Da + mix*D_old%alpha
               Db = (1-mix)*Db + mix*D_old%beta
            case ("uhf","unrestricted_hartree_fock")
               Da = (1-mix)*Da + mix*D_old%alpha
               Db = (1-mix)*Db + mix*D_old%beta
            case ("ghf","general_hartree_fock")
               D = (1-mix)*D + mix*D_old%general
            case ("rchf","restricted_complex_hartree_fock")
               CD = (1-mix)*CD + mix*D_old%restricted_complex
            case ("uchf","unrestricted_complex_hartree_fock")
               CDa = (1-mix)*CDa + mix*D_old%alpha_complex
               CDb = (1-mix)*CDb + mix*D_old%beta_complex
            case ("gchf","general_complex_hartree_fock")
               CD = (1-mix)*CD + mix*D_old%general_complex
        end
      end
      D_old.destroy
      archive.write(.density_matrix)
   end

   make_ao_density_matrix [leaky]
   ! Make the AO (spin independent) density matrix from the existing density matrix
   ! The result is placed in the "restricted" part of the density matrix
      STR :: kind
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if ( kind=="restricted") return
      if ( kind=="restricted_complex") return
      if ( kind.includes("complex")) then
         .density_matrix.destroy("restricted_complex")
         .density_matrix.create("restricted_complex")
      else
         .density_matrix.destroy("restricted")
         .density_matrix.create("restricted")
      end
      select case (kind)
         case ("unrestricted")
            .density_matrix%restricted = .density_matrix%alpha + .density_matrix%beta
         case ("general")
            .density_matrix%restricted = .density_matrix%general.alpha_alpha &
                                       + .density_matrix%general.beta_beta 
         case ("unrestricted_complex")
            .density_matrix%restricted_complex = .density_matrix%alpha_complex &
                                               + .density_matrix%beta_complex
         case ("general_complex")
            .density_matrix%restricted_complex = .density_matrix%general_complex.alpha_alpha &
                                               + .density_matrix%general_complex.beta_beta 
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   make_ao_sz_density_matrix
   ! Make the AO (spin independent) density matrix from the existing density matrix
   ! The result is placed in the "restricted" part of the density matrix
      STR :: kind
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if ( kind=="restricted") return
      if ( kind.includes("complex")) then
         .density_matrix.destroy("restricted_complex")
         .density_matrix.create("restricted_complex")
      else
         .density_matrix.destroy("restricted")
         .density_matrix.create("restricted")
      end
      select case (kind)
         case ("unrestricted")
            .density_matrix%restricted = .density_matrix%alpha - .density_matrix%beta
         case ("general")
            .density_matrix%restricted = .density_matrix%general.alpha_alpha &
                                       - .density_matrix%general.beta_beta 
         case ("unrestricted_complex")
            .density_matrix%restricted_complex = .density_matrix%alpha_complex &
                                               - .density_matrix%beta_complex
         case ("general_complex")
            .density_matrix%restricted_complex = .density_matrix%general_complex.alpha_alpha &
                                               - .density_matrix%general_complex.beta_beta 
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   make_scf_density_matrix(n,nb)
   ! Make the density matrix from orbital "n" of the molecular orbitals. 
   ! If present, orbital "nb" of the beta molecular orbitals is used.
   ! If either index is not an occupied MO, the density is set to zero.
      INT :: n
      INT, optional :: nb
      MAT, PTR :: MO,D,MOa,MOb,Da,Db
      CMAT, PTR :: CMO,CD,CMOa,CMOb,CDa,CDb
      STR :: kind
      ARCHIVE :: archive
      INT :: m
      BIN :: uhf
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .molecular_orbitals.created, "no molecular orbitals")
      uhf = .scfdata%kind.includes("unrestricted")
      if (present(nb)) WARN_IF( NOT uhf, "nb ignored")
      m = n
      if (present(nb)) m = nb
      kind = .scfdata.spinorbital_kind
      .density_matrix.destroy(kind)
      .density_matrix.create(kind)
      archive.set(.name,"density_matrix",kind)
      kind = .scfdata%kind
      select case (kind)
         case ("rhf","restricted_hartree_fock", &
               "xray_rhf","xray_constrained_restricted_hartree_fock", &
               "xray_fit","xray_constrained")
            DIE_IF(.mult/=1,"this is not a singlet state")
            D  => .density_matrix%restricted
            if (n>0 AND n<=.n_a) then
               MO => .molecular_orbitals%restricted(:,n:n)
               D.to_product(MO,MO,transpose_b=TRUE)
               D = TWO*D
            else
               D = ZERO
            end 
         case ("rohf","restricted_open_shell_hartree_fock")
            Da => .density_matrix%alpha
            Db => .density_matrix%beta
            if (n>0 AND n<=.n_b) then
               MOa => .molecular_orbitals%restricted(:,n:n)
               MOb => .molecular_orbitals%restricted(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
               Db.to_product(MOb,MOb,transpose_b=TRUE)
            else if (n>nb AND n<=.n_a) then
               MOa => .molecular_orbitals%restricted(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
               Db = ZERO
            else
               Da = ZERO
               Db = ZERO
            end
         case ("uhf","unrestricted_hartree_fock")
            Da => .density_matrix%alpha
            Db => .density_matrix%beta
            if (n>0 AND n<=.n_a) then
               MOa => .molecular_orbitals%alpha(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
            else
               Da = ZERO
            end
            if (m>0 AND m<=.n_b) then
               MOb => .molecular_orbitals%beta(:,m:m)
               Db.to_product(MOb,MOb,transpose_b=TRUE)
            else
               Db = ZERO
            end
         case ("ghf","general_hartree_fock")
            DIE_IF(.mult/=1,"this is not a singlet state")
            D =>  .density_matrix%general
            if (n>0 AND n<=.n_e) then
               MO => .molecular_orbitals%general(:,n:n)
               D.to_product(MO,MO,transpose_b=TRUE)
            else
               D = ZERO
            end 
         case ("rchf","restricted_complex_hartree_fock")
            CD  => .density_matrix%restricted_complex
            if (n>0 AND n<=.n_a) then
               CMO => .molecular_orbitals%restricted_complex(:,n:n)
               CD.to_product(CMO,CMO,dagger_b=TRUE)
               CD = TWO*CD
            else
               CD = ZERO
            end 
         case ("uchf","unrestricted_complex_hartree_fock")
            CDa => .density_matrix%alpha_complex
            CDb => .density_matrix%beta_complex
            if (n>0 AND n<=.n_a) then
               CMOa => .molecular_orbitals%alpha_complex(:,n:n)
               CDa.to_product(CMOa,CMOa,dagger_b=TRUE)
            else 
               CDa = ZERO
            end
            if (m>0 AND m<=.n_b) then
               CMOb => .molecular_orbitals%beta_complex(:,m:m)
               CDb.to_product(CMOb,CMOb,dagger_b=TRUE)
            else 
               CDb = ZERO
            end
         case ("gchf","general_complex_hartree_fock")
            CD =>  .density_matrix%general_complex
            if (n>0 AND n<=.n_e) then
               CMO => .molecular_orbitals%general_complex(:,n:n)
               CD.to_product(CMO,CMO,dagger_b=TRUE)
            else
               CD = ZERO
            end 
      end
      archive.write(.density_matrix)
   end


!****************************
!* Overlap Matrix formation *
!****************************


  get_overlap_matrix(S)
  ! Set "S" to the overlap matrix. 
  ! If the archive file exists, read it; otherwise make it.
     MAT :: S
     ARCHIVE :: archive
     archive.set(.name,"overlap_matrix")
     if ( archive.exists) then; archive.read(S)
     else;                      .make_overlap_matrix(S)
     end
  end
 
  make_overlap_matrix(S)
  ! Calculate the overlap matrix "S"
    MAT, target :: S
    INT :: q,fa,la,fb,lb,a,b,atom_a,atom_b
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    S = ZERO
    if (.scfdata%NDDO) then
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (atom_a==atom_b) then
          shell.make_overlap(S(fa:la,fb:lb))
        else
          S(fa:la,fb:lb) = ZERO
        end
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        shell.make_overlap(S(fa:la,fb:lb))
        shell.destroy_ptr_part
      end
    end
    S.make_symmetric
    archive.set(.name,"overlap_matrix")
    archive.write(S)
  end

!  ***************
!  Inquiry methods
!  ***************

   no_of_electrons result(res) 
   ! Work out and return the number of electrons in the molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      res = 0
      do a = 1,.no_of_atoms
         res = res + .atom(a)%atomic_number
      end
      res = res - .charge
   end

   no_of_alpha_electrons result(res) 
   ! Work out and return the number of alpha electrons in the molecule
      INT :: res
      res = (.no_of_electrons+.mult-1)/2
   end

   no_of_beta_electrons result(res) 
   ! Work out and return the number of alpha electrons in the molecule
      INT :: res
      res = (.no_of_electrons-.mult+1)/2
   end

   no_of_atoms result(res) 
   ! Return the number of atoms in the molecule
      INT :: res
      ENSURE( .atom.created,  "no atom list")
      res = size(.atom)
   end

   no_of_basis_sets result(res) 
   ! Return the number of distinct atomic basis sets for the molecule
      INT :: res
      ENSURE( .atom.basis_resolved, "no basis set")
      res = size(.basis)
   end

   no_of_shells result(res) 
   ! Work out and return the number of gaussian shells in the basis set for the molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      res = 0
      do a = 1,.n_atom
         res = res + .atom(a)%basis%n_shell
      end
   end

   no_of_shell_pairs result(res) 
   ! Return the number of shell pairs in the basis set for the molecule
      INT :: res
      INT :: n_shell
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      n_shell = .no_of_shells
      res = n_shell*(n_shell+1)/2
   end

   no_of_shell_quartets result (res)
   ! Return the number of shell quartets in the basis set for the molecule
      INT :: res
      res = .n_shell_pairs*(.n_shell_pairs+1)/2
   end

   no_of_basis_functions result (res)
   ! Work out and return the number of basis functions in the basis set for the molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      res = 0
      do a = 1,.n_atom
         res = res + .atom(a)%basis%n_bf
      end
   end

   no_of_primitives result (res)
   ! Work out and return the number of primitives in the basis set for the molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      res = 0
      do a= 1,.n_atom
         res = res + .atom(a)%basis%n_prim
      end
   end

   no_of_occupied_NOs(kind,tol) result (res)
   ! Returns the number of non-zero occupied natural orbitals. For this purpose, 
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      STR, optional :: kind
      DBL, optional :: tol
      INT :: res
      STR :: itemkind
      DBL :: eps
      INT :: n,n_bf
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .occupation.created, "no occupation numbers")
      itemkind = .occupation.spinorbital_kind
      if (present(kind)) itemkind=kind
      eps = TOL(7)
      if (present(tol)) eps = tol 
      select case (itemkind)
         case ("restricted")
            n_bf = .occupation%n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation%restricted(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case ("unrestricted")
            n_bf = .occupation%n_bf
            res = 2*n_bf
            do n = 1,n_bf
               if (.occupation%alpha(n)<eps) then
                  res = n-1
                  exit
               end
            end
            do n = 1,n_bf
               if (.occupation%beta(n)<eps) then
                  res = res + n-1
                  exit
               end
            end
         case ("general")
            n_bf = 2*.occupation%n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation%general(n)<eps) then
                  res = n-1
                  exit
               end
            end
      end
   end

   maximum_basis_set_l_value result (res)
   ! Returns the maximum basis set l value
      INT :: res
      INT :: i,j,l
      res = 0 
      do i = 1,size(.basis)
         do j = 1,size(.basis(i)%shell)
            l = .basis(i)%shell(j)%l
            res = max(l,res)
         end
      end
   end

!  ****************
!  Natural orbitals
!  ****************

   make_natural_orbitals [leaky]
   ! Make the natural orbitals from the density matrix
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      select case ( .density_matrix.spinorbital_kind)
         case ("restricted");         .make_restricted_NOs
         case ("unrestricted");       .make_unrestricted_NOs
!        case ("general");            .make_general_NOs
         case ("restricted_complex"); .make_restricted_complex_NOs
         case ("general_complex");    .make_general_complex_NOs
      end
   end

   make_restricted_NOs [leaky]
   ! Make the restricted natural orbitals from the density matrix
      ENSURE( .density_matrix%restricted.created, "no density matrix")
      .natural_orbitals.destroy("restricted")
      .natural_orbitals.create("restricted")
      .occupation.destroy("restricted")
      .occupation.create("restricted")
      .make_r_NOs(.natural_orbitals%restricted,.occupation%restricted,.density_matrix%restricted)
   end

   make_unrestricted_NOs [leaky]
   ! Make the unrestricted natural orbitals from the density matrix
      ENSURE( .density_matrix%alpha.created, "no density matrix")
      ENSURE( .density_matrix%beta.created, "no density matrix")
      .natural_orbitals.destroy("unrestricted")
      .natural_orbitals.create("unrestricted")
      .occupation.destroy("unrestricted")
      .occupation.create("unrestricted")
      .make_r_NOs(.natural_orbitals%alpha,.occupation%alpha,.density_matrix%alpha)
      .make_r_NOs(.natural_orbitals%beta, .occupation%beta, .density_matrix%beta)
   end

   make_r_NOs(NO,occupation,P)
   ! Make the real natural orbitals "NO" and "occupation" numbers from the density matrix "P"
      MAT :: NO,P
      VEC :: occupation
      MAT, PTR :: V,X,S
      V.create( .n_bf, .n_bf)
      X.create( .n_bf, .n_bf)
      S.create( .n_bf, .n_bf); .get_overlap_matrix(S)
      V.to_sqrt(S)
      X = P
      X.change_basis(V)
      X.solve_eigenproblem(occupation,V)
      X.to_inverse_sqrt(S)
      NO = matmul(X,V)
      occupation = occupation(.n_bf:1:-1)
      occupation.zero_small_values(TOL(10))
      NO = NO(:,.n_bf:1:-1)
      S.destroy
      X.destroy
      V.destroy
   end

  make_restricted_complex_NOs [leaky]
  ! Make the restricted complex natural orbitals from the density matrix
    CMAT, PTR :: V,X
    MAT, PTR  :: S,O

    ENSURE( .density_matrix%restricted_complex.created, &
             "no density matrix")
    .natural_orbitals.destroy("restricted_complex")
    .natural_orbitals.create("restricted_complex")
    .occupation.destroy("restricted")
    .occupation.create("restricted")
    V.create( .n_bf, .n_bf)
    X.create( .n_bf, .n_bf)
    S.create( .n_bf, .n_bf); .get_overlap_matrix(S)
    O.create( .n_bf, .n_bf); O.to_sqrt(S)
    V = O
    X = .density_matrix%restricted_complex
    X.change_basis(V)
    X.solve_eigenproblem(.occupation%restricted,V)
    O.to_inverse_sqrt(S)
    X = O
    O.destroy
    .natural_orbitals%restricted_complex = matmul(X,V)
    .occupation%restricted = .occupation%restricted(.n_bf:1:-1)
    .occupation%restricted.zero_small_values(TOL(10))
    .natural_orbitals%restricted_complex = .natural_orbitals%restricted_complex(:,.n_bf:1:-1)
    S.destroy
    X.destroy
    V.destroy
  end

   make_general_complex_NOs [leaky]
   ! Make the general natural orbitals and occupations from the complex density matrix
      MAT, PTR :: S,R
      CMAT, PTR :: V,X
      ENSURE( .density_matrix%general_complex.created, "no density matrix")
      .natural_orbitals.destroy("general_complex")
      .natural_orbitals.create("general_complex")
      .occupation.destroy("general")
      .occupation.create("general")
      V.create( 2*.n_bf, 2*.n_bf)
      X.create( 2*.n_bf, 2*.n_bf)
      S.create( .n_bf, .n_bf)
      R.create( .n_bf, .n_bf)
      .get_overlap_matrix(S)
      R.to_sqrt(S)
      V.set_alpha_alpha(R)
      V.set_beta_beta(R)
      X = .density_matrix%general_complex
      X.change_basis(V)
      X.solve_eigenproblem(.occupation%general,V)
      R.to_inverse_sqrt(S)
      X.set_alpha_alpha(R)
      X.set_beta_beta(R)
      .natural_orbitals%general_complex = matmul(X,V)
      .occupation%general = .occupation%general(2*.n_bf:1:-1)
      .occupation%general.zero_small_values(TOL(10))
      .natural_orbitals%general = .natural_orbitals%general(:,2*.n_bf:1:-1)
      S.destroy
      X.destroy
      V.destroy
   end

!  ***************************
!  Population Analysis Methods
!  ***************************
   
   make_mulliken_matrix
   ! sets the mulliken population matrix and the outputs it.
      MAT, PTR :: mulliken_matrix, S
      VEC, PTR :: diagonals
      S.create( .n_bf, .n_bf)
      mulliken_matrix.create( .n_bf, .n_bf)
      diagonals.create( .n_bf)
      .get_overlap_matrix(S)
      mulliken_matrix = matmul( .density_matrix%restricted, S)
      mulliken_matrix.get_diagonal( diagonals)
      .put_mulliken_populations( mulliken_matrix, diagonals)
      S.destroy
      mulliken_matrix.destroy
      diagonals.destroy
   end
   
   put_mulliken_populations( mulliken_matrix, diagonals)
   ! outputs the mulliken populations to mol.out
      MAT :: mulliken_matrix      
      VEC :: diagonals
      DBL :: sum
      INT :: o_count, a, b, c
      .out.flush
      .out.text( "Mulliken population analysis: ")
      .out.dash(int_fields=2,dbl_fields=1)
      .out.put( "Atom", int_width = TRUE)
      .out.put( "Type", int_width = TRUE)
      .out.put( "Population")
      .out.flush
      .out.dash(int_fields=2,dbl_fields=1)
      o_count = 1
      do a = 1, .n_atom
         do b = 1, .atom.n_shell_for_atom(a)
            do c = 1, .atom(a)%basis%shell(b)%n_comp
               .out.put( .atom(a)%label, int_width = TRUE)
               .out.put( .atom(a)%basis%shell(b).l_chr, int_width = TRUE)
               .out.put( diagonals(c + o_count - 1))
               .out.flush
            end
            o_count = o_count + .atom(a)%basis%shell(b)%n_comp
         end
      end
      .out.flush
      .out.text( "Trace of the matrix: ")
      .out.put( mulliken_matrix.trace )
      .out.flush
      .out.text( "Atomic Populations: ")
      .out.dash(int_fields=1, dbl_fields=1)
      .out.put( "Atom", int_width = TRUE)
      .out.put( "Population")
      .out.flush
      .out.dash(int_fields=1, dbl_fields=1)
      o_count = 1
      do a = 1, .n_atom
         .out.put( .atom(a)%label, int_width = TRUE)
         sum = 0
         do b = 1, .atom.n_shell_for_atom(a)
            sum = sum + diagonals(b - 1 + o_count)
         end
         .out.put( sum)
         .out.flush
         o_count = o_count + .atom.n_bf_for_atom(a)
      end
   end

end 
