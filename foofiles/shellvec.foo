! $Id$
!---------------------------------------------------------------------------
!  SHELLVEC: SHELL vectors
!  (c) dylan jayatilaka, 1998
!---------------------------------------------------------------------------
module SHELLVEC

   use TYPES
   use SYSTEM
   use STR
   use TEXTFILE
   use SHELL

   implicit none

#  include "macros"
#  include "shellvec.int"

contains

!  ******************
!  Allocation methods
!  ******************

   create(dim)
   ! Create space for a shell vector
      PTR :: self
      INT :: dim
      nullify(self)
      allocate(self(dim))
      ADD_MEM(dim*SHELL_SIZE)
      .nullify_ptr_part
   end

   destroy
   ! Destroy space for a string vector
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(size(self)*SHELL_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify pointer parts of self
      INT :: s
      do s = 1,size(self)
         self(s).nullify_ptr_part
      end
   end

   destroy_ptr_part
   ! Destroy pointer parts of self
      INT :: s
      do s = 1,size(self)
         self(s).destroy_ptr_part 
      end
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

!  *************
!  Input methods
!  *************

   read(in) [leaky]
   ! Create and read a shellvec from file "in"
      PTR :: self
      TEXTFILE :: in
      INT :: line,item,n_shell,i
      STR :: word
      SHELL, PTR :: sh
      line = in.line_number                 ! Store line & item number
      item = in.next_line_item              ! The line item the cursor lies *before*
      n_shell = 0
      do                                    ! Read ahead for the number of shells
         in.read(word)
         word.to_lower_case
         if (word=="end") exit
         in.move_to_previous_item
         n_shell = n_shell + 1
         sh.create
         sh.read(in)
         sh.destroy
      end
      self.create(n_shell)                  ! Allocate the whole shell array
      in.move_to_line(line)                 ! Move back to the start of the basis set
      in.move_to_line_item(item)
      do i = 1,n_shell                      ! Read the basis set
         self(i).read(in)    
      end
      in.read(word)
      word.to_lower_case
      DIE_IF(word/="end","end keyword wrongly positioned")
   end

   maximum_l_value result(res)
   ! Return the maximum l value in the shell vector
      INT :: res
      INT :: n
      res = 0
      do n = 1,size(self)
         res = max(res,self(n)%l)
      end
   end
      
end 
