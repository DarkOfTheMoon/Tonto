!---------------------------------------------------------------------------
!
!  VEC{STR}: String vectors
!
!  Notes
!
!  Normally, a STR variable means a character string of length STR_SIZE.
!  However, in this module we use assumed length character strings.
!  Note also that ELEMENT_TYPE_SIZE is defind as "len(self(1))*CHR_SIZE".
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module VEC{STR}

   implicit none

contains

! *****************
! Memory allocation
! *****************

   create(dim) ::: get_from(VEC{INTRINSIC}), leaky
   ! Create space for object
      self :: PTR
      dim :: INT, IN
   end

   create(lb,ub) ::: get_from(VEC{INTRINSIC}), leaky
   ! Create the vector with lower bound "lb", upper bound "ub"
      self :: PTR
      lb,ub :: INT, IN
   end

   create(bounds) ::: get_from(VEC{INTRINSIC}), leaky
   ! Create the vector with "bounds"
      self :: PTR
      bounds :: VEC{INT}(2), IN
   end

   destroy ::: get_from(VEC{INTRINSIC}), leaky
   ! Destroy space for object
      self :: PTR
   end

   create_copy(v) ::: get_from(VEC{INTRINSIC}), leaky
   ! Create a copy of vector "v".
      self :: PTR
      v :: VEC{STR}, IN
   end

   copy(v) ::: get_from(VEC{INTRINSIC})
   ! Copy vector "v".
      v :: VEC{STR}, IN
   end

   created result(res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

! ******************
! Size-of operations
! ******************

   size result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo
   ! Return the size of the array
      res :: INT
   end

   dim result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo
   ! Return the size of the 1st dimension
      res :: INT
   end

! ***********************
! Shrinking and expansion
! ***********************

   shrink(dim) ::: get_from(VEC{INTRINSIC}), leaky
   ! Shrink self to dimension dim.  Contents are retained.
     self :: PTR
     dim :: INT, IN
   end

   expand(dim) ::: get_from(VEC{INTRINSIC}), leaky
   ! Expand self to dimension dim. New slots are left undefined.
     self :: PTR
     dim :: INT, IN
   end

   append(v) ::: get_from(VEC{INTRINSIC}), leaky
   ! Expands self and appends the contents of vector "v".
     self :: PTR
     v :: VEC{STR}, IN
   end

   append(value) ::: get_from(VEC{INTRINSIC}), leaky
   ! Expands self by 1, and appends the single scalar "value" onto the end.
     self :: PTR
     value :: STR, IN
   end

   append_only_if_unique(value) ::: get_from(VEC{INTRINSIC}), leaky
   ! Expands self by 1, and appends the single scalar "value" onto the end, but
   ! only if the "value" is unique
     self :: PTR
     value :: STR, IN
   end

   prepend(v) ::: get_from(VEC{INTRINSIC}), leaky
   ! Prepend the vector "v" to "self". "self" is expanded.
     self :: PTR
     v :: VEC{STR}, IN
   end

   prepend(value) ::: get_from(VEC{INTRINSIC}), leaky
   ! Prepend an single "value" to "self". "self" is expanded.
     self :: PTR
     value :: STR, IN
   end

   join(v) result (res) ::: get_from(VEC{INTRINSIC}), leaky
   ! Yield a vector which is the concatenation of "self" and "v"
     v :: VEC{STR}, IN
     res :: VEC{STR}(len=len(self(1)))*
   end

   join(v1,v2) result (res) ::: get_from(VEC{INTRINSIC}), leaky
   ! Yield a vector which is the concatenation of "self" and "v1" and "v2"
     v1,v2 :: VEC{STR}, IN
     res :: VEC{STR}(len=len(self(1)))*
   end

   prune(values) ::: get_from(VEC{INTRINSIC}), leaky
   ! Removes the scalar "values" from the vector, if they are there.
   ! The order of the elementsis otherwise unchanged.
     self :: PTR
     values :: VEC{STR}, IN
   end

   prune(value) ::: get_from(VEC{INTRINSIC}), leaky
   ! Removes the single scalar "value" from the vector, if it is there.
   ! The order of the elementsis otherwise unchanged.
     self :: PTR
     value :: STR, IN
   end

! ********************
! Comparison functions
! ********************

   equals(v) result(res) ::: get_from(VEC{INTRINSIC})
   ! Return true if "self" is the same as "v".
      self :: IN
      v :: VEC{STR}, IN
      res :: BIN
   end

   same_as(v) result(res) ::: get_from(VEC{INTRINSIC})
   ! Return true if "self" is the same as "v".
      self :: IN
      v :: VEC{STR}, IN
      res :: BIN
   end

! *****************************
! Repetition related operations
! *****************************

   remove_repetitions ::: get_from(VEC{OBJECT}), leaky
   ! Sort through the vector and remove repeated elements which come later in
   ! the list.  NOTE: the vector may shrink
      self :: PTR
   end

   has_repetitions result (res) ::: get_from(VEC{OBJECT})
   ! Return TRUE if self has at least one repeated element.
      res :: BIN
   end

   no_of_unique_elements result (res) ::: get_from(VEC{OBJECT}), pure
   ! Return the number of unique elements in the vector.
      self :: IN
      res :: INT
   end

! ****************
! Sorting routines
! ****************

   sort(decreasing_order) ::: get_from(VEC{OBJECT})
   ! Sort array "self" from lowest to highest, using simple insertion sort.  If
   ! "decreasing_order" is present and TRUE sort from highest to lowest instead.
   end

   quick_sort(decreasing_order) ::: get_from(VEC{OBJECT})
   ! Sort the vector into increasing order.If "decreasing_order" is present and
   ! TRUE, the vector is sorted from largest to smallest
   end

   quick_sort_increasing ::: get_from(VEC{OBJECT}), recursive, private
   ! Sort the vector into order, smallest to largest
   end

   quick_sort_decreasing ::: get_from(VEC{OBJECT}), recursive, private
   ! Sort the vector into order, largest to smallest
   end

   quick_sort(indices,decreasing_order) ::: get_from(VEC{OBJECT})
   ! Return the "indices" which sort self from smallest to largest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
   ! If "decreasing_order" is present and TRUE, the indices are sorted from
   ! largest to smallest
   end

   quick_sort_increasing(indices) ::: get_from(VEC{OBJECT}), recursive, private
   ! Return the indices which sort vector from smallest to largest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
   end

   quick_sort_decreasing(indices) ::: get_from(VEC{OBJECT}), recursive, private
   ! Return the indices which sort vector from largest to smallest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
   end

   reverse_order ::: get_from(VEC{INTRINSIC})
   ! Reverse the order of the elements of self
   end

   swap_elements(e1,e2) ::: get_from(VEC{INTRINSIC}), pure
   ! Swap elements "e1" and "e2" in "self".
      self :: INOUT
      e1,e2 :: INT, IN
   end

! *****************************************
! Inclusion and matching related operations
! *****************************************

   has_any_included_in(string,at_start) result(res)
   ! Return TRUE if self has any element included in "string" which starts at
   ! the start of the "string", provided "at_start" is TRUE; otherwise
   ! returns TRUE even if the match was not at the start.
      string :: STR, IN
      at_start :: BIN, optional
      res :: BIN
      first :: BIN
      first = FALSE
      if (present(at_start)) first = at_start
      if (first) then
         res = any(index(spread(string,1,.dim),self) == 1)
      else
         res = any(index(spread(string,1,.dim),self) /= 0)
      end
   end

   index_of_first_included_in(string) result(res)
   ! Return the index of the first element in self which is included in
   ! "string", or zero otherwise.
      string :: STR, IN
      res :: INT
      i :: INT
      res = 0
      do i = 1,size(self)
         res = index(string,self(i))
         if (res>0) exit
      end
   end

   has_any_including(string) result(res)
   ! Return TRUE if self has any element which includes "string".
      string :: STR, IN
      res :: BIN
      res = any(index(self,spread(string,1,.dim)) /= 0)
   end

   includes(string,at_start) result(res)
   ! Return TRUE for a particular element, if that element of self includes "string".
   ! Returns FALSE if no element matches. If "at_start" is present and TRUE, then the
   ! result is TRUE only if the item matches at the start of the string.
      string :: STR, IN
      at_start :: BIN, optional
      res :: VEC{BIN}(size(self))
      first :: BIN
      first = FALSE
      if (present(at_start)) first = at_start
      if (first) then
         res = index(self,spread(string,1,.dim)) == 1
      else
         res = index(self,spread(string,1,.dim)) /= 0
      end
   end

   index_of_first_that_includes(string) result(res)
   ! Return the index of the first element of self that includes "string".
   ! Returns 0 if no element matches.
      string :: STR, IN
      res :: INT
      i :: INT
      do i = 1,.dim
         res = index(self(i),string)
         if (res==0) cycle
         res = i
         exit
      end
   end

   index_of(string) result(res)
   ! Return the first index of the "string" in self.
   ! Returns 0 if no element matches.
      string :: STR, IN
      res :: INT
      i :: INT
      res = 0
      do i = 1,.dim
         if (self(i)/=string) cycle
         res = i
         exit
      end
   end

   index_of_matching_bracket(symbol) result(res)
   ! Return the first index of the matching bracket "symbol" in self.
   ! The first element of self need not be an opening bracket symbol.
      symbol :: STR, IN
      res :: INT
   ENSURE(any(symbol==opening),"unrecognised open bracket symbol")
   ENSURE(.index_of(symbol)>0,"no open bracket symbol in self")
   ENSURE(.index_of(symbol)<.dim,"open bracket is at end of self")
      opening :: VEC{STR}(len=1,4) = ["{","(","\[","<"]
      closing :: VEC{STR}(len=1,4) = ["}",")","\]",">"]
      op,cl :: STR(1)
      i,s,n :: INT
      op = symbol
      cl = closing(opening.index_of(symbol))
      s = .index_of(op)
      n = 0
      do i = s+1,.dim
         if (self(i)==op) n = n + 1
         if (self(i)==cl AND n==0) exit
         if (self(i)==cl AND n>0) n = n - 1
      end
      ENSURE(n==0,"unmatching number of closing bracket symbols")
      res = i
   end

! **********
! Misc stuff
! **********

   to_lower_case
   ! Change upper case charaters to lower case in all elements
       i :: INT
      do i = 1,size(self)
         self(i).to_lower_case
      end
   end

   to_upper_case
   ! Change lower case charaters to upper case in all elements
       i :: INT
      do i = 1,size(self)
         self(i).to_upper_case
      end
   end

   replace_all(a,b)
   ! Replace all occurences of string "a" by "b". String "b" can be zero
   ! length, however, replacements only occur up to the last nonblank
   ! character in "self" i.e. up to len_trim(self).
      a,b :: STR
      i :: INT
      do i = 1,size(self)
         self(i).replace_all(a,b)
      end
   end

   remove_blanks
   ! Replace all blanks by moving all non-blank characters leftwards
      i :: INT
      do i = 1,size(self)
         self(i).remove_blanks
      end
   end

end
