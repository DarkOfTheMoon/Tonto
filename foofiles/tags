!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	0	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
cube3	adaptive_quadrature.foo	/^   cube3 :: MAT{INT}(3,27), private$/;"	g
corners	adaptive_quadrature.foo	/^   corners :: VEC{INT}(8), private$/;"	g
non_corners	adaptive_quadrature.foo	/^   non_corners :: VEC{INT}(19), private$/;"	g
subcube	adaptive_quadrature.foo	/^   subcube :: MAT{INT}(8,8), private$/;"	g
bcc3	adaptive_quadrature.foo	/^   bcc3 :: MAT{INT}(3,35), private$/;"	g
bcc	adaptive_quadrature.foo	/^   bcc :: VEC{INT}(9), private$/;"	g
non_bcc	adaptive_quadrature.foo	/^   non_bcc :: VEC{INT}(26), private$/;"	g
subbcc	adaptive_quadrature.foo	/^   subbcc :: MAT{INT}(9,8), private$/;"	g
e0	adaptive_quadrature.foo	/^   e0 :: VEC{INT}(3), private = [0,0,0]$/;"	g
e1_fs	adaptive_quadrature.foo	/^   e1_fs :: MAT{INT}(3,6), private $/;"	g
e2_fs	adaptive_quadrature.foo	/^   e2_fs :: MAT{INT}(3,12), private $/;"	g
e3_fs	adaptive_quadrature.foo	/^   e3_fs :: MAT{INT}(3,8), private $/;"	g
create	adaptive_quadrature.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	adaptive_quadrature.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	adaptive_quadrature.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	adaptive_quadrature.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	adaptive_quadrature.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	adaptive_quadrature.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	adaptive_quadrature.foo	/^   set_defaults $/;"	r
set_accuracy	adaptive_quadrature.foo	/^   set_accuracy(accuracy)$/;"	r
set_algorithm	adaptive_quadrature.foo	/^   set_algorithm(alg)$/;"	r
set_limits	adaptive_quadrature.foo	/^   set_limits(limits)$/;"	r
set_lower_limit	adaptive_quadrature.foo	/^   set_lower_limit(limit)$/;"	r
set_upper_limit	adaptive_quadrature.foo	/^   set_upper_limit(limit)$/;"	r
set_T53	adaptive_quadrature.foo	/^   set_T53 ::: leaky, private$/;"	r
set_HS58	adaptive_quadrature.foo	/^   set_HS58 ::: leaky, private$/;"	r
set_GM80	adaptive_quadrature.foo	/^   set_GM80 ::: leaky, private$/;"	r
adaptive_integrate	adaptive_quadrature.foo	/^   adaptive_integrate(func) result (res)$/;"	r
adaptive_trapezoid_integrate	adaptive_quadrature.foo	/^   adaptive_trapezoid_integrate(func) result (res) ::: private$/;"	r
adaptive_trapezoid_integrate	adaptive_quadrature.foo	/^   adaptive_trapezoid_integrate(func,a,b,fa,fb,trap,accuracy) result (res) ::: recursive, private$/;"	r
adaptive_simpson_integrate	adaptive_quadrature.foo	/^   adaptive_simpson_integrate(func) result (res) ::: private$/;"	r
adaptive_simpson_integrate	adaptive_quadrature.foo	/^   adaptive_simpson_integrate(func,a,m,b,fa,fm,fb,simp,accuracy) result (res) ::: recursive, private$/;"	r
adaptive_integrate	adaptive_quadrature.foo	/^   adaptive_integrate(func) result (res)$/;"	r
adaptive_trapezoid_integrate	adaptive_quadrature.foo	/^   adaptive_trapezoid_integrate(func) result (res) ::: private$/;"	r
adaptive_trapezoid_integrate	adaptive_quadrature.foo	/^   adaptive_trapezoid_integrate(func,c2,v2,h,trap,accuracy) result (res) ::: recursive, private$/;"	r
adaptive_E41_integrate	adaptive_quadrature.foo	/^   adaptive_E41_integrate(func) result (res) ::: private$/;"	r
adaptive_E41_integrate	adaptive_quadrature.foo	/^   adaptive_E41_integrate(func,b2,v2,h,ewe,accuracy) result (res) ::: recursive, private$/;"	r
adaptive_T53_integrate	adaptive_quadrature.foo	/^   adaptive_T53_integrate(func) result (res) ::: leaky, private$/;"	r
adaptive_T53_integrate	adaptive_quadrature.foo	/^   adaptive_T53_integrate(func,m,h,ty,accuracy) result (res) ::: recursive, private$/;"	r
adaptive_HS58_integrate	adaptive_quadrature.foo	/^   adaptive_HS58_integrate(func) result (res) ::: leaky, private$/;"	r
adaptive_HS58_integrate	adaptive_quadrature.foo	/^   adaptive_HS58_integrate(func,m,h,hs,accuracy) result (res) ::: recursive, private$/;"	r
adaptive_GM80_integrate	adaptive_quadrature.foo	/^   adaptive_GM80_integrate(func) result (res) ::: leaky, private$/;"	r
adaptive_GM80_integrate	adaptive_quadrature.foo	/^   adaptive_GM80_integrate(func,m,h,accuracy) result (res) ::: recursive, private$/;"	r
test_sin	adaptive_quadrature.foo	/^   test_sin(x) result (res) ::: selfless, public$/;"	r
test_x2	adaptive_quadrature.foo	/^   test_x2(x) result (res) ::: selfless, public$/;"	r
test_x3	adaptive_quadrature.foo	/^   test_x3(x) result (res) ::: selfless, public$/;"	r
test_x4	adaptive_quadrature.foo	/^   test_x4(x) result (res) ::: selfless, public$/;"	r
test_gauss	adaptive_quadrature.foo	/^   test_gauss(x,res) ::: selfless, public$/;"	r
create	archive.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	archive.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	archive.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	archive.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	archive.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	archive.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
copy	archive.foo	/^   copy(archive) ::: leaky$/;"	r
set_defaults	archive.foo	/^   set_defaults$/;"	r
create	archive.foo	/^   create(root_name,name,genre,format)$/;"	r
set	archive.foo	/^   set(root_name,name,genre,format)$/;"	r
set_root_name	archive.foo	/^   set_root_name(root_name)$/;"	r
set_root	archive.foo	/^   set_root(root_name)$/;"	r
set_name	archive.foo	/^   set_name(name)$/;"	r
set_genre	archive.foo	/^   set_genre(genre)$/;"	r
set_format	archive.foo	/^   set_format(format)$/;"	r
file_name	archive.foo	/^   file_name(genre) result (res)$/;"	r
is_a_text_file	archive.foo	/^   is_a_text_file result (res) ::: private$/;"	r
exists	archive.foo	/^   exists(genre) result (res)$/;"	r
open	archive.foo	/^   open(for,buffered,type,genre,ascii) ::: leaky$/;"	r
close	archive.foo	/^   close ::: leaky$/;"	r
delete	archive.foo	/^   delete(genre)$/;"	r
delete_all_genres	archive.foo	/^   delete_all_genres$/;"	r
read	archive.foo	/^   read(item,genre) ::: template$/;"	r
read	archive.foo	/^   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>INT, BUFFER_TYPE=>INT)$/;"	r
read	archive.foo	/^   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>REAL, BUFFER_TYPE=>REAL)$/;"	r
read	archive.foo	/^   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{INT}, BUFFER_TYPE=>INT)$/;"	r
read	archive.foo	/^   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{REAL}, BUFFER_TYPE=>REAL)$/;"	r
read	archive.foo	/^   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{CPX}, BUFFER_TYPE=>CPX)$/;"	r
read	archive.foo	/^   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{REAL}, BUFFER_TYPE=>REAL)$/;"	r
read	archive.foo	/^   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{CPX}, BUFFER_TYPE=>CPX)$/;"	r
read	archive.foo	/^   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{REAL}, BUFFER_TYPE=>REAL)$/;"	r
read	archive.foo	/^   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{CPX}, BUFFER_TYPE=>CPX)$/;"	r
read	archive.foo	/^   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT5{CPX}, BUFFER_TYPE=>CPX)$/;"	r
read	archive.foo	/^   read(item,genre,by_column) ::: template$/;"	r
read	archive.foo	/^   read(item,genre,by_column) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{REAL}, BUFFER_TYPE=>REAL)$/;"	r
read	archive.foo	/^   read(item,genre,by_column) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{CPX}, BUFFER_TYPE=>CPX)$/;"	r
read	archive.foo	/^   read(item,genre) ::: template$/;"	r
item	archive.foo	/^     item :: ITEM_TYPE$/;"	a
genre	archive.foo	/^     genre :: STR, optional$/;"	a
read	archive.foo	/^   read(item,genre)  ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{MAT_{REAL}})$/;"	r
read	archive.foo	/^   read(item,genre) ::: leaky$/;"	r
read	archive.foo	/^   read(item,genre,by_column) ::: leaky$/;"	r
write	archive.foo	/^   write(item,genre,ascii) ::: template$/;"	r
write	archive.foo	/^   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>INT, TYPE=>"int")$/;"	r
write	archive.foo	/^   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>REAL, TYPE=>"real")$/;"	r
write	archive.foo	/^   write(item,genre,by_row,by_column,ascii) ::: template$/;"	r
write	archive.foo	/^   write(item,genre,by_row,by_column,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{INT}, TYPE=>"int")$/;"	r
write	archive.foo	/^   write(item,genre,by_row,by_column,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{REAL}, TYPE=>"real")$/;"	r
write	archive.foo	/^   write(item,genre,by_row,by_column,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{CPX}, TYPE=>"cpx")$/;"	r
write	archive.foo	/^   write(item,genre,by_row,by_column,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{REAL}, TYPE=>"real")$/;"	r
write	archive.foo	/^   write(item,genre,by_row,by_column,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{CPX}, TYPE=>"cpx")$/;"	r
write	archive.foo	/^   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{REAL}, TYPE=>"real")$/;"	r
write	archive.foo	/^   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{CPX}, TYPE=>"cpx")$/;"	r
write	archive.foo	/^   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{REAL}, TYPE=>"real")$/;"	r
write	archive.foo	/^   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{CPX}, TYPE=>"cpx")$/;"	r
write	archive.foo	/^   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT5{CPX}, TYPE=>"cpx")$/;"	r
write	archive.foo	/^   write(item1,item2,ascii) ::: template$/;"	r
write	archive.foo	/^   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>VEC{REAL}, TYPE=>"real")$/;"	r
write	archive.foo	/^   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>MAT{REAL}, TYPE=>"real")$/;"	r
write	archive.foo	/^   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>VEC{REAL}, TYPE=>"real")$/;"	r
write	archive.foo	/^   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>MAT{REAL}, TYPE=>"real")$/;"	r
write	archive.foo	/^   write(item,genre) ::: template$/;"	r
write	archive.foo	/^   write(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{MAT_{REAL}})$/;"	r
write	archive.foo	/^   write(item,genre,by_column,ascii)$/;"	r
write	archive.foo	/^   write(item,genre,by_column,ascii)$/;"	r
write_ppm	archive.foo	/^   write_ppm(matrix,max_colours)$/;"	r
write_orbital	archive.foo	/^   write_orbital(gcu,gcd,n_pt)$/;"	r
write_gnuplot	archive.foo	/^   write_gnuplot(density,n_x,n_y,n_z)$/;"	r
write_mathematica	archive.foo	/^   write_mathematica(density,n_x,n_y,n_z)$/;"	r
write_mathematica	archive.foo	/^   write_mathematica(density,grid,atom,math_pos,bonds)$/;"	r
write_gnuplot	archive.foo	/^   write_gnuplot(j,n_x,n_y,n_z,norm,normalise)$/;"	r
write_contour_a_la_nancy	archive.foo	/^   write_contour_a_la_nancy(density,grid,atom)$/;"	r
write_a_la_xdgraph	archive.foo	/^   write_a_la_xdgraph(density,grid,atom)$/;"	r
write_gaussian_cube	archive.foo	/^   write_gaussian_cube(density,grid,atom,title)$/;"	r
write_xcrysden_xsf	archive.foo	/^   write_xcrysden_xsf(density,grid,atom,title)$/;"	r
write_drishti	archive.foo	/^   write_drishti(density,n_x,n_y,n_z)$/;"	r
keys	atom.foo	/^   keys :: VEC{STR}*, private DEFAULT_NULL$/;"	g
element_symbols	atom.foo	/^   element_symbols :: VEC{STR}(len=2,103)$/;"	g
element_names	atom.foo	/^   element_names :: VEC{STR}(len=12,103)$/;"	g
bragg_slater_radii	atom.foo	/^   bragg_slater_radii :: VEC{REAL}(54)$/;"	g
atom_bonded_range_factor	atom.foo	/^   atom_bonded_range_factor :: REAL = 0.4d0*BOHR_PER_ANGSTROM$/;"	g
atom_vdw_bonded_range_pc	atom.foo	/^   atom_vdw_bonded_range_pc :: REAL = 1.0d0$/;"	g
covalent_radii_invariom	atom.foo	/^   covalent_radii_invariom :: VEC{INT}(109)$/;"	g
allred_rochow_electronegs	atom.foo	/^   allred_rochow_electronegs :: VEC{INT}(85)$/;"	g
covalent_radii_ccdc	atom.foo	/^   covalent_radii_ccdc :: VEC{REAL}(110)$/;"	g
vdw_radii_ccdc	atom.foo	/^   vdw_radii_ccdc :: VEC{REAL}(110)$/;"	g
atomic_masses	atom.foo	/^   atomic_masses :: VEC{REAL}(92)$/;"	g
neutron_scattering_lengths	atom.foo	/^   neutron_scattering_lengths :: VEC{REAL}(95)$/;"	g
dispersion_correction_Cr	atom.foo	/^   dispersion_correction_Cr :: VEC{CPX}(92)$/;"	g
dispersion_correction_Cu	atom.foo	/^   dispersion_correction_Cu :: VEC{CPX}(92)$/;"	g
dispersion_correction_Mo	atom.foo	/^   dispersion_correction_Mo :: VEC{CPX}(92)$/;"	g
dispersion_correction_Ag	atom.foo	/^   dispersion_correction_Ag :: VEC{CPX}(92)$/;"	g
saved_self	atom.foo	/^   saved_self :: ATOM*, private  DEFAULT_NULL$/;"	g
create	atom.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	atom.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	atom.foo	/^   nullify_ptr_part $/;"	r
destroy_ptr_part	atom.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	atom.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	atom.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	atom.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	atom.foo	/^   copy(atom) ::: leaky$/;"	r
set_defaults	atom.foo	/^   set_defaults$/;"	r
set_label_and_atomic_number	atom.foo	/^   set_label_and_atomic_number(label)$/;"	r
set_atomic_number	atom.foo	/^   set_atomic_number(val)$/;"	r
set_nuclear_charge	atom.foo	/^   set_nuclear_charge(val)$/;"	r
set_dummy_charge	atom.foo	/^   set_dummy_charge(label)$/;"	r
set_label	atom.foo	/^   set_label(label)$/;"	r
set_atom_bonded_range_factor	atom.foo	/^   set_atom_bonded_range_factor(fac) ::: selfless$/;"	r
set_covalent_radii_ccdc	atom.foo	/^   set_covalent_radii_ccdc ::: selfless$/;"	r
set_saved_self	atom.foo	/^   set_saved_self ::: get_from(OBJECT)$/;"	r
read_keywords	atom.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	atom.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	atom.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_junk	atom.foo	/^   read_junk ::: get_from(OBJECT), selfless, private$/;"	r
read_group	atom.foo	/^   read_group$/;"	r
read_pos	atom.foo	/^   read_pos$/;"	r
read_label	atom.foo	/^   read_label$/;"	r
read_charge	atom.foo	/^   read_charge$/;"	r
read_nuclear_charge	atom.foo	/^   read_nuclear_charge$/;"	r
read_dipole	atom.foo	/^   read_dipole$/;"	r
read_oxidation_state	atom.foo	/^   read_oxidation_state$/;"	r
read_residue_atom_code	atom.foo	/^   read_residue_atom_code$/;"	r
read_residue_code	atom.foo	/^   read_residue_code$/;"	r
read_pdb_input_line	atom.foo	/^   read_pdb_input_line$/;"	r
read_residue_sequence_number	atom.foo	/^   read_residue_sequence_number$/;"	r
read_mm_atom_type	atom.foo	/^   read_mm_atom_type$/;"	r
read_mm_charge	atom.foo	/^   read_mm_charge$/;"	r
read_mm_forcefield_name	atom.foo	/^   read_mm_forcefield_name$/;"	r
read_restraining_position	atom.foo	/^   read_restraining_position$/;"	r
read_restraining_force	atom.foo	/^   read_restraining_force$/;"	r
read_site_disorder_group	atom.foo	/^   read_site_disorder_group$/;"	r
read_site_occupancy	atom.foo	/^   read_site_occupancy$/;"	r
read_axis_system	atom.foo	/^   read_axis_system$/;"	r
set_axis_system	atom.foo	/^   set_axis_system(word)$/;"	r
read_thermal_axis_system	atom.foo	/^   read_thermal_axis_system$/;"	r
set_thermal_axis_system	atom.foo	/^   set_thermal_axis_system(word)$/;"	r
read_basis_label	atom.foo	/^   read_basis_label ::: leaky$/;"	r
read_slaterbasis_label	atom.foo	/^   read_slaterbasis_label ::: leaky$/;"	r
read_coppensbasis_label	atom.foo	/^   read_coppensbasis_label ::: leaky$/;"	r
read_U_iso	atom.foo	/^   read_U_iso$/;"	r
read_B_iso	atom.foo	/^   read_B_iso$/;"	r
read_thermal_tensor	atom.foo	/^   read_thermal_tensor$/;"	r
read_keys	atom.foo	/^   read_keys ::: get_from(OBJECT)$/;"	r
process_keys	atom.foo	/^   process_keys ::: get_from(OBJECT), leaky$/;"	r
keys_created	atom.foo	/^   keys_created result (res) ::: get_from(OBJECT)$/;"	r
set_keys	atom.foo	/^   set_keys(the_keys) ::: get_from(OBJECT)$/;"	r
clear_keys	atom.foo	/^   clear_keys ::: get_from(OBJECT)$/;"	r
put_table_footer	atom.foo	/^   put_table_footer ::: get_from(OBJECT)$/;"	r
put_table_header	atom.foo	/^   put_table_header$/;"	r
table_width	atom.foo	/^   table_width result (res)$/;"	r
resolve_axis_system	atom.foo	/^   resolve_axis_system(cell)$/;"	r
change_axis_system_to	atom.foo	/^   change_axis_system_to(axiskind,cell)$/;"	r
change_coord_axis_system_to	atom.foo	/^   change_coord_axis_system_to(axiskind,cell)$/;"	r
change_thermal_axis_system_to	atom.foo	/^   change_thermal_axis_system_to(axiskind,cell)$/;"	r
thermal_tensor_from	atom.foo	/^   thermal_tensor_from(cell)$/;"	r
thermal_tensor_to	atom.foo	/^   thermal_tensor_to(cell)$/;"	r
thermal_tensor_from_U_iso	atom.foo	/^   thermal_tensor_from_U_iso(cell)$/;"	r
position_from	atom.foo	/^   position_from(cell)$/;"	r
position_to	atom.foo	/^   position_to(cell)$/;"	r
change_coordinate_axes	atom.foo	/^   change_coordinate_axes(axes)$/;"	r
resolve_basis	atom.foo	/^   resolve_basis(basis,suffix,found) ::: template$/;"	r
resolve_basis	atom.foo	/^   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASE=>.basis, LABEL=>.basis_label)$/;"	r
resolve_basis	atom.foo	/^   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASIS=>SLATERBASIS, BASE=>.slaterbasis, LABEL=>.slaterbasis_label)$/;"	r
resolve_basis	atom.foo	/^   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASIS=>COPPENSBASIS, BASE=>.coppensbasis, LABEL=>.coppensbasis_label)$/;"	r
has_a_dummy_label	atom.foo	/^   has_a_dummy_label result (res) ::: elemental$/;"	r
is_a_dummy_atom	atom.foo	/^   is_a_dummy_atom result (res) ::: elemental$/;"	r
is_a_nondummy_atom	atom.foo	/^   is_a_nondummy_atom result (res) ::: elemental$/;"	r
is_a_ghost_atom	atom.foo	/^   is_a_ghost_atom result (res) ::: elemental$/;"	r
is_a_point_charge	atom.foo	/^   is_a_point_charge result (res) ::: elemental$/;"	r
is_a_pseudo_atom	atom.foo	/^   is_a_pseudo_atom result (res) ::: elemental$/;"	r
has_basis	atom.foo	/^   has_basis result (res) ::: elemental$/;"	r
basis_descriptor	atom.foo	/^   basis_descriptor result (res) ::: elemental$/;"	r
slaterbasis_descriptor	atom.foo	/^   slaterbasis_descriptor result (res) ::: get_from(ATOM:basis_descriptor, basis=>slaterbasis), elemental$/;"	r
coppensbasis_descriptor	atom.foo	/^   coppensbasis_descriptor result (res) ::: get_from(ATOM:basis_descriptor, basis=>coppensbasis), elemental$/;"	r
same_kind_as	atom.foo	/^   same_kind_as(atom) result (res)$/;"	r
is_distinct_from	atom.foo	/^   is_distinct_from(atom) result (res)$/;"	r
no_of_shells	atom.foo	/^   no_of_shells result (res) ::: pure$/;"	r
n_shell	atom.foo	/^   n_shell result (res) ::: pure$/;"	r
no_of_basis_functions	atom.foo	/^   no_of_basis_functions result (res) ::: pure$/;"	r
no_of_sph_basis_functions	atom.foo	/^   no_of_sph_basis_functions result (res) ::: pure$/;"	r
n_bf	atom.foo	/^   n_bf result (res) ::: pure$/;"	r
no_of_primitives	atom.foo	/^   no_of_primitives result (res) ::: pure$/;"	r
no_of_sph_primitives	atom.foo	/^   no_of_sph_primitives result (res) ::: pure$/;"	r
n_prim	atom.foo	/^   n_prim result (res) ::: pure$/;"	r
no_of_occupied_NOs	atom.foo	/^   no_of_occupied_NOs(axiskind,tol) result (res)$/;"	r
chemical_symbol	atom.foo	/^   chemical_symbol(Z) result (res) ::: elemental$/;"	r
chemical_symbol	atom.foo	/^   chemical_symbol(Z) result (res) ::: elemental, selfless$/;"	r
mass	atom.foo	/^   mass result (res)$/;"	r
mean_neutron_number	atom.foo	/^   mean_neutron_number result (res)$/;"	r
bragg_slater_radius	atom.foo	/^   bragg_slater_radius result (res)$/;"	r
neutron_scattering_length	atom.foo	/^   neutron_scattering_length result (res)$/;"	r
n_core_electrons	atom.foo	/^   n_core_electrons(Z) result(noble)$/;"	r
period_number	atom.foo	/^   period_number(Z) result(p)$/;"	r
column_number	atom.foo	/^   column_number(Z) result(col)$/;"	r
period_block	atom.foo	/^   period_block(Z) result(b)$/;"	r
ground_state_multiplicity	atom.foo	/^   ground_state_multiplicity(Z) result(mult)$/;"	r
dispersion_correction	atom.foo	/^   dispersion_correction(wavelength) result (res)$/;"	r
library_basis_label	atom.foo	/^   library_basis_label(suffix) result (label)$/;"	r
library_basis_label	atom.foo	/^   library_basis_label(Z,suffix) result (label) ::: selfless, leaky$/;"	r
oxidation_state_str	atom.foo	/^   oxidation_state_str result (res) $/;"	r
has_ANO_data	atom.foo	/^   has_ANO_data result (res)$/;"	r
is_bonded_to	atom.foo	/^   is_bonded_to(b,range_factor) result (res) ::: pure$/;"	r
is_nearby_to	atom.foo	/^   is_nearby_to(b,dist) result (res)$/;"	r
is_vdw_bonded_to	atom.foo	/^   is_vdw_bonded_to(b,range_factor,vdw_range_pc) result (res)$/;"	r
minimum_basis_exponent	atom.foo	/^   minimum_basis_exponent result (res)$/;"	r
r_max	atom.foo	/^   r_max(cutoff) result (res)$/;"	r
r2_max	atom.foo	/^   r2_max(cutoff) result (res)$/;"	r
has_dipole	atom.foo	/^   has_dipole result (res)$/;"	r
has_polarisability	atom.foo	/^   has_polarisability result (res)$/;"	r
has_recognised_label	atom.foo	/^   has_recognised_label result (res)$/;"	r
covalent_radius_ccdc	atom.foo	/^   covalent_radius_ccdc result (res) ::: pure$/;"	r
vdw_radius_ccdc	atom.foo	/^   vdw_radius_ccdc result (res)$/;"	r
allred_rochow_en	atom.foo	/^   allred_rochow_en result (res)$/;"	r
invariom_covalent_radius	atom.foo	/^   invariom_covalent_radius result (res)$/;"	r
get_invariom_rotation	atom.foo	/^   get_invariom_rotation(U,actual,reference,L,fail)$/;"	r
make_density_grid	atom.foo	/^   make_density_grid(density_grid,pt,occ)$/;"	r
add_density_grid	atom.foo	/^   add_density_grid(density_grid,pt,occ)$/;"	r
make_density_grid_r	atom.foo	/^   make_density_grid_r(density_grid,pt,occ)$/;"	r
add_density_grid_r	atom.foo	/^   add_density_grid_r(density_grid,pt,occ)$/;"	r
make_density_grid_c	atom.foo	/^   make_density_grid_c(density_grid,pt,occ)$/;"	r
add_density_grid_c	atom.foo	/^   add_density_grid_c(density_grid,pt,occ)$/;"	r
make_density_grid	atom.foo	/^   make_density_grid(density_grid,pt,D,occ)$/;"	r
add_density_grid	atom.foo	/^   add_density_grid(density_grid,pt,D,occ)$/;"	r
make_AO_grid	atom.foo	/^   make_AO_grid(g,pt,pos)$/;"	r
make_orbital_grid_r	atom.foo	/^   make_orbital_grid_r(g,orb,pt,pos,square)$/;"	r
make_orbital_grid_c	atom.foo	/^   make_orbital_grid_c(g,orb,pt,pos,square)$/;"	r
density_at_radius	atom.foo	/^   density_at_radius(R) result (res)$/;"	r
density_value_at_radius	atom.foo	/^   density_value_at_radius(R) result (res) ::: selfless, public$/;"	r
make_interpolator	atom.foo	/^   make_interpolator(interpolator) ::: leaky$/;"	r
interpolator_table_length	atom.foo	/^   interpolator_table_length(tol) result (length)$/;"	r
make_interpolated_density	atom.foo	/^   make_interpolated_density(density,pt,occ)$/;"	r
add_interpolated_density	atom.foo	/^   add_interpolated_density(density,pt,occ)$/;"	r
make_nabla_density_grid	atom.foo	/^   make_nabla_density_grid(nabla_grid,pts)$/;"	r
make_nabla_density_grid	atom.foo	/^   make_nabla_density_grid(nabla_grid,grid,pts)$/;"	r
make_nabla_density_grid_r	atom.foo	/^   make_nabla_density_grid_r(nabla_grid,pts)$/;"	r
make_nabla_density_grid_r	atom.foo	/^   make_nabla_density_grid_r(nabla_grid,grid,pts)$/;"	r
make_nabla_orbital_grid_r	atom.foo	/^   make_nabla_orbital_grid_r(g,h,orb,pt)$/;"	r
make_laplacian_grid	atom.foo	/^   make_laplacian_grid(laplacian_grid,pt)$/;"	r
make_laplacian_grid_r	atom.foo	/^   make_laplacian_grid_r(laplacian_grid,pt)$/;"	r
make_laplacian_orbital_grid_r	atom.foo	/^   make_laplacian_orbital_grid_r(g,h,i,orb,pt)$/;"	r
make_rL_grid	atom.foo	/^   make_rL_grid(laplacian_grid,pt)$/;"	r
make_rL_grid_r	atom.foo	/^   make_rL_grid_r(laplacian_grid,pt)$/;"	r
make_E_hf_dens_from_rho_grid	atom.foo	/^   make_E_hf_dens_from_rho_grid(E_grid,pt)$/;"	r
make_H_from_virial_grid	atom.foo	/^   make_H_from_virial_grid(H_grid,pt)$/;"	r
make_rH_from_virial_grid	atom.foo	/^   make_rH_from_virial_grid(H_grid,pt)$/;"	r
make_H_Kirzhnits_grid	atom.foo	/^   make_H_Kirzhnits_grid(H_grid,pt)$/;"	r
make_V_from_virial_grid	atom.foo	/^   make_V_from_virial_grid(V,pt)$/;"	r
make_rV_from_virial_grid	atom.foo	/^   make_rV_from_virial_grid(V,pt)$/;"	r
make_V_Kirzhnits_grid	atom.foo	/^   make_V_Kirzhnits_grid(V,pt)$/;"	r
make_G_kinetic_energy_grid	atom.foo	/^   make_G_kinetic_energy_grid(G_grid,pt)$/;"	r
make_G_kinetic_energy_grid_r	atom.foo	/^   make_G_kinetic_energy_grid_r(G_grid,pt)$/;"	r
make_rG_kinetic_energy_grid	atom.foo	/^   make_rG_kinetic_energy_grid(G_grid,pt)$/;"	r
make_rG_kinetic_energy_grid_r	atom.foo	/^   make_rG_kinetic_energy_grid_r(G_grid,pt)$/;"	r
make_G_Kirzhnits_grid	atom.foo	/^   make_G_Kirzhnits_grid(G_grid,pt)$/;"	r
make_G_Kirzhnits_grid_r	atom.foo	/^   make_G_Kirzhnits_grid_r(G_grid,pt)$/;"	r
make_K_kinetic_energy_grid	atom.foo	/^   make_K_kinetic_energy_grid(K_grid,pt)$/;"	r
make_K_kinetic_energy_grid_r	atom.foo	/^   make_K_kinetic_energy_grid_r(K_grid,pt)$/;"	r
make_rK_kinetic_energy_grid	atom.foo	/^   make_rK_kinetic_energy_grid(K_grid,pt)$/;"	r
make_rK_kinetic_energy_grid_r	atom.foo	/^   make_rK_kinetic_energy_grid_r(K_grid,pt)$/;"	r
make_dft_xc_pot_grid	atom.foo	/^   make_dft_xc_pot_grid(V,pt,exchange,correlation)$/;"	r
make_dft_eff_pot_grid	atom.foo	/^   make_dft_eff_pot_grid(V,pt,exchange,correlation)$/;"	r
make_dft_energy_grid	atom.foo	/^   make_dft_energy_grid(V,pt,exchange,correlation)$/;"	r
make_H_dft_energy_grid	atom.foo	/^   make_H_dft_energy_grid(H_grid,pt,exchange,correlation)$/;"	r
make_electric_potential_grid	atom.foo	/^   make_electric_potential_grid(pot_grid,pt)$/;"	r
make_electric_potential_grid_r	atom.foo	/^   make_electric_potential_grid_r(pot_grid,pt,dens)$/;"	r
make_electronic_pot_grid_r	atom.foo	/^   make_electronic_pot_grid_r(pot_grid,pt,dens)$/;"	r
nuclear_potential	atom.foo	/^   nuclear_potential(values,pts)$/;"	r
make_bf_grid	atom.foo	/^   make_bf_grid(grid,pt)$/;"	r
make_nabla_bf_grid	atom.foo	/^   make_nabla_bf_grid(nabla_grid,pt)$/;"	r
make_nabla_bf_grid	atom.foo	/^   make_nabla_bf_grid(nabla_grid,grid,pt)$/;"	r
make_bf_grid	atom.foo	/^   make_bf_grid(grid0,pt,cutoff)$/;"	r
make_nabla_bf_grid	atom.foo	/^   make_nabla_bf_grid(grid1,pt,cutoff)$/;"	r
make_nabla_bf_grid	atom.foo	/^   make_nabla_bf_grid(grid1,grid0,pt,cutoff)$/;"	r
make_displaced_points	atom.foo	/^   make_displaced_points(x,y,z,r2,pt,create) ::: leaky$/;"	r
tidy_displaced_points	atom.foo	/^   tidy_displaced_points(x,y,z,r2) ::: leaky$/;"	r
make_displaced_pts	atom.foo	/^   make_displaced_pts(dx,dy,dz,r2,skip,pt,n_pt,cutoff) ::: public$/;"	r
make_significant_points	atom.foo	/^   make_significant_points(x,y,z,r2,skip,pt,cutoff) ::: leaky$/;"	r
make_significant_points	atom.foo	/^   make_significant_points(x,y,z,r2,d2,skip,pt,cutoff) ::: leaky$/;"	r
make_significant_points	atom.foo	/^   make_significant_points(x,y,z,r2,skip,pt,skip2,cutoff) ::: leaky$/;"	r
make_shell_info	atom.foo	/^   make_shell_info ::: leaky$/;"	r
set_shell_limits	atom.foo	/^   set_shell_limits(first,last) ::: leaky$/;"	r
make_precomputed_shellpairs	atom.foo	/^   make_precomputed_shellpairs ::: leaky$/;"	r
get_precomputed_shell_pair	atom.foo	/^   get_precomputed_shell_pair(shell,q,fa,la,fb,lb) ::: leaky$/;"	r
put	atom.foo	/^   put$/;"	r
put_mm_info	atom.foo	/^   put_mm_info$/;"	r
put_natural_orbitals	atom.foo	/^   put_natural_orbitals$/;"	r
put_interpolator	atom.foo	/^   put_interpolator$/;"	r
keys	atom_group.foo	/^   keys :: VEC{STR}*, private DEFAULT_NULL$/;"	g
create	atom_group.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	atom_group.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	atom_group.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	atom_group.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	atom_group.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	atom_group.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	atom_group.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	atom_group.foo	/^   copy(atom_group) ::: leaky$/;"	r
set_defaults	atom_group.foo	/^   set_defaults$/;"	r
set_one_group	atom_group.foo	/^   set_one_group$/;"	r
set_atom	atom_group.foo	/^   set_atom(atom)$/;"	r
set_mol	atom_group.foo	/^   set_mol(mol)$/;"	r
set_name	atom_group.foo	/^   set_name(name)$/;"	r
read_keywords	atom_group.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	atom_group.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_atom_indices	atom_group.foo	/^   read_atom_indices ::: leaky$/;"	r
read_charge	atom_group.foo	/^   read_charge ::: leaky$/;"	r
read_n_MOs	atom_group.foo	/^   read_n_MOs ::: leaky$/;"	r
read_name	atom_group.foo	/^   read_name ::: leaky$/;"	r
finalise	atom_group.foo	/^   finalise(atom) ::: leaky$/;"	r
read_keys	atom_group.foo	/^   read_keys ::: get_from(OBJECT)$/;"	r
process_keys	atom_group.foo	/^   process_keys ::: get_from(OBJECT), leaky$/;"	r
keys_created	atom_group.foo	/^   keys_created result (res) ::: get_from(OBJECT)$/;"	r
set_keys	atom_group.foo	/^   set_keys(the_keys) ::: get_from(OBJECT)$/;"	r
clear_keys	atom_group.foo	/^   clear_keys ::: get_from(OBJECT)$/;"	r
put_table_footer	atom_group.foo	/^   put_table_footer ::: get_from(OBJECT)$/;"	r
put_table_header	atom_group.foo	/^   put_table_header$/;"	r
table_width	atom_group.foo	/^   table_width result (res)$/;"	r
put_chemical_symbols	atom_group.foo	/^   put_chemical_symbols$/;"	r
put_atom_indices	atom_group.foo	/^   put_atom_indices$/;"	r
create	basis.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	basis.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	basis.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	basis.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	basis.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	basis.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	basis.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	basis.foo	/^   copy(b) ::: leaky$/;"	r
set_defaults	basis.foo	/^   set_defaults$/;"	r
set_spherical	basis.foo	/^   set_spherical(val)$/;"	r
update	basis.foo	/^   update$/;"	r
set_label	basis.foo	/^   set_label(label)$/;"	r
read_keywords	basis.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	basis.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	basis.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_label	basis.foo	/^   read_label$/;"	r
read_shell	basis.foo	/^   read_shell ::: leaky$/;"	r
read_tonto_style	basis.foo	/^   read_tonto_style ::: leaky$/;"	r
read_gamess_us	basis.foo	/^   read_gamess_us ::: leaky$/;"	r
read_turbomole	basis.foo	/^   read_turbomole ::: leaky$/;"	r
read_keys	basis.foo	/^   read_keys ::: get_from(OBJECT)$/;"	r
process_keys	basis.foo	/^   process_keys ::: get_from(OBJECT), leaky$/;"	r
keys_created	basis.foo	/^   keys_created result (res) ::: get_from(OBJECT)$/;"	r
set_keys	basis.foo	/^   set_keys(the_keys) ::: get_from(OBJECT)$/;"	r
clear_keys	basis.foo	/^   clear_keys ::: get_from(OBJECT)$/;"	r
put_table_footer	basis.foo	/^   put_table_footer ::: get_from(OBJECT)$/;"	r
put_table_header	basis.foo	/^   put_table_header$/;"	r
table_width	basis.foo	/^   table_width result (res)$/;"	r
resolve_by_label	basis.foo	/^   resolve_by_label(label,basis,clobber,minlab,found)$/;"	r
unnormalise	basis.foo	/^   unnormalise$/;"	r
renormalise	basis.foo	/^   renormalise$/;"	r
get_lc_bf_ex_cc	basis.foo	/^   get_lc_bf_ex_cc(lc,bf,ex,cc)$/;"	r
contraction_matrix	basis.foo	/^   contraction_matrix result(ccm)$/;"	r
make_contraction_matrix	basis.foo	/^   make_contraction_matrix(ccm)$/;"	r
make_normalised_contraction_mx	basis.foo	/^   make_normalised_contraction_mx(ccm,spherical)$/;"	r
put	basis.foo	/^   put$/;"	r
same_as	basis.foo	/^   same_as(b) result (res)$/;"	r
is_resolved	basis.foo	/^   is_resolved result (res) ::: pure$/;"	r
is_created_and_resolved	basis.foo	/^   is_created_and_resolved result (res)$/;"	r
is_created_and_has_label	basis.foo	/^   is_created_and_has_label result (res)$/;"	r
no_of_shells	basis.foo	/^   no_of_shells result (res) ::: pure$/;"	r
no_of_primitive_shells	basis.foo	/^   no_of_primitive_shells result (res) ::: pure$/;"	r
no_of_basis_functions	basis.foo	/^   no_of_basis_functions result (res) ::: pure$/;"	r
no_of_sph_basis_functions	basis.foo	/^   no_of_sph_basis_functions result (res) ::: pure$/;"	r
no_of_primitives	basis.foo	/^   no_of_primitives result (res) ::: pure$/;"	r
no_of_sph_primitives	basis.foo	/^   no_of_sph_primitives result (res) ::: pure$/;"	r
min_exponent	basis.foo	/^   min_exponent result (res) ::: pure$/;"	r
r_max	basis.foo	/^   r_max(cutoff) result (res)$/;"	r
r2_max	basis.foo	/^   r2_max(cutoff) result (res)$/;"	r
bragg_slater_radius	becke_grid.foo	/^   bragg_slater_radius :: VEC{REAL}(89), private $/;"	g
TA_zeta	becke_grid.foo	/^   TA_zeta :: VEC{REAL}(89), private $/;"	g
MK_zeta	becke_grid.foo	/^   MK_zeta :: VEC{REAL}(89), private $/;"	g
period	becke_grid.foo	/^   period :: VEC{INT}(89), private $/;"	g
sg1_pruning_parameter	becke_grid.foo	/^   sg1_pruning_parameter :: MAT{REAL}(4,7), private $/;"	g
sg1_atomic_radii	becke_grid.foo	/^   sg1_atomic_radii :: VEC{REAL}(18), private $/;"	g
create	becke_grid.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	becke_grid.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
destroy_ptr_part	becke_grid.foo	/^   destroy_ptr_part ::: leaky$/;"	r
nullify_ptr_part	becke_grid.foo	/^   nullify_ptr_part ::: leaky$/;"	r
destroy_grid_part	becke_grid.foo	/^   destroy_grid_part ::: leaky$/;"	r
destroy_unscaled_grid	becke_grid.foo	/^   destroy_unscaled_grid ::: leaky$/;"	r
destroy_atom_info	becke_grid.foo	/^   destroy_atom_info ::: leaky$/;"	r
created	becke_grid.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	becke_grid.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	becke_grid.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	becke_grid.foo	/^   copy(b) ::: leaky$/;"	r
set_defaults	becke_grid.foo	/^   set_defaults ::: leaky$/;"	r
set_kind	becke_grid.foo	/^   set_kind(kind) ::: leaky$/;"	r
set_partition_scheme	becke_grid.foo	/^   set_partition_scheme(scheme)$/;"	r
set_partition_scaling_scheme	becke_grid.foo	/^   set_partition_scaling_scheme(scheme)$/;"	r
set_pruning_scheme	becke_grid.foo	/^   set_pruning_scheme(scheme)$/;"	r
set_zeta	becke_grid.foo	/^   set_zeta ::: leaky, private$/;"	r
set_zeta	becke_grid.foo	/^   set_zeta(i,zeta) ::: leaky$/;"	r
set_accuracy	becke_grid.foo	/^   set_accuracy(acc)$/;"	r
set_atom_info	becke_grid.foo	/^   set_atom_info(atom,atom_lowest_exponents) ::: leaky$/;"	r
set_basis_function_cutoff	becke_grid.foo	/^   set_basis_function_cutoff(cutoff)$/;"	r
set_partition_cutoff	becke_grid.foo	/^   set_partition_cutoff(cutoff)$/;"	r
set_rho_cutoff	becke_grid.foo	/^   set_rho_cutoff(cutoff)$/;"	r
set_n_radial_points	becke_grid.foo	/^   set_n_radial_points(n)$/;"	r
set_n_extra_points_per_shell	becke_grid.foo	/^   set_n_extra_points_per_shell(n)$/;"	r
set_l_angular_grid	becke_grid.foo	/^   set_l_angular_grid(l)$/;"	r
set_l_H_angular_grid	becke_grid.foo	/^   set_l_H_angular_grid(l)$/;"	r
set_reduce_H_angular_grid	becke_grid.foo	/^   set_reduce_H_angular_grid(reduce)$/;"	r
set_scale_atomic_grids	becke_grid.foo	/^   set_scale_atomic_grids(scale) ::: leaky$/;"	r
read_keywords	becke_grid.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	becke_grid.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_accuracy	becke_grid.foo	/^   read_accuracy$/;"	r
read_kind	becke_grid.foo	/^   read_kind ::: leaky$/;"	r
read_partition_scheme	becke_grid.foo	/^   read_partition_scheme$/;"	r
read_partition_scaling_scheme	becke_grid.foo	/^   read_partition_scaling_scheme$/;"	r
read_pruning_scheme	becke_grid.foo	/^   read_pruning_scheme$/;"	r
read_l_angular_grid	becke_grid.foo	/^   read_l_angular_grid$/;"	r
read_l_H_angular_grid	becke_grid.foo	/^   read_l_H_angular_grid$/;"	r
read_n_extra_points_per_shell	becke_grid.foo	/^   read_n_extra_points_per_shell$/;"	r
read_n_radial_points	becke_grid.foo	/^   read_n_radial_points$/;"	r
read_reduce_H_angular_grid	becke_grid.foo	/^   read_reduce_H_angular_grid$/;"	r
read_scale_atomic_grids	becke_grid.foo	/^   read_scale_atomic_grids$/;"	r
read_basis_function_cutoff	becke_grid.foo	/^   read_basis_function_cutoff$/;"	r
read_partition_cutoff	becke_grid.foo	/^   read_partition_cutoff$/;"	r
read_rho_cutoff	becke_grid.foo	/^   read_rho_cutoff$/;"	r
set_grid_data	becke_grid.foo	/^   set_grid_data ::: leaky$/;"	r
set_radial_grids	becke_grid.foo	/^   set_radial_grids ::: private, leaky$/;"	r
set_radial_grid	becke_grid.foo	/^   set_radial_grid(radial,p) ::: private, leaky$/;"	r
no_of_radial_points	becke_grid.foo	/^   no_of_radial_points(p) result (res) $/;"	r
set_B_radial_grid	becke_grid.foo	/^   set_B_radial_grid(radial_grid,nr) ::: private, leaky$/;"	r
set_TA_radial_grid	becke_grid.foo	/^   set_TA_radial_grid(radial_grid,nr) ::: private, leaky$/;"	r
set_MK_radial_grid	becke_grid.foo	/^   set_MK_radial_grid(radial_grid,nr) ::: private, leaky$/;"	r
set_angular_grids	becke_grid.foo	/^   set_angular_grids ::: private, leaky$/;"	r
set_n_points_for_row	becke_grid.foo	/^   set_n_points_for_row ::: private, leaky$/;"	r
set_unique_atoms	becke_grid.foo	/^   set_unique_atoms ::: leaky, private$/;"	r
set_atom_grids	becke_grid.foo	/^   set_atom_grids ::: leaky, private$/;"	r
set_atom_density_grids	becke_grid.foo	/^   set_atom_density_grids ::: leaky, private$/;"	r
set_atom_min_distance	becke_grid.foo	/^   set_atom_min_distance ::: leaky, private$/;"	r
set_atom_n1_SS	becke_grid.foo	/^   set_atom_n1_SS ::: leaky, private$/;"	r
set_unscaled_grid	becke_grid.foo	/^   set_unscaled_grid(p) ::: leaky, private$/;"	r
no_of_points_for_row	becke_grid.foo	/^   no_of_points_for_row(p) result (res) ::: private$/;"	r
no_of_points_for_atom	becke_grid.foo	/^   no_of_points_for_atom(a) result (res)$/;"	r
apply_pruning_scheme	becke_grid.foo	/^   apply_pruning_scheme(lebedev_grid,i,nr,scheme) ::: private$/;"	r
apply_pruning_scheme_J0	becke_grid.foo	/^   apply_pruning_scheme_J0(lebedev_grid,i,nr) ::: private$/;"	r
apply_pruning_scheme_J1	becke_grid.foo	/^   apply_pruning_scheme_J1(lebedev_grid,i,nr) ::: private$/;"	r
apply_pruning_scheme_J2	becke_grid.foo	/^   apply_pruning_scheme_J2(lebedev_grid,i,nr) ::: private$/;"	r
apply_pruning_scheme_TA	becke_grid.foo	/^   apply_pruning_scheme_TA(lebedev_grid,i,nr) ::: private$/;"	r
no_of_points	becke_grid.foo	/^   no_of_points result (res)$/;"	r
no_of_points	becke_grid.foo	/^   no_of_points(atom) result (res)$/;"	r
no_of_points	becke_grid.foo	/^   no_of_points(atoms) result (res)$/;"	r
max_no_of_points_per_atom	becke_grid.foo	/^   max_no_of_points_per_atom result (res)$/;"	r
r_max_for_atom	becke_grid.foo	/^   r_max_for_atom(a) result (r_max)$/;"	r
r_max_SS_for_atom	becke_grid.foo	/^   r_max_SS_for_atom(a) result(r_max)$/;"	r
n1_SS_for_atom	becke_grid.foo	/^   n1_SS_for_atom(a) result (res)$/;"	r
make_grid	becke_grid.foo	/^   make_grid(pt,wt,atom_a) ::: leaky$/;"	r
make_grid	becke_grid.foo	/^   make_grid(pt,wt,f0,atom_a) ::: leaky$/;"	r
make_grid	becke_grid.foo	/^   make_grid(pt,wt,f0,gx,gy,gz,atom_a) ::: leaky$/;"	r
make_grid	becke_grid.foo	/^   make_grid(pt,wt,compress,weight_is_0) ::: leaky$/;"	r
make_grid	becke_grid.foo	/^   make_grid(pt,wt,atoms,compress,weight_is_0) ::: leaky$/;"	r
make_displacements	becke_grid.foo	/^   make_displacements(dx,dy,dz,d2,pt,overlapping_atom) ::: leaky$/;"	r
displace	becke_grid.foo	/^   displace(pt,a) ::: private$/;"	r
displace	becke_grid.foo	/^   displace(pt,pos) ::: private$/;"	r
prune_grid	becke_grid.foo	/^   prune_grid(pt,wt) ::: leaky$/;"	r
prune_grid	becke_grid.foo	/^   prune_grid(pt,wt,f0,atom_a) ::: leaky$/;"	r
prune_grid	becke_grid.foo	/^   prune_grid(pt,wt,f0,gx,gy,gz,atom_a) ::: leaky$/;"	r
prune_pair_grid	becke_grid.foo	/^   prune_pair_grid(pt,wt,atoms) ::: leaky$/;"	r
make_SS_grid	becke_grid.foo	/^   make_SS_grid(pt,wt,f0,atom_a,overlapping_atom) ::: leaky$/;"	r
make_SS_grid	becke_grid.foo	/^   make_SS_grid(pt,wt,f0,gx,gy,gz,atom_a,overlapping_atom) ::: leaky$/;"	r
make_unpruned_SS_grid	becke_grid.foo	/^   make_unpruned_SS_grid(pt,wt,f0,atom_a,overlapping_atom) ::: leaky, private$/;"	r
make_unpruned_SS_grid	becke_grid.foo	/^   make_unpruned_SS_grid(pt,wt,f0,gx,gy,gz,atom_a,overlapping_atom) ::: leaky, private$/;"	r
compress_zeros	becke_grid.foo	/^   compress_zeros(pt,wt,f0,dist,zero,atom_a,overlapping_atom) ::: leaky, private$/;"	r
compress_zeros	becke_grid.foo	/^   compress_zeros(pt,wt,f0,gx,gy,gz,dist,zero,atom_a,overlapping_atom) ::: leaky, private$/;"	r
make_distances	becke_grid.foo	/^   make_distances(dist,zero,pt,atom_a,overlapping_atom) ::: private$/;"	r
make_SS_weight	becke_grid.foo	/^   make_SS_weight(wt,dist,atom_a,overlapping_atom) ::: private$/;"	r
partition	becke_grid.foo	/^   partition(wt,pt,a,atoms,weight_is_0) ::: private$/;"	r
partition_D	becke_grid.foo	/^   partition_D(wt,pt,a,atoms,weight_is_0) ::: private$/;"	r
partition_B_no_adj	becke_grid.foo	/^   partition_B_no_adj(wt,pt,a,atoms,weight_is_0) ::: private$/;"	r
partition_B_B_adj	becke_grid.foo	/^   partition_B_B_adj(wt,pt,a,atoms,weight_is_0) ::: private$/;"	r
partition_B_TA_adj	becke_grid.foo	/^   partition_B_TA_adj(wt,pt,a,atoms,weight_is_0) ::: private$/;"	r
partition_SS	becke_grid.foo	/^   partition_SS(wt,pt,a,atoms,weight_is_zero) ::: private$/;"	r
partition_SS_pair	becke_grid.foo	/^   partition_SS_pair(wt,pt,a,atoms,weight_is_zero) ::: private$/;"	r
partition_SS_gnrl	becke_grid.foo	/^   partition_SS_gnrl(wt,pt,a,atoms,weight_is_zero) ::: private$/;"	r
partition_wt	becke_grid.foo	/^   partition_wt(wt,partition,a,weight_is_0) ::: private$/;"	r
make_bf_grids	becke_grid.foo	/^   make_bf_grids(a0,b0,ma,mb,pt,atoms) ::: leaky$/;"	r
make_bf_grids	becke_grid.foo	/^   make_bf_grids(a1,b1,ma,mb,pt,atoms) ::: leaky$/;"	r
make_bf_grids	becke_grid.foo	/^   make_bf_grids(a0,a1,b0,b1,ma,mb,pt,atoms) ::: leaky$/;"	r
sort_points	becke_grid.foo	/^   sort_points(a0,a1,b0,b1,pt,ma,mb,atoms) ::: private$/;"	r
integrate_function	becke_grid.foo	/^   integrate_function(f,ans)$/;"	r
put	becke_grid.foo	/^   put(out)$/;"	r
put_atom_info	becke_grid.foo	/^   put_atom_info(out)$/;"	r
put_radial_angular_grids	becke_grid.foo	/^   put_radial_angular_grids(out)$/;"	r
put_unique_atom_grids	becke_grid.foo	/^   put_unique_atom_grids(out)$/;"	r
str_length	bin.foo	/^   str_length(spaces) result (res) ::: get_from(INTRINSIC, FMT=>*), pure$/;"	r
to_str	bin.foo	/^   to_str result (string) ::: get_from(INTRINSIC, FMT=>*), pure$/;"	r
to_str	bin.foo	/^   to_str(format,left_justify) result (string) ::: get_from(INTRINSIC), pure$/;"	r
to_str	bin.foo	/^   to_str(width,left_justify) result (string) ::: get_from(INTRINSIC, STYLE=>L), pure$/;"	r
get	buffer.foo	/^   interface get$/;"	i
put	buffer.foo	/^   interface put$/;"	i
create	buffer.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	buffer.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	buffer.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	buffer.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	buffer.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	buffer.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	buffer.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	buffer.foo	/^   copy(b)$/;"	r
set_defaults	buffer.foo	/^   set_defaults$/;"	r
set_and_analyse	buffer.foo	/^   set_and_analyse(string)$/;"	r
set_string	buffer.foo	/^   set_string(string)$/;"	r
set_comment_chars	buffer.foo	/^   set_comment_chars(comment_chars)$/;"	r
set_quote_chars	buffer.foo	/^   set_quote_chars(quote_chars)$/;"	r
set_ignore_unmatched_quotes	buffer.foo	/^   set_ignore_unmatched_quotes(ignore_unmatched_quotes)$/;"	r
set_eliminate_specials	buffer.foo	/^   set_eliminate_specials(eliminate_specials)$/;"	r
set_replacement_list	buffer.foo	/^   set_replacement_list(replacement_list) ::: leaky$/;"	r
clear	buffer.foo	/^   clear$/;"	r
replace_list	buffer.foo	/^   replace_list(list)$/;"	r
eliminate_special_chars	buffer.foo	/^   eliminate_special_chars$/;"	r
analyse	buffer.foo	/^   analyse$/;"	r
get_item	buffer.foo	/^   get_item(item)$/;"	r
skip_item	buffer.foo	/^   skip_item$/;"	r
move_to_item	buffer.foo	/^   move_to_item(number)$/;"	r
get_str	buffer.foo	/^   get_str(value)$/;"	r
get_bin	buffer.foo	/^   get_bin(value)$/;"	r
get_int	buffer.foo	/^   get_int(value)$/;"	r
get_real	buffer.foo	/^   get_real(value)$/;"	r
get_cpx	buffer.foo	/^   get_cpx(value)$/;"	r
get_formatted_real	buffer.foo	/^   get_formatted_real(value,format)$/;"	r
get_imprecise_real	buffer.foo	/^   get_imprecise_real(value,error)$/;"	r
move_cursor	buffer.foo	/^   move_cursor(skip)$/;"	r
put_str	buffer.foo	/^   put_str(string)$/;"	r
put_formatted_str	buffer.foo	/^   put_formatted_str(value,format)$/;"	r
put_formatted_bin	buffer.foo	/^   put_formatted_bin(value,format)$/;"	r
put_formatted_int	buffer.foo	/^   put_formatted_int(value,format)$/;"	r
put_formatted_real	buffer.foo	/^   put_formatted_real(value,format)$/;"	r
put_formatted_cpx	buffer.foo	/^   put_formatted_cpx(value,format)$/;"	r
next_item_number	buffer.foo	/^   next_item_number result (res)$/;"	r
next_item	buffer.foo	/^   next_item result (res)$/;"	r
previous_item	buffer.foo	/^   previous_item result (res)$/;"	r
all_items	buffer.foo	/^   all_items result (res)$/;"	r
all_remaining_items	buffer.foo	/^   all_remaining_items result (res)$/;"	r
n_items	buffer.foo	/^   n_items result (res)$/;"	r
buffer_string	buffer.foo	/^   buffer_string result (res)$/;"	r
cursor_pointer	buffer.foo	/^   cursor_pointer result (res)$/;"	r
analysed	buffer.foo	/^   analysed result (res)$/;"	r
exhausted	buffer.foo	/^   exhausted result (res)$/;"	r
not_exhausted	buffer.foo	/^   not_exhausted result (res)$/;"	r
empty	buffer.foo	/^   empty result (res)$/;"	r
includes	buffer.foo	/^   includes(item) result (res)$/;"	r
square	capping_square.foo	/^   square :: MAT{INT}(1:2,0:3), private$/;"	g
vertex_1_of_edge	capping_square.foo	/^   vertex_1_of_edge :: VEC{INT}(0:3), private$/;"	g
vertex_2_of_edge	capping_square.foo	/^   vertex_2_of_edge :: VEC{INT}(0:3), private$/;"	g
xy_axis_of_edge	capping_square.foo	/^   xy_axis_of_edge :: VEC{INT}(0:3), private$/;"	g
triangle_table	capping_square.foo	/^   triangle_table :: MAT{INT}(0:11,0:15), private$/;"	g
face_normal_table	capping_square.foo	/^   face_normal_table :: MAT{REAL}(1:3,1:6)$/;"	g
create	capping_square.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create_copy	capping_square.foo	/^   create_copy(s) ::: leaky$/;"	r
copy	capping_square.foo	/^   copy(s) ::: leaky$/;"	r
destroy	capping_square.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	capping_square.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	capping_square.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	capping_square.foo	/^   set_defaults ::: leaky$/;"	r
reset	capping_square.foo	/^   reset ::: leaky$/;"	r
set_iso_value	capping_square.foo	/^   set_iso_value(iso_value)$/;"	r
set_n_pt	capping_square.foo	/^   set_n_pt(n_pt)$/;"	r
set_face	capping_square.foo	/^   set_face(face_number)$/;"	r
set_vertex_pos	capping_square.foo	/^   set_vertex_pos(pos)$/;"	r
set_vertex_values	capping_square.foo	/^   set_vertex_values(values)$/;"	r
set_edge_vertex_index	capping_square.foo	/^   set_edge_vertex_index(edge_index)$/;"	r
set_edge_vertex_pos	capping_square.foo	/^   set_edge_vertex_pos(edge_pos)$/;"	r
set_cap_vertex_flags	capping_square.foo	/^   set_cap_vertex_flags$/;"	r
set_case_info	capping_square.foo	/^   set_case_info $/;"	r
no_of_triangles	capping_square.foo	/^   no_of_triangles(case) result (res)$/;"	r
set_triangulation_info	capping_square.foo	/^   set_triangulation_info ::: leaky$/;"	r
no_of_new_vertices	capping_square.foo	/^   no_of_new_vertices result (res)$/;"	r
get_new_vertex_positions	capping_square.foo	/^   get_new_vertex_positions(pos)$/;"	r
get_new_vertex_gradients	capping_square.foo	/^   get_new_vertex_gradients(g)$/;"	r
get_new_mean_curvatures	capping_square.foo	/^   get_new_mean_curvatures(c)$/;"	r
get_new_gaussian_curvatures	capping_square.foo	/^   get_new_gaussian_curvatures(c)$/;"	r
get_triangle_vertex_indices	capping_square.foo	/^   get_triangle_vertex_indices(ind)$/;"	r
triangulate	capping_square.foo	/^   triangulate$/;"	r
set_triangle_vertex_info	capping_square.foo	/^   set_triangle_vertex_info ::: private$/;"	r
case_number	capping_square.foo	/^   case_number result (res)$/;"	r
put_case_info	capping_square.foo	/^   put_case_info$/;"	r
put	capping_square.foo	/^   put(output)$/;"	r
create	cif.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	cif.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	cif.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	cif.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	cif.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	cif.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	cif.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	cif.foo	/^   copy(cif) ::: leaky$/;"	r
create	cif.foo	/^   create(name) ::: leaky$/;"	r
set_defaults	cif.foo	/^   set_defaults(name) $/;"	r
set_file_name	cif.foo	/^   set_file_name(name) ::: leaky$/;"	r
set_data_block_name	cif.foo	/^   set_data_block_name(name) ::: leaky$/;"	r
open	cif.foo	/^   open $/;"	r
close	cif.foo	/^   close $/;"	r
read_keywords	cif.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	cif.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_data_block_name	cif.foo	/^   read_data_block_name$/;"	r
read_file_name	cif.foo	/^   read_file_name ::: leaky$/;"	r
read_apply_BH_bond_length	cif.foo	/^   read_apply_BH_bond_length$/;"	r
read_apply_CH_bond_length	cif.foo	/^   read_apply_CH_bond_length$/;"	r
read_apply_NH_bond_length	cif.foo	/^   read_apply_NH_bond_length$/;"	r
read_apply_OH_bond_length	cif.foo	/^   read_apply_OH_bond_length$/;"	r
read_BH_bond_length	cif.foo	/^   read_BH_bond_length$/;"	r
read_CH_bond_length	cif.foo	/^   read_CH_bond_length$/;"	r
read_NH_bond_length	cif.foo	/^   read_NH_bond_length$/;"	r
read_OH_bond_length	cif.foo	/^   read_OH_bond_length$/;"	r
apply_BH_bond_length	cif.foo	/^   apply_BH_bond_length result (apply)$/;"	r
apply_CH_bond_length	cif.foo	/^   apply_CH_bond_length result (apply)$/;"	r
apply_NH_bond_length	cif.foo	/^   apply_NH_bond_length result (apply)$/;"	r
apply_OH_bond_length	cif.foo	/^   apply_OH_bond_length result (apply)$/;"	r
read_U_iso_is_B_iso	cif.foo	/^   read_U_iso_is_B_iso$/;"	r
read_U_is_B	cif.foo	/^   read_U_is_B$/;"	r
read_U_is_beta	cif.foo	/^   read_U_is_beta$/;"	r
find_data_block	cif.foo	/^   find_data_block(block_name,found)$/;"	r
find_next_data_block	cif.foo	/^   find_next_data_block $/;"	r
find_start_of_data_block	cif.foo	/^   find_start_of_data_block ::: private$/;"	r
find_end_of_data_block	cif.foo	/^   find_end_of_data_block ::: private$/;"	r
find_crystal_data_block	cif.foo	/^   find_crystal_data_block(found)$/;"	r
find_item	cif.foo	/^   find_item(ID,found)$/;"	r
read_item	cif.foo	/^   read_item(ID,item,itemvec,found) ::: leaky$/;"	r
read_item	cif.foo	/^   read_item(ID,real,error,found)$/;"	r
read_item	cif.foo	/^   read_item(ID,int,found)$/;"	r
read_item	cif.foo	/^   read_item(ID,vec,found)$/;"	r
read_item	cif.foo	/^   read_item(ID,mat,found)$/;"	r
find_looped_item	cif.foo	/^   find_looped_item(ID,found,n_item,n_data)$/;"	r
read_looped_item	cif.foo	/^   read_looped_item(ID,ivec,found) ::: leaky$/;"	r
read_looped_item	cif.foo	/^   read_looped_item(ID,vec,error,found) ::: leaky$/;"	r
read_looped_item	cif.foo	/^   read_looped_item(ID,strvec,found) ::: leaky$/;"	r
find_looped_items	cif.foo	/^   find_looped_items(ID,found,ID_pos,ID_ind,n_labels)$/;"	r
read_looped_items	cif.foo	/^   read_looped_items(ID,mat,error,found) ::: leaky$/;"	r
read_looped_items	cif.foo	/^   read_looped_items(ID,mat,found) ::: leaky$/;"	r
debug_list	cluster.foo	/^   debug_list :: VEC{STR}*, private  DEFAULT_NULL$/;"	g
create	cluster.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	cluster.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	cluster.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	cluster.foo	/^   destroy_ptr_part ::: leaky$/;"	r
destroy_cluster_info_ptr_part	cluster.foo	/^   destroy_cluster_info_ptr_part ::: leaky$/;"	r
created	cluster.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	cluster.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	cluster.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	cluster.foo	/^   copy(cluster) ::: leaky$/;"	r
create	cluster.foo	/^   create(crystal) ::: leaky$/;"	r
set_defaults	cluster.foo	/^   set_defaults(crystal) ::: leaky$/;"	r
set_fragment_geometry	cluster.foo	/^   set_fragment_geometry(fragment_geometry,cartesian) ::: leaky$/;"	r
set_generation_method	cluster.foo	/^   set_generation_method(method)$/;"	r
set_unit_cell_offset	cluster.foo	/^   set_unit_cell_offset(offset)$/;"	r
read_keywords	cluster.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	cluster.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	cluster.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_unit_cell_offset	cluster.foo	/^   read_unit_cell_offset$/;"	r
read_generation_method	cluster.foo	/^   read_generation_method$/;"	r
read_defragment	cluster.foo	/^   read_defragment$/;"	r
read_radius	cluster.foo	/^   read_radius$/;"	r
read_atom_density_cutoff	cluster.foo	/^   read_atom_density_cutoff$/;"	r
read_fragment_geometry	cluster.foo	/^   read_fragment_geometry ::: leaky$/;"	r
set_fragment_geometry_from_first_atom_in_asymm_unit	cluster.foo	/^   set_fragment_geometry_from_first_atom_in_asymm_unit$/;"	r
read_fractional_fragment	cluster.foo	/^   read_fractional_fragment ::: leaky$/;"	r
read_atoms	cluster.foo	/^   read_atoms ::: leaky$/;"	r
make_info	cluster.foo	/^   make_info ::: leaky$/;"	r
make_occupation_list	cluster.foo	/^   make_occupation_list ::: leaky$/;"	r
make_radius	cluster.foo	/^   make_radius$/;"	r
make_within_radius	cluster.foo	/^   make_within_radius ::: leaky$/;"	r
do_connectify	cluster.foo	/^   do_connectify ::: leaky$/;"	r
do_defragment	cluster.foo	/^   do_defragment ::: leaky$/;"	r
do_defragment	cluster.foo	/^   do_defragment(occupation_list) ::: leaky$/;"	r
do_defragment_uc_atom	cluster.foo	/^   do_defragment_uc_atom(u,geometry) ::: leaky$/;"	r
do_defragment_uc_atom	cluster.foo	/^   do_defragment_uc_atom(u,symop,par,pos,mass) ::: leaky$/;"	r
do_defragment_uc_atom	cluster.foo	/^   do_defragment_uc_atom(u,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m) ::: leaky$/;"	r
do_defragment_uc_atom	cluster.foo	/^   do_defragment_uc_atom(u,pos,charge,dipole,frag_atom) ::: leaky$/;"	r
extract_geometry	cluster.foo	/^   extract_geometry ::: leaky$/;"	r
extract_geometry	cluster.foo	/^   extract_geometry(occupation_list,geometry) ::: leaky$/;"	r
extract_molecule_atom_info	cluster.foo	/^   extract_molecule_atom_info(occ_list,par,pos,mass)$/;"	r
extract_atom_info	cluster.foo	/^   extract_atom_info(occ_list,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m)$/;"	r
extract_atom_info	cluster.foo	/^   extract_atom_info(occ_list,pos,charge,dipole,frag_atom)$/;"	r
cartesian_geometry	cluster.foo	/^   cartesian_geometry result (res) ::: leaky$/;"	r
cluster_width	cluster.foo	/^   cluster_width result (res)$/;"	r
create_fragment_atom_list	cluster.foo	/^   create_fragment_atom_list(fragment_atom) ::: leaky$/;"	r
make_fragment_atom_list	cluster.foo	/^   make_fragment_atom_list(fragment_atom)$/;"	r
fragment_atom_indices	cluster.foo	/^   fragment_atom_indices result (res) $/;"	r
nonfragment_atom_indices	cluster.foo	/^   nonfragment_atom_indices result (res) $/;"	r
create_atom_list	cluster.foo	/^   create_atom_list(atom) ::: leaky$/;"	r
make_atom_list	cluster.foo	/^   make_atom_list(atom)$/;"	r
make_non_fragment_mu_charges	cluster.foo	/^   make_non_fragment_mu_charges(pos,charge)$/;"	r
make_non_fragment_qq_charges	cluster.foo	/^   make_non_fragment_qq_charges(pos,charge)$/;"	r
add_uc_tensors	cluster.foo	/^   add_uc_tensors(tensor) ::: template$/;"	r
add_uc_tensors	cluster.foo	/^   add_uc_tensors(tensor) ::: get_from(CLUSTER, TENSOR_TYPE=>MAT{REAL}(3,3))$/;"	r
add_uc_tensors	cluster.foo	/^   add_uc_tensors(tensor) ::: get_from(CLUSTER, TENSOR_TYPE=>MAT3{REAL}(3,3,3))$/;"	r
put_averaged_LFF_tensors	cluster.foo	/^   put_averaged_LFF_tensors$/;"	r
put_centroid_LFF_tensors	cluster.foo	/^   put_centroid_LFF_tensors$/;"	r
put_centroid_LFF_tensors_old	cluster.foo	/^   put_centroid_LFF_tensors_old $/;"	r
get_uc_molecule_centroids	cluster.foo	/^   get_uc_molecule_centroids(centroid) $/;"	r
put_LFF_info	cluster.foo	/^   put_LFF_info$/;"	r
make_chi1_naive	cluster.foo	/^   make_chi1_naive(chi1,alpha_mol)$/;"	r
make_alpha_uc	cluster.foo	/^   make_alpha_uc(alpha_uc,alpha_mol)$/;"	r
make_chi1_ALFFA	cluster.foo	/^   make_chi1_ALFFA(chi1,alpha_mol)$/;"	r
make_chi1_RLFTn	cluster.foo	/^   make_chi1_RLFTn(chi1,alpha_mol)$/;"	r
make_chi1_RLFTn_av_L	cluster.foo	/^   make_chi1_RLFTn_av_L(chi1,alpha_mol)$/;"	r
make_local_field_factors	cluster.foo	/^   make_local_field_factors(Df,D)$/;"	r
make_D_matrix	cluster.foo	/^   make_D_matrix(D)$/;"	r
make_Dnc_matrix	cluster.foo	/^   make_Dnc_matrix(Dnc)$/;"	r
make_Lorentz_fields	cluster.foo	/^   make_Lorentz_fields(F,sphere_sum)$/;"	r
make_Lorentz_interactions	cluster.foo	/^   make_Lorentz_interactions(I0,I1,sphere_sum)$/;"	r
get_uc_molecule_info	cluster.foo	/^   get_uc_molecule_info(mol,symop,par,pos,com) ::: leaky$/;"	r
get_uc_molecule_info	cluster.foo	/^   get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m) ::: leaky$/;"	r
get_uc_molecule_info	cluster.foo	/^   get_uc_molecule_info(mol,pos,charge,dipole,frag_atom) ::: leaky$/;"	r
put	cluster.foo	/^   put$/;"	r
put_fragment_geometry	cluster.foo	/^   put_fragment_geometry$/;"	r
put_occupation_list	cluster.foo	/^   put_occupation_list$/;"	r
put_atom_connection_table	cluster.foo	/^   put_atom_connection_table$/;"	r
put_atom_symmetry_table	cluster.foo	/^   put_atom_symmetry_table$/;"	r
put_tonto_input	cluster.foo	/^   put_tonto_input$/;"	r
put_CX	cluster.foo	/^   put_CX(label,angstrom)$/;"	r
put_CX_atoms	cluster.foo	/^   put_CX_atoms$/;"	r
put_spartan	cluster.foo	/^   put_spartan(label)$/;"	r
read_debug_on	cluster.foo	/^   read_debug_on ::: get_from(DEBUG), leaky$/;"	r
read_debug_off	cluster.foo	/^   read_debug_off ::: get_from(DEBUG), leaky$/;"	r
debugging	cluster.foo	/^   debugging(name) result (res) ::: get_from(DEBUG)$/;"	r
put_debug_list	cluster.foo	/^   put_debug_list ::: get_from(DEBUG)$/;"	r
put_debug	cluster.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)$/;"	r
put_debug	cluster.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{INT})$/;"	r
put_debug	cluster.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})$/;"	r
put_debug	cluster.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})$/;"	r
std_colour_RGB255	colour.foo	/^   std_colour_RGB255 :: MAT{INT}(3,650), private$/;"	g
std_colour_names	colour.foo	/^   std_colour_names :: VEC{STR}(650), private$/;"	g
set	colour.foo	/^   set(RGB255)$/;"	r
set	colour.foo	/^   set(name)$/;"	r
is_a_valid_RGB255	colour.foo	/^   is_a_valid_RGB255 result (res)$/;"	r
is_a_valid_RGB255	colour.foo	/^   is_a_valid_RGB255(RGB255) result (res)$/;"	r
is_a_known_colourname	colour.foo	/^   is_a_known_colourname(index) result (res)$/;"	r
is_a_known_colourname	colour.foo	/^   is_a_known_colourname(name,index) result (res)$/;"	r
index_of_colourname	colour.foo	/^   index_of_colourname result (res)$/;"	r
index_of_colourname	colour.foo	/^   index_of_colourname(name) result (res)$/;"	r
nearest_colourname	colour.foo	/^   nearest_colourname result (res)$/;"	r
nearest_colourname_for	colour.foo	/^   nearest_colourname_for(RGB255,index) result (res)$/;"	r
read	colour.foo	/^   read$/;"	r
read_RGB255	colour.foo	/^   read_RGB255$/;"	r
read_RGB	colour.foo	/^   read_RGB$/;"	r
read_name	colour.foo	/^   read_name$/;"	r
create	colour_function.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	colour_function.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	colour_function.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	colour_function.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	colour_function.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	colour_function.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	colour_function.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	colour_function.foo	/^   copy(c) ::: leaky$/;"	r
create	colour_function.foo	/^   create(range) ::: leaky$/;"	r
set_defaults	colour_function.foo	/^   set_defaults(range) ::: leaky$/;"	r
set_reverse_defaults	colour_function.foo	/^   set_reverse_defaults(range)$/;"	r
read_keywords	colour_function.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	colour_function.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	colour_function.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_data_and_RGB	colour_function.foo	/^   read_data_and_RGB ::: leaky$/;"	r
finalise	colour_function.foo	/^   finalise ::: leaky$/;"	r
set_data	colour_function.foo	/^   set_data(data) ::: leaky$/;"	r
set_RGB	colour_function.foo	/^   set_RGB(RGB) ::: leaky$/;"	r
RGB_for	colour_function.foo	/^   RGB_for(value,truncate_to_range) result (res)$/;"	r
RGB255_for	colour_function.foo	/^   RGB255_for(value) result (res)$/;"	r
get_RGB_for	colour_function.foo	/^   get_RGB_for(values,RGB)$/;"	r
get_RGB_for	colour_function.foo	/^   get_RGB_for(values,RGB)$/;"	r
get_RGB_for	colour_function.foo	/^   get_RGB_for(values,RGB)$/;"	r
get_RGB255_for	colour_function.foo	/^   get_RGB255_for(values,RGB255)$/;"	r
rescale_data	colour_function.foo	/^   rescale_data(range)$/;"	r
set_default_colours	colour_function.foo	/^   set_default_colours(values) ::: leaky$/;"	r
put	colour_function.foo	/^   put$/;"	r
keys	coppensbasis.foo	/^   keys :: VEC{STR}*, private  DEFAULT_NULL$/;"	g
create	coppensbasis.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	coppensbasis.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	coppensbasis.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	coppensbasis.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	coppensbasis.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	coppensbasis.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	coppensbasis.foo	/^   create_copy(b) ::: leaky$/;"	r
copy	coppensbasis.foo	/^   copy(b) ::: leaky$/;"	r
set_defaults	coppensbasis.foo	/^   set_defaults$/;"	r
update	coppensbasis.foo	/^   update$/;"	r
set_label	coppensbasis.foo	/^   set_label(label)$/;"	r
resolve_by_label	coppensbasis.foo	/^   resolve_by_label(label,basis,clobber,minlab,found) ::: get_from(BASIS, BASIS=>COPPENSBASIS)$/;"	r
read_keywords	coppensbasis.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	coppensbasis.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	coppensbasis.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_label	coppensbasis.foo	/^   read_label$/;"	r
read_orbitals	coppensbasis.foo	/^   read_orbitals ::: leaky$/;"	r
read_tonto_style	coppensbasis.foo	/^   read_tonto_style ::: leaky$/;"	r
put	coppensbasis.foo	/^   put$/;"	r
put_table	coppensbasis.foo	/^   put_table$/;"	r
read_keys	coppensbasis.foo	/^   read_keys ::: get_from(OBJECT)$/;"	r
process_keys	coppensbasis.foo	/^   process_keys ::: get_from(OBJECT), leaky$/;"	r
keys_created	coppensbasis.foo	/^   keys_created result (res) ::: get_from(OBJECT)$/;"	r
set_keys	coppensbasis.foo	/^   set_keys(the_keys) ::: get_from(OBJECT)$/;"	r
clear_keys	coppensbasis.foo	/^   clear_keys ::: get_from(OBJECT)$/;"	r
put_table_footer	coppensbasis.foo	/^   put_table_footer ::: get_from(OBJECT)$/;"	r
put_table_header	coppensbasis.foo	/^   put_table_header$/;"	r
table_width	coppensbasis.foo	/^   table_width result (res)$/;"	r
is_resolved	coppensbasis.foo	/^   is_resolved result (res) ::: get_from(BASIS, shell=>orbital), pure$/;"	r
is_created_and_resolved	coppensbasis.foo	/^   is_created_and_resolved result (res) ::: get_from(BASIS, shell=>orbital)$/;"	r
is_created_and_has_label	coppensbasis.foo	/^   is_created_and_has_label result (res) ::: get_from(BASIS)$/;"	r
same_as	coppensbasis.foo	/^   same_as(b) result (res)$/;"	r
no_of_orbitals	coppensbasis.foo	/^   no_of_orbitals result (res) ::: pure$/;"	r
no_of_primitives	coppensbasis.foo	/^   no_of_primitives result (res) ::: pure$/;"	r
maximum_basis_n_value	coppensbasis.foo	/^   maximum_basis_n_value result (res)$/;"	r
min_exponent	coppensbasis.foo	/^   min_exponent result (res) ::: pure$/;"	r
make_density_grid	coppensbasis.foo	/^   make_density_grid(density_grid,pt,pos,occ)$/;"	r
add_density_grid	coppensbasis.foo	/^   add_density_grid(density_grid,pt,pos,occ)$/;"	r
make_normal_density_grid	coppensbasis.foo	/^   make_normal_density_grid(density_grid,pt,pos,occ)$/;"	r
add_normal_density_grid	coppensbasis.foo	/^   add_normal_density_grid(density_grid,pt,pos,occ)$/;"	r
make_interpolated_density	coppensbasis.foo	/^   make_interpolated_density(density,pt,pos,occ)$/;"	r
add_interpolated_density	coppensbasis.foo	/^   add_interpolated_density(density,pt,pos,occ)$/;"	r
density_at_radius	coppensbasis.foo	/^   density_at_radius(R) result (res)$/;"	r
make_interpolator	coppensbasis.foo	/^   make_interpolator(interpolator) ::: leaky$/;"	r
interpolator_table_length	coppensbasis.foo	/^   interpolator_table_length(tol) result (length)$/;"	r
unnormalise	coppensbasis.foo	/^   unnormalise$/;"	r
renormalise	coppensbasis.foo	/^   renormalise$/;"	r
keys	coppensorbital.foo	/^   keys :: VEC{STR}*, private DEFAULT_NULL$/;"	g
values_cutoff	coppensorbital.foo	/^   values_cutoff :: REAL, private = COPPENSORBITAL_VALUES_CUTOFF$/;"	g
create	coppensorbital.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	coppensorbital.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	coppensorbital.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	coppensorbital.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	coppensorbital.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	coppensorbital.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	coppensorbital.foo	/^   set_defaults$/;"	r
copy	coppensorbital.foo	/^   copy(c) ::: leaky$/;"	r
ex	coppensorbital.foo	/^   ex(i) result (res)$/;"	r
cc	coppensorbital.foo	/^   cc(i) result (res)$/;"	r
read_keywords	coppensorbital.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	coppensorbital.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_orb_kind	coppensorbital.foo	/^   read_orb_kind$/;"	r
read_occupancy	coppensorbital.foo	/^   read_occupancy$/;"	r
read_n_fun	coppensorbital.foo	/^   read_n_fun$/;"	r
read_n	coppensorbital.foo	/^   read_n ::: leaky$/;"	r
read_c	coppensorbital.foo	/^   read_c ::: leaky$/;"	r
read_z	coppensorbital.foo	/^   read_z ::: leaky$/;"	r
read_n_c_z	coppensorbital.foo	/^   read_n_c_z ::: leaky$/;"	r
read_n_c_z_ptr	coppensorbital.foo	/^   read_n_c_z_ptr ::: leaky$/;"	r
read_orb_kind_occ_num_n_c_z	coppensorbital.foo	/^   read_orb_kind_occ_num_n_c_z ::: leaky$/;"	r
read_values_cutoff	coppensorbital.foo	/^   read_values_cutoff$/;"	r
read_keys	coppensorbital.foo	/^   read_keys ::: get_from(OBJECT)$/;"	r
process_keys	coppensorbital.foo	/^   process_keys ::: get_from(OBJECT), leaky$/;"	r
keys_created	coppensorbital.foo	/^   keys_created result (res) ::: get_from(OBJECT)$/;"	r
set_keys	coppensorbital.foo	/^   set_keys(the_keys) ::: get_from(OBJECT)$/;"	r
clear_keys	coppensorbital.foo	/^   clear_keys ::: get_from(OBJECT)$/;"	r
put_table_footer	coppensorbital.foo	/^   put_table_footer ::: get_from(OBJECT)$/;"	r
put_table_header	coppensorbital.foo	/^   put_table_header$/;"	r
table_width	coppensorbital.foo	/^   table_width result (res)$/;"	r
same_as	coppensorbital.foo	/^   same_as(b) result (res)$/;"	r
density_at_radius	coppensorbital.foo	/^   density_at_radius(R) result (res)$/;"	r
densities_at_radii	coppensorbital.foo	/^   densities_at_radii(R) result (res)$/;"	r
value_at_radius	coppensorbital.foo	/^   value_at_radius(R) result (res)$/;"	r
values_at_radii	coppensorbital.foo	/^   values_at_radii(R) result (res)$/;"	r
radial_density_at_radius	coppensorbital.foo	/^   radial_density_at_radius(R) result (res)$/;"	r
unnormalise	coppensorbital.foo	/^   unnormalise $/;"	r
renormalise	coppensorbital.foo	/^   renormalise $/;"	r
put	coppensorbital.foo	/^   put$/;"	r
put_table	coppensorbital.foo	/^   put_table$/;"	r
str_length	cpx.foo	/^   str_length(spaces) result (res) ::: get_from(INTRINSIC, FMT=>*), pure$/;"	r
str_length_with_precision	cpx.foo	/^   str_length_with_precision(dp,spaces) result (res) ::: pure$/;"	r
to_str	cpx.foo	/^   to_str result (string) ::: get_from(INTRINSIC, FMT=>*), pure$/;"	r
to_str	cpx.foo	/^   to_str(format,left_justify) result (string) ::: get_from(INTRINSIC), pure$/;"	r
to_str	cpx.foo	/^   to_str(style,width,precision,left_justify) result (string) ::: get_from(INTRINSIC), pure$/;"	r
equals	cpx.foo	/^   equals(c,eps) result (res) ::: pure$/;"	r
same_as	cpx.foo	/^   same_as(c,eps) result (res) ::: pure$/;"	r
is_zero	cpx.foo	/^   is_zero(eps) result (res) ::: pure$/;"	r
is_one	cpx.foo	/^   is_one(eps) result (res) ::: pure$/;"	r
is_minus_one	cpx.foo	/^   is_minus_one(eps) result (res) ::: pure$/;"	r
saved_self	crystal.foo	/^   saved_self :: CRYSTAL*$/;"	g
debug_list	crystal.foo	/^   debug_list :: VEC{STR}*, private  DEFAULT_NULL$/;"	g
create	crystal.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	crystal.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	crystal.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	crystal.foo	/^   destroy_ptr_part ::: leaky$/;"	r
destroy_data	crystal.foo	/^   destroy_data ::: leaky$/;"	r
destroy_fragment_data	crystal.foo	/^   destroy_fragment_data ::: leaky$/;"	r
destroy_asymmetric_unit	crystal.foo	/^   destroy_asymmetric_unit ::: leaky$/;"	r
created	crystal.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	crystal.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	crystal.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	crystal.foo	/^   copy(crystal) ::: leaky$/;"	r
set_defaults	crystal.foo	/^   set_defaults ::: leaky$/;"	r
update	crystal.foo	/^   update ::: leaky$/;"	r
set_r_free_reflections	crystal.foo	/^   set_r_free_reflections(data,free_data) ::: leaky$/;"	r
assign_xray	crystal.foo	/^   assign_xray $/;"	r
assign_xray_r_free	crystal.foo	/^   assign_xray_r_free$/;"	r
assign_pnd	crystal.foo	/^   assign_pnd $/;"	r
assign_pnd_r_free	crystal.foo	/^   assign_pnd_r_free$/;"	r
read_keywords	crystal.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	crystal.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	crystal.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_junk	crystal.foo	/^   read_junk ::: get_from(OBJECT), selfless, private$/;"	r
redirect	crystal.foo	/^   redirect ::: get_from(OBJECT), leaky$/;"	r
revert	crystal.foo	/^   revert ::: get_from(OBJECT), leaky$/;"	r
read_kind	crystal.foo	/^   read_kind$/;"	r
read_finalize	crystal.foo	/^   read_finalize$/;"	r
read_r_free_percentage	crystal.foo	/^   read_r_free_percentage$/;"	r
read_spacegroup	crystal.foo	/^   read_spacegroup ::: leaky$/;"	r
read_unit_cell	crystal.foo	/^   read_unit_cell $/;"	r
read_xray_data	crystal.foo	/^   read_xray_data ::: leaky$/;"	r
read_pnd_data	crystal.foo	/^   read_pnd_data ::: leaky$/;"	r
read_use_manual_rep_factors	crystal.foo	/^   read_use_manual_rep_factors ::: leaky, private$/;"	r
read_repetition_factors	crystal.foo	/^   read_repetition_factors ::: leaky, private$/;"	r
read_prune_asymmetric_unit	crystal.foo	/^   read_prune_asymmetric_unit ::: private$/;"	r
read_CIF	crystal.foo	/^   read_CIF ::: leaky$/;"	r
read_CIF	crystal.foo	/^   read_CIF(cif,skip_atoms) ::: leaky$/;"	r
read_CIF_atoms	crystal.foo	/^   read_CIF_atoms(cif) ::: leaky, private$/;"	r
read_asymmetric_unit_geometry	crystal.foo	/^   read_asymmetric_unit_geometry$/;"	r
make_k_pts	crystal.foo	/^   make_k_pts(res)$/;"	r
n_unique_SF_k_pts	crystal.foo	/^   n_unique_SF_k_pts result (res) ::: pure$/;"	r
make_unique_SF_k_pts	crystal.foo	/^   make_unique_SF_k_pts(k)$/;"	r
d_chi2_dX	crystal.foo	/^   d_chi2_dX(res,dFdX)$/;"	r
d_chi2_dX_plus_se	crystal.foo	/^   d_chi2_dX_plus_se(res,dFdX)$/;"	r
d_F_abs_dX	crystal.foo	/^   d_F_abs_dX(res,dFdX)$/;"	r
solve_normal_equations	crystal.foo	/^   solve_normal_equations(shifts,dFdX) ::: leaky$/;"	r
initialise_refinement	crystal.foo	/^   initialise_refinement$/;"	r
put_iteration_results	crystal.foo	/^   put_iteration_results$/;"	r
set_parameter_errors	crystal.foo	/^   set_parameter_errors$/;"	r
finalise_refinement	crystal.foo	/^   finalise_refinement$/;"	r
put_refinement_results	crystal.foo	/^   put_refinement_results(no_correlations)$/;"	r
get_precision_and_error	crystal.foo	/^   get_precision_and_error(value,error,p,d,n,e,angstrom,angstrom2) ::: private$/;"	r
refinement_finished	crystal.foo	/^   refinement_finished(chi2_increased,too_many,converged) result (res)$/;"	r
sum_unique_sf	crystal.foo	/^   sum_unique_sf(sf,unique_sf)$/;"	r
sum_unique_sf_ints	crystal.foo	/^   sum_unique_sf_ints(sf_ints,unique_sf_ints)$/;"	r
sum_unique_sf_derivs	crystal.foo	/^   sum_unique_sf_derivs(sf,unique_sf)$/;"	r
sum_unique_sf_derivs_t	crystal.foo	/^   sum_unique_sf_derivs_t(sf,unique_sf)$/;"	r
sum_unique_sf_pts	crystal.foo	/^   sum_unique_sf_pts(X,k_pts,pts,tf,Fr,Fc)$/;"	r
make_fragment_data	crystal.foo	/^   make_fragment_data(atom,warnings) ::: leaky$/;"	r
make_fragment_data	crystal.foo	/^   make_fragment_data(fragment_geometry,cartesian) ::: leaky$/;"	r
make_asymmetric_unit	crystal.foo	/^   make_asymmetric_unit(atom,prune_asymmetric_unit,warnings) ::: leaky, private$/;"	r
make_frag_atom_for_cell_atom	crystal.foo	/^   make_frag_atom_for_cell_atom(atom) ::: leaky, private$/;"	r
make_frag_atom_for_cell_atom	crystal.foo	/^   make_frag_atom_for_cell_atom ::: leaky, private$/;"	r
make_unique_frag_atoms	crystal.foo	/^   make_unique_frag_atoms ::: leaky, private$/;"	r
make_unit_cell_connections	crystal.foo	/^   make_unit_cell_connections ::: leaky$/;"	r
make_uc_vdw_connections	crystal.foo	/^   make_uc_vdw_connections ::: leaky$/;"	r
z_factor	crystal.foo	/^   z_factor result (res)$/;"	r
make_repetition_factors	crystal.foo	/^   make_repetition_factors ::: leaky, private$/;"	r
make_asym_atom_rep_factors	crystal.foo	/^   make_asym_atom_rep_factors ::: leaky, private$/;"	r
reset_H_bond_lengths_in	crystal.foo	/^   reset_H_bond_lengths_in(atom,H_bond_length,reset) ::: leaky$/;"	r
transform_geometry	crystal.foo	/^   transform_geometry(g,op,translate,ignore_glide,to_unit_cell)$/;"	r
transform_position	crystal.foo	/^   transform_position(p,op,translate,ignore_glide,to_unit_cell,unit_cell_shift) $/;"	r
put_to_unit_cell	crystal.foo	/^   put_to_unit_cell(g)$/;"	r
put_to_unit_cell	crystal.foo	/^   put_to_unit_cell(p,shift)$/;"	r
move_to_unit_cell	crystal.foo	/^   move_to_unit_cell(g)$/;"	r
unit_cell_offset	crystal.foo	/^   unit_cell_offset(g) result (res)$/;"	r
fragment_width	crystal.foo	/^   fragment_width result (res)$/;"	r
cartesian_fragment_width	crystal.foo	/^   cartesian_fragment_width result (res)$/;"	r
make_xyz_seitz_matrices	crystal.foo	/^   make_xyz_seitz_matrices(res) ::: leaky$/;"	r
xyz_seitz_matrices	crystal.foo	/^   xyz_seitz_matrices result (res) ::: leaky$/;"	r
transposed_xyz_seitz_matrices	crystal.foo	/^   transposed_xyz_seitz_matrices result (res) ::: leaky$/;"	r
make_stabilizer_symops	crystal.foo	/^   make_stabilizer_symops ::: leaky, private$/;"	r
is_same_geometry	crystal.foo	/^   is_same_geometry(geom_i,geom_j) result (res) ::: private$/;"	r
xyz_stabilizer_matrices	crystal.foo	/^   xyz_stabilizer_matrices result (res) ::: leaky$/;"	r
make_stabilizer_xyz_matrices	crystal.foo	/^   make_stabilizer_xyz_matrices ::: leaky, private$/;"	r
xyz_stabilizer_matrix	crystal.foo	/^   xyz_stabilizer_matrix(n,l) result (res)$/;"	r
make_list_of_equivalents	crystal.foo	/^   make_list_of_equivalents(list,n_unique,show) ::: leaky, private$/;"	r
merge_equivalents	crystal.foo	/^   merge_equivalents ::: leaky$/;"	r
make_list_of_equivalents_ord	crystal.foo	/^   make_list_of_equivalents_ord(list,n_unique,show) ::: leaky, private$/;"	r
merge_ordered_equivalents	crystal.foo	/^   merge_ordered_equivalents ::: leaky$/;"	r
expand_unique_reflections	crystal.foo	/^   expand_unique_reflections ::: leaky$/;"	r
read_debug_on	crystal.foo	/^   read_debug_on ::: get_from(DEBUG), leaky$/;"	r
read_debug_off	crystal.foo	/^   read_debug_off ::: get_from(DEBUG), leaky$/;"	r
debugging	crystal.foo	/^   debugging(name) result (res) ::: get_from(DEBUG)$/;"	r
put_debug_list	crystal.foo	/^   put_debug_list ::: get_from(DEBUG)$/;"	r
put_debug	crystal.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)$/;"	r
put_debug	crystal.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{INT})$/;"	r
put_debug	crystal.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})$/;"	r
put_debug	crystal.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})$/;"	r
put_debug	crystal.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{CPX})$/;"	r
put_debug	crystal.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT3{REAL})$/;"	r
put	crystal.foo	/^   put$/;"	r
put_xyz_seitz	crystal.foo	/^   put_xyz_seitz$/;"	r
put_asymmetric_unit_geometry	crystal.foo	/^   put_asymmetric_unit_geometry ::: private$/;"	r
put_asym_atom_rep_factors	crystal.foo	/^   put_asym_atom_rep_factors ::: private$/;"	r
put_unit_cell_geometry	crystal.foo	/^   put_unit_cell_geometry ::: private$/;"	r
put_pdb	crystal.foo	/^   put_pdb(pdbfile)$/;"	r
make_cif_errors	crystal.foo	/^   make_cif_errors(delta_p)$/;"	r
put_cif	crystal.foo	/^   put_cif(basis,scf_type)$/;"	r
put_accurate_cif	crystal.foo	/^   put_accurate_cif(basis,scf_type)$/;"	r
put_molecule_cif	crystal.foo	/^   put_molecule_cif(atom,basis,scf_type)$/;"	r
put_NKA_cartesian	crystal.foo	/^   put_NKA_cartesian$/;"	r
put_NKA_crystal	crystal.foo	/^   put_NKA_crystal$/;"	r
put_excel_crystal	crystal.foo	/^   put_excel_crystal$/;"	r
put_uc_connection_table	crystal.foo	/^   put_uc_connection_table$/;"	r
put_uc_vdw_connection_table	crystal.foo	/^   put_uc_vdw_connection_table$/;"	r
put_fragment_data	crystal.foo	/^   put_fragment_data ::: private$/;"	r
put_stabilizer_symops	crystal.foo	/^   put_stabilizer_symops ::: private$/;"	r
put_fragment_geometry	crystal.foo	/^   put_fragment_geometry ::: private$/;"	r
put_reflection_data	crystal.foo	/^   put_reflection_data$/;"	r
put_correction_data	crystal.foo	/^   put_correction_data$/;"	r
put_F_statistics	crystal.foo	/^   put_F_statistics$/;"	r
put_F_calc	crystal.foo	/^   put_F_calc$/;"	r
put_PND_sf	crystal.foo	/^   put_PND_sf(name)$/;"	r
put_CX	crystal.foo	/^   put_CX(label,formula,spacegroup)$/;"	r
put_fitting_plots	crystal.foo	/^   put_fitting_plots$/;"	r
put_chi2_vs_angle_plot	crystal.foo	/^   put_chi2_vs_angle_plot$/;"	r
put_qq_plot	crystal.foo	/^   put_qq_plot$/;"	r
put_labelled_qq_plot	crystal.foo	/^   put_labelled_qq_plot$/;"	r
put_fcalc_plots	crystal.foo	/^   put_fcalc_plots$/;"	r
make_residual_error_map	crystal.foo	/^   make_residual_error_map(map,pts)$/;"	r
reflection_data_exists	crystal.foo	/^   reflection_data_exists result (res)$/;"	r
data_exists	crystal.foo	/^   data_exists result (res)$/;"	r
asymmetric_unit_exists	crystal.foo	/^   asymmetric_unit_exists result (res)$/;"	r
unit_cell_geometry_exists	crystal.foo	/^   unit_cell_geometry_exists result (res)$/;"	r
fragment_data_exists	crystal.foo	/^   fragment_data_exists result (res)$/;"	r
n_refl	crystal.foo	/^   n_refl result (res)$/;"	r
F_exp	crystal.foo	/^   F_exp result (res)$/;"	r
F_sigma	crystal.foo	/^   F_sigma result (res)$/;"	r
F_calc	crystal.foo	/^   F_calc result (res)$/;"	r
F_chi2	crystal.foo	/^   F_chi2 result (res)$/;"	r
F_goodness_of_fit	crystal.foo	/^   F_goodness_of_fit result (res)$/;"	r
F_r_factor	crystal.foo	/^   F_r_factor result (res)$/;"	r
F_weighted_r_factor	crystal.foo	/^   F_weighted_r_factor result (res)$/;"	r
F_val_r_factor	crystal.foo	/^   F_val_r_factor result (res) $/;"	r
set_F_calc	crystal.foo	/^   set_F_calc(F_calc)$/;"	r
make_F_predicted	crystal.foo	/^   make_F_predicted$/;"	r
update_n_param_and_chi2	crystal.foo	/^   update_n_param_and_chi2$/;"	r
extinction_correction	crystal.foo	/^   extinction_correction result (res)$/;"	r
n_param	crystal.foo	/^   n_param result (res)$/;"	r
partition_model	crystal.foo	/^   partition_model result (res)$/;"	r
thermal_smearing_model	crystal.foo	/^   thermal_smearing_model result (res)$/;"	r
correct_dispersion	crystal.foo	/^   correct_dispersion result (res)$/;"	r
wavelength	crystal.foo	/^   wavelength result (res)$/;"	r
optimise_extinction	crystal.foo	/^   optimise_extinction result (res)$/;"	r
optimise_scale	crystal.foo	/^   optimise_scale result (res)$/;"	r
xyz_asymmetric_unit_geometry	crystal.foo	/^   xyz_asymmetric_unit_geometry result (res)$/;"	r
simulate_new_F_exp	crystal.foo	/^   simulate_new_F_exp$/;"	r
debug_list	debug.foo	/^   debug_list :: VEC{STR}*, private  DEFAULT_NULL$/;"	g
read_debug_on	debug.foo	/^   read_debug_on ::: leaky$/;"	r
read_debug_off	debug.foo	/^   read_debug_off ::: leaky$/;"	r
debugging	debug.foo	/^   debugging(name) result (res)$/;"	r
put_debug_list	debug.foo	/^   put_debug_list$/;"	r
put_debug	debug.foo	/^   put_debug(X,name) ::: template$/;"	r
put_debug	debug.foo	/^   put_debug(X,name) ::: template$/;"	r
put_debug	debug.foo	/^   put_debug(X,name) ::: template$/;"	r
put_debug	debug.foo	/^   put_debug(X,name) ::: template$/;"	r
create	dft_functional.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	dft_functional.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	dft_functional.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	dft_functional.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
nullify_ptr_part	dft_functional.foo	/^   nullify_ptr_part $/;"	r
destroy_ptr_part	dft_functional.foo	/^   destroy_ptr_part $/;"	r
create_copy	dft_functional.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	dft_functional.foo	/^   copy(d) ::: leaky$/;"	r
set_defaults	dft_functional.foo	/^   set_defaults$/;"	r
set_rho_cutoff	dft_functional.foo	/^   set_rho_cutoff(cutoff)$/;"	r
read_keywords	dft_functional.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	dft_functional.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_name	dft_functional.foo	/^   read_name$/;"	r
read_Xalpha	dft_functional.foo	/^   read_Xalpha$/;"	r
read_rho_cutoff	dft_functional.foo	/^   read_rho_cutoff$/;"	r
is_GGA_functional	dft_functional.foo	/^   is_GGA_functional(name) result (res)$/;"	r
is_LDA_functional	dft_functional.foo	/^   is_LDA_functional(name) result (res)$/;"	r
new_r_functional	dft_functional.foo	/^   new_r_functional(name,E,N0,Nx,Ny,Nz)$/;"	r
new_r_energy_density	dft_functional.foo	/^   new_r_energy_density(name,E,N0,Nx,Ny,Nz)$/;"	r
new_r_potential	dft_functional.foo	/^   new_r_potential(name,V0,N0,Vx,Vy,Vz,Nx,Ny,Nz)$/;"	r
new_u_functional	dft_functional.foo	/^   new_u_functional(name,E,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)$/;"	r
new_u_energy_density	dft_functional.foo	/^   new_u_energy_density(name,E,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)$/;"	r
new_u_potential	dft_functional.foo	/^   new_u_potential(name,V0a,V0b,N0a,N0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,Nxa,Nya,Nza,Nxb,Nyb,Nzb)$/;"	r
new_r_LDA_x_functional	dft_functional.foo	/^   new_r_LDA_x_functional(E,N0)$/;"	r
new_r_LDA_x_energy_density	dft_functional.foo	/^   new_r_LDA_x_energy_density(E,N0)$/;"	r
new_r_LDA_x_potential	dft_functional.foo	/^   new_r_LDA_x_potential(V0,N0)$/;"	r
new_u_LDA_x_functional	dft_functional.foo	/^   new_u_LDA_x_functional(E,N0a,N0b)$/;"	r
new_u_LDA_x_energy_density	dft_functional.foo	/^   new_u_LDA_x_energy_density(E,N0a,N0b)$/;"	r
new_u_LDA_x_potential	dft_functional.foo	/^   new_u_LDA_x_potential(V0a,V0b,N0a,N0b)$/;"	r
new_r_Xalpha_x_functional	dft_functional.foo	/^   new_r_Xalpha_x_functional(E,N0)$/;"	r
new_r_Xalpha_x_energy_density	dft_functional.foo	/^   new_r_Xalpha_x_energy_density(E,N0)$/;"	r
new_r_Xalpha_x_potential	dft_functional.foo	/^   new_r_Xalpha_x_potential(V0,N0)$/;"	r
new_u_Xalpha_x_functional	dft_functional.foo	/^   new_u_Xalpha_x_functional(E,N0a,N0b)$/;"	r
new_u_Xalpha_x_energy_density	dft_functional.foo	/^   new_u_Xalpha_x_energy_density(E,N0a,N0b)$/;"	r
new_u_Xalpha_x_potential	dft_functional.foo	/^   new_u_Xalpha_x_potential(V0a,V0b,N0a,N0b)$/;"	r
new_r_Becke88_x_functional	dft_functional.foo	/^   new_r_Becke88_x_functional(E,N0,Nx,Ny,Nz)$/;"	r
new_r_Becke88_x_energy_density	dft_functional.foo	/^   new_r_Becke88_x_energy_density(E,N0,Nx,Ny,Nz)$/;"	r
new_r_Becke88_x_potential	dft_functional.foo	/^   new_r_Becke88_x_potential(V0,N0,Vx,Vy,Vz,Nx,Ny,Nz)$/;"	r
new_u_Becke88_x_functional	dft_functional.foo	/^   new_u_Becke88_x_functional(E,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)$/;"	r
new_u_Becke88_x_energy_density	dft_functional.foo	/^   new_u_Becke88_x_energy_density(E,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)$/;"	r
new_u_Becke88_x_potential	dft_functional.foo	/^   new_u_Becke88_x_potential(V0a,V0b,N0a,N0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,Nxa,Nya,Nza,Nxb,Nyb,Nzb)$/;"	r
new_r_LYP_c_functional	dft_functional.foo	/^   new_r_LYP_c_functional(E,N0,Nx,Ny,Nz)$/;"	r
new_r_LYP_c_energy_density	dft_functional.foo	/^   new_r_LYP_c_energy_density(E,N0,Nx,Ny,Nz)$/;"	r
new_r_LYP_c_potential	dft_functional.foo	/^   new_r_LYP_c_potential(V0,N0,Vx,Vy,Vz,Nx,Ny,Nz)$/;"	r
new_u_LYP_c_functional	dft_functional.foo	/^   new_u_LYP_c_functional(f,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)$/;"	r
new_u_LYP_c_energy_density	dft_functional.foo	/^   new_u_LYP_c_energy_density(f,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)$/;"	r
new_u_LYP_c_potential	dft_functional.foo	/^   new_u_LYP_c_potential(V0a,V0b,N0a,N0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,Nxa,Nya,Nza,Nxb,Nyb,Nzb)$/;"	r
saved_self	diffraction_data.foo	/^   saved_self :: DIFFRACTION_DATA*, private$/;"	g
debug_list	diffraction_data.foo	/^   debug_list :: VEC{STR}*, private  DEFAULT_NULL$/;"	g
create	diffraction_data.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	diffraction_data.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	diffraction_data.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	diffraction_data.foo	/^   destroy_ptr_part ::: leaky$/;"	r
destroy_reflection_data	diffraction_data.foo	/^   destroy_reflection_data ::: leaky$/;"	r
created	diffraction_data.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	diffraction_data.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	diffraction_data.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	diffraction_data.foo	/^   copy(diffraction_data) ::: leaky$/;"	r
set_defaults	diffraction_data.foo	/^   set_defaults ::: leaky$/;"	r
update	diffraction_data.foo	/^   update(unit_cell,spacegroup)$/;"	r
set_equivalence_factors	diffraction_data.foo	/^   set_equivalence_factors(spacegroup) $/;"	r
set_theta_angles	diffraction_data.foo	/^   set_theta_angles(reciprocal_matrix)$/;"	r
read_keywords	diffraction_data.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	diffraction_data.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
redirect	diffraction_data.foo	/^   redirect ::: leaky, get_from(OBJECT)$/;"	r
revert	diffraction_data.foo	/^   revert ::: leaky, get_from(OBJECT)$/;"	r
prune	diffraction_data.foo	/^   prune ::: template$/;"	r
prune_bad_reflections	diffraction_data.foo	/^   prune_bad_reflections ::: get_from(DIFFRACTION_DATA:prune, REJECT=>has_large_F_z, CUTOFF=>.F_z_cutoff, SHOW=>F_z), leaky$/;"	r
prune_high_angle_reflections	diffraction_data.foo	/^   prune_high_angle_reflections ::: get_from(DIFFRACTION_DATA:prune, REJECT=>has_high_stl, CUTOFF=>.stl_cutoff, SHOW=>stl), leaky$/;"	r
prune_low_angle_reflections	diffraction_data.foo	/^   prune_low_angle_reflections ::: get_from(DIFFRACTION_DATA:prune, REJECT=>has_low_stl, CUTOFF=>.stl_cutoff SHOW=>stl), leaky$/;"	r
prune_negative_F_exp	diffraction_data.foo	/^   prune_negative_F_exp ::: get_from(DIFFRACTION_DATA:prune, REJECT=>has_small_F_exp, CUTOFF=>ZERO, SHOW=>F_exp), leaky$/;"	r
prune_weak_reflections	diffraction_data.foo	/^   prune_weak_reflections ::: leaky$/;"	r
prune_weak_Fs	diffraction_data.foo	/^   prune_weak_Fs ::: get_from(DIFFRACTION_DATA:prune, REJECT=>has_weak_F_exp, CUTOFF=>.F_sigma_cutoff, SHOW=>F_exp_on_sigma), leaky$/;"	r
prune_weak_F2s	diffraction_data.foo	/^   prune_weak_F2s ::: get_from(DIFFRACTION_DATA:prune, REJECT=>has_weak_F2_exp, CUTOFF=>.F2_sigma_cutoff, SHOW=>F2_exp_on_sigma), leaky$/;"	r
read_units	diffraction_data.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_junk	diffraction_data.foo	/^   read_junk ::: get_from(OBJECT), selfless, private$/;"	r
read_data_kind	diffraction_data.foo	/^   read_data_kind$/;"	r
read_F_sigma_cutoff	diffraction_data.foo	/^   read_F_sigma_cutoff ::: private$/;"	r
read_F2_sigma_cutoff	diffraction_data.foo	/^   read_F2_sigma_cutoff ::: private$/;"	r
read_F_z_cutoff	diffraction_data.foo	/^   read_F_z_cutoff ::: private$/;"	r
read_stl_cutoff	diffraction_data.foo	/^   read_stl_cutoff ::: private$/;"	r
read_show_rejects	diffraction_data.foo	/^   read_show_rejects ::: private$/;"	r
read_exp_scale_factor	diffraction_data.foo	/^   read_exp_scale_factor ::: private$/;"	r
read_wavelength	diffraction_data.foo	/^   read_wavelength ::: private$/;"	r
read_optimise_scale	diffraction_data.foo	/^   read_optimise_scale ::: private$/;"	r
read_SF_mixing_parameter	diffraction_data.foo	/^   read_SF_mixing_parameter ::: private$/;"	r
read_synthesize_sigma_I	diffraction_data.foo	/^   read_synthesize_sigma_I ::: private$/;"	r
read_optimise_extinction	diffraction_data.foo	/^   read_optimise_extinction ::: private$/;"	r
read_correct_dispersion	diffraction_data.foo	/^   read_correct_dispersion ::: private$/;"	r
read_thermal_smearing_model	diffraction_data.foo	/^   read_thermal_smearing_model ::: private$/;"	r
read_partition_model	diffraction_data.foo	/^   read_partition_model ::: private$/;"	r
zero_negative_F_exp	diffraction_data.foo	/^   zero_negative_F_exp ::: leaky$/;"	r
read_temperature	diffraction_data.foo	/^   read_temperature$/;"	r
read_NKA_T_seq_no	diffraction_data.foo	/^   read_NKA_T_seq_no$/;"	r
read_max_allowed_shift	diffraction_data.foo	/^   read_max_allowed_shift$/;"	r
read_max_iterations	diffraction_data.foo	/^   read_max_iterations$/;"	r
read_min_iterations	diffraction_data.foo	/^   read_min_iterations$/;"	r
read_reflection_data	diffraction_data.foo	/^   read_reflection_data ::: leaky, private$/;"	r
read_refine_ADPs_only	diffraction_data.foo	/^   read_refine_ADPs_only$/;"	r
read_refine_F	diffraction_data.foo	/^   read_refine_F$/;"	r
read_refine_H_ADPs	diffraction_data.foo	/^   read_refine_H_ADPs$/;"	r
read_refine_H_U_iso	diffraction_data.foo	/^   read_refine_H_U_iso$/;"	r
read_refine_positions_only	diffraction_data.foo	/^   read_refine_positions_only$/;"	r
read_use_Voronoi_atoms	diffraction_data.foo	/^   read_use_Voronoi_atoms$/;"	r
read_tol_0	diffraction_data.foo	/^   read_tol_0$/;"	r
read_tol_near_0	diffraction_data.foo	/^   read_tol_near_0$/;"	r
read_tol_shift_convergence	diffraction_data.foo	/^   read_tol_shift_convergence$/;"	r
read_convergence_tolerance	diffraction_data.foo	/^   read_convergence_tolerance$/;"	r
read_display_corr_matrix	diffraction_data.foo	/^   read_display_corr_matrix$/;"	r
read_display_near_0_evecs	diffraction_data.foo	/^   read_display_near_0_evecs$/;"	r
read_debug_on	diffraction_data.foo	/^   read_debug_on ::: get_from(DEBUG), leaky$/;"	r
read_debug_off	diffraction_data.foo	/^   read_debug_off ::: get_from(DEBUG), leaky$/;"	r
debugging	diffraction_data.foo	/^   debugging(name) result (res) ::: get_from(DEBUG)$/;"	r
put_debug_list	diffraction_data.foo	/^   put_debug_list ::: get_from(DEBUG)$/;"	r
put_debug	diffraction_data.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)$/;"	r
put_debug	diffraction_data.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})$/;"	r
put_debug	diffraction_data.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})$/;"	r
put_debug	diffraction_data.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>SHELL2)$/;"	r
lp_factor	diffraction_data.foo	/^   lp_factor result (res)$/;"	r
I_pred	diffraction_data.foo	/^   I_pred result (res)$/;"	r
I_exp	diffraction_data.foo	/^   I_exp result (res)$/;"	r
I_sigma	diffraction_data.foo	/^   I_sigma result (res)$/;"	r
make_F_predicted	diffraction_data.foo	/^   make_F_predicted$/;"	r
update_n_param_and_chi2	diffraction_data.foo	/^   update_n_param_and_chi2$/;"	r
get_optimum_parameters	diffraction_data.foo	/^   get_optimum_parameters ::: private$/;"	r
extinction_correction	diffraction_data.foo	/^   extinction_correction result (res)$/;"	r
extinction_correction	diffraction_data.foo	/^   extinction_correction(scale_factor,extinction_factor) result (res)$/;"	r
extinction_correction	diffraction_data.foo	/^   extinction_correction(scale_factors,extinction_factor) result (res)$/;"	r
extinction_angle_part	diffraction_data.foo	/^   extinction_angle_part result (res) ::: private$/;"	r
optimise_scale_factor	diffraction_data.foo	/^   optimise_scale_factor$/;"	r
optimise_scale_factors	diffraction_data.foo	/^   optimise_scale_factors ::: leaky$/;"	r
optimise_extinction_factor	diffraction_data.foo	/^   optimise_extinction_factor$/;"	r
chi2	diffraction_data.foo	/^   chi2(p) result (res) ::: selfless$/;"	r
d_chi2	diffraction_data.foo	/^   d_chi2(p) result (res) ::: selfless$/;"	r
d_chi2_d_scale	diffraction_data.foo	/^   d_chi2_d_scale(p) result (res)$/;"	r
d_chi2_d_ext	diffraction_data.foo	/^   d_chi2_d_ext(p) result (res)$/;"	r
d_chi2_dX	diffraction_data.foo	/^   d_chi2_dX(res,dFdX)$/;"	r
d_chi2_dX_plus_se	diffraction_data.foo	/^   d_chi2_dX_plus_se(res,dFdX)$/;"	r
d_F_abs_dX	diffraction_data.foo	/^   d_F_abs_dX(res,dFdX)$/;"	r
d_F_pred_dX	diffraction_data.foo	/^   d_F_pred_dX(res,sig,del,dFdX)$/;"	r
d_scale_dX	diffraction_data.foo	/^   d_scale_dX(res,dFdX)$/;"	r
solve_normal_equations	diffraction_data.foo	/^   solve_normal_equations(shifts,dFdX) ::: leaky$/;"	r
solve_F_normal_equations	diffraction_data.foo	/^   solve_F_normal_equations(shifts,dFdX) ::: leaky$/;"	r
solve_F2_normal_equations	diffraction_data.foo	/^   solve_F2_normal_equations(shifts,dFdX) ::: leaky$/;"	r
initialise_refinement	diffraction_data.foo	/^   initialise_refinement(n_p)$/;"	r
put_refinement_params	diffraction_data.foo	/^   put_refinement_params$/;"	r
put_iteration_header	diffraction_data.foo	/^   put_iteration_header$/;"	r
put_iteration_results	diffraction_data.foo	/^   put_iteration_results$/;"	r
put_iteration_footer	diffraction_data.foo	/^   put_iteration_footer$/;"	r
refinement_finished	diffraction_data.foo	/^   refinement_finished(chi2_increased,too_many,converged) result (res)$/;"	r
set_parameter_errors	diffraction_data.foo	/^   set_parameter_errors$/;"	r
refine_positions_and_ADPs	diffraction_data.foo	/^   refine_positions_and_ADPs result (res)$/;"	r
put	diffraction_data.foo	/^   put$/;"	r
put_sin_theta_on_lambda	diffraction_data.foo	/^   put_sin_theta_on_lambda$/;"	r
put_F_calc	diffraction_data.foo	/^   put_F_calc$/;"	r
put_F_statistics	diffraction_data.foo	/^   put_F_statistics$/;"	r
put_I_stats	diffraction_data.foo	/^   put_I_stats ::: private$/;"	r
put_correction_data	diffraction_data.foo	/^   put_correction_data$/;"	r
put_gof_data	diffraction_data.foo	/^   put_gof_data$/;"	r
put_free_gof_data	diffraction_data.foo	/^   put_free_gof_data$/;"	r
put_reflection_data	diffraction_data.foo	/^   put_reflection_data(core_reflection)$/;"	r
put_reflection_phases	diffraction_data.foo	/^   put_reflection_phases ::: private$/;"	r
put_qq_plot	diffraction_data.foo	/^   put_qq_plot$/;"	r
put_labelled_qq_plot	diffraction_data.foo	/^   put_labelled_qq_plot$/;"	r
put_chi2_vs_angle_plot	diffraction_data.foo	/^   put_chi2_vs_angle_plot$/;"	r
put_fcalc_plots	diffraction_data.foo	/^   put_fcalc_plots$/;"	r
put_PND_sf	diffraction_data.foo	/^   put_PND_sf(name)$/;"	r
put_cif	diffraction_data.foo	/^   put_cif(basis,scf_type)$/;"	r
put_cif_reflections	diffraction_data.foo	/^   put_cif_reflections$/;"	r
reflection_data_exists	diffraction_data.foo	/^   reflection_data_exists result (res)$/;"	r
have_F_exp	diffraction_data.foo	/^   have_F_exp result (res)$/;"	r
have_F_calc	diffraction_data.foo	/^   have_F_calc result (res)$/;"	r
have_F_pred	diffraction_data.foo	/^   have_F_pred result (res)$/;"	r
have_F_sigma	diffraction_data.foo	/^   have_F_sigma result (res)$/;"	r
use_multiple_scale_factors	diffraction_data.foo	/^   use_multiple_scale_factors result (res)$/;"	r
n_refl	diffraction_data.foo	/^   n_refl result (res)$/;"	r
F_calc	diffraction_data.foo	/^   F_calc result (res)$/;"	r
F_pred	diffraction_data.foo	/^   F_pred result (res)$/;"	r
F_sigma	diffraction_data.foo	/^   F_sigma result (res)$/;"	r
F_exp	diffraction_data.foo	/^   F_exp result (res)$/;"	r
set_F_calc	diffraction_data.foo	/^   set_F_calc(F_calc)$/;"	r
F_chi2	diffraction_data.foo	/^   F_chi2 result (res)$/;"	r
F_goodness_of_fit	diffraction_data.foo	/^   F_goodness_of_fit result (res)$/;"	r
F_r_factor	diffraction_data.foo	/^   F_r_factor result (res)$/;"	r
F_weighted_r_factor	diffraction_data.foo	/^   F_weighted_r_factor result (res)$/;"	r
F_val_r_factor	diffraction_data.foo	/^   F_val_r_factor(core_reflection) result (res) $/;"	r
I_chi2	diffraction_data.foo	/^   I_chi2 result (res)$/;"	r
I_goodness_of_fit	diffraction_data.foo	/^   I_goodness_of_fit result (res)$/;"	r
I_r_factor	diffraction_data.foo	/^   I_r_factor result (res)$/;"	r
I_weighted_r_factor	diffraction_data.foo	/^   I_weighted_r_factor result (res)$/;"	r
simulate_new_F_exp	diffraction_data.foo	/^   simulate_new_F_exp$/;"	r
saved_self	diis.foo	/^   saved_self :: DIIS*, private   DEFAULT_NULL$/;"	g
create	diis.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	diis.foo	/^   create(root_name,name,diis_kind,format,keep) ::: leaky$/;"	r
destroy	diis.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	diis.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	diis.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
nullify_ptr_part	diis.foo	/^   nullify_ptr_part$/;"	r
nullify_matrices	diis.foo	/^   nullify_matrices$/;"	r
destroy_ptr_part	diis.foo	/^   destroy_ptr_part ::: leaky$/;"	r
create_copy	diis.foo	/^   create_copy(diis) ::: leaky$/;"	r
copy	diis.foo	/^   copy(diis) ::: leaky$/;"	r
set_defaults	diis.foo	/^   set_defaults ::: leaky$/;"	r
reset_iteration_defaults	diis.foo	/^   reset_iteration_defaults ::: leaky$/;"	r
set_genre	diis.foo	/^   set_genre(genre)$/;"	r
set_convergence_tolerance	diis.foo	/^   set_convergence_tolerance(tolerance)$/;"	r
set_start_tolerance	diis.foo	/^   set_start_tolerance(tolerance)$/;"	r
set_keep	diis.foo	/^   set_keep(keep) ::: leaky$/;"	r
set_start_iteration	diis.foo	/^   set_start_iteration(start)$/;"	r
set_save_iteration	diis.foo	/^   set_save_iteration(save_it)$/;"	r
set_encore_iterations	diis.foo	/^   set_encore_iterations(encore)$/;"	r
set_force_convexity	diis.foo	/^   set_force_convexity(force)$/;"	r
set_replacement_method	diis.foo	/^   set_replacement_method(method)$/;"	r
set_micro_iteration_method	diis.foo	/^   set_micro_iteration_method(method)$/;"	r
set_micro_starting_guess	diis.foo	/^   set_micro_starting_guess(guess)$/;"	r
set_micro_convergence_tol	diis.foo	/^   set_micro_convergence_tol(tol)$/;"	r
set_micro_damp_factor	diis.foo	/^   set_micro_damp_factor(damp)$/;"	r
set_micro_max_iterations	diis.foo	/^   set_micro_max_iterations(maxit)$/;"	r
set_archive_root_name	diis.foo	/^   set_archive_root_name(root_name)$/;"	r
set_archive_name	diis.foo	/^   set_archive_name(name)$/;"	r
set_archive_format	diis.foo	/^   set_archive_format(format)$/;"	r
cleanup	diis.foo	/^   cleanup$/;"	r
delete_archives	diis.foo	/^   delete_archives$/;"	r
delete_archives	diis.foo	/^   delete_archives(name)$/;"	r
delete_CPHF_archives	diis.foo	/^   delete_CPHF_archives(n_pert)$/;"	r
read_keywords	diis.foo	/^   read_keywords ::: get_from(OBJECT)$/;"	r
process_keyword	diis.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_genre	diis.foo	/^   read_genre$/;"	r
read_convergence_tolerance	diis.foo	/^   read_convergence_tolerance$/;"	r
read_start_tolerance	diis.foo	/^   read_start_tolerance$/;"	r
read_keep	diis.foo	/^   read_keep ::: leaky$/;"	r
read_force_convexity	diis.foo	/^   read_force_convexity$/;"	r
read_replacement_method	diis.foo	/^   read_replacement_method$/;"	r
read_micro_iteration_method	diis.foo	/^   read_micro_iteration_method$/;"	r
read_micro_starting_guess	diis.foo	/^   read_micro_starting_guess$/;"	r
read_micro_convergence_tol	diis.foo	/^   read_micro_convergence_tol$/;"	r
read_micro_damp_factor	diis.foo	/^   read_micro_damp_factor$/;"	r
read_micro_max_iterations	diis.foo	/^   read_micro_max_iterations$/;"	r
read_start_iteration	diis.foo	/^   read_start_iteration$/;"	r
read_save_iteration	diis.foo	/^   read_save_iteration$/;"	r
read_encore_iterations	diis.foo	/^   read_encore_iterations$/;"	r
apply_diis	diis.foo	/^   apply_diis result (res)$/;"	r
subspace_saturated	diis.foo	/^   subspace_saturated result (res)$/;"	r
is_stuck_or_oscillating	diis.foo	/^   is_stuck_or_oscillating result (res)$/;"	r
was_stuck	diis.foo	/^   was_stuck result (res)$/;"	r
solve_equations	diis.foo	/^   solve_equations result (res)$/;"	r
switch_to_diis	diis.foo	/^   switch_to_diis result (res)$/;"	r
switch_to_encore_ediis	diis.foo	/^   switch_to_encore_ediis result (res)$/;"	r
switch_back_to_diis	diis.foo	/^   switch_back_to_diis result (res)$/;"	r
actual_iteration	diis.foo	/^   actual_iteration result (res)$/;"	r
saved_iteration	diis.foo	/^   saved_iteration result (res)$/;"	r
next_replacement	diis.foo	/^   next_replacement(best) result (res) ::: private$/;"	r
the_replacement	diis.foo	/^   the_replacement result (res) ::: private$/;"	r
oldest_item	diis.foo	/^   oldest_item result (res) ::: private$/;"	r
worst_item	diis.foo	/^   worst_item result (res) ::: private$/;"	r
best_item	diis.foo	/^   best_item result (res) ::: private$/;"	r
dimension	diis.foo	/^   dimension result (res) ::: private$/;"	r
update_kept	diis.foo	/^   update_kept ::: private$/;"	r
set_diis_error_length	diis.foo	/^   set_diis_error_length(length)$/;"	r
set_diis_error_length	diis.foo	/^   set_diis_error_length$/;"	r
set_diis_error_length	diis.foo	/^   set_diis_error_length(F,D,S)$/;"	r
make_diis_commutator	diis.foo	/^   make_diis_commutator(C,F,D,S)$/;"	r
make_diis_commutator	diis.foo	/^   make_diis_commutator(C,F,D,S)$/;"	r
make_diis_commutator	diis.foo	/^   make_diis_commutator(C,F,D,S)$/;"	r
extrapolate	diis.foo	/^   extrapolate(par) ::: template$/;"	r
extrapolate	diis.foo	/^   extrapolate(par) ::: get_from(DIIS, TYPE=>VEC{REAL})$/;"	r
extrapolate	diis.foo	/^   extrapolate(par) ::: get_from(DIIS, TYPE=>MAT{REAL})$/;"	r
extrapolate	diis.foo	/^   extrapolate(par,err) ::: template$/;"	r
extrapolate	diis.foo	/^   extrapolate(par,err) ::: get_from(DIIS, TYPE=>VEC{REAL})$/;"	r
extrapolate	diis.foo	/^   extrapolate(par,err) ::: get_from(DIIS, TYPE=>MAT{REAL})$/;"	r
extrapolate	diis.foo	/^   extrapolate(par,err) ::: get_from(DIIS, TYPE=>MAT3{REAL})$/;"	r
do_extrapolate	diis.foo	/^   do_extrapolate(par,err) ::: template$/;"	r
do_extrapolate	diis.foo	/^   do_extrapolate(par,err) ::: get_from(DIIS, TYPE=>VEC{REAL}), private$/;"	r
do_extrapolate	diis.foo	/^   do_extrapolate(par,err) ::: get_from(DIIS, TYPE=>MAT{REAL}), private$/;"	r
do_extrapolate	diis.foo	/^   do_extrapolate(par,err) ::: get_from(DIIS, TYPE=>MAT3{REAL}), private$/;"	r
make_diis_lhs	diis.foo	/^   make_diis_lhs(lhs,err,old_err,save_lhs) ::: template$/;"	r
make_diis_lhs	diis.foo	/^   make_diis_lhs(lhs,err,old_err,save_lhs) ::: get_from(DIIS, TYPE=>VEC{REAL}), leaky, private$/;"	r
make_diis_lhs	diis.foo	/^   make_diis_lhs(lhs,err,old_err,save_lhs) ::: get_from(DIIS, TYPE=>MAT{REAL}), leaky, private$/;"	r
make_diis_lhs	diis.foo	/^   make_diis_lhs(lhs,err,old_err,save_lhs) ::: get_from(DIIS, TYPE=>MAT3{REAL}), leaky, private$/;"	r
condition_diis_lhs	diis.foo	/^   condition_diis_lhs(lhs) $/;"	r
remake_diis_lhs	diis.foo	/^   remake_diis_lhs(e_i,e_j) ::: template$/;"	r
remake_diis_lhs	diis.foo	/^   remake_diis_lhs(e_i,e_j) ::: get_from(DIIS, TYPE=>VEC{REAL}), leaky, private$/;"	r
remake_diis_lhs	diis.foo	/^   remake_diis_lhs(e_i,e_j) ::: get_from(DIIS, TYPE=>MAT{REAL}), leaky, private$/;"	r
remake_diis_lhs	diis.foo	/^   remake_diis_lhs(e_i,e_j) ::: get_from(DIIS, TYPE=>MAT3{REAL}), leaky, private$/;"	r
accelerate	diis.foo	/^   accelerate(F,D,S,energy,J)$/;"	r
modify_constraint	diis.foo	/^   modify_constraint(FF,SS,lambda_step)$/;"	r
ediis_plus_diis	diis.foo	/^   ediis_plus_diis(F,D,S,energy,J)$/;"	r
fdiis	diis.foo	/^   fdiis(F,D,S,energy,J)$/;"	r
r_fdiis	diis.foo	/^   r_fdiis ::: private$/;"	r
u_fdiis	diis.foo	/^   u_fdiis ::: private$/;"	r
u2_fdiis	diis.foo	/^   u2_fdiis ::: private$/;"	r
gc_fdiis	diis.foo	/^   gc_fdiis ::: private$/;"	r
make_r_diis_system	diis.foo	/^   make_r_diis_system(lhs,rhs) ::: private, leaky$/;"	r
make_u_diis_system	diis.foo	/^   make_u_diis_system(lhs,rhs) ::: private, leaky$/;"	r
make_u2_diis_system	diis.foo	/^   make_u2_diis_system(lhs,rhs) ::: private, leaky$/;"	r
make_gc_diis_system	diis.foo	/^   make_gc_diis_system(lhs,rhs) ::: private, leaky$/;"	r
remake_diis_lhs	diis.foo	/^   remake_diis_lhs(genre)$/;"	r
remake_r_diis_lhs	diis.foo	/^   remake_r_diis_lhs $/;"	r
remake_u_diis_lhs	diis.foo	/^   remake_u_diis_lhs$/;"	r
remake_gc_diis_lhs	diis.foo	/^   remake_gc_diis_lhs $/;"	r
ediis	diis.foo	/^   ediis(F,D,S,energy,J)$/;"	r
r_ediis	diis.foo	/^   r_ediis ::: private$/;"	r
u_ediis	diis.foo	/^   u_ediis ::: private$/;"	r
make_r_ediis_system	diis.foo	/^   make_r_ediis_system(lhs,rhs) ::: private, leaky$/;"	r
make_u_ediis_system	diis.foo	/^   make_u_ediis_system(lhs,rhs) ::: private, leaky$/;"	r
remake_ediis_lhs	diis.foo	/^   remake_ediis_lhs(genre,modify_rhs,lambda_step)$/;"	r
remake_r_ediis_system	diis.foo	/^   remake_r_ediis_system(modify_rhs,lambda_step) ::: private$/;"	r
remake_u_ediis_system	diis.foo	/^   remake_u_ediis_system(modify_rhs,lambda_step) ::: private$/;"	r
ddiis	diis.foo	/^   ddiis(D,F,S,energy,J)$/;"	r
r_ddiis	diis.foo	/^   r_ddiis ::: private$/;"	r
u_ddiis	diis.foo	/^   u_ddiis ::: private$/;"	r
make_r_ddiis_system	diis.foo	/^   make_r_ddiis_system(lhs,rhs,coeff) ::: private, leaky$/;"	r
make_u_ddiis_system	diis.foo	/^   make_u_ddiis_system(lhs,rhs,coeff) ::: private, leaky$/;"	r
r_ddiis_length	diis.foo	/^   r_ddiis_length(coeff,l,dl) ::: selfless$/;"	r
u_ddiis_length	diis.foo	/^   u_ddiis_length(coeff,l,dl) ::: selfless$/;"	r
solve_r_diis_equations	diis.foo	/^   solve_r_diis_equations(lhs,rhs,solution,emin)$/;"	r
solve_u_diis_equations	diis.foo	/^   solve_u_diis_equations(lhs,rhs,solution)$/;"	r
solve_convex	diis.foo	/^   solve_convex(lhs,rhs,solution,plist,keep0,fmin,fail) ::: private$/;"	r
get_old_lhs	diis.foo	/^   get_old_lhs(lhs) ::: leaky$/;"	r
get_old_r_lhs	diis.foo	/^   get_old_r_lhs(lhs) ::: leaky$/;"	r
get_old_u_lhs	diis.foo	/^   get_old_u_lhs(lhs) ::: leaky$/;"	r
get_old_r_rhs	diis.foo	/^   get_old_r_rhs(rhs) ::: leaky, private$/;"	r
get_old_u_rhs	diis.foo	/^   get_old_u_rhs(rhs) ::: leaky, private$/;"	r
save_item	diis.foo	/^   save_item(item,name,i,genre) ::: template$/;"	r
save_item	diis.foo	/^   save_item(item,name,i,genre) ::: get_from(DIIS, ITEM_TYPE=>REAL)$/;"	r
save_item	diis.foo	/^   save_item(item,name,i,genre) ::: get_from(DIIS, ITEM_TYPE=>VEC{REAL})$/;"	r
save_item	diis.foo	/^   save_item(item,name,i,genre) ::: get_from(DIIS, ITEM_TYPE=>VEC{CPX})$/;"	r
save_item	diis.foo	/^   save_item(item,name,i,genre) ::: get_from(DIIS, ITEM_TYPE=>MAT{REAL})$/;"	r
save_item	diis.foo	/^   save_item(item,name,i,genre) ::: get_from(DIIS, ITEM_TYPE=>MAT{CPX})$/;"	r
save_item	diis.foo	/^   save_item(item,name,i,genre) ::: get_from(DIIS, ITEM_TYPE=>MAT3{REAL})$/;"	r
save_item	diis.foo	/^   save_item(item,name,i,genre) ::: get_from(DIIS, ITEM_TYPE=>OPMATRIX)$/;"	r
save_current_item	diis.foo	/^   save_current_item(item,name) ::: template$/;"	r
save_current_item	diis.foo	/^   save_current_item(item,name) ::: get_from(DIIS, ITEM_TYPE=>OPMATRIX)$/;"	r
read_item	diis.foo	/^   read_item(item,name,i) ::: template$/;"	r
read_item	diis.foo	/^   read_item(item,name,i) ::: get_from(DIIS, ITEM_TYPE=>REAL)$/;"	r
read_item	diis.foo	/^   read_item(item,name,i) ::: get_from(DIIS, ITEM_TYPE=>VEC{REAL})$/;"	r
read_item	diis.foo	/^   read_item(item,name,i) ::: get_from(DIIS, ITEM_TYPE=>VEC{CPX})$/;"	r
read_item	diis.foo	/^   read_item(item,name,i) ::: get_from(DIIS, ITEM_TYPE=>MAT{REAL})$/;"	r
read_item	diis.foo	/^   read_item(item,name,i) ::: get_from(DIIS, ITEM_TYPE=>MAT{CPX})$/;"	r
read_item	diis.foo	/^   read_item(item,name,i) ::: get_from(DIIS, ITEM_TYPE=>MAT3{REAL})$/;"	r
read_item	diis.foo	/^   read_item(item,name,i) ::: get_from(DIIS, ITEM_TYPE=>OPVECTOR)$/;"	r
read_item	diis.foo	/^   read_item(item,name,i) ::: get_from(DIIS, ITEM_TYPE=>OPMATRIX)$/;"	r
archive_name	diis.foo	/^   archive_name(name,i) result (res)$/;"	r
archive_exists	diis.foo	/^   archive_exists(name,i) result (res)$/;"	r
delete_archive	diis.foo	/^   delete_archive(name,i) $/;"	r
is_converged	diis.foo	/^   is_converged result (res)$/;"	r
put	diis.foo	/^   put$/;"	r
create	file.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	file.foo	/^   create(name) ::: leaky$/;"	r
destroy	file.foo	/^   destroy ::: leaky$/;"	r
nullify_ptr_part	file.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	file.foo	/^   destroy_ptr_part ::: leaky$/;"	r
create_copy	file.foo	/^   create_copy(f) ::: leaky$/;"	r
copy	file.foo	/^   copy(f) ::: leaky$/;"	r
set_defaults	file.foo	/^   set_defaults$/;"	r
open	file.foo	/^   open(for,buffered,type) ::: leaky$/;"	r
close	file.foo	/^   close ::: leaky$/;"	r
close_and_delete	file.foo	/^   close_and_delete ::: leaky$/;"	r
delete	file.foo	/^   delete$/;"	r
read	file.foo	/^   read(value) ::: template$/;"	r
read	file.foo	/^   read(value) ::: get_from(FILE, VALUE_TYPE=>STR, .read_buffered(value)=>DIE("unavailable"))$/;"	r
read	file.foo	/^   read(value) ::: get_from(FILE, VALUE_TYPE=>BIN, .read_buffered(value)=>DIE("unavailable"))$/;"	r
read	file.foo	/^   read(value) ::: get_from(FILE, VALUE_TYPE=>INT)$/;"	r
read	file.foo	/^   read(value) ::: get_from(FILE, VALUE_TYPE=>REAL)$/;"	r
read	file.foo	/^   read(value) ::: get_from(FILE, VALUE_TYPE=>CPX)$/;"	r
read	file.foo	/^   read(values) ::: template$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>VEC{STR}, .read_buffered(values)=>DIE("unavailable"))$/;"	r
read	file.foo	/^   read(matvec)$/;"	r
matvec	file.foo	/^     matvec :: VEC{MAT_{REAL}}$/;"	a
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>VEC{BIN}, .read_buffered(values)=>DIE("unavailable"))$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>VEC{INT})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>VEC{REAL})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>VEC{CPX})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT{STR}, .read_buffered(values)=>DIE("unavailable"))$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT{BIN}, .read_buffered(values)=>DIE("unavailable"))$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT{INT})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT{REAL})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT{CPX})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT3{BIN}, .read_buffered(values)=>DIE("unavailable"))$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT3{INT})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT3{REAL})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT3{CPX})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT4{INT})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT4{REAL})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT4{CPX})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT5{REAL})$/;"	r
read	file.foo	/^   read(values) ::: get_from(FILE, VALUES_TYPE=>MAT5{CPX})$/;"	r
write	file.foo	/^   write(value) ::: template$/;"	r
write	file.foo	/^   write(value) ::: get_from(FILE, VALUE_TYPE=>STR, .write_buffered(value)=>DIE("unavailable"))$/;"	r
write	file.foo	/^   write(value) ::: get_from(FILE, VALUE_TYPE=>BIN, .write_buffered(value)=>DIE("unavailable"))$/;"	r
write	file.foo	/^   write(value) ::: get_from(FILE, VALUE_TYPE=>INT)$/;"	r
write	file.foo	/^   write(value) ::: get_from(FILE, VALUE_TYPE=>REAL)$/;"	r
write	file.foo	/^   write(value) ::: get_from(FILE, VALUE_TYPE=>CPX)$/;"	r
write	file.foo	/^   write(values) ::: template$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>VEC{STR}, .write_buffered(values)=>DIE("unavailable"))$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>VEC{BIN}, .write_buffered(values)=>DIE("unavailable"))$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>VEC{INT})$/;"	r
write	file.foo	/^   write(matvec)$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>VEC{CPX})$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT{STR}, .write_buffered(values)=>DIE("unavailable"))$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT{BIN}, .write_buffered(values)=>DIE("unavailable"))$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT{INT})$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT{REAL})$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT{CPX})$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT3{BIN}, .write_buffered(values)=>DIE("unavailable"))$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT3{INT})$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT3{REAL})$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT3{CPX})$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT4{INT})$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT4{REAL})$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT4{CPX})$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT5{REAL})$/;"	r
write	file.foo	/^   write(values) ::: get_from(FILE, VALUES_TYPE=>MAT5{CPX})$/;"	r
read_buffered	file.foo	/^   read_buffered(value) ::: template$/;"	r
read_buffered	file.foo	/^   read_buffered(value) ::: get_from(FILE, VALUE=>INT, BBUF=>.int_buffer, POS=>.int_buffer_pos, GET=>.get_int_buffer)$/;"	r
read_buffered	file.foo	/^   read_buffered(value) ::: get_from(FILE, VALUE=>REAL, BBUF=>.real_buffer, POS=>.real_buffer_pos, GET=>.get_real_buffer)$/;"	r
read_buffered	file.foo	/^   read_buffered(value) ::: get_from(FILE, VALUE=>CPX, BBUF=>.cpx_buffer, POS=>.cpx_buffer_pos, GET=>.get_cpx_buffer)$/;"	r
write_buffered	file.foo	/^   write_buffered(value) ::: template$/;"	r
write_buffered	file.foo	/^   write_buffered(value) ::: get_from(FILE, VALUE=>INT, BBUF=>.int_buffer, POS=>.int_buffer_pos, FLUSH=>.flush_int_buffer)$/;"	r
write_buffered	file.foo	/^   write_buffered(value) ::: get_from(FILE, VALUE=>REAL, BBUF=>.real_buffer, POS=>.real_buffer_pos, FLUSH=>.flush_real_buffer)$/;"	r
write_buffered	file.foo	/^   write_buffered(value) ::: get_from(FILE, VALUE=>CPX, BBUF=>.cpx_buffer, POS=>.cpx_buffer_pos, FLUSH=>.flush_cpx_buffer)$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: template$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, VALUES=>VEC{INT}, BBUF=>.int_buffer, POS=>.int_buffer_pos, GET=>.get_int_buffer)$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, VALUES=>VEC{REAL}, BBUF=>.real_buffer, POS=>.real_buffer_pos, GET=>.get_real_buffer)$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, VALUES=>VEC{CPX}, BBUF=>.cpx_buffer, POS=>.cpx_buffer_pos, GET=>.get_cpx_buffer)$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: template$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>VEC{INT}, BBUF=>.int_buffer, POS=>.int_buffer_pos, FLUSH=>.flush_int_buffer)$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>VEC{REAL}, BBUF=>.real_buffer, POS=>.real_buffer_pos, FLUSH=>.flush_real_buffer)$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>VEC{CPX}, BBUF=>.cpx_buffer, POS=>.cpx_buffer_pos, FLUSH=>.flush_cpx_buffer)$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: template$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>MAT{INT})$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>MAT{REAL})$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>MAT{CPX})$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>MAT3{INT})$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>MAT3{REAL})$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>MAT3{CPX})$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>MAT4{INT})$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>MAT4{REAL})$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>MAT4{CPX})$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>MAT5{REAL})$/;"	r
write_buffered	file.foo	/^   write_buffered(values) ::: get_from(FILE, VALUES=>MAT5{CPX})$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: template$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, ARR{VALUE}=>MAT{INT})$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, ARR{VALUE}=>MAT{REAL})$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, ARR{VALUE}=>MAT{CPX})$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, ARR{VALUE}=>MAT3{INT})$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, ARR{VALUE}=>MAT3{REAL})$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, ARR{VALUE}=>MAT3{CPX})$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, ARR{VALUE}=>MAT4{INT})$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, ARR{VALUE}=>MAT4{REAL})$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, ARR{VALUE}=>MAT4{CPX})$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, ARR{VALUE}=>MAT5{REAL})$/;"	r
read_buffered	file.foo	/^   read_buffered(values) ::: get_from(FILE, ARR{VALUE}=>MAT5{CPX})$/;"	r
flush_real_buffer	file.foo	/^   flush_real_buffer$/;"	r
flush_int_buffer	file.foo	/^   flush_int_buffer$/;"	r
flush_cpx_buffer	file.foo	/^   flush_cpx_buffer$/;"	r
get_real_buffer	file.foo	/^   get_real_buffer$/;"	r
get_int_buffer	file.foo	/^   get_int_buffer$/;"	r
get_cpx_buffer	file.foo	/^   get_cpx_buffer$/;"	r
write_buffered	file.foo	/^   write_buffered(matvec)$/;"	r
matvec	file.foo	/^     matvec :: VEC{MAT_{REAL}}, IN$/;"	a
read_buffered	file.foo	/^   read_buffered(matvec)$/;"	r
matvec	file.foo	/^     matvec :: VEC{MAT_{REAL}}$/;"	a
rewind	file.foo	/^   rewind$/;"	r
backspace	file.foo	/^   backspace$/;"	r
skip	file.foo	/^   skip$/;"	r
move_to_end	file.foo	/^   move_to_end$/;"	r
move_to_position	file.foo	/^   move_to_position(pos)$/;"	r
move_to_record	file.foo	/^   move_to_record(rec)$/;"	r
exists	file.foo	/^   exists(name) result (res)$/;"	r
is_open	file.foo	/^   is_open result (res)$/;"	r
unit_used	file.foo	/^   unit_used result (res)$/;"	r
created	file.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	file.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
position	file.foo	/^   position result (res)$/;"	r
is_for_reading	file.foo	/^   is_for_reading result (res)$/;"	r
pi212	gaussian2.foo	/^   pi212 :: REAL, private  = 1.1283791670955d+0$/;"	g
first_pt	gaussian2.foo	/^   first_pt :: VEC{INT}(9), private = [ 1,2,4, 7,11,16,22,29,37 ]$/;"	g
last_pt	gaussian2.foo	/^   last_pt  :: VEC{INT}(9), private = [ 1,3,6,10,15,21,28,36,45 ]$/;"	g
gauss_hermite_pt	gaussian2.foo	/^   gauss_hermite_pt :: VEC{REAL}(45), private$/;"	g
gauss_hermite_wt	gaussian2.foo	/^   gauss_hermite_wt :: VEC{REAL}(45), private$/;"	g
create	gaussian2.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	gaussian2.foo	/^   create(Ga,Gb) ::: leaky$/;"	r
destroy	gaussian2.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	gaussian2.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	gaussian2.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	gaussian2.foo	/^   create_copy(G) ::: leaky$/;"	r
copy	gaussian2.foo	/^   copy(G)$/;"	r
set	gaussian2.foo	/^   set(Ga,Gb)$/;"	r
set	gaussian2.foo	/^   set(l_a,pos_a,ex_a,l_b,pos_b,ex_b)$/;"	r
set	gaussian2.foo	/^   set(ex_a,ex_b)$/;"	r
make_e_coeff	gaussian2.foo	/^   make_e_coeff(e,comp) $/;"	r
make_e_coeff_derivative	gaussian2.foo	/^   make_e_coeff_derivative(e1,comp,e0) ::: pure, private$/;"	r
make_ft_component	gaussian2.foo	/^   make_ft_component(res,comp,k_pts)$/;"	r
make_ft_dab_component	gaussian2.foo	/^   make_ft_dab_component(res,comp,k_pts,k_max) ::: private$/;"	r
make_ft_da_db_component	gaussian2.foo	/^   make_ft_da_db_component(da,db,comp,k_pts) ::: private$/;"	r
make_ft_dab	gaussian2.foo	/^   make_ft_dab(res,ft)$/;"	r
make_ft	gaussian2.foo	/^   make_ft(ft,k_pts)$/;"	r
make_ft_00	gaussian2.foo	/^   make_ft_00(ft,k_pts) $/;"	r
make_ft_XX	gaussian2.foo	/^   make_ft_XX(ft,k_pts) $/;"	r
make_ft_v2	gaussian2.foo	/^   make_ft_v2(ft,k_pts) $/;"	r
make_ft_nabla	gaussian2.foo	/^   make_ft_nabla(ft,k_pts)$/;"	r
make_ft_da_db	gaussian2.foo	/^   make_ft_da_db(ft_da,ft_db,k_pts)$/;"	r
make_ft_r	gaussian2.foo	/^   make_ft_r(ft,k_pts)$/;"	r
put_e_coeff	gaussian2.foo	/^   put_e_coeff(out)$/;"	r
normalisation_factor	gaussian2.foo	/^   normalisation_factor result (res) $/;"	r
change_to_spherical	gaussian2.foo	/^   change_to_spherical(C,S)$/;"	r
change_to_spherical	gaussian2.foo	/^   change_to_spherical(C,S)$/;"	r
make_normalised_overlap_ints	gaussian2.foo	/^   make_normalised_overlap_ints(S,spherical) $/;"	r
make_overlap_ints	gaussian2.foo	/^   make_overlap_ints(S)$/;"	r
make_overlap_ints	gaussian2.foo	/^   make_overlap_ints(Sx,x,max_a,max_b)$/;"	r
make_S_1st_deriv_ints	gaussian2.foo	/^   make_S_1st_deriv_ints(AAx,AAy,AAz)$/;"	r
make_oscillator_overlap_ints	gaussian2.foo	/^   make_oscillator_overlap_ints(S,c,d,lc_min,lc_max,ld_min,ld_max)$/;"	r
make_oscillator_overlap_ints	gaussian2.foo	/^   make_oscillator_overlap_ints(Sx,x,cx,l_c,dx,l_d,max_a,max_b)$/;"	r
make_normalised_kinetic_ints	gaussian2.foo	/^   make_normalised_kinetic_ints(T,spherical) $/;"	r
make_kinetic_ints	gaussian2.foo	/^   make_kinetic_ints(T)$/;"	r
make_T_1st_deriv_ints	gaussian2.foo	/^   make_T_1st_deriv_ints(AAx,AAy,AAz)$/;"	r
make_dipole_ints	gaussian2.foo	/^   make_dipole_ints(Dx,Dy,Dz,origin)$/;"	r
make_dipole_ints	gaussian2.foo	/^   make_dipole_ints(Sx,Dx,x,ox,max_a,max_b)$/;"	r
make_quadrupole_ints	gaussian2.foo	/^   make_quadrupole_ints(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz,origin)$/;"	r
make_quadrupole_ints	gaussian2.foo	/^   make_quadrupole_ints(Sx,Dx,Qx,x,ox,max_a,max_b)$/;"	r
make_octupole_ints	gaussian2.foo	/^   make_octupole_ints(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz,origin)$/;"	r
make_octupole_ints	gaussian2.foo	/^   make_octupole_ints(Sx,Dx,Qx,Ox,x,og,max_a,max_b)$/;"	r
make_normalised_NA_ints	gaussian2.foo	/^   make_normalised_NA_ints(NA,c,spherical) $/;"	r
make_nuclear_attraction_ints	gaussian2.foo	/^   make_nuclear_attraction_ints(NA,c)$/;"	r
make_nuclear_attraction_ints	gaussian2.foo	/^   make_nuclear_attraction_ints(Nx,x,uu,cx,max_a,max_b)$/;"	r
make_NA_1st_deriv_ints	gaussian2.foo	/^   make_NA_1st_deriv_ints(DAx,DAy,DAz,DBx,DBy,DBz,c)$/;"	r
make_normalised_DKH_ints	gaussian2.foo	/^   make_normalised_DKH_ints(T,SOx,SOy,SOz,c,spherical) $/;"	r
make_DKH_ints	gaussian2.foo	/^   make_DKH_ints(T,SOx,SOy,SOz,c)$/;"	r
make_normalised_DK3_ppZpp_ints	gaussian2.foo	/^   make_normalised_DK3_ppZpp_ints(ppZpp,c,spherical) $/;"	r
make_DK3_ppZpp_ints	gaussian2.foo	/^   make_DK3_ppZpp_ints(ppZpp,c)$/;"	r
make_DK3_ppZpp_ints_ori	gaussian2.foo	/^   make_DK3_ppZpp_ints_ori(ppZpp,c)$/;"	r
make_spin_orbit_ints	gaussian2.foo	/^   make_spin_orbit_ints(Lx,Ly,Lz,c)$/;"	r
make_E_field_ints	gaussian2.foo	/^   make_E_field_ints(Ex,Ey,Ez,c)$/;"	r
make_E_field_ints	gaussian2.foo	/^   make_E_field_ints(Sx,Fx,x,uu,cx,max_a,max_b)$/;"	r
make_E_gradient_ints	gaussian2.foo	/^   make_E_gradient_ints(Exx,Eyy,Ezz,Exy,Exz,Eyz,c)$/;"	r
make_E_gradient_ints	gaussian2.foo	/^   make_E_gradient_ints(Sx,Fx,Gx,x,uu,cx,max_a,max_b)$/;"	r
make_spin_orbit_B_ints	gaussian2.foo	/^   make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,c,origin)$/;"	r
make_q_field_ints	gaussian2.foo	/^   make_q_field_ints(Sx,Dx,Fx,Qx,x,uu,cx,ox,max_a,max_b)$/;"	r
make_L_ints	gaussian2.foo	/^   make_L_ints(Lx,Ly,Lz,origin)$/;"	r
differentiate	gaussian2.foo	/^   differentiate(I,index,D)$/;"	r
make_magnetic_jp_ints	gaussian2.foo	/^   make_magnetic_jp_ints(Jx,Jy,Jz,c)$/;"	r
make_magnetic_S_ints	gaussian2.foo	/^   make_magnetic_S_ints(Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz,c)$/;"	r
make_magnetic_S_ints	gaussian2.foo	/^   make_magnetic_S_ints(M,c)$/;"	r
make_solenoidal_jp_ints	gaussian2.foo	/^   make_solenoidal_jp_ints(Jx,Jy,Jz,c)$/;"	r
make_solenoidal_jd_ints	gaussian2.foo	/^   make_solenoidal_jd_ints(Jx,Jy,Jz,B_field,origin,c)$/;"	r
make_irrotational_jp_ints	gaussian2.foo	/^   make_irrotational_jp_ints(Jx,Jy,Jz,c)$/;"	r
make_irrotational_jd_ints	gaussian2.foo	/^   make_irrotational_jd_ints(Jx,Jy,Jz,B_field,origin,c)$/;"	r
put	gaussian2.foo	/^   put$/;"	r
make_normalised_density_gg	gaussian2.foo	/^   make_normalised_density_gg(S,x,y,z,spherical) $/;"	r
make_density_gg	gaussian2.foo	/^   make_density_gg(S,x,y,z)$/;"	r
make_density_part	gaussian2.foo	/^   make_density_part(Sx,x,pos,max_a,max_b)$/;"	r
make_normalised_pDp_gg	gaussian2.foo	/^   make_normalised_pDp_gg(T,x,y,z,spherical) $/;"	r
make_pDp_gg	gaussian2.foo	/^   make_pDp_gg(T,x,y,z)$/;"	r
make_normalised_ppDpp_gg	gaussian2.foo	/^   make_normalised_ppDpp_gg(T,x,y,z,spherical) $/;"	r
make_ppDpp_gg	gaussian2.foo	/^   make_ppDpp_gg(ppDpp,x,y,z)$/;"	r
make_ppDpp_gg_ori	gaussian2.foo	/^   make_ppDpp_gg_ori(ppDpp,x,y,z)$/;"	r
make_normalised_pDp_SO_gg	gaussian2.foo	/^   make_normalised_pDp_SO_gg(Dx,Dy,Dz,x,y,z,spherical) $/;"	r
make_pDp_SO_gg	gaussian2.foo	/^   make_pDp_SO_gg(SOx,SOy,SOz,x,y,z)$/;"	r
normalise_ft	gaussian2.foo	/^   normalise_ft(ft)$/;"	r
ft	gaussian2.foo	/^     ft :: MAT{CPX}, target$/;"	a
ft_ab	gaussian2.foo	/^     ft_ab :: CPX*$/;"	a
make_normalised_ft_00	gaussian2.foo	/^   make_normalised_ft_00(ft_ab,h,k,l)$/;"	r
make_dkh_ft_00	gaussian2.foo	/^   make_dkh_ft_00(ft,h,k,l) $/;"	r
make_normalised_ft_v2	gaussian2.foo	/^   make_normalised_ft_v2(ft_ab,h,k,l,spherical) $/;"	r
make_dkh_ft_v2	gaussian2.foo	/^   make_dkh_ft_v2(ft,h1,h2,h3) $/;"	r
make_normalised_pftp_v2	gaussian2.foo	/^   make_normalised_pftp_v2(ft_ab,h,k,l,spherical) $/;"	r
make_dkh_ft_dadb_v2	gaussian2.foo	/^   make_dkh_ft_dadb_v2(ft,h1,h2,h3) $/;"	r
make_ft_component	gaussian2.foo	/^   make_ft_component(res,comp,k_pts)$/;"	r
make_ft_dadb_component	gaussian2.foo	/^   make_ft_dadb_component(res,comp,k_pts)$/;"	r
make_e_coeff_dadb	gaussian2.foo	/^   make_e_coeff_dadb(e,comp) $/;"	r
create	gaussian4.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	gaussian4.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	gaussian4.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	gaussian4.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	gaussian4.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	gaussian4.foo	/^   copy(G)$/;"	r
make_ERI_ints	gaussian4.foo	/^   make_ERI_ints(I)$/;"	r
transfer_2d_ints	gaussian4.foo	/^   transfer_2d_ints(Ix,Iy,Iz,AB,CD,max_b,max_d) ::: pure, private$/;"	r
form_2d_ints	gaussian4.foo	/^   form_2d_ints(Ix,Iy,Iz,t2,wt,rho,zinv,einv,PA,QC,QP,max_e,max_f) ::: pure$/;"	r
make_spin_orbit_ints	gaussian4.foo	/^   make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)$/;"	r
differentiate	gaussian4.foo	/^   differentiate(I,index,ID)$/;"	r
make_spin_spin_dipole_ints	gaussian4.foo	/^   make_spin_spin_dipole_ints(Dxx,Dyy,Dzz,Dxy,Dxz,Dyz)$/;"	r
make_ERI_derivatives	gaussian4.foo	/^   make_ERI_derivatives(AA,BB,CC,DD)$/;"	r
put	gaussian4.foo	/^   put(out)$/;"	r
l_max_saved	gaussian_data.foo	/^   l_max_saved :: INT, private = -1$/;"	g
px	gaussian_data.foo	/^   px :: VEC{INT}*, public  DEFAULT_NULL$/;"	g
py	gaussian_data.foo	/^   py :: VEC{INT}*, public  DEFAULT_NULL$/;"	g
pz	gaussian_data.foo	/^   pz :: VEC{INT}*, public  DEFAULT_NULL$/;"	g
pp	gaussian_data.foo	/^   pp :: MAT{INT}*, public  DEFAULT_NULL$/;"	g
normalising_factors	gaussian_data.foo	/^   normalising_factors :: VEC{REAL}*, public  DEFAULT_NULL$/;"	g
nx	gaussian_data.foo	/^   nx :: VEC{INT}*, public  DEFAULT_NULL$/;"	g
ny	gaussian_data.foo	/^   ny :: VEC{INT}*, public  DEFAULT_NULL$/;"	g
nz	gaussian_data.foo	/^   nz :: VEC{INT}*, public  DEFAULT_NULL$/;"	g
nn	gaussian_data.foo	/^   nn :: MAT{INT}*, public  DEFAULT_NULL$/;"	g
Ishida_ordering	gaussian_data.foo	/^   Ishida_ordering :: BIN, public = FALSE$/;"	g
first_nonzero	gaussian_data.foo	/^   first_nonzero :: VEC{INT}*, public  DEFAULT_NULL$/;"	g
index_of	gaussian_data.foo	/^   index_of :: MAT3{INT}*, public  DEFAULT_NULL$/;"	g
index_m1	gaussian_data.foo	/^   index_m1 :: VEC{INT}*, public  DEFAULT_NULL$/;"	g
index_p1	gaussian_data.foo	/^   index_p1 :: MAT{INT}*, public  DEFAULT_NULL$/;"	g
binomial_p1	gaussian_data.foo	/^   binomial_p1 :: VEC{VEC_{INT}}*, public  DEFAULT_NULL$/;"	g
rms_indices	gaussian_data.foo	/^   rms_indices :: MAT{RMS_INDICES}*, public  DEFAULT_NULL$/;"	g
rms2_indices	gaussian_data.foo	/^   rms2_indices :: MAT{RMS2_INDICES}*, public  DEFAULT_NULL$/;"	g
spherical_harmonics_for	gaussian_data.foo	/^   spherical_harmonics_for :: VEC{MAT_{REAL}}*, public   DEFAULT_NULL$/;"	g
create	gaussian_data.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	gaussian_data.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	gaussian_data.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	gaussian_data.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroy_data	gaussian_data.foo	/^   destroy_data ::: selfless, leaky$/;"	r
set_defaults	gaussian_data.foo	/^   set_defaults$/;"	r
set_indices	gaussian_data.foo	/^   set_indices(l_max) ::: selfless, leaky$/;"	r
set_gaussian_indices	gaussian_data.foo	/^   set_gaussian_indices(l_max,nx,ny,nz,first_nonzero,index_of,index_m1,index_p1) ::: selfless, private$/;"	r
set_Ishida_indices	gaussian_data.foo	/^   set_Ishida_indices(l_max,nx,ny,nz,first_nonzero,index_of,index_m1,index_p1) ::: selfless, private$/;"	r
set_normalising_factors	gaussian_data.foo	/^   set_normalising_factors(l_max,normalising_factors,px,py,pz) ::: selfless, private$/;"	r
set_binomial_coefficients	gaussian_data.foo	/^   set_binomial_coefficients(l_max,binomial) ::: selfless, leaky, private$/;"	r
set_binomial_p1_coefficients	gaussian_data.foo	/^   set_binomial_p1_coefficients(l_max,binomial_p1) ::: selfless, leaky, private$/;"	r
n_comp	gaussian_data.foo	/^   n_comp(l) result (res) ::: selfless, public, always_pure$/;"	r
n_comp_up_to	gaussian_data.foo	/^   n_comp_up_to(l) result (res) ::: selfless, public, always_pure$/;"	r
n_sph	gaussian_data.foo	/^   n_sph(l) result (res) ::: selfless, public, always_pure$/;"	r
n_sph_up_to	gaussian_data.foo	/^   n_sph_up_to(l) result (res) ::: selfless, public, always_pure$/;"	r
make_xyz_to_solid_harmonics	gaussian_data.foo	/^   make_xyz_to_solid_harmonics(sph) ::: selfless, leaky$/;"	r
d_xyz_rep_matrices_for	gaussian_data.foo	/^   d_xyz_rep_matrices_for(R,is_spherical) result (res) ::: selfless, leaky$/;"	r
f_xyz_rep_matrices_for	gaussian_data.foo	/^   f_xyz_rep_matrices_for(R,is_spherical) result (res) ::: selfless, leaky$/;"	r
g_xyz_rep_matrices_for	gaussian_data.foo	/^   g_xyz_rep_matrices_for(R,is_spherical) result (res) ::: selfless, leaky$/;"	r
d_xyz_rep_matrix_for	gaussian_data.foo	/^   d_xyz_rep_matrix_for(R) result (dtr) ::: selfless$/;"	r
f_xyz_rep_matrix_for	gaussian_data.foo	/^   f_xyz_rep_matrix_for(R) result (ftr) ::: selfless$/;"	r
g_xyz_rep_matrix_for	gaussian_data.foo	/^   g_xyz_rep_matrix_for(R) result (gtr) ::: selfless$/;"	r
create	gaussian.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	gaussian.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	gaussian.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	gaussian.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	gaussian.foo	/^   create_copy(G) ::: leaky$/;"	r
copy	gaussian.foo	/^   copy(G)$/;"	r
set_defaults	gaussian.foo	/^   set_defaults$/;"	r
set	gaussian.foo	/^   set(G)$/;"	r
set_pos	gaussian.foo	/^   set_pos(pos)$/;"	r
set_l	gaussian.foo	/^   set_l(l)$/;"	r
set_ex	gaussian.foo	/^   set_ex(ex)$/;"	r
l_chr	gaussian.foo	/^   l_chr result (res)$/;"	r
put	gaussian.foo	/^   put$/;"	r
read_keywords	gaussian.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	gaussian.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_l	gaussian.foo	/^   read_l$/;"	r
read_l_int	gaussian.foo	/^   read_l_int$/;"	r
read_l_chr	gaussian.foo	/^   read_l_chr$/;"	r
read_ex	gaussian.foo	/^   read_ex$/;"	r
read_pos	gaussian.foo	/^   read_pos$/;"	r
normalisation_factor	gaussian.foo	/^   normalisation_factor result (res) $/;"	r
same_as	gaussian.foo	/^   same_as(G) result (same)$/;"	r
make_grid	gaussian.foo	/^   make_grid(g,pt)$/;"	r
make_grid	gaussian.foo	/^   make_grid(g,x,y,z)$/;"	r
keys	geminal_mf_scheme.foo	/^   keys :: VEC{STR}*, private DEFAULT_NULL$/;"	g
create	geminal_mf_scheme.foo	/^   create ::: leaky$/;"	r
create	geminal_mf_scheme.foo	/^   create(name,nuc,n_geminals,n_bf,use_brillouin,orthogonality_type,guess_type,print_hamiltonian,convergence,n_step) ::: leaky$/;"	r
destroy	geminal_mf_scheme.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	geminal_mf_scheme.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	geminal_mf_scheme.foo	/^   destroy_ptr_part  ::: leaky$/;"	r
create_copy	geminal_mf_scheme.foo	/^   create_copy(b) ::: leaky$/;"	r
n_step	geminal_mf_scheme.foo	/^     n_step :: INT$/;"	a
self	geminal_mf_scheme.foo	/^     self :: PTR$/;"	a
copy	geminal_mf_scheme.foo	/^   copy(b) ::: leaky$/;"	r
created	geminal_mf_scheme.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	geminal_mf_scheme.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	geminal_mf_scheme.foo	/^   set_defaults(n_geminals,n_bf,name,nuclear_repulsion_energy,use_brillouin,orthogonality_type,guess_type,print_hamiltonian,convergence,max_it,make_integrals,readin_mos,add_core,make_singlet_extremals,readin_scheme) ::: leaky$/;"	r
name	geminal_mf_scheme.foo	/^     name :: STR$/;"	a
nuclear_repulsion_energy	geminal_mf_scheme.foo	/^     nuclear_repulsion_energy :: REAL$/;"	a
orthogonality_type	geminal_mf_scheme.foo	/^     orthogonality_type :: STR, optional$/;"	a
guess_type	geminal_mf_scheme.foo	/^     guess_type :: STR, optional$/;"	a
convergence	geminal_mf_scheme.foo	/^     convergence :: REAL, optional$/;"	a
max_it	geminal_mf_scheme.foo	/^     max_it :: INT, optional$/;"	a
add_core	geminal_mf_scheme.foo	/^     add_core :: BIN, optional$/;"	a
make_singlet_extremals	geminal_mf_scheme.foo	/^     make_singlet_extremals :: BIN, optional$/;"	a
readin_scheme	geminal_mf_scheme.foo	/^     readin_scheme :: BIN, optional$/;"	a
n_step	geminal_mf_scheme.foo	/^     n_step :: INT$/;"	a
read_keywords	geminal_mf_scheme.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	geminal_mf_scheme.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
keyword	geminal_mf_scheme.foo	/^     keyword :: STR, IN$/;"	a
word	geminal_mf_scheme.foo	/^     word :: STR$/;"	a
read_orthogonality_type	geminal_mf_scheme.foo	/^   read_orthogonality_type$/;"	r
read_use_brillouin	geminal_mf_scheme.foo	/^   read_use_brillouin$/;"	r
read_make_integrals	geminal_mf_scheme.foo	/^   read_make_integrals$/;"	r
read_guess_type	geminal_mf_scheme.foo	/^   read_guess_type$/;"	r
read_add_core	geminal_mf_scheme.foo	/^   read_add_core$/;"	r
read_make_singlet_extremals	geminal_mf_scheme.foo	/^   read_make_singlet_extremals$/;"	r
read_readin_mos	geminal_mf_scheme.foo	/^   read_readin_mos$/;"	r
read_readin_scheme	geminal_mf_scheme.foo	/^   read_readin_scheme$/;"	r
read_scheme	geminal_mf_scheme.foo	/^   read_scheme$/;"	r
in	geminal_mf_scheme.foo	/^     in :: TEXTFILE*$/;"	a
read_n_orbitals	geminal_mf_scheme.foo	/^   read_n_orbitals$/;"	r
read_starting_group	geminal_mf_scheme.foo	/^   read_starting_group$/;"	r
read_max_iterations	geminal_mf_scheme.foo	/^   read_max_iterations$/;"	r
n_step	geminal_mf_scheme.foo	/^     n_step :: INT$/;"	a
tolerance	geminal_mf_scheme.foo	/^     tolerance :: INT$/;"	a
ld_tol	geminal_mf_scheme.foo	/^     ld_tol :: REAL$/;"	a
ig_tol	geminal_mf_scheme.foo	/^     ig_tol :: REAL$/;"	a
truncation	geminal_mf_scheme.foo	/^     truncation :: REAL$/;"	a
do_triplet_energies	geminal_mf_scheme.foo	/^     do_triplet_energies :: BIN$/;"	a
do_electric_dipole	geminal_mf_scheme.foo	/^     do_electric_dipole :: BIN$/;"	a
read_convergence_tolerance	geminal_mf_scheme.foo	/^   read_convergence_tolerance$/;"	r
read_print_hamiltonian	geminal_mf_scheme.foo	/^   read_print_hamiltonian$/;"	r
read_units	geminal_mf_scheme.foo	/^   read_units ::: get_from(OBJECT)$/;"	r
read_junk	geminal_mf_scheme.foo	/^   read_junk ::: get_from(OBJECT)$/;"	r
get_n_iterations	geminal_mf_scheme.foo	/^   get_n_iterations$/;"	r
n_iterations_archive	geminal_mf_scheme.foo	/^     n_iterations_archive :: ARCHIVE$/;"	a
name	geminal_mf_scheme.foo	/^     name :: STR$/;"	a
get_old_tolerance	geminal_mf_scheme.foo	/^   get_old_tolerance(old_tolerance)$/;"	r
old_tolerance	geminal_mf_scheme.foo	/^     old_tolerance :: VEC{INT}$/;"	a
old_tolerance_archive	geminal_mf_scheme.foo	/^     old_tolerance_archive :: ARCHIVE$/;"	a
name	geminal_mf_scheme.foo	/^     name :: STR$/;"	a
get_gs_energies	geminal_mf_scheme.foo	/^   get_gs_energies(gs_energies)$/;"	r
gs_energies	geminal_mf_scheme.foo	/^     gs_energies :: VEC{REAL}$/;"	a
gs_energies_archive	geminal_mf_scheme.foo	/^     gs_energies_archive :: ARCHIVE$/;"	a
name	geminal_mf_scheme.foo	/^     name :: STR$/;"	a
read_keys	geminal_mf_scheme.foo	/^   read_keys ::: get_from(OBJECT)$/;"	r
process_keys	geminal_mf_scheme.foo	/^   process_keys ::: get_from(OBJECT), leaky$/;"	r
keys_created	geminal_mf_scheme.foo	/^   keys_created result (res) ::: get_from(OBJECT)$/;"	r
set_keys	geminal_mf_scheme.foo	/^   set_keys(the_keys) ::: get_from(OBJECT)$/;"	r
clear_keys	geminal_mf_scheme.foo	/^   clear_keys ::: get_from(OBJECT)$/;"	r
put_table_footer	geminal_mf_scheme.foo	/^   put_table_footer ::: get_from(OBJECT)$/;"	r
put_table_header	geminal_mf_scheme.foo	/^   put_table_header$/;"	r
word	geminal_mf_scheme.foo	/^     word :: STR$/;"	a
table_width	geminal_mf_scheme.foo	/^   table_width result (res)$/;"	r
res	geminal_mf_scheme.foo	/^     res :: INT$/;"	a
word	geminal_mf_scheme.foo	/^     word :: STR$/;"	a
same_as	geminal_mf_scheme.foo	/^   same_as(b) result(res) $/;"	r
put	geminal_mf_scheme.foo	/^   put$/;"	r
put_gs_energies	geminal_mf_scheme.foo	/^   put_gs_energies(gs_energies)$/;"	r
gs_energies	geminal_mf_scheme.foo	/^     gs_energies :: VEC{REAL}$/;"	a
gs_energies_archive	geminal_mf_scheme.foo	/^     gs_energies_archive :: ARCHIVE$/;"	a
name	geminal_mf_scheme.foo	/^     name :: STR$/;"	a
put_n_iterations	geminal_mf_scheme.foo	/^   put_n_iterations$/;"	r
n_iterations_archive	geminal_mf_scheme.foo	/^     n_iterations_archive :: ARCHIVE$/;"	a
name	geminal_mf_scheme.foo	/^     name :: STR$/;"	a
put_old_tolerance	geminal_mf_scheme.foo	/^   put_old_tolerance(old_tolerance)$/;"	r
old_tolerance	geminal_mf_scheme.foo	/^     old_tolerance :: VEC{INT}$/;"	a
old_tolerance_archive	geminal_mf_scheme.foo	/^     old_tolerance_archive :: ARCHIVE$/;"	a
name	geminal_mf_scheme.foo	/^     name :: STR$/;"	a
do_gmf_auto	geminal_mf_scheme.foo	/^   do_gmf_auto ::: leaky !because of the set_defaults$/;"	r
ham	geminal_mf_scheme.foo	/^     ham :: MAT{REAL}*$/;"	a
gs_energies	geminal_mf_scheme.foo	/^     gs_energies :: VEC{REAL}*$/;"	a
old_tolerance	geminal_mf_scheme.foo	/^     old_tolerance :: VEC{INT}*$/;"	a
group_order	geminal_mf_scheme.foo	/^     group_order :: VEC{INT}*$/;"	a
lowest_energy	geminal_mf_scheme.foo	/^     lowest_energy :: REAL$/;"	a
old_energy	geminal_mf_scheme.foo	/^     old_energy :: REAL$/;"	a
n_nonzero	geminal_mf_scheme.foo	/^     n_nonzero :: INT$/;"	a
eigenvec	geminal_mf_scheme.foo	/^     eigenvec :: MAT{REAL}*$/;"	a
timer	geminal_mf_scheme.foo	/^     timer :: TIME$/;"	a
set	geminal_mf_scheme.foo	/^     set :: BIN$/;"	a
save_step	geminal_mf_scheme.foo	/^     save_step :: BIN$/;"	a
restart_gmf_auto	geminal_mf_scheme.foo	/^   restart_gmf_auto$/;"	r
ham	geminal_mf_scheme.foo	/^     ham :: MAT{REAL}*$/;"	a
gs_energies	geminal_mf_scheme.foo	/^     gs_energies :: VEC{REAL}*$/;"	a
old_tolerance	geminal_mf_scheme.foo	/^     old_tolerance :: VEC{INT}*$/;"	a
group_order	geminal_mf_scheme.foo	/^     group_order :: VEC{INT}*$/;"	a
lowest_energy	geminal_mf_scheme.foo	/^     lowest_energy :: REAL$/;"	a
old_energy	geminal_mf_scheme.foo	/^     old_energy :: REAL$/;"	a
n_nonzero	geminal_mf_scheme.foo	/^     n_nonzero :: INT$/;"	a
eigenvec	geminal_mf_scheme.foo	/^     eigenvec :: MAT{REAL}*$/;"	a
timer	geminal_mf_scheme.foo	/^     timer :: TIME$/;"	a
set	geminal_mf_scheme.foo	/^     set :: BIN$/;"	a
save_step	geminal_mf_scheme.foo	/^     save_step :: BIN$/;"	a
do_triplet_spectrum	geminal_mf_scheme.foo	/^   do_triplet_spectrum ::: leaky !because of the set_defaults$/;"	r
ham	geminal_mf_scheme.foo	/^     ham :: MAT{REAL}*$/;"	a
i_geminals	geminal_mf_scheme.foo	/^     i_geminals :: INT$/;"	a
max_bas	geminal_mf_scheme.foo	/^     max_bas :: INT$/;"	a
eigenvec	geminal_mf_scheme.foo	/^     eigenvec :: MAT{REAL}*$/;"	a
timer	geminal_mf_scheme.foo	/^     timer :: TIME$/;"	a
electric_dipole_matrices	geminal_mf_scheme.foo	/^   electric_dipole_matrices $/;"	r
max_bas	geminal_mf_scheme.foo	/^     max_bas :: INT$/;"	a
timer	geminal_mf_scheme.foo	/^     timer :: TIME$/;"	a
remove_singlet_dependencies	geminal_mf_scheme.foo	/^   remove_singlet_dependencies ::: leaky$/;"	r
remove_triplet_dependencies	geminal_mf_scheme.foo	/^   remove_triplet_dependencies ::: leaky$/;"	r
keys	geminal_mf_spectrum.foo	/^   keys :: VEC{STR}*, private DEFAULT_NULL$/;"	g
create	geminal_mf_spectrum.foo	/^   create(name,nuc,n_geminals,i_geminals,n_bf) ::: leaky$/;"	r
destroy	geminal_mf_spectrum.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	geminal_mf_spectrum.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	geminal_mf_spectrum.foo	/^   destroy_ptr_part  ::: leaky$/;"	r
create_copy	geminal_mf_spectrum.foo	/^   create_copy(b) ::: leaky$/;"	r
self	geminal_mf_spectrum.foo	/^     self :: PTR$/;"	a
copy	geminal_mf_spectrum.foo	/^   copy(b) ::: leaky$/;"	r
created	geminal_mf_spectrum.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	geminal_mf_spectrum.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	geminal_mf_spectrum.foo	/^   set_defaults(n_geminals,i_geminals,n_bf,name,nuclear_repulsion_energy,n_bas) $/;"	r
name	geminal_mf_spectrum.foo	/^     name :: STR, optional$/;"	a
nuclear_repulsion_energy	geminal_mf_spectrum.foo	/^     nuclear_repulsion_energy :: REAL, optional$/;"	a
set_singlet_agp	geminal_mf_spectrum.foo	/^   set_singlet_agp ::: leaky$/;"	r
i_geminals	geminal_mf_spectrum.foo	/^     i_geminals :: INT$/;"	a
n_nonzero	geminal_mf_spectrum.foo	/^     n_nonzero :: INT$/;"	a
set_singlet_random	geminal_mf_spectrum.foo	/^   set_singlet_random ::: leaky$/;"	r
i_geminals	geminal_mf_spectrum.foo	/^     i_geminals :: INT$/;"	a
n_nonzero	geminal_mf_spectrum.foo	/^     n_nonzero :: INT$/;"	a
val	geminal_mf_spectrum.foo	/^     val :: REAL$/;"	a
set_singlet_mono	geminal_mf_spectrum.foo	/^   set_singlet_mono ::: leaky$/;"	r
i_geminals	geminal_mf_spectrum.foo	/^     i_geminals :: INT$/;"	a
val	geminal_mf_spectrum.foo	/^     val :: REAL$/;"	a
set_singlet_defaults	geminal_mf_spectrum.foo	/^   set_singlet_defaults ::: leaky$/;"	r
i_geminals	geminal_mf_spectrum.foo	/^     i_geminals :: INT$/;"	a
n_nonzero	geminal_mf_spectrum.foo	/^     n_nonzero :: INT$/;"	a
make_singlet_extremals	geminal_mf_spectrum.foo	/^   make_singlet_extremals ::: leaky$/;"	r
n_bas	geminal_mf_spectrum.foo	/^     n_bas :: INT$/;"	a
rhm	geminal_mf_spectrum.foo	/^     rhm :: MAT{REAL}*$/;"	a
extremal_gem	geminal_mf_spectrum.foo	/^     extremal_gem :: MAT{REAL}*$/;"	a
extremal_val	geminal_mf_spectrum.foo	/^     extremal_val :: VEC{REAL}*$/;"	a
set_singlet_readin	geminal_mf_spectrum.foo	/^   set_singlet_readin::: leaky$/;"	r
i_geminals	geminal_mf_spectrum.foo	/^     i_geminals :: INT$/;"	a
n_nonzero	geminal_mf_spectrum.foo	/^     n_nonzero :: INT$/;"	a
ov	geminal_mf_spectrum.foo	/^     ov :: MAT{REAL}*$/;"	a
set_active_singlet_defaults	geminal_mf_spectrum.foo	/^   set_active_singlet_defaults ::: leaky$/;"	r
set_triplet_defaults	geminal_mf_spectrum.foo	/^   set_triplet_defaults ::: leaky$/;"	r
i_geminals	geminal_mf_spectrum.foo	/^     i_geminals :: INT$/;"	a
set_active_triplet_defaults	geminal_mf_spectrum.foo	/^   set_active_triplet_defaults ::: leaky$/;"	r
n_bf	geminal_mf_spectrum.foo	/^     n_bf :: INT$/;"	a
set_to_zero_special_ket	geminal_mf_spectrum.foo	/^   set_to_zero_special_ket$/;"	r
set_to_zero_ket	geminal_mf_spectrum.foo	/^   set_to_zero_ket$/;"	r
set_to_zero_bra	geminal_mf_spectrum.foo	/^   set_to_zero_bra$/;"	r
set_to_zero_contraction_wfs	geminal_mf_spectrum.foo	/^   set_to_zero_contraction_wfs$/;"	r
set_to_zero_energies	geminal_mf_spectrum.foo	/^   set_to_zero_energies$/;"	r
read_keywords	geminal_mf_spectrum.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	geminal_mf_spectrum.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
keyword	geminal_mf_spectrum.foo	/^     keyword :: STR, IN$/;"	a
word	geminal_mf_spectrum.foo	/^     word :: STR$/;"	a
read_units	geminal_mf_spectrum.foo	/^   read_units ::: get_from(OBJECT)$/;"	r
read_junk	geminal_mf_spectrum.foo	/^   read_junk ::: get_from(OBJECT)$/;"	r
read_geminal	geminal_mf_spectrum.foo	/^   read_geminal(j,mat) ::: leaky$/;"	r
mat	geminal_mf_spectrum.foo	/^     mat :: MAT{REAL}*$/;"	a
in	geminal_mf_spectrum.foo	/^     in :: TEXTFILE*$/;"	a
name	geminal_mf_spectrum.foo	/^     name :: STR$/;"	a
get_wfs	geminal_mf_spectrum.foo	/^   get_wfs ::: leaky$/;"	r
wfs_archive	geminal_mf_spectrum.foo	/^     wfs_archive :: ARCHIVE$/;"	a
name	geminal_mf_spectrum.foo	/^     name :: STR$/;"	a
get_ground_state	geminal_mf_spectrum.foo	/^   get_ground_state$/;"	r
ground_state_archive	geminal_mf_spectrum.foo	/^     ground_state_archive :: ARCHIVE$/;"	a
name	geminal_mf_spectrum.foo	/^     name :: STR$/;"	a
get_max_bas	geminal_mf_spectrum.foo	/^   get_max_bas$/;"	r
max_bas_archive	geminal_mf_spectrum.foo	/^     max_bas_archive :: ARCHIVE$/;"	a
name	geminal_mf_spectrum.foo	/^     name :: STR$/;"	a
gs_permutation	geminal_mf_spectrum.foo	/^   gs_permutation$/;"	r
temp	geminal_mf_spectrum.foo	/^     temp :: MAT{REAL}*$/;"	a
read_keys	geminal_mf_spectrum.foo	/^   read_keys ::: get_from(OBJECT)$/;"	r
process_keys	geminal_mf_spectrum.foo	/^   process_keys ::: get_from(OBJECT), leaky$/;"	r
keys_created	geminal_mf_spectrum.foo	/^   keys_created result (res) ::: get_from(OBJECT)$/;"	r
set_keys	geminal_mf_spectrum.foo	/^   set_keys(the_keys) ::: get_from(OBJECT)$/;"	r
clear_keys	geminal_mf_spectrum.foo	/^   clear_keys ::: get_from(OBJECT)$/;"	r
put_table_footer	geminal_mf_spectrum.foo	/^   put_table_footer ::: get_from(OBJECT)$/;"	r
put_table_header	geminal_mf_spectrum.foo	/^   put_table_header$/;"	r
word	geminal_mf_spectrum.foo	/^     word :: STR$/;"	a
table_width	geminal_mf_spectrum.foo	/^   table_width result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: INT$/;"	a
word	geminal_mf_spectrum.foo	/^     word :: STR$/;"	a
same_as	geminal_mf_spectrum.foo	/^   same_as(b) result(res) $/;"	r
put	geminal_mf_spectrum.foo	/^   put$/;"	r
put_ground_state_geminals	geminal_mf_spectrum.foo	/^   put_ground_state_geminals$/;"	r
put_wfs	geminal_mf_spectrum.foo	/^   put_wfs$/;"	r
wfs_archive	geminal_mf_spectrum.foo	/^     wfs_archive :: ARCHIVE$/;"	a
name	geminal_mf_spectrum.foo	/^     name :: STR$/;"	a
put_ground_state	geminal_mf_spectrum.foo	/^   put_ground_state$/;"	r
ground_state_archive	geminal_mf_spectrum.foo	/^     ground_state_archive :: ARCHIVE$/;"	a
name	geminal_mf_spectrum.foo	/^     name :: STR$/;"	a
put_max_bas	geminal_mf_spectrum.foo	/^   put_max_bas$/;"	r
max_bas_archive	geminal_mf_spectrum.foo	/^     max_bas_archive :: ARCHIVE$/;"	a
name	geminal_mf_spectrum.foo	/^     name :: STR$/;"	a
electric_dipole_x	geminal_mf_spectrum.foo	/^   electric_dipole_x result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bas,.n_bas)$/;"	a
edm_archive	geminal_mf_spectrum.foo	/^     edm_archive :: ARCHIVE$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
electric_dipole_y	geminal_mf_spectrum.foo	/^   electric_dipole_y result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bas,.n_bas)$/;"	a
edm_archive	geminal_mf_spectrum.foo	/^     edm_archive :: ARCHIVE$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
electric_dipole_z	geminal_mf_spectrum.foo	/^   electric_dipole_z result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bas,.n_bas)$/;"	a
edm_archive	geminal_mf_spectrum.foo	/^     edm_archive :: ARCHIVE$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
hamiltonian	geminal_mf_spectrum.foo	/^   hamiltonian result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bas,.n_bas)$/;"	a
eri_archive	geminal_mf_spectrum.foo	/^     eri_archive :: ARCHIVE$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
hamiltonian	geminal_mf_spectrum.foo	/^   hamiltonian(i) result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: VEC{REAL}(.n_bas)$/;"	a
eri_archive	geminal_mf_spectrum.foo	/^     eri_archive :: ARCHIVE$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
hamiltonian	geminal_mf_spectrum.foo	/^   hamiltonian(i,j) result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: REAL$/;"	a
eri_archive	geminal_mf_spectrum.foo	/^     eri_archive :: ARCHIVE$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
make_RHM	geminal_mf_spectrum.foo	/^   make_RHM(rhm)$/;"	r
rhm	geminal_mf_spectrum.foo	/^     rhm ::  MAT{REAL}*$/;"	a
eri_archive	geminal_mf_spectrum.foo	/^     eri_archive :: ARCHIVE$/;"	a
hamiltonian_for	geminal_mf_spectrum.foo	/^   hamiltonian_for(v,order_ket) result (res) ::: recursive$/;"	r
order_ket	geminal_mf_spectrum.foo	/^     order_ket :: VEC{INT}, IN$/;"	a
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bas,.n_bas)$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_bra_q	geminal_mf_spectrum.foo	/^     temp_bra_q :: MAT{REAL}*$/;"	a
temp_bra_i	geminal_mf_spectrum.foo	/^     temp_bra_i :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
temp_h2_q	geminal_mf_spectrum.foo	/^     temp_h2_q ::  MAT{REAL}*$/;"	a
temp_qa_h2	geminal_mf_spectrum.foo	/^     temp_qa_h2 :: MAT4{REAL}*$/;"	a
temp_qb_h2	geminal_mf_spectrum.foo	/^     temp_qb_h2 :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_ex	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_ex :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_ex	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_ex :: MAT4{REAL}*$/;"	a
temp_qa_h2_jb	geminal_mf_spectrum.foo	/^     temp_qa_h2_jb :: MAT4{REAL}*$/;"	a
temp_qb_h2_ja	geminal_mf_spectrum.foo	/^     temp_qb_h2_ja :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_kb	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_kb :: MAT4{REAL}*$/;"	a
temp_qa_h2_jb_ka	geminal_mf_spectrum.foo	/^     temp_qa_h2_jb_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_ka	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_ja_kb	geminal_mf_spectrum.foo	/^     temp_qb_h2_ja_kb :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_ka	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_kb	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_kb :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_ex_ka	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_ex_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_ex_kb	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_ex_kb :: MAT4{REAL}*$/;"	a
temp_qb_jb	geminal_mf_spectrum.foo	/^     temp_qb_jb :: MAT{REAL}*$/;"	a
temp_qa_ja	geminal_mf_spectrum.foo	/^     temp_qa_ja :: MAT{REAL}*$/;"	a
temp_q_h2_ja_kb	geminal_mf_spectrum.foo	/^     temp_q_h2_ja_kb :: MAT{REAL}*$/;"	a
temp_q_h2_jb_ka	geminal_mf_spectrum.foo	/^     temp_q_h2_jb_ka :: MAT{REAL}*$/;"	a
temp_qa_h2_j	geminal_mf_spectrum.foo	/^     temp_qa_h2_j :: MAT{REAL}*$/;"	a
temp_qb_h2_j	geminal_mf_spectrum.foo	/^     temp_qb_h2_j :: MAT{REAL}*$/;"	a
hamiltonian_for	geminal_mf_spectrum.foo	/^   hamiltonian_for(v,order_ket,col_ind) result (res) ::: recursive$/;"	r
order_ket	geminal_mf_spectrum.foo	/^     order_ket :: VEC{INT}, IN$/;"	a
col_ind	geminal_mf_spectrum.foo	/^     col_ind :: INT, IN$/;"	a
res	geminal_mf_spectrum.foo	/^     res :: VEC{REAL}(.n_bas)$/;"	a
row_ind	geminal_mf_spectrum.foo	/^     row_ind :: INT$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_bra_q	geminal_mf_spectrum.foo	/^     temp_bra_q :: MAT{REAL}*$/;"	a
temp_bra_i	geminal_mf_spectrum.foo	/^     temp_bra_i :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
temp_h2_q	geminal_mf_spectrum.foo	/^     temp_h2_q ::  MAT{REAL}*$/;"	a
temp_qa_h2	geminal_mf_spectrum.foo	/^     temp_qa_h2 :: MAT4{REAL}*$/;"	a
temp_qb_h2	geminal_mf_spectrum.foo	/^     temp_qb_h2 :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_ex	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_ex :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_ex	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_ex :: MAT4{REAL}*$/;"	a
temp_qa_h2_jb	geminal_mf_spectrum.foo	/^     temp_qa_h2_jb :: MAT4{REAL}*$/;"	a
temp_qb_h2_ja	geminal_mf_spectrum.foo	/^     temp_qb_h2_ja :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_kb	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_kb :: MAT4{REAL}*$/;"	a
temp_qa_h2_jb_ka	geminal_mf_spectrum.foo	/^     temp_qa_h2_jb_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_ka	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_ja_kb	geminal_mf_spectrum.foo	/^     temp_qb_h2_ja_kb :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_ka	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_kb	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_kb :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_ex_ka	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_ex_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_ex_kb	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_ex_kb :: MAT4{REAL}*$/;"	a
temp_qb_jb	geminal_mf_spectrum.foo	/^     temp_qb_jb :: MAT{REAL}*$/;"	a
temp_qa_ja	geminal_mf_spectrum.foo	/^     temp_qa_ja :: MAT{REAL}*$/;"	a
temp_q_h2_ja_kb	geminal_mf_spectrum.foo	/^     temp_q_h2_ja_kb :: MAT{REAL}*$/;"	a
temp_q_h2_jb_ka	geminal_mf_spectrum.foo	/^     temp_q_h2_jb_ka :: MAT{REAL}*$/;"	a
temp_qa_h2_j	geminal_mf_spectrum.foo	/^     temp_qa_h2_j :: MAT{REAL}*$/;"	a
temp_qb_h2_j	geminal_mf_spectrum.foo	/^     temp_qb_h2_j :: MAT{REAL}*$/;"	a
hamiltonian_for	geminal_mf_spectrum.foo	/^   hamiltonian_for(v,order_ket,row_ind,col_ind) result (res) ::: recursive$/;"	r
order_ket	geminal_mf_spectrum.foo	/^     order_ket :: VEC{INT}, IN$/;"	a
res	geminal_mf_spectrum.foo	/^     res :: REAL$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_bra_q	geminal_mf_spectrum.foo	/^     temp_bra_q :: MAT{REAL}*$/;"	a
temp_bra_i	geminal_mf_spectrum.foo	/^     temp_bra_i :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
temp_q_h2	geminal_mf_spectrum.foo	/^     temp_q_h2 ::  MAT{REAL}*$/;"	a
temp_qa_h2	geminal_mf_spectrum.foo	/^     temp_qa_h2 :: MAT4{REAL}*$/;"	a
temp_qb_h2	geminal_mf_spectrum.foo	/^     temp_qb_h2 :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_ex	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_ex :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_ex	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_ex :: MAT4{REAL}*$/;"	a
temp_qa_h2_jb	geminal_mf_spectrum.foo	/^     temp_qa_h2_jb :: MAT4{REAL}*$/;"	a
temp_qb_h2_ja	geminal_mf_spectrum.foo	/^     temp_qb_h2_ja :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_kb	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_kb :: MAT4{REAL}*$/;"	a
temp_qa_h2_jb_ka	geminal_mf_spectrum.foo	/^     temp_qa_h2_jb_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_ka	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_ja_kb	geminal_mf_spectrum.foo	/^     temp_qb_h2_ja_kb :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_ka	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_kb	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_kb :: MAT4{REAL}*$/;"	a
temp_qa_h2_ja_ex_ka	geminal_mf_spectrum.foo	/^     temp_qa_h2_ja_ex_ka :: MAT4{REAL}*$/;"	a
temp_qb_h2_jb_ex_kb	geminal_mf_spectrum.foo	/^     temp_qb_h2_jb_ex_kb :: MAT4{REAL}*$/;"	a
temp_qb_jb	geminal_mf_spectrum.foo	/^     temp_qb_jb :: MAT{REAL}*$/;"	a
temp_qa_ja	geminal_mf_spectrum.foo	/^     temp_qa_ja :: MAT{REAL}*$/;"	a
temp_q_h2_ja_kb	geminal_mf_spectrum.foo	/^     temp_q_h2_ja_kb :: MAT{REAL}*$/;"	a
temp_q_h2_jb_ka	geminal_mf_spectrum.foo	/^     temp_q_h2_jb_ka :: MAT{REAL}*$/;"	a
temp_qa_h2_j	geminal_mf_spectrum.foo	/^     temp_qa_h2_j :: MAT{REAL}*$/;"	a
temp_qb_h2_j	geminal_mf_spectrum.foo	/^     temp_qb_h2_j :: MAT{REAL}*$/;"	a
overlap_for	geminal_mf_spectrum.foo	/^   overlap_for(order_bra,order_ket) result (res) ::: recursive$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bas,.n_bas)$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
reorder_bra	geminal_mf_spectrum.foo	/^     reorder_bra :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_bra_q	geminal_mf_spectrum.foo	/^     temp_bra_q :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
temp_qa_ja	geminal_mf_spectrum.foo	/^     temp_qa_ja :: MAT{REAL}*$/;"	a
temp_qb_jb	geminal_mf_spectrum.foo	/^     temp_qb_jb :: MAT{REAL}*$/;"	a
overlap_for	geminal_mf_spectrum.foo	/^   overlap_for(order_bra,order_ket,col_ind) result (res) ::: recursive$/;"	r
col_ind	geminal_mf_spectrum.foo	/^     col_ind :: INT, IN$/;"	a
res	geminal_mf_spectrum.foo	/^     res :: VEC{REAL}(.n_bas)$/;"	a
row_ind	geminal_mf_spectrum.foo	/^     row_ind :: INT$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
reorder_bra	geminal_mf_spectrum.foo	/^     reorder_bra :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_bra_q	geminal_mf_spectrum.foo	/^     temp_bra_q :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
temp_qa_ja	geminal_mf_spectrum.foo	/^     temp_qa_ja :: MAT{REAL}*$/;"	a
temp_qb_jb	geminal_mf_spectrum.foo	/^     temp_qb_jb :: MAT{REAL}*$/;"	a
overlap_for	geminal_mf_spectrum.foo	/^   overlap_for(order_bra,order_ket,row_ind,col_ind) result (res) ::: recursive$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: REAL$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
reorder_bra	geminal_mf_spectrum.foo	/^     reorder_bra :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_bra_q	geminal_mf_spectrum.foo	/^     temp_bra_q :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
temp_qa_ja	geminal_mf_spectrum.foo	/^     temp_qa_ja :: MAT{REAL}*$/;"	a
temp_qb_jb	geminal_mf_spectrum.foo	/^     temp_qb_jb :: MAT{REAL}*$/;"	a
special_overlap_spin_ab_for	geminal_mf_spectrum.foo	/^   special_overlap_spin_ab_for(order_bra,order_ket,b1,b2) result (res) ::: recursive$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bas,.n_bas)$/;"	a
col_ind	geminal_mf_spectrum.foo	/^     col_ind :: INT$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_ket_q	geminal_mf_spectrum.foo	/^     temp_ket_q :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
special_overlap_spin_ab_for	geminal_mf_spectrum.foo	/^   special_overlap_spin_ab_for(order_bra,order_ket,col_ind,b1,b2) result (res) ::: recursive$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: VEC{REAL}(.n_bas)$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_ket_q	geminal_mf_spectrum.foo	/^     temp_ket_q :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
special_overlap_spin_ab_for	geminal_mf_spectrum.foo	/^   special_overlap_spin_ab_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res) ::: recursive$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: REAL$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_ket_q	geminal_mf_spectrum.foo	/^     temp_ket_q :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
special_overlap_spin_bb_for	geminal_mf_spectrum.foo	/^   special_overlap_spin_bb_for(order_bra,order_ket,b1,b2) result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bas,.n_bas)$/;"	a
col_ind	geminal_mf_spectrum.foo	/^     col_ind :: INT$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
special_overlap_spin_bb_for	geminal_mf_spectrum.foo	/^   special_overlap_spin_bb_for(order_bra,order_ket,col_ind,b1,b2) result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: VEC{REAL}(.n_bas)$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
special_overlap_spin_bb_for	geminal_mf_spectrum.foo	/^   special_overlap_spin_bb_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: REAL$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
special_overlap_spin_aa_for	geminal_mf_spectrum.foo	/^   special_overlap_spin_aa_for(order_bra,order_ket,b1,b2) result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bas,.n_bas)$/;"	a
col_ind	geminal_mf_spectrum.foo	/^     col_ind :: INT$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
special_overlap_spin_aa_for	geminal_mf_spectrum.foo	/^   special_overlap_spin_aa_for(order_bra,order_ket,col_ind,b1,b2) result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: VEC{REAL}(.n_bas)$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
special_overlap_spin_aa_for	geminal_mf_spectrum.foo	/^   special_overlap_spin_aa_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: REAL$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
overlap	geminal_mf_spectrum.foo	/^   overlap result (res)$/;"	r
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bas,.n_bas)$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
overlap_for	geminal_mf_spectrum.foo	/^   overlap_for(order_ket) result (res) ::: recursive$/;"	r
order_ket	geminal_mf_spectrum.foo	/^     order_ket :: VEC{INT}, IN$/;"	a
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bas,.n_bas)$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_bra_q	geminal_mf_spectrum.foo	/^     temp_bra_q :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
temp_qa_ja	geminal_mf_spectrum.foo	/^     temp_qa_ja :: MAT{REAL}*$/;"	a
temp_qb_jb	geminal_mf_spectrum.foo	/^     temp_qb_jb :: MAT{REAL}*$/;"	a
overlap_for	geminal_mf_spectrum.foo	/^   overlap_for(order_ket,col_ind) result (res) ::: recursive$/;"	r
col_ind	geminal_mf_spectrum.foo	/^     col_ind :: INT, IN$/;"	a
order_ket	geminal_mf_spectrum.foo	/^     order_ket :: VEC{INT}, IN$/;"	a
res	geminal_mf_spectrum.foo	/^     res :: VEC{REAL}(.n_bas)$/;"	a
row_ind	geminal_mf_spectrum.foo	/^     row_ind :: INT$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_bra_q	geminal_mf_spectrum.foo	/^     temp_bra_q :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
temp_qa_ja	geminal_mf_spectrum.foo	/^     temp_qa_ja :: MAT{REAL}*$/;"	a
temp_qb_jb	geminal_mf_spectrum.foo	/^     temp_qb_jb :: MAT{REAL}*$/;"	a
overlap_for	geminal_mf_spectrum.foo	/^   overlap_for(order_ket,row_ind,col_ind) result (res) ::: recursive$/;"	r
order_ket	geminal_mf_spectrum.foo	/^     order_ket :: VEC{INT}, IN$/;"	a
res	geminal_mf_spectrum.foo	/^     res :: REAL$/;"	a
reorder_ket	geminal_mf_spectrum.foo	/^     reorder_ket :: VEC{INT}*$/;"	a
fac	geminal_mf_spectrum.foo	/^     fac :: REAL$/;"	a
temp_bra_q	geminal_mf_spectrum.foo	/^     temp_bra_q :: MAT{REAL}*$/;"	a
temp_ket_j	geminal_mf_spectrum.foo	/^     temp_ket_j :: MAT{REAL}*$/;"	a
temp_ket_k	geminal_mf_spectrum.foo	/^     temp_ket_k :: MAT{REAL}*$/;"	a
temp_qa_ja	geminal_mf_spectrum.foo	/^     temp_qa_ja :: MAT{REAL}*$/;"	a
temp_qb_jb	geminal_mf_spectrum.foo	/^     temp_qb_jb :: MAT{REAL}*$/;"	a
do_hamiltonian	geminal_mf_spectrum.foo	/^   do_hamiltonian(print_hamiltonian)$/;"	r
print_hamiltonian	geminal_mf_spectrum.foo	/^     print_hamiltonian :: BIN, optional, IN$/;"	a
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}*$/;"	a
print_default	geminal_mf_spectrum.foo	/^     print_default :: BIN$/;"	a
do_overlap	geminal_mf_spectrum.foo	/^   do_overlap$/;"	r
do_step_0	geminal_mf_spectrum.foo	/^   do_step_0(use_brillouin,print_hamiltonian,truncation_threshold,do_electric_dipole) $/;"	r
use_brillouin	geminal_mf_spectrum.foo	/^     use_brillouin :: BIN, IN$/;"	a
print_hamiltonian	geminal_mf_spectrum.foo	/^     print_hamiltonian :: BIN, IN$/;"	a
truncation_threshold	geminal_mf_spectrum.foo	/^     truncation_threshold :: REAL, IN$/;"	a
do_electric_dipole	geminal_mf_spectrum.foo	/^     do_electric_dipole :: BIN, IN$/;"	a
ham	geminal_mf_spectrum.foo	/^     ham :: MAT{REAL}*$/;"	a
indices	geminal_mf_spectrum.foo	/^     indices :: VEC{INT}*$/;"	a
increasing_vec	geminal_mf_spectrum.foo	/^     increasing_vec :: VEC{MAT_{REAL}}*$/;"	a
increasing_values	geminal_mf_spectrum.foo	/^     increasing_values :: VEC{REAL}*$/;"	a
eigenvec	geminal_mf_spectrum.foo	/^     eigenvec :: MAT{REAL}*$/;"	a
new_wfs	geminal_mf_spectrum.foo	/^     new_wfs :: VEC{MAT_{REAL}}*$/;"	a
remove_dependencies	geminal_mf_spectrum.foo	/^   remove_dependencies(orthogonality_type,print_hamiltonian) $/;"	r
orthogonality_type	geminal_mf_spectrum.foo	/^     orthogonality_type :: STR, IN$/;"	a
print_hamiltonian	geminal_mf_spectrum.foo	/^     print_hamiltonian :: BIN, IN$/;"	a
word	geminal_mf_spectrum.foo	/^     word :: STR$/;"	a
ov	geminal_mf_spectrum.foo	/^     ov :: MAT{REAL}*$/;"	a
norms	geminal_mf_spectrum.foo	/^     norms :: VEC{REAL}*$/;"	a
order_ket	geminal_mf_spectrum.foo	/^     order_ket :: VEC{INT}*$/;"	a
n_geminals	geminal_mf_spectrum.foo	/^     n_geminals :: INT$/;"	a
n_singlet	geminal_mf_spectrum.foo	/^     n_singlet :: INT$/;"	a
remove_triplet_dependencies	geminal_mf_spectrum.foo	/^   remove_triplet_dependencies(print_hamiltonian) ::: leaky $/;"	r
print_hamiltonian	geminal_mf_spectrum.foo	/^     print_hamiltonian :: BIN, IN$/;"	a
ov	geminal_mf_spectrum.foo	/^     ov :: MAT{REAL}*$/;"	a
eigenvalues	geminal_mf_spectrum.foo	/^     eigenvalues :: VEC{REAL}*$/;"	a
orthovec	geminal_mf_spectrum.foo	/^     orthovec :: MAT{REAL}*$/;"	a
make_2RDM_singlet	geminal_mf_spectrum.foo	/^   make_2RDM_singlet(order_ket,res)$/;"	r
order_ket	geminal_mf_spectrum.foo	/^     order_ket :: VEC{INT}, IN$/;"	a
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bf*(.n_bf+1)\/2,.n_bf*(.n_bf+1)\/2)$/;"	a
n_bf	geminal_mf_spectrum.foo	/^     n_bf :: INT$/;"	a
interior_product_by_special_geminal_ab	geminal_mf_spectrum.foo	/^   interior_product_by_special_geminal_ab(order_ket,b1,b2) result(res) $/;"	r
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bf,.n_bf)$/;"	a
order_ket	geminal_mf_spectrum.foo	/^     order_ket :: VEC{INT}, IN$/;"	a
n_bf	geminal_mf_spectrum.foo	/^     n_bf :: INT$/;"	a
interior_product_by_geminal_ab_singlet	geminal_mf_spectrum.foo	/^   interior_product_by_geminal_ab_singlet(order_ket,b1,b2) result(res) $/;"	r
res	geminal_mf_spectrum.foo	/^     res :: MAT{REAL}(.n_bf,.n_bf)$/;"	a
order_ket	geminal_mf_spectrum.foo	/^     order_ket :: VEC{INT}, IN$/;"	a
n_bf	geminal_mf_spectrum.foo	/^     n_bf :: INT$/;"	a
make_gs_electric_dipole	geminal_mf_spectrum.foo	/^   make_gs_electric_dipole $/;"	r
dip	geminal_mf_spectrum.foo	/^     dip :: MAT{REAL}*$/;"	a
n_bas	geminal_mf_spectrum.foo	/^     n_bas :: INT$/;"	a
create	hash{vec{int},vec{int}}.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	hash{vec{int},vec{int}}.foo	/^   create(n_size,keydim,valdim) ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
destroy	hash{vec{int},vec{int}}.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	hash{vec{int},vec{int}}.foo	/^   nullify_ptr_part ::: get_from(HASH{VEC{KEY},VEC{VAL}})$/;"	r
destroy_ptr_part	hash{vec{int},vec{int}}.foo	/^   destroy_ptr_part ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
created	hash{vec{int},vec{int}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	hash{vec{int},vec{int}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	hash{vec{int},vec{int}}.foo	/^   set_defaults ::: get_from(HASH{VEC{KEY},VEC{VAL}})$/;"	r
set_reverse_search	hash{vec{int},vec{int}}.foo	/^   set_reverse_search(value) ::: get_from(HASH{VEC{KEY},VEC{VAL}})$/;"	r
create_copy	hash{vec{int},vec{int}}.foo	/^   create_copy(hash) ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
copy	hash{vec{int},vec{int}}.foo	/^   copy(hash) ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
shrink	hash{vec{int},vec{int}}.foo	/^   shrink ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
shrink	hash{vec{int},vec{int}}.foo	/^   shrink(n_size) ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
expand	hash{vec{int},vec{int}}.foo	/^   expand(n_size) ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
resize	hash{vec{int},vec{int}}.foo	/^   resize(n_size) ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
append_pair	hash{vec{int},vec{int}}.foo	/^   append_pair(key,value) ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
set	hash{vec{int},vec{int}}.foo	/^   set(key,value) ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
append_pairs	hash{vec{int},vec{int}}.foo	/^   append_pairs(keys,values) ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
set	hash{vec{int},vec{int}}.foo	/^   set(keys,values) ::: get_from(HASH{VEC{KEY},VEC{VAL}}), leaky$/;"	r
delete	hash{vec{int},vec{int}}.foo	/^   delete(key,has_key)  ::: get_from(HASH{VEC{KEY},VEC{VAL}})$/;"	r
delete_item	hash{vec{int},vec{int}}.foo	/^   delete_item(index)  ::: get_from(HASH{VEC{KEY},VEC{VAL}})$/;"	r
delete_items	hash{vec{int},vec{int}}.foo	/^   delete_items(list) ::: get_from(HASH{VEC{KEY},VEC{VAL}})$/;"	r
index_of_key	hash{vec{int},vec{int}}.foo	/^   index_of_key(key) result (res) ::: get_from(HASH{VEC{KEY},VEC{VAL}})$/;"	r
has_key	hash{vec{int},vec{int}}.foo	/^   has_key(key,index) result (res) ::: get_from(HASH{VEC{KEY},VEC{VAL}})$/;"	r
value_for_key	hash{vec{int},vec{int}}.foo	/^   value_for_key(key,has_key,index) result (res) ::: get_from(HASH{VEC{KEY},VEC{VAL}})$/;"	r
value_for_item	hash{vec{int},vec{int}}.foo	/^   value_for_item(index) result (res) ::: get_from(HASH{VEC{KEY},VEC{VAL}})$/;"	r
create	hash{vec{key},vec{val}}.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	hash{vec{key},vec{val}}.foo	/^   create(n_size,keydim,valdim) ::: leaky$/;"	r
destroy	hash{vec{key},vec{val}}.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	hash{vec{key},vec{val}}.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	hash{vec{key},vec{val}}.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	hash{vec{key},vec{val}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	hash{vec{key},vec{val}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	hash{vec{key},vec{val}}.foo	/^   set_defaults$/;"	r
set_reverse_search	hash{vec{key},vec{val}}.foo	/^   set_reverse_search(value)$/;"	r
create_copy	hash{vec{key},vec{val}}.foo	/^   create_copy(hash) ::: leaky$/;"	r
copy	hash{vec{key},vec{val}}.foo	/^   copy(hash) ::: leaky$/;"	r
shrink	hash{vec{key},vec{val}}.foo	/^   shrink ::: leaky$/;"	r
shrink	hash{vec{key},vec{val}}.foo	/^   shrink(n_size) ::: leaky$/;"	r
expand	hash{vec{key},vec{val}}.foo	/^   expand(n_size) ::: leaky$/;"	r
resize	hash{vec{key},vec{val}}.foo	/^   resize(n_size) ::: leaky$/;"	r
append_pair	hash{vec{key},vec{val}}.foo	/^   append_pair(key,value) ::: leaky$/;"	r
set	hash{vec{key},vec{val}}.foo	/^   set(key,value) ::: leaky$/;"	r
append_pairs	hash{vec{key},vec{val}}.foo	/^   append_pairs(keys,values) ::: leaky$/;"	r
set	hash{vec{key},vec{val}}.foo	/^   set(keys,values) ::: leaky$/;"	r
delete	hash{vec{key},vec{val}}.foo	/^   delete(key,has_key) $/;"	r
delete_item	hash{vec{key},vec{val}}.foo	/^   delete_item(index) $/;"	r
delete_items	hash{vec{key},vec{val}}.foo	/^   delete_items(list) $/;"	r
index_of_key	hash{vec{key},vec{val}}.foo	/^   index_of_key(key) result (res)$/;"	r
has_key	hash{vec{key},vec{val}}.foo	/^   has_key(key,index) result (res)$/;"	r
value_for_key	hash{vec{key},vec{val}}.foo	/^   value_for_key(key,has_key,index) result (res)$/;"	r
value_for_item	hash{vec{key},vec{val}}.foo	/^   value_for_item(index) result (res)$/;"	r
create	interpolator.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	interpolator.foo	/^   create(spacing,first) ::: leaky$/;"	r
self	interpolator.foo	/^     self :: PTR$/;"	a
spacing	interpolator.foo	/^     spacing :: REAL$/;"	a
first	interpolator.foo	/^     first :: REAL, optional$/;"	a
create_copy	interpolator.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	interpolator.foo	/^   copy(c) ::: leaky$/;"	r
destroy	interpolator.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	interpolator.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	interpolator.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	interpolator.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	interpolator.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	interpolator.foo	/^   set_defaults(spacing,first)$/;"	r
set_interpolation_method	interpolator.foo	/^   set_interpolation_method(method)$/;"	r
set_range_mapping	interpolator.foo	/^   set_range_mapping(method)$/;"	r
set_domain_mapping	interpolator.foo	/^   set_domain_mapping(method)$/;"	r
set_domain_scale_factor	interpolator.foo	/^   set_domain_scale_factor(fac)$/;"	r
set_spacing	interpolator.foo	/^   set_spacing(spacing) ::: leaky$/;"	r
set_table_spacing	interpolator.foo	/^   set_table_spacing(spacing) ::: leaky$/;"	r
set_table_length	interpolator.foo	/^   set_table_length(length)$/;"	r
set_table_origin	interpolator.foo	/^   set_table_origin(origin)$/;"	r
set_table_eps	interpolator.foo	/^   set_table_eps(eps)$/;"	r
first_data_point	interpolator.foo	/^   first_data_point result (res) $/;"	r
last_data_point	interpolator.foo	/^   last_data_point result (res) $/;"	r
last_data_value	interpolator.foo	/^   last_data_value result (res) $/;"	r
read_keywords	interpolator.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	interpolator.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	interpolator.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_interpolation_method	interpolator.foo	/^   read_interpolation_method$/;"	r
read_range_mapping	interpolator.foo	/^   read_range_mapping$/;"	r
read_domain_mapping	interpolator.foo	/^   read_domain_mapping$/;"	r
read_domain_scale_factor	interpolator.foo	/^   read_domain_scale_factor$/;"	r
read_table_length	interpolator.foo	/^   read_table_length$/;"	r
read_table_origin	interpolator.foo	/^   read_table_origin$/;"	r
read_table_eps	interpolator.foo	/^   read_table_eps$/;"	r
read_data_points	interpolator.foo	/^   read_data_points ::: leaky$/;"	r
read_data_values	interpolator.foo	/^   read_data_values ::: leaky$/;"	r
read_spacing	interpolator.foo	/^   read_spacing ::: leaky$/;"	r
read_y1_initial	interpolator.foo	/^   read_y1_initial$/;"	r
read_y1_final	interpolator.foo	/^   read_y1_final$/;"	r
set_data_points	interpolator.foo	/^   set_data_points(points) ::: leaky$/;"	r
set_data_values	interpolator.foo	/^   set_data_values(values) ::: leaky$/;"	r
finalise	interpolator.foo	/^   finalise ::: leaky$/;"	r
set_spline_2nd_derivatives	interpolator.foo	/^   set_spline_2nd_derivatives ::: leaky$/;"	r
y1_initial_set	interpolator.foo	/^   y1_initial_set result (res)$/;"	r
y1_final_set	interpolator.foo	/^   y1_final_set result (res)$/;"	r
set_even_spaced_data	interpolator.foo	/^   set_even_spaced_data(func,tol,length) ::: leaky$/;"	r
set_even_spaced_data	interpolator.foo	/^   set_even_spaced_data(first,spacing,length,func,tol) ::: leaky$/;"	r
the_table_length	interpolator.foo	/^   the_table_length(func,tol) result (p)$/;"	r
set_even_spaced_d_data	interpolator.foo	/^   set_even_spaced_d_data(func) ::: leaky$/;"	r
set_even_spaced_d_data	interpolator.foo	/^   set_even_spaced_d_data(first,spacing,length,func,tol) ::: leaky$/;"	r
set_even_spaced_d2_data	interpolator.foo	/^   set_even_spaced_d2_data(func) ::: leaky$/;"	r
set_even_spaced_d2_data	interpolator.foo	/^   set_even_spaced_d2_data(first,spacing,length,func,tol) ::: leaky$/;"	r
set_data_values	interpolator.foo	/^   set_data_values(func) ::: leaky$/;"	r
set_data_values	interpolator.foo	/^   set_data_values(func_at,pos) ::: leaky$/;"	r
value_for	interpolator.foo	/^   value_for(point) result (res)$/;"	r
value_for_linear	interpolator.foo	/^   value_for_linear(point) result (res)$/;"	r
value_for_spline	interpolator.foo	/^   value_for_spline(point) result (res)$/;"	r
values_for	interpolator.foo	/^   values_for(points,values,fac)$/;"	r
values_for_linear	interpolator.foo	/^   values_for_linear(points,values,fac)$/;"	r
values_for_spline	interpolator.foo	/^   values_for_spline(points,values,fac)$/;"	r
add_values_for	interpolator.foo	/^   add_values_for(points,values,fac)$/;"	r
add_values_for_linear	interpolator.foo	/^   add_values_for_linear(points,values,fac)$/;"	r
add_values_for_spline	interpolator.foo	/^   add_values_for_spline(points,values,fac) $/;"	r
skip_values_for	interpolator.foo	/^   skip_values_for(points) result (res)$/;"	r
put	interpolator.foo	/^   put$/;"	r
put_gnuplot	interpolator.foo	/^   put_gnuplot(do_log10,to_angstrom)$/;"	r
put_gnuplot	interpolator.foo	/^   put_gnuplot(ref,do_log10,to_angstrom)$/;"	r
equals	int.foo	/^   equals(i) result (same) ::: pure$/;"	r
same_as	int.foo	/^   same_as(i) result (same) ::: pure$/;"	r
is_zero	int.foo	/^   is_zero result (res) ::: pure$/;"	r
is_one	int.foo	/^   is_one result (res) ::: pure$/;"	r
is_minus_one	int.foo	/^   is_minus_one result (res) ::: pure$/;"	r
is_even	int.foo	/^   is_even result (res)$/;"	r
is_odd	int.foo	/^   is_odd result (res)$/;"	r
is_in_range	int.foo	/^   is_in_range(range) result (res)$/;"	r
delta	int.foo	/^   delta(j) result (res)$/;"	r
raised_to	int.foo	/^   raised_to(n) result (res)$/;"	r
factorial	int.foo	/^   factorial result (res) ::: always_elemental$/;"	r
double_factorial	int.foo	/^   double_factorial result (res) ::: always_elemental$/;"	r
gamma_plus_half	int.foo	/^   gamma_plus_half result (res) ::: always_elemental$/;"	r
permutation	int.foo	/^   permutation(n) result (res) ::: pure$/;"	r
permutation	int.foo	/^   permutation(n,m) result (res) ::: pure$/;"	r
choose	int.foo	/^   choose(n) result (res) ::: pure$/;"	r
sqrt_permutation	int.foo	/^   sqrt_permutation(n) result (res)$/;"	r
sqrt_permutation	int.foo	/^   sqrt_permutation(n,m) result (res)$/;"	r
triangle	int.foo	/^   triangle result (res) ::: always_pure$/;"	r
triangle_number	int.foo	/^   triangle_number result (res) ::: always_pure$/;"	r
inverse_triangle_number	int.foo	/^   inverse_triangle_number result (res)$/;"	r
hermite_polynomial_coeffs	int.foo	/^   hermite_polynomial_coeffs(normalise) result (res)$/;"	r
legendre_polynomial_coeffs	int.foo	/^   legendre_polynomial_coeffs result (res) ::: always_pure$/;"	r
assoc_legendre_coeffs	int.foo	/^   assoc_legendre_coeffs(m) result (res)$/;"	r
assoc_laguerre_coeffs	int.foo	/^   assoc_laguerre_coeffs(k) result (res) ::: recursive$/;"	r
radial_laguerre_function	int.foo	/^   radial_laguerre_function(l,zeta) result (res) ::: leaky$/;"	r
check_if_one_of	int.foo	/^   check_if_one_of(allowed) result (ok)$/;"	r
bit_set	int.foo	/^   bit_set(pos) result (res)$/;"	r
bit_test	int.foo	/^   bit_test(pos) result (res)$/;"	r
bit_count	int.foo	/^   bit_count result (res)$/;"	r
is_a_prime	int.foo	/^   is_a_prime result (res)$/;"	r
largest_int	int.foo	/^   largest_int result (res)$/;"	r
str_length	int.foo	/^   str_length(spaces) result (res) ::: get_from(INTRINSIC, FMT=>*), pure$/;"	r
bit_string_length	int.foo	/^   bit_string_length(spaces) result (res) ::: get_from(INTRINSIC:str_length, FMT=>"(b22)"), pure$/;"	r
to_str	int.foo	/^   to_str result (string) ::: get_from(INTRINSIC, FMT=>*), pure$/;"	r
to_str	int.foo	/^   to_str(format,left_justify) result (string) ::: get_from(INTRINSIC), pure$/;"	r
to_str	int.foo	/^   to_str(width,left_justify) result (string) ::: get_from(INTRINSIC, STYLE=>I), pure$/;"	r
to_bit_string	int.foo	/^   to_bit_string result (string) ::: get_from(INTRINSIC:to_str, str_length=>bit_string_length, FMT=>"(b22)"), pure$/;"	r
to_bit_string	int.foo	/^   to_bit_string(format,left_justify) result (string) ::: get_from(INTRINSIC:to_str), pure$/;"	r
to_bit_string	int.foo	/^   to_bit_string(width,left_justify) result (string) ::: get_from(INTRINSIC:to_str, STYLE=>I), pure$/;"	r
convert_to	int.foo	/^   convert_to(units)$/;"	r
to_units	int.foo	/^   to_units(units) result (res)$/;"	r
convert_from	int.foo	/^   convert_from(units)$/;"	r
from_units	int.foo	/^   from_units(units) result (res)$/;"	r
str_length	intrinsic.foo	/^   str_length(spaces) result (res) ::: pure$/;"	r
to_str	intrinsic.foo	/^   to_str result (string) ::: pure$/;"	r
to_str	intrinsic.foo	/^   to_str(format,left_justify) result (string) ::: pure$/;"	r
to_str	intrinsic.foo	/^   to_str(width,left_justify) result (string) ::: pure$/;"	r
to_str	intrinsic.foo	/^   to_str(style,width,precision,left_justify) result (string) ::: pure$/;"	r
create	irrep.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	irrep.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	irrep.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	irrep.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	irrep.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	irrep.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	irrep.foo	/^   create_copy(irrep) ::: leaky$/;"	r
copy	irrep.foo	/^   copy(irrep) ::: leaky$/;"	r
create	isosurface.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	isosurface.foo	/^   create(atom) ::: leaky$/;"	r
create_copy	isosurface.foo	/^   create_copy(s) ::: leaky$/;"	r
copy	isosurface.foo	/^   copy(s) ::: leaky$/;"	r
destroy	isosurface.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	isosurface.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	isosurface.foo	/^   destroy_ptr_part ::: leaky$/;"	r
destroy_info_arrays	isosurface.foo	/^   destroy_info_arrays ::: leaky$/;"	r
created	isosurface.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	isosurface.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	isosurface.foo	/^   set_defaults(atom,destroy_atom) ::: leaky$/;"	r
set_atom_defaults	isosurface.foo	/^   set_atom_defaults(atom,destroy_atom) ::: leaky$/;"	r
property_bounds_set	isosurface.foo	/^   property_bounds_set result (res)$/;"	r
surface_property_lb_set	isosurface.foo	/^   surface_property_lb_set result (res)$/;"	r
surface_property_ub_set	isosurface.foo	/^   surface_property_ub_set result (res)$/;"	r
surface_property_ub_abs_set	isosurface.foo	/^   surface_property_ub_abs_set result (res)$/;"	r
surface_point_set	isosurface.foo	/^   surface_point_set result (res)$/;"	r
read_keywords	isosurface.foo	/^   read_keywords ::: get_from(OBJECT), leaky$/;"	r
process_keyword	isosurface.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_CX_output_fingerprint	isosurface.foo	/^   read_CX_output_fingerprint$/;"	r
read_CX_fingerprint_grid	isosurface.foo	/^   read_CX_fingerprint_grid$/;"	r
read_small_hash	isosurface.foo	/^   read_small_hash$/;"	r
read_big_interior	isosurface.foo	/^   read_big_interior$/;"	r
read_cap_ends	isosurface.foo	/^   read_cap_ends$/;"	r
read_suppress_caps	isosurface.foo	/^   read_suppress_caps$/;"	r
read_colour_function	isosurface.foo	/^   read_colour_function$/;"	r
read_iso_value	isosurface.foo	/^   read_iso_value$/;"	r
read_iso_values	isosurface.foo	/^   read_iso_values$/;"	r
read_kind	isosurface.foo	/^   read_kind$/;"	r
read_triangulation_method	isosurface.foo	/^   read_triangulation_method$/;"	r
read_plot_grid	isosurface.foo	/^   read_plot_grid$/;"	r
read_surface_point	isosurface.foo	/^   read_surface_point$/;"	r
read_surface_property	isosurface.foo	/^   read_surface_property$/;"	r
read_surface_property_lb	isosurface.foo	/^   read_surface_property_lb$/;"	r
read_surface_property_ub	isosurface.foo	/^   read_surface_property_ub$/;"	r
read_surface_property_lb_abs	isosurface.foo	/^   read_surface_property_lb_abs$/;"	r
read_surface_property_ub_abs	isosurface.foo	/^   read_surface_property_ub_abs$/;"	r
read_units	isosurface.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_minimum_scan_division	isosurface.foo	/^   read_minimum_scan_division$/;"	r
read_minimum_scan_level	isosurface.foo	/^   read_minimum_scan_level$/;"	r
read_voxel_proximity_factor	isosurface.foo	/^   read_voxel_proximity_factor$/;"	r
is_hirshfeld_surface	isosurface.foo	/^   is_hirshfeld_surface result (res)$/;"	r
surface_label	isosurface.foo	/^   surface_label result (res)$/;"	r
orbital_label	isosurface.foo	/^   orbital_label result (res)$/;"	r
cubify	isosurface.foo	/^   cubify(func) ::: leaky$/;"	r
prepare_grid	isosurface.foo	/^   prepare_grid $/;"	r
capping_number	isosurface.foo	/^   capping_number(x,y,z) result (res)$/;"	r
on_boundary	isosurface.foo	/^   on_boundary(x,y,z) result (res)$/;"	r
cubify_normally	isosurface.foo	/^   cubify_normally(func) ::: leaky, private$/;"	r
set_edge_vertices	isosurface.foo	/^   set_edge_vertices(cap_square)$/;"	r
cap_square	isosurface.foo	/^     cap_square :: CAPPING_SQUARE, INOUT$/;"	a
cubify_recursively	isosurface.foo	/^   cubify_recursively(func) ::: leaky, private$/;"	r
cubify_recursively_this	isosurface.foo	/^   cubify_recursively_this(func) ::: leaky, private$/;"	r
divide_cubes	isosurface.foo	/^   divide_cubes(func,corner_values) ::: recursive, private, leaky$/;"	r
divide_cubes_small_hash	isosurface.foo	/^   divide_cubes_small_hash(func,corner_values) ::: recursive, private, leaky$/;"	r
set_isosurface_info_arrays	isosurface.foo	/^   set_isosurface_info_arrays ::: leaky, private$/;"	r
set_default_cube	isosurface.foo	/^   set_default_cube(cube) ::: private$/;"	r
update_4_slab	isosurface.foo	/^   update_4_slab(p,f,slice,func) ::: private$/;"	r
append_new_face_info	isosurface.foo	/^   append_new_face_info(cube) ::: leaky, private$/;"	r
append_new_cap_info	isosurface.foo	/^   append_new_cap_info(cap_square) ::: leaky, private$/;"	r
rotate_gradients	isosurface.foo	/^   rotate_gradients ::: private$/;"	r
no_of_divisions	isosurface.foo	/^   no_of_divisions(side_length) result (res) ::: private$/;"	r
initialize_eval_f5	isosurface.foo	/^   initialize_eval_f5(eval,f5,f3) ::: private$/;"	r
make_2_cube_of_values	isosurface.foo	/^   make_2_cube_of_values(f,func,p) ::: private$/;"	r
make_3_cube_of_values	isosurface.foo	/^   make_3_cube_of_values(f,func,p,corner_value) ::: private$/;"	r
make_5_cube_of_values	isosurface.foo	/^   make_5_cube_of_values(f,func,p,eval) ::: private$/;"	r
plot_function	isosurface.foo	/^   plot_function(func) ::: leaky$/;"	r
put_connected_area	isosurface.foo	/^   put_connected_area$/;"	r
index_of_nearest_point	isosurface.foo	/^   index_of_nearest_point result (res) $/;"	r
connected_property_area	isosurface.foo	/^   connected_property_area(property,lower,upper) result (res) $/;"	r
connected_property_area	isosurface.foo	/^   connected_property_area(property,lower,upper) result (res) $/;"	r
connected_property_area	isosurface.foo	/^   connected_property_area(property,ind,lower,upper) result (res) $/;"	r
total_area	isosurface.foo	/^   total_area(faces) result (res) $/;"	r
face_area	isosurface.foo	/^   face_area(face) result (res) $/;"	r
face_normal	isosurface.foo	/^   face_normal(face) result (res) $/;"	r
face_midpoint	isosurface.foo	/^   face_midpoint(face) result (res) $/;"	r
average_face_normal	isosurface.foo	/^   average_face_normal(n) result (res) $/;"	r
average_face_gradient	isosurface.foo	/^   average_face_gradient(n) result (res) $/;"	r
point_normal	isosurface.foo	/^   point_normal(n) result (res) $/;"	r
set_area	isosurface.foo	/^   set_area $/;"	r
set_volume	isosurface.foo	/^   set_volume $/;"	r
make_vertex_RMS_curvature	isosurface.foo	/^   make_vertex_RMS_curvature(RMS)$/;"	r
make_vertex_curvedness	isosurface.foo	/^   make_vertex_curvedness(c)$/;"	r
make_vertex_curvedness	isosurface.foo	/^   make_vertex_curvedness(c,k1,k2)$/;"	r
make_vertex_shape_index	isosurface.foo	/^   make_vertex_shape_index(si)$/;"	r
make_vertex_shape_index	isosurface.foo	/^   make_vertex_shape_index(si,k1,k2)$/;"	r
make_vertex_SI_and_curvedness	isosurface.foo	/^   make_vertex_SI_and_curvedness(si,cn)$/;"	r
make_principal_curvatures	isosurface.foo	/^   make_principal_curvatures(k1,k2)$/;"	r
make_vertex_normals	isosurface.foo	/^   make_vertex_normals(normal)$/;"	r
make_average_face_normals	isosurface.foo	/^   make_average_face_normals(normal)$/;"	r
d_min_to	isosurface.foo	/^   d_min_to(list) result (res) ::: leaky$/;"	r
d_norm_to	isosurface.foo	/^   d_norm_to(list) result (res) ::: leaky$/;"	r
make_d_min_d_norm_to	isosurface.foo	/^   make_d_min_d_norm_to(list,atom,d_min,d_norm)$/;"	r
make_fingerprint_distances	isosurface.foo	/^   make_fingerprint_distances(d_e,d_i,d_norm_e,d_norm_i,d_norm,in,out,atom,angstrom)$/;"	r
make_d_min_atoms_to	isosurface.foo	/^   make_d_min_atoms_to(list,d_min_list)$/;"	r
make_d_min_atoms_to_face	isosurface.foo	/^   make_d_min_atoms_to_face(list,d_min_list)$/;"	r
make_fingerprint_atoms	isosurface.foo	/^   make_fingerprint_atoms(d_e_atoms,d_i_atoms,in,out,atom)$/;"	r
make_fingerprint_face_atoms	isosurface.foo	/^   make_fingerprint_face_atoms(d_e_atoms,d_i_atoms,in,out,atom)$/;"	r
merge_with	isosurface.foo	/^   merge_with(other) ::: leaky$/;"	r
put	isosurface.foo	/^   put$/;"	r
put_grid	isosurface.foo	/^   put_grid$/;"	r
put_CX	isosurface.foo	/^   put_CX(in,out,atom,angstrom)$/;"	r
put_points	isosurface.foo	/^   put_points(angstrom)$/;"	r
put_faces	isosurface.foo	/^   put_faces$/;"	r
put_vertex_gradients	isosurface.foo	/^   put_vertex_gradients$/;"	r
put_vertex_normals	isosurface.foo	/^   put_vertex_normals$/;"	r
put_face_normals	isosurface.foo	/^   put_face_normals$/;"	r
put_fingerprint_properties	isosurface.foo	/^   put_fingerprint_properties(in,out,atom,angstrom)$/;"	r
put_fingerprint_atoms	isosurface.foo	/^   put_fingerprint_atoms(in,out,atom)$/;"	r
put_fingerprint_face_atoms	isosurface.foo	/^   put_fingerprint_face_atoms(in,out,atom)$/;"	r
put_vertex_SI_and_curvedness	isosurface.foo	/^   put_vertex_SI_and_curvedness$/;"	r
put_surface_property_values	isosurface.foo	/^   put_surface_property_values$/;"	r
put_surface_iso_values	isosurface.foo	/^   put_surface_iso_values$/;"	r
put_surface_iso_values	isosurface.foo	/^   put_surface_iso_values(label)$/;"	r
put_vertex_mean_curvatures	isosurface.foo	/^   put_vertex_mean_curvatures$/;"	r
put_vertex_gaussian_curvatures	isosurface.foo	/^   put_vertex_gaussian_curvatures$/;"	r
put_vertex_RMS_curvature	isosurface.foo	/^   put_vertex_RMS_curvature$/;"	r
put_vertex_property	isosurface.foo	/^   put_vertex_property(prop,prop_name,n_size) ::: template$/;"	r
put_vertex_property	isosurface.foo	/^   put_vertex_property(prop,prop_name,n_size) ::: get_from(ISOSURFACE, TYPE=>VEC{INT}, PROP=>prop)$/;"	r
put_vertex_property	isosurface.foo	/^   put_vertex_property(prop,prop_name,n_size) ::: get_from(ISOSURFACE, TYPE=>VEC{REAL}, PROP=>prop)$/;"	r
put_vertex_property	isosurface.foo	/^   put_vertex_property(prop,prop_name,n_size) ::: get_from(ISOSURFACE, TYPE=>MAT{INT}, PROP=>prop,transpose=TRUE)$/;"	r
put_vertex_property	isosurface.foo	/^   put_vertex_property(prop,prop_name,n_size) ::: get_from(ISOSURFACE, TYPE=>MAT{REAL}, PROP=>prop,transpose=TRUE)$/;"	r
put_2_vertex_properties	isosurface.foo	/^   put_2_vertex_properties(prop1,prop2,prop_name,n_size1,n_size2)$/;"	r
put_d_e_colors	isosurface.foo	/^   put_d_e_colors(out)$/;"	r
put_d_i_colors	isosurface.foo	/^   put_d_i_colors(in)$/;"	r
put_binned_d_i_d_e	isosurface.foo	/^   put_binned_d_i_d_e(in,out)$/;"	r
put_binned_d_i_d_e_RGBs	isosurface.foo	/^   put_binned_d_i_d_e_RGBs(in,out)$/;"	r
put_d_i_d_e_RGBs	isosurface.foo	/^   put_d_i_d_e_RGBs(in,out)$/;"	r
put_vrml	isosurface.foo	/^   put_vrml(out)$/;"	r
test_cubify	isosurface.foo	/^   test_cubify$/;"	r
test_func	isosurface.foo	/^   test_func(res,pt) ::: selfless$/;"	r
create	lebedev.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	lebedev.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	lebedev.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	lebedev.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	lebedev.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	lebedev.foo	/^   copy(l) ::: leaky$/;"	r
nullify_ptr_part	lebedev.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	lebedev.foo	/^   destroy_ptr_part  ::: leaky$/;"	r
set_defaults	lebedev.foo	/^   set_defaults$/;"	r
set_n_points	lebedev.foo	/^   set_n_points(n_points) ::: leaky$/;"	r
set_l	lebedev.foo	/^   set_l(l) ::: leaky$/;"	r
set	lebedev.foo	/^   set(n_points,n_shell) ::: private, leaky$/;"	r
gen_oh	lebedev.foo	/^   gen_oh(code,a,b,w) ::: private$/;"	r
ld0006	lebedev.foo	/^   ld0006 ::: leaky$/;"	r
ld0014	lebedev.foo	/^   ld0014 ::: leaky$/;"	r
ld0026	lebedev.foo	/^   ld0026 ::: leaky$/;"	r
ld0038	lebedev.foo	/^   ld0038 ::: leaky$/;"	r
ld0050	lebedev.foo	/^   ld0050 ::: leaky$/;"	r
ld0074	lebedev.foo	/^   ld0074 ::: leaky$/;"	r
ld0086	lebedev.foo	/^   ld0086 ::: leaky$/;"	r
ld0110	lebedev.foo	/^   ld0110 ::: leaky$/;"	r
ld0146	lebedev.foo	/^   ld0146 ::: leaky$/;"	r
ld0170	lebedev.foo	/^   ld0170 ::: leaky$/;"	r
ld0194	lebedev.foo	/^   ld0194 ::: leaky$/;"	r
ld0230	lebedev.foo	/^   ld0230 ::: leaky$/;"	r
ld0266	lebedev.foo	/^   ld0266 ::: leaky$/;"	r
ld0302	lebedev.foo	/^   ld0302 ::: leaky$/;"	r
ld0350	lebedev.foo	/^   ld0350 ::: leaky$/;"	r
ld0434	lebedev.foo	/^   ld0434 ::: leaky$/;"	r
ta0434	lebedev.foo	/^   ta0434 ::: leaky$/;"	r
ld0590	lebedev.foo	/^   ld0590 ::: leaky$/;"	r
ld0770	lebedev.foo	/^   ld0770 ::: leaky$/;"	r
ld0974	lebedev.foo	/^   ld0974 ::: leaky$/;"	r
ld1202	lebedev.foo	/^   ld1202 ::: leaky$/;"	r
ld1454	lebedev.foo	/^   ld1454 ::: leaky$/;"	r
ld1730	lebedev.foo	/^   ld1730 ::: leaky$/;"	r
ld2030	lebedev.foo	/^   ld2030 ::: leaky$/;"	r
ld2354	lebedev.foo	/^   ld2354 ::: leaky$/;"	r
ld2702	lebedev.foo	/^   ld2702 ::: leaky$/;"	r
ld3074	lebedev.foo	/^   ld3074 ::: leaky$/;"	r
ld3470	lebedev.foo	/^   ld3470 ::: leaky$/;"	r
ld3890	lebedev.foo	/^   ld3890 ::: leaky$/;"	r
ld4334	lebedev.foo	/^   ld4334 ::: leaky$/;"	r
ld4802	lebedev.foo	/^   ld4802 ::: leaky$/;"	r
ld5294	lebedev.foo	/^   ld5294 ::: leaky$/;"	r
ld5810	lebedev.foo	/^   ld5810 ::: leaky$/;"	r
n_fail	marchingcube.foo	/^   n_fail :: INT, save, private = 0$/;"	g
once	marchingcube.foo	/^   once   :: INT, save, private = 0$/;"	g
vertices_of_face	marchingcube.foo	/^   vertices_of_face :: MAT{INT}(1:4,1:6), private$/;"	g
edges_of_face	marchingcube.foo	/^   edges_of_face :: MAT{INT}(1:4,1:6), private$/;"	g
cube	marchingcube.foo	/^   cube :: MAT{INT}(1:3,0:7), private$/;"	g
tube	marchingcube.foo	/^   tube :: MAT{INT}(0:7,1:3), private$/;"	g
vertex_1_of_edge	marchingcube.foo	/^   vertex_1_of_edge :: VEC{INT}(0:11), private$/;"	g
vertex_2_of_edge	marchingcube.foo	/^   vertex_2_of_edge :: VEC{INT}(0:11), private$/;"	g
xyz_axis_of_edge	marchingcube.foo	/^   xyz_axis_of_edge :: VEC{INT}(0:11), private$/;"	g
edge_table	marchingcube.foo	/^   edge_table :: VEC{INT}(0:255), private $/;"	g
triangle_table	marchingcube.foo	/^   triangle_table :: MAT{INT}(0:15,0:255), private$/;"	g
create	marchingcube.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create_copy	marchingcube.foo	/^   create_copy(s) ::: leaky$/;"	r
copy	marchingcube.foo	/^   copy(s) ::: leaky$/;"	r
destroy	marchingcube.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	marchingcube.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	marchingcube.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	marchingcube.foo	/^   set_defaults ::: leaky$/;"	r
reset	marchingcube.foo	/^   reset ::: leaky$/;"	r
read_keywords	marchingcube.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	marchingcube.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	marchingcube.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_accuracy	marchingcube.foo	/^   read_accuracy$/;"	r
read_interior_is_big	marchingcube.foo	/^   read_interior_is_big$/;"	r
read_iso_value	marchingcube.foo	/^   read_iso_value$/;"	r
set_axes	marchingcube.foo	/^   set_axes(axes)$/;"	r
set_vertex_info	marchingcube.foo	/^   set_vertex_info(p,f)  $/;"	r
set_vertex_info3	marchingcube.foo	/^   set_vertex_info3(p,f,ox,oy,oz) ::: public$/;"	r
set_vertex_info	marchingcube.foo	/^   set_vertex_info(p,f,g)  $/;"	r
set_vertex_info	marchingcube.foo	/^   set_vertex_info(p,f,g,h)  $/;"	r
set_gradient_info	marchingcube.foo	/^   set_gradient_info(f)  $/;"	r
set_hessian_info	marchingcube.foo	/^   set_hessian_info(f)  $/;"	r
set_hessian_info5	marchingcube.foo	/^   set_hessian_info5(f,ox,oy,oz) ::: public$/;"	r
set_hessian_eval_array	marchingcube.foo	/^   set_hessian_eval_array(eval,ox,oy,oz) ::: public$/;"	r
set_gradient_eval_array	marchingcube.foo	/^   set_gradient_eval_array(eval,ox,oy,oz) ::: public$/;"	r
set_vertex_and_gradient_info	marchingcube.foo	/^   set_vertex_and_gradient_info(p,f)  $/;"	r
set_n_pt	marchingcube.foo	/^   set_n_pt(n)$/;"	r
set_iso_value	marchingcube.foo	/^   set_iso_value(iso_value)$/;"	r
set_side_length	marchingcube.foo	/^   set_side_length(length)$/;"	r
set_side_length	marchingcube.foo	/^   set_side_length(x_length,y_length,z_length)$/;"	r
set_accuracy	marchingcube.foo	/^   set_accuracy(accuracy)$/;"	r
set_big_interior	marchingcube.foo	/^   set_big_interior(big_interior)$/;"	r
set_case_info	marchingcube.foo	/^   set_case_info $/;"	r
set_triangulation_info	marchingcube.foo	/^   set_triangulation_info ::: leaky$/;"	r
set_left_info	marchingcube.foo	/^   set_left_info(left) $/;"	r
set_front_info	marchingcube.foo	/^   set_front_info(front) $/;"	r
set_below_info	marchingcube.foo	/^   set_below_info(below) $/;"	r
set_left_skip_bit_string	marchingcube.foo	/^   set_left_skip_bit_string$/;"	r
set_front_skip_bit_string	marchingcube.foo	/^   set_front_skip_bit_string $/;"	r
set_below_skip_bit_string	marchingcube.foo	/^   set_below_skip_bit_string $/;"	r
set_edge_bit_string	marchingcube.foo	/^   set_edge_bit_string $/;"	r
set_left_face_edges	marchingcube.foo	/^   set_left_face_edges$/;"	r
set_right_face_edges	marchingcube.foo	/^   set_right_face_edges$/;"	r
set_front_face_edges	marchingcube.foo	/^   set_front_face_edges$/;"	r
set_back_face_edges	marchingcube.foo	/^   set_back_face_edges$/;"	r
set_below_face_edges	marchingcube.foo	/^   set_below_face_edges$/;"	r
set_top_face_edges	marchingcube.foo	/^   set_top_face_edges$/;"	r
set_cube_bit_string	marchingcube.foo	/^   set_cube_bit_string $/;"	r
no_of_triangles	marchingcube.foo	/^   no_of_triangles(case) result (res)$/;"	r
no_of_edges	marchingcube.foo	/^   no_of_edges result (res)$/;"	r
no_of_active_edges	marchingcube.foo	/^   no_of_active_edges result (res)$/;"	r
get_edge_vertex_positions	marchingcube.foo	/^   get_edge_vertex_positions(pos) $/;"	r
get_edge_vertex_gradients	marchingcube.foo	/^   get_edge_vertex_gradients(g) $/;"	r
get_edge_mean_curvatures	marchingcube.foo	/^   get_edge_mean_curvatures(c) $/;"	r
get_edge_gaussian_curvatures	marchingcube.foo	/^   get_edge_gaussian_curvatures(c) $/;"	r
get_triangle_vertex_indices	marchingcube.foo	/^   get_triangle_vertex_indices(ind) $/;"	r
set_capping_square	marchingcube.foo	/^   set_capping_square(face_number, cappingsquare)$/;"	r
interpolate_faces	marchingcube.foo	/^   interpolate_faces$/;"	r
interpolate_edge_info	marchingcube.foo	/^   interpolate_edge_info ::: private$/;"	r
set_triangle_vertex_info	marchingcube.foo	/^   set_triangle_vertex_info ::: private$/;"	r
interpolate_oblique_faces	marchingcube.foo	/^   interpolate_oblique_faces$/;"	r
interpolate_oblique_edge_info	marchingcube.foo	/^   interpolate_oblique_edge_info ::: private$/;"	r
triangulate	marchingcube.foo	/^   triangulate(below,left,front) ::: leaky$/;"	r
set_skip_bit_string	marchingcube.foo	/^   set_skip_bit_string(below,left,front) $/;"	r
set_edge_vertex_info	marchingcube.foo	/^   set_edge_vertex_info(below,left,front)$/;"	r
case_number	marchingcube.foo	/^   case_number result (res)$/;"	r
case_number	marchingcube.foo	/^   case_number(iso_value) result (res)$/;"	r
case_number	marchingcube.foo	/^   case_number(edge_bit_string) result (res)$/;"	r
is_on_surface	marchingcube.foo	/^   is_on_surface result (res)$/;"	r
is_outside_surface	marchingcube.foo	/^   is_outside_surface result (res)$/;"	r
is_inside_surface	marchingcube.foo	/^   is_inside_surface result (res)$/;"	r
is_nearly_on_surface	marchingcube.foo	/^   is_nearly_on_surface(tol) result (res)$/;"	r
is_nearly_on_surface_old	marchingcube.foo	/^   is_nearly_on_surface_old(tol) result (res)$/;"	r
has_left_face_on_surface	marchingcube.foo	/^   has_left_face_on_surface result (res)$/;"	r
has_front_face_on_surface	marchingcube.foo	/^   has_front_face_on_surface result (res)$/;"	r
has_lower_face_on_surface	marchingcube.foo	/^   has_lower_face_on_surface result (res)$/;"	r
has_right_face_on_surface	marchingcube.foo	/^   has_right_face_on_surface result (res)$/;"	r
has_back_face_on_surface	marchingcube.foo	/^   has_back_face_on_surface result (res)$/;"	r
has_upper_face_on_surface	marchingcube.foo	/^   has_upper_face_on_surface result (res)$/;"	r
has_reusable_edge_vertices	marchingcube.foo	/^   has_reusable_edge_vertices result (res)$/;"	r
put	marchingcube.foo	/^   put(output)$/;"	r
put_bitmask_info	marchingcube.foo	/^   put_bitmask_info(output)$/;"	r
put_vertex_index_info	marchingcube.foo	/^   put_vertex_index_info(output)$/;"	r
put_positional_info	marchingcube.foo	/^   put_positional_info(output)$/;"	r
create	mat3{bin}.foo	/^   create(dim1,dim2,dim3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{bin}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{bin}.foo	/^   create(bounds1,bounds2,bounds3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{bin}.foo	/^   create(bounds) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create_copy	mat3{bin}.foo	/^   create_copy(c) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
destroy	mat3{bin}.foo	/^   destroy ::: get_from(MAT3{INTRINSIC})$/;"	r
created	mat3{bin}.foo	/^   created result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat3{bin}.foo	/^   destroyed result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
size	mat3{bin}.foo	/^   size result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat3{bin}.foo	/^   dim1 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat3{bin}.foo	/^   dim2 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim3	mat3{bin}.foo	/^   dim3 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat3{bin}.foo	/^   shape result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
is_same_shape_as	mat3{bin}.foo	/^   is_same_shape_as(b) result (res)  ::: get_from(MAT3{INTRINSIC})$/;"	r
set_to	mat3{bin}.foo	/^   set_to(b) ::: get_from(MAT3{INTRINSIC})$/;"	r
set_to	mat3{bin}.foo	/^   set_to(b) ::: get_from(MAT3{INTRINSIC})$/;"	r
create	mat3{cpx}.foo	/^   create(dim1,dim2,dim3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{cpx}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{cpx}.foo	/^   create(bounds1,bounds2,bounds3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{cpx}.foo	/^   create(bounds) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create_copy	mat3{cpx}.foo	/^   create_copy(c) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
destroy	mat3{cpx}.foo	/^   destroy ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
created	mat3{cpx}.foo	/^   created result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat3{cpx}.foo	/^   destroyed result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
size	mat3{cpx}.foo	/^   size result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat3{cpx}.foo	/^   dim1 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat3{cpx}.foo	/^   dim2 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim3	mat3{cpx}.foo	/^   dim3 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat3{cpx}.foo	/^   shape result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
is_same_shape_as	mat3{cpx}.foo	/^   is_same_shape_as(b) result (res)  ::: get_from(MAT3{INTRINSIC})$/;"	r
set_to	mat3{cpx}.foo	/^   set_to(b) ::: get_from(MAT3{INTRINSIC})$/;"	r
set_to	mat3{cpx}.foo	/^   set_to(b) ::: get_from(MAT3{INTRINSIC})$/;"	r
create	mat3{int}.foo	/^   create(dim1,dim2,dim3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{int}.foo	/^   create(dim) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{int}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{int}.foo	/^   create(bounds1,bounds2,bounds3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{int}.foo	/^   create(bounds) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create_copy	mat3{int}.foo	/^   create_copy(c) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
destroy	mat3{int}.foo	/^   destroy ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
created	mat3{int}.foo	/^   created result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat3{int}.foo	/^   destroyed result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
size	mat3{int}.foo	/^   size result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat3{int}.foo	/^   dim1 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat3{int}.foo	/^   dim2 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim3	mat3{int}.foo	/^   dim3 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat3{int}.foo	/^   shape result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
is_same_shape_as	mat3{int}.foo	/^   is_same_shape_as(b) result (res)  ::: get_from(MAT3{INTRINSIC})$/;"	r
set_to	mat3{int}.foo	/^   set_to(b) ::: get_from(MAT3{INTRINSIC})$/;"	r
set_to	mat3{int}.foo	/^   set_to(b) ::: get_from(MAT3{INTRINSIC})$/;"	r
create	mat3{intrinsic}.foo	/^   create(dim1,dim2,dim3) ::: leaky$/;"	r
create	mat3{intrinsic}.foo	/^   create(dim) ::: leaky$/;"	r
create	mat3{intrinsic}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3) ::: leaky$/;"	r
create	mat3{intrinsic}.foo	/^   create(bounds1,bounds2,bounds3) ::: leaky$/;"	r
create	mat3{intrinsic}.foo	/^   create(bounds) ::: leaky$/;"	r
create_copy	mat3{intrinsic}.foo	/^   create_copy(c) ::: leaky$/;"	r
destroy	mat3{intrinsic}.foo	/^   destroy ::: leaky$/;"	r
created	mat3{intrinsic}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	mat3{intrinsic}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
size	mat3{intrinsic}.foo	/^   size result (res) ::: inlined_by_foo$/;"	r
dim1	mat3{intrinsic}.foo	/^   dim1 result (res) ::: inlined_by_foo$/;"	r
dim2	mat3{intrinsic}.foo	/^   dim2 result (res) ::: inlined_by_foo$/;"	r
dim3	mat3{intrinsic}.foo	/^   dim3 result (res) ::: inlined_by_foo$/;"	r
shape	mat3{intrinsic}.foo	/^   shape result (res)$/;"	r
is_same_shape_as	mat3{intrinsic}.foo	/^   is_same_shape_as(b) result (res) $/;"	r
is_cube	mat3{intrinsic}.foo	/^   is_cube result (res) $/;"	r
set_to	mat3{intrinsic}.foo	/^   set_to(b)$/;"	r
set_to	mat3{intrinsic}.foo	/^   set_to(b)$/;"	r
set_to_reverse_of	mat3{intrinsic}.foo	/^   set_to_reverse_of(b)$/;"	r
change_basis_using	mat3{intrinsic}.foo	/^   change_basis_using(V)$/;"	r
change_basis_to	mat3{intrinsic}.foo	/^   change_basis_to(new,V)$/;"	r
back_transform_using	mat3{intrinsic}.foo	/^   back_transform_using(V)$/;"	r
back_transform_to	mat3{intrinsic}.foo	/^   back_transform_to(new,V)$/;"	r
create	mat3{real}.foo	/^   create(dim1,dim2,dim3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{real}.foo	/^   create(dim) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{real}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{real}.foo	/^   create(bounds1,bounds2,bounds3) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create	mat3{real}.foo	/^   create(bounds) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
create_copy	mat3{real}.foo	/^   create_copy(c) ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
destroy	mat3{real}.foo	/^   destroy ::: get_from(MAT3{INTRINSIC}), leaky$/;"	r
created	mat3{real}.foo	/^   created result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat3{real}.foo	/^   destroyed result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
size	mat3{real}.foo	/^   size result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat3{real}.foo	/^   dim1 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat3{real}.foo	/^   dim2 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim3	mat3{real}.foo	/^   dim3 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat3{real}.foo	/^   shape result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
is_same_shape_as	mat3{real}.foo	/^   is_same_shape_as(b) result (res)  ::: get_from(MAT3{INTRINSIC})$/;"	r
is_cube	mat3{real}.foo	/^   is_cube result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
is_square_23	mat3{real}.foo	/^   is_square_23 result (res)$/;"	r
set_to	mat3{real}.foo	/^   set_to(b) ::: get_from(MAT3{INTRINSIC})$/;"	r
set_to	mat3{real}.foo	/^   set_to(b) ::: get_from(MAT3{INTRINSIC})$/;"	r
make_symmetric	mat3{real}.foo	/^   make_symmetric$/;"	r
transpose_12	mat3{real}.foo	/^   transpose_12$/;"	r
symmetric_reflect_12	mat3{real}.foo	/^   symmetric_reflect_12$/;"	r
symmetric_reflect_23	mat3{real}.foo	/^   symmetric_reflect_23$/;"	r
to_tri_23	mat3{real}.foo	/^   to_tri_23(tr)$/;"	r
from_tri_23	mat3{real}.foo	/^   from_tri_23(tr)$/;"	r
tri_size_23	mat3{real}.foo	/^   tri_size_23 result (ltr)$/;"	r
dot	mat3{real}.foo	/^   dot(a) result (res) $/;"	r
gaussian_d_xyz_matrices	mat3{real}.foo	/^   gaussian_d_xyz_matrices result (dtr) ::: leaky$/;"	r
gaussian_f_xyz_matrices	mat3{real}.foo	/^   gaussian_f_xyz_matrices result (ftr) ::: leaky$/;"	r
gaussian_g_xyz_matrices	mat3{real}.foo	/^   gaussian_g_xyz_matrices result (gtr) ::: leaky$/;"	r
trace_over_indices	mat3{real}.foo	/^   trace_over_indices(d1,d2,T)$/;"	r
similarity_transform_12	mat3{real}.foo	/^   similarity_transform_12(V)$/;"	r
change_basis_using	mat3{real}.foo	/^   change_basis_using(V) ::: get_from(MAT3{INTRINSIC})$/;"	r
change_basis_to	mat3{real}.foo	/^   change_basis_to(new,V) ::: get_from(MAT3{INTRINSIC})$/;"	r
set_vector_hyperpolarisability	mat3{real}.foo	/^   set_vector_hyperpolarisability(beta)$/;"	r
create	mat3{vec_{bin}}.foo	/^   create(dim1,dim2,dim3) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{bin}}.foo	/^   create(dim) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{bin}}.foo	/^   create(dim1,dim2,dim3,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{bin}}.foo	/^   create(dim1,dim2,dim3,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{bin}}.foo	/^   create(dim,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{bin}}.foo	/^   create(dim,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	mat3{vec_{bin}}.foo	/^   create_vec(dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	mat3{vec_{bin}}.foo	/^   create_vec(dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create_copy	mat3{vec_{bin}}.foo	/^   create_copy(v) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
copy	mat3{vec_{bin}}.foo	/^   copy(v) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
destroy	mat3{vec_{bin}}.foo	/^   destroy ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	mat3{vec_{bin}}.foo	/^   nullify_ptr_part ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
destroy_ptr_part	mat3{vec_{bin}}.foo	/^   destroy_ptr_part ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
created	mat3{vec_{bin}}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	mat3{vec_{bin}}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
set_to	mat3{vec_{bin}}.foo	/^   set_to(v) ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
zero	mat3{vec_{bin}}.foo	/^   zero ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
size	mat3{vec_{bin}}.foo	/^   size result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat3{vec_{bin}}.foo	/^   dim1 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
dim2	mat3{vec_{bin}}.foo	/^   dim2 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
dim3	mat3{vec_{bin}}.foo	/^   dim3 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
shape	mat3{vec_{bin}}.foo	/^   shape result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
is_same_shape_as	mat3{vec_{bin}}.foo	/^   is_same_shape_as(b) result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
create	mat3{vec_{int}}.foo	/^   create(dim1,dim2,dim3) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{int}}.foo	/^   create(dim) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{int}}.foo	/^   create(dim1,dim2,dim3,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{int}}.foo	/^   create(dim1,dim2,dim3,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{int}}.foo	/^   create(dim,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{int}}.foo	/^   create(dim,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	mat3{vec_{int}}.foo	/^   create_vec(dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	mat3{vec_{int}}.foo	/^   create_vec(dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create_copy	mat3{vec_{int}}.foo	/^   create_copy(v) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
copy	mat3{vec_{int}}.foo	/^   copy(v) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
destroy	mat3{vec_{int}}.foo	/^   destroy ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	mat3{vec_{int}}.foo	/^   nullify_ptr_part ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
destroy_ptr_part	mat3{vec_{int}}.foo	/^   destroy_ptr_part ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
created	mat3{vec_{int}}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	mat3{vec_{int}}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
set_to	mat3{vec_{int}}.foo	/^   set_to(v) ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
zero	mat3{vec_{int}}.foo	/^   zero ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
size	mat3{vec_{int}}.foo	/^   size result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat3{vec_{int}}.foo	/^   dim1 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
dim2	mat3{vec_{int}}.foo	/^   dim2 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
dim3	mat3{vec_{int}}.foo	/^   dim3 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
shape	mat3{vec_{int}}.foo	/^   shape result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
is_same_shape_as	mat3{vec_{int}}.foo	/^   is_same_shape_as(b) result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
create	mat3{vec_{intrinsic}}.foo	/^   create(dim1,dim2,dim3) ::: leaky$/;"	r
create	mat3{vec_{intrinsic}}.foo	/^   create(dim) ::: leaky$/;"	r
create	mat3{vec_{intrinsic}}.foo	/^   create(dim1,dim2,dim3,dimv) ::: leaky$/;"	r
create	mat3{vec_{intrinsic}}.foo	/^   create(dim1,dim2,dim3,dimv) ::: leaky$/;"	r
create	mat3{vec_{intrinsic}}.foo	/^   create(dim,dimv) ::: leaky$/;"	r
create	mat3{vec_{intrinsic}}.foo	/^   create(dim,dimv) ::: leaky$/;"	r
create_vec	mat3{vec_{intrinsic}}.foo	/^   create_vec(dimv) ::: leaky$/;"	r
create_vec	mat3{vec_{intrinsic}}.foo	/^   create_vec(dimv) ::: leaky$/;"	r
create_copy	mat3{vec_{intrinsic}}.foo	/^   create_copy(v) ::: leaky$/;"	r
copy	mat3{vec_{intrinsic}}.foo	/^   copy(v) ::: leaky$/;"	r
destroy	mat3{vec_{intrinsic}}.foo	/^   destroy ::: leaky$/;"	r
nullify_ptr_part	mat3{vec_{intrinsic}}.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	mat3{vec_{intrinsic}}.foo	/^   destroy_ptr_part$/;"	r
created	mat3{vec_{intrinsic}}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	mat3{vec_{intrinsic}}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
set_to	mat3{vec_{intrinsic}}.foo	/^   set_to(v)$/;"	r
zero	mat3{vec_{intrinsic}}.foo	/^   zero$/;"	r
size	mat3{vec_{intrinsic}}.foo	/^   size result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat3{vec_{intrinsic}}.foo	/^   dim1 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
dim2	mat3{vec_{intrinsic}}.foo	/^   dim2 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
dim3	mat3{vec_{intrinsic}}.foo	/^   dim3 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
shape	mat3{vec_{intrinsic}}.foo	/^   shape result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
is_same_shape_as	mat3{vec_{intrinsic}}.foo	/^   is_same_shape_as(b) result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
create	mat3{vec_{real}}.foo	/^   create(dim1,dim2,dim3) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{real}}.foo	/^   create(dim) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{real}}.foo	/^   create(dim1,dim2,dim3,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{real}}.foo	/^   create(dim1,dim2,dim3,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{real}}.foo	/^   create(dim,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create	mat3{vec_{real}}.foo	/^   create(dim,dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	mat3{vec_{real}}.foo	/^   create_vec(dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	mat3{vec_{real}}.foo	/^   create_vec(dimv) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
create_copy	mat3{vec_{real}}.foo	/^   create_copy(v) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
copy	mat3{vec_{real}}.foo	/^   copy(v) ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
destroy	mat3{vec_{real}}.foo	/^   destroy ::: get_from(MAT3{VEC_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	mat3{vec_{real}}.foo	/^   nullify_ptr_part ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
destroy_ptr_part	mat3{vec_{real}}.foo	/^   destroy_ptr_part ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
created	mat3{vec_{real}}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	mat3{vec_{real}}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
set_to	mat3{vec_{real}}.foo	/^   set_to(v) ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
zero	mat3{vec_{real}}.foo	/^   zero ::: get_from(MAT3{VEC_{INTRINSIC}})$/;"	r
size	mat3{vec_{real}}.foo	/^   size result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat3{vec_{real}}.foo	/^   dim1 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
dim2	mat3{vec_{real}}.foo	/^   dim2 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
dim3	mat3{vec_{real}}.foo	/^   dim3 result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
shape	mat3{vec_{real}}.foo	/^   shape result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
is_same_shape_as	mat3{vec_{real}}.foo	/^   is_same_shape_as(b) result (res) ::: get_from(MAT3{INTRINSIC})$/;"	r
create	mat4{cpx}.foo	/^   create(dim1,dim2,dim3,dim4) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{cpx}.foo	/^   create(bounds) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{cpx}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{cpx}.foo	/^   create(bounds1,bounds2,bounds3,bounds4) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{cpx}.foo	/^   create(bounds) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create_copy	mat4{cpx}.foo	/^   create_copy(c) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
destroy	mat4{cpx}.foo	/^   destroy ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
created	mat4{cpx}.foo	/^   created result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat4{cpx}.foo	/^   destroyed result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
size	mat4{cpx}.foo	/^   size result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat4{cpx}.foo	/^   dim1 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat4{cpx}.foo	/^   dim2 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim3	mat4{cpx}.foo	/^   dim3 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim4	mat4{cpx}.foo	/^   dim4 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat4{cpx}.foo	/^   shape result (res) ::: get_from(MAT4{INTRINSIC})$/;"	r
is_same_shape_as	mat4{cpx}.foo	/^   is_same_shape_as(b) result (res)  ::: get_from(MAT4{INTRINSIC})$/;"	r
set_to	mat4{cpx}.foo	/^   set_to(b) ::: get_from(MAT4{INTRINSIC})$/;"	r
set_to	mat4{cpx}.foo	/^   set_to(b) ::: get_from(MAT4{INTRINSIC})$/;"	r
create	mat4{int}.foo	/^   create(dim1,dim2,dim3,dim4) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{int}.foo	/^   create(bounds) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{int}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{int}.foo	/^   create(bounds1,bounds2,bounds3,bounds4) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{int}.foo	/^   create(bounds) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create_copy	mat4{int}.foo	/^   create_copy(c) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
destroy	mat4{int}.foo	/^   destroy ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
created	mat4{int}.foo	/^   created result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat4{int}.foo	/^   destroyed result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
size	mat4{int}.foo	/^   size result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat4{int}.foo	/^   dim1 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat4{int}.foo	/^   dim2 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim3	mat4{int}.foo	/^   dim3 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim4	mat4{int}.foo	/^   dim4 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat4{int}.foo	/^   shape result (res) ::: get_from(MAT4{INTRINSIC})$/;"	r
is_same_shape_as	mat4{int}.foo	/^   is_same_shape_as(b) result (res)  ::: get_from(MAT4{INTRINSIC})$/;"	r
set_to	mat4{int}.foo	/^   set_to(b) ::: get_from(MAT4{INTRINSIC})$/;"	r
set_to	mat4{int}.foo	/^   set_to(b) ::: get_from(MAT4{INTRINSIC})$/;"	r
create	mat4{intrinsic}.foo	/^   create(dim1,dim2,dim3,dim4) ::: leaky$/;"	r
create	mat4{intrinsic}.foo	/^   create(bounds) ::: leaky$/;"	r
create	mat4{intrinsic}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4) ::: leaky$/;"	r
create	mat4{intrinsic}.foo	/^   create(bounds1,bounds2,bounds3,bounds4) ::: leaky$/;"	r
create	mat4{intrinsic}.foo	/^   create(bounds) ::: leaky$/;"	r
create_copy	mat4{intrinsic}.foo	/^   create_copy(c) ::: leaky$/;"	r
destroy	mat4{intrinsic}.foo	/^   destroy ::: leaky$/;"	r
created	mat4{intrinsic}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	mat4{intrinsic}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
size	mat4{intrinsic}.foo	/^   size result (res) ::: inlined_by_foo$/;"	r
dim1	mat4{intrinsic}.foo	/^   dim1 result (res) ::: inlined_by_foo$/;"	r
dim2	mat4{intrinsic}.foo	/^   dim2 result (res) ::: inlined_by_foo$/;"	r
dim3	mat4{intrinsic}.foo	/^   dim3 result (res) ::: inlined_by_foo$/;"	r
dim4	mat4{intrinsic}.foo	/^   dim4 result (res) ::: inlined_by_foo$/;"	r
shape	mat4{intrinsic}.foo	/^   shape result (res)$/;"	r
is_same_shape_as	mat4{intrinsic}.foo	/^   is_same_shape_as(b) result (res) $/;"	r
set_to	mat4{intrinsic}.foo	/^   set_to(b)$/;"	r
set_to	mat4{intrinsic}.foo	/^   set_to(b)$/;"	r
create	mat4{object}.foo	/^   create(dim1,dim2,dim3,dim4) ::: leaky$/;"	r
create	mat4{object}.foo	/^   create(dim1,dim2,dim3,dim4) ::: leaky$/;"	r
create	mat4{object}.foo	/^   create(bounds) ::: leaky$/;"	r
create	mat4{object}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4) ::: leaky$/;"	r
create	mat4{object}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4) ::: leaky$/;"	r
create	mat4{object}.foo	/^   create(bounds1,bounds2,bounds3,bounds4) ::: leaky$/;"	r
create	mat4{object}.foo	/^   create(bounds) ::: leaky$/;"	r
create_copy	mat4{object}.foo	/^   create_copy(c) ::: leaky$/;"	r
destroy	mat4{object}.foo	/^   destroy ::: leaky$/;"	r
nullify_ptr_part	mat4{object}.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	mat4{object}.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	mat4{object}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	mat4{object}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
size	mat4{object}.foo	/^   size result (res) ::: inlined_by_foo$/;"	r
dim1	mat4{object}.foo	/^   dim1 result (res) ::: inlined_by_foo$/;"	r
dim2	mat4{object}.foo	/^   dim2 result (res) ::: inlined_by_foo$/;"	r
dim3	mat4{object}.foo	/^   dim3 result (res) ::: inlined_by_foo$/;"	r
dim4	mat4{object}.foo	/^   dim4 result (res) ::: inlined_by_foo$/;"	r
shape	mat4{object}.foo	/^   shape result (res)$/;"	r
is_same_shape_as	mat4{object}.foo	/^   is_same_shape_as(b) result (res) $/;"	r
set_to	mat4{object}.foo	/^   set_to(b)$/;"	r
set_to	mat4{object}.foo	/^   set_to(b)$/;"	r
create	mat4{real}.foo	/^   create(dim1,dim2,dim3,dim4) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{real}.foo	/^   create(bounds) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{real}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{real}.foo	/^   create(bounds1,bounds2,bounds3,bounds4) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create	mat4{real}.foo	/^   create(bounds) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
create_copy	mat4{real}.foo	/^   create_copy(c) ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
destroy	mat4{real}.foo	/^   destroy ::: get_from(MAT4{INTRINSIC}), leaky$/;"	r
created	mat4{real}.foo	/^   created result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat4{real}.foo	/^   destroyed result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
size	mat4{real}.foo	/^   size result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat4{real}.foo	/^   dim1 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat4{real}.foo	/^   dim2 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim3	mat4{real}.foo	/^   dim3 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
dim4	mat4{real}.foo	/^   dim4 result (res) ::: get_from(MAT4{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat4{real}.foo	/^   shape result (res) ::: get_from(MAT4{INTRINSIC})$/;"	r
is_same_shape_as	mat4{real}.foo	/^   is_same_shape_as(b) result (res)  ::: get_from(MAT4{INTRINSIC})$/;"	r
set_to	mat4{real}.foo	/^   set_to(b) ::: get_from(MAT4{INTRINSIC})$/;"	r
set_to	mat4{real}.foo	/^   set_to(b) ::: get_from(MAT4{INTRINSIC})$/;"	r
partial_trace	mat4{real}.foo	/^   partial_trace(d1,d2,T)$/;"	r
change_index_1_to	mat4{real}.foo	/^   change_index_1_to(new,V)$/;"	r
change_index_2_to	mat4{real}.foo	/^   change_index_2_to(new,V)$/;"	r
change_index_3_to	mat4{real}.foo	/^   change_index_3_to(new,V)$/;"	r
change_index_4_to	mat4{real}.foo	/^   change_index_4_to(new,V)$/;"	r
create	mat4{rms2_indices}.foo	/^   create(dim1,dim2,dim3,dim4) ::: get_from(MAT4{OBJECT}), leaky$/;"	r
create	mat4{rms2_indices}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4) ::: get_from(MAT4{OBJECT}), leaky$/;"	r
destroy	mat4{rms2_indices}.foo	/^   destroy ::: get_from(MAT4{OBJECT}), leaky$/;"	r
created	mat4{rms2_indices}.foo	/^   created result (res) ::: get_from(MAT4{OBJECT}), inlined_by_foo$/;"	r
destroyed	mat4{rms2_indices}.foo	/^   destroyed result (res) ::: get_from(MAT4{OBJECT}), inlined_by_foo$/;"	r
nullify_ptr_part	mat4{rms2_indices}.foo	/^   nullify_ptr_part ::: get_from(MAT4{OBJECT})$/;"	r
destroy_ptr_part	mat4{rms2_indices}.foo	/^   destroy_ptr_part ::: get_from(MAT4{OBJECT}), leaky$/;"	r
dim1	mat4{rms2_indices}.foo	/^   dim1 result (res) ::: get_from(MAT4{OBJECT}), inlined_by_foo$/;"	r
dim2	mat4{rms2_indices}.foo	/^   dim2 result (res) ::: get_from(MAT4{OBJECT}), inlined_by_foo$/;"	r
dim3	mat4{rms2_indices}.foo	/^   dim3 result (res) ::: get_from(MAT4{OBJECT}), inlined_by_foo$/;"	r
dim4	mat4{rms2_indices}.foo	/^   dim4 result (res) ::: get_from(MAT4{OBJECT}), inlined_by_foo$/;"	r
set_indices	mat4{rms2_indices}.foo	/^   set_indices(l_max,rms_indices,nx,ny,nz) ::: leaky$/;"	r
self	mat4{rms2_indices}.foo	/^     self :: PTR$/;"	a
l_max	mat4{rms2_indices}.foo	/^     l_max :: INT, IN$/;"	a
rms_indices	mat4{rms2_indices}.foo	/^     rms_indices :: MAT{RMS_INDICES}*$/;"	a
n_comp_up_to	mat4{rms2_indices}.foo	/^   n_comp_up_to(l) result (res) ::: selfless, always_pure, private$/;"	r
create	mat5{cpx}.foo	/^   create(dim1,dim2,dim3,dim4,dim5) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{cpx}.foo	/^   create(bounds) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{cpx}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4,lb5,ub5) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{cpx}.foo	/^   create(bounds1,bounds2,bounds3,bounds4,bounds5) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{cpx}.foo	/^   create(bounds) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create_copy	mat5{cpx}.foo	/^   create_copy(c) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
destroy	mat5{cpx}.foo	/^   destroy ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
created	mat5{cpx}.foo	/^   created result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat5{cpx}.foo	/^   destroyed result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
size	mat5{cpx}.foo	/^   size result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat5{cpx}.foo	/^   dim1 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat5{cpx}.foo	/^   dim2 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim3	mat5{cpx}.foo	/^   dim3 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim4	mat5{cpx}.foo	/^   dim4 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim5	mat5{cpx}.foo	/^   dim5 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat5{cpx}.foo	/^   shape result (res) ::: get_from(MAT5{INTRINSIC})$/;"	r
is_same_shape_as	mat5{cpx}.foo	/^   is_same_shape_as(b) result (res)  ::: get_from(MAT5{INTRINSIC})$/;"	r
set_to	mat5{cpx}.foo	/^   set_to(b) ::: get_from(MAT5{INTRINSIC})$/;"	r
set_to	mat5{cpx}.foo	/^   set_to(b) ::: get_from(MAT5{INTRINSIC})$/;"	r
create	mat5{int}.foo	/^   create(dim1,dim2,dim3,dim4,dim5) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{int}.foo	/^   create(bounds) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{int}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4,lb5,ub5) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{int}.foo	/^   create(bounds1,bounds2,bounds3,bounds4,bounds5) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{int}.foo	/^   create(bounds) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create_copy	mat5{int}.foo	/^   create_copy(c) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
destroy	mat5{int}.foo	/^   destroy ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
created	mat5{int}.foo	/^   created result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat5{int}.foo	/^   destroyed result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
size	mat5{int}.foo	/^   size result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat5{int}.foo	/^   dim1 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat5{int}.foo	/^   dim2 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim3	mat5{int}.foo	/^   dim3 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim4	mat5{int}.foo	/^   dim4 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim5	mat5{int}.foo	/^   dim5 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat5{int}.foo	/^   shape result (res) ::: get_from(MAT5{INTRINSIC})$/;"	r
is_same_shape_as	mat5{int}.foo	/^   is_same_shape_as(b) result (res)  ::: get_from(MAT5{INTRINSIC})$/;"	r
set_to	mat5{int}.foo	/^   set_to(b) ::: get_from(MAT5{INTRINSIC})$/;"	r
set_to	mat5{int}.foo	/^   set_to(b) ::: get_from(MAT5{INTRINSIC})$/;"	r
create	mat5{intrinsic}.foo	/^   create(dim1,dim2,dim3,dim4,dim5) ::: leaky$/;"	r
create	mat5{intrinsic}.foo	/^   create(bounds) ::: leaky$/;"	r
self	mat5{intrinsic}.foo	/^     self :: PTR$/;"	a
bounds	mat5{intrinsic}.foo	/^     bounds :: VEC{INT}(5), IN$/;"	a
create	mat5{intrinsic}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4,lb5,ub5) ::: leaky$/;"	r
create	mat5{intrinsic}.foo	/^   create(bounds1,bounds2,bounds3,bounds4,bounds5) ::: leaky$/;"	r
create	mat5{intrinsic}.foo	/^   create(bounds) ::: leaky$/;"	r
create_copy	mat5{intrinsic}.foo	/^   create_copy(c) ::: leaky$/;"	r
destroy	mat5{intrinsic}.foo	/^   destroy ::: leaky$/;"	r
created	mat5{intrinsic}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	mat5{intrinsic}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
size	mat5{intrinsic}.foo	/^   size result (res) ::: inlined_by_foo$/;"	r
dim1	mat5{intrinsic}.foo	/^   dim1 result (res) ::: inlined_by_foo$/;"	r
dim2	mat5{intrinsic}.foo	/^   dim2 result (res) ::: inlined_by_foo$/;"	r
dim3	mat5{intrinsic}.foo	/^   dim3 result (res) ::: inlined_by_foo$/;"	r
dim4	mat5{intrinsic}.foo	/^   dim4 result (res) ::: inlined_by_foo$/;"	r
dim5	mat5{intrinsic}.foo	/^   dim5 result (res) ::: inlined_by_foo$/;"	r
shape	mat5{intrinsic}.foo	/^   shape result (res)$/;"	r
is_same_shape_as	mat5{intrinsic}.foo	/^   is_same_shape_as(b) result (res) $/;"	r
set_to	mat5{intrinsic}.foo	/^   set_to(b)$/;"	r
set_to	mat5{intrinsic}.foo	/^   set_to(b)$/;"	r
create	mat5{real}.foo	/^   create(dim1,dim2,dim3,dim4,dim5) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{real}.foo	/^   create(bounds) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{real}.foo	/^   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4,lb5,ub5) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{real}.foo	/^   create(bounds1,bounds2,bounds3,bounds4,bounds5) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create	mat5{real}.foo	/^   create(bounds) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
create_copy	mat5{real}.foo	/^   create_copy(c) ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
destroy	mat5{real}.foo	/^   destroy ::: get_from(MAT5{INTRINSIC}), leaky$/;"	r
created	mat5{real}.foo	/^   created result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat5{real}.foo	/^   destroyed result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
size	mat5{real}.foo	/^   size result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat5{real}.foo	/^   dim1 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat5{real}.foo	/^   dim2 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim3	mat5{real}.foo	/^   dim3 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim4	mat5{real}.foo	/^   dim4 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
dim5	mat5{real}.foo	/^   dim5 result (res) ::: get_from(MAT5{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat5{real}.foo	/^   shape result (res) ::: get_from(MAT5{INTRINSIC})$/;"	r
is_same_shape_as	mat5{real}.foo	/^   is_same_shape_as(b) result (res)  ::: get_from(MAT5{INTRINSIC})$/;"	r
set_to	mat5{real}.foo	/^   set_to(b) ::: get_from(MAT5{INTRINSIC})$/;"	r
set_to	mat5{real}.foo	/^   set_to(b) ::: get_from(MAT5{INTRINSIC})$/;"	r
create	mat{bin}.foo	/^   create(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{bin}.foo	/^   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{bin}.foo	/^   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{bin}.foo	/^   create(bounds1,bounds2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{bin}.foo	/^   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create_copy	mat{bin}.foo	/^   create_copy(matrix) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
destroy	mat{bin}.foo	/^   destroy ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
created	mat{bin}.foo	/^   created result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat{bin}.foo	/^   destroyed result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
size	mat{bin}.foo	/^   size result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat{bin}.foo	/^   dim1 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat{bin}.foo	/^   dim2 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat{bin}.foo	/^   shape result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_same_shape_as	mat{bin}.foo	/^   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{BIN}), pure$/;"	r
is_transposed_shape_of	mat{bin}.foo	/^   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{BIN}), pure$/;"	r
is_square	mat{bin}.foo	/^   is_square result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
shrink	mat{bin}.foo	/^   shrink(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
expand	mat{bin}.foo	/^   expand(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
shrink_columns	mat{bin}.foo	/^   shrink_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
expand_columns	mat{bin}.foo	/^   expand_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
append_columns	mat{bin}.foo	/^   append_columns(cols) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
append_column	mat{bin}.foo	/^   append_column(col) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
equals	mat{bin}.foo	/^   equals(b) result (res)$/;"	r
same_as	mat{bin}.foo	/^   same_as(b) result (res)$/;"	r
str_lengths	mat{bin}.foo	/^   str_lengths(spaces) result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
str_length	mat{bin}.foo	/^   str_length(spaces) result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
tol5	mat{cpx}.foo	/^   tol5 :: REAL, private = 1.0d-5$/;"	g
trace_of_product_with	mat{cpx}.foo	/^   interface trace_of_product_with$/;"	i
diagonal_set_to	mat{cpx}.foo	/^   interface diagonal_set_to$/;"	i
diagonal_plus	mat{cpx}.foo	/^   interface diagonal_plus$/;"	i
diagonal_times	mat{cpx}.foo	/^   interface diagonal_times$/;"	i
diagonal_max_abs	mat{cpx}.foo	/^   interface diagonal_max_abs$/;"	i
create	mat{cpx}.foo	/^   create(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{cpx}.foo	/^   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{cpx}.foo	/^   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{cpx}.foo	/^   create(bounds1,bounds2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{cpx}.foo	/^   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create_copy	mat{cpx}.foo	/^   create_copy(matrix) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
destroy	mat{cpx}.foo	/^   destroy ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
created	mat{cpx}.foo	/^   created result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat{cpx}.foo	/^   destroyed result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
size	mat{cpx}.foo	/^   size result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat{cpx}.foo	/^   dim1 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat{cpx}.foo	/^   dim2 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat{cpx}.foo	/^   shape result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_same_shape_as	mat{cpx}.foo	/^   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}), pure$/;"	r
is_same_shape_as	mat{cpx}.foo	/^   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}), pure$/;"	r
is_transposed_shape_of	mat{cpx}.foo	/^   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}), pure$/;"	r
is_transposed_shape_of	mat{cpx}.foo	/^   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}), pure$/;"	r
is_square	mat{cpx}.foo	/^   is_square result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
shrink	mat{cpx}.foo	/^   shrink(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
expand	mat{cpx}.foo	/^   expand(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
shrink_columns	mat{cpx}.foo	/^   shrink_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
expand_columns	mat{cpx}.foo	/^   expand_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
append_columns	mat{cpx}.foo	/^   append_columns(cols) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
append_column	mat{cpx}.foo	/^   append_column(col) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
equals	mat{cpx}.foo	/^   equals(b) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
same_as	mat{cpx}.foo	/^   same_as(b,eps,diff) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_diagonal	mat{cpx}.foo	/^   is_diagonal(eps) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
has_unit_diagonal	mat{cpx}.foo	/^   has_unit_diagonal(eps) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
has_minus_unit_diagonal	mat{cpx}.foo	/^   has_minus_unit_diagonal result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_unit_matrix	mat{cpx}.foo	/^   is_unit_matrix(eps) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_inversion_matrix	mat{cpx}.foo	/^   is_inversion_matrix result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_symmetric	mat{cpx}.foo	/^   is_symmetric result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_antisymmetric	mat{cpx}.foo	/^   is_antisymmetric result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_zero	mat{cpx}.foo	/^   is_zero(eps) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_hermitian	mat{cpx}.foo	/^   is_hermitian(tol) result (res)$/;"	r
is_antihermitian	mat{cpx}.foo	/^   is_antihermitian(tol) result (res)$/;"	r
has_column	mat{cpx}.foo	/^   has_column(c,eps,col) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
column_index	mat{cpx}.foo	/^   column_index(c,eps) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
swap_columns	mat{cpx}.foo	/^   swap_columns(col1,col2) ::: get_from(MAT{INTRINSIC})$/;"	r
swap_columns	mat{cpx}.foo	/^   swap_columns(list) ::: get_from(MAT{INTRINSIC})$/;"	r
column_norms	mat{cpx}.foo	/^   column_norms result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
get_column_norms	mat{cpx}.foo	/^   get_column_norms(res) ::: get_from(MAT{INTRINSIC})$/;"	r
get_column_dot_products	mat{cpx}.foo	/^   get_column_dot_products(res) ::: get_from(MAT{INTRINSIC})$/;"	r
index_of_minimum_column_norm	mat{cpx}.foo	/^   index_of_minimum_column_norm(offset) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
max_abs_column_difference	mat{cpx}.foo	/^   max_abs_column_difference result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
mean_column_vector	mat{cpx}.foo	/^   mean_column_vector result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
sum_column_vectors	mat{cpx}.foo	/^   sum_column_vectors result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
reverse_column_order	mat{cpx}.foo	/^   reverse_column_order ::: get_from(MAT{INTRINSIC})$/;"	r
sum_row_vectors	mat{cpx}.foo	/^   sum_row_vectors result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
determinant	mat{cpx}.foo	/^   determinant result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
cofactor	mat{cpx}.foo	/^   cofactor result (res) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
dot	mat{cpx}.foo	/^   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{CPX}, RES_TYPE=>CPX)$/;"	r
dot	mat{cpx}.foo	/^   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{REAL}, RES_TYPE=>CPX)$/;"	r
rotate	mat{cpx}.foo	/^   rotate(v) ::: get_from(MAT{INTRINSIC})$/;"	r
to_unit_matrix	mat{cpx}.foo	/^   to_unit_matrix ::: get_from(MAT{INTRINSIC})$/;"	r
zero_small_values	mat{cpx}.foo	/^   zero_small_values(eps) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
set_to	mat{cpx}.foo	/^   set_to(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})$/;"	r
set_to	mat{cpx}.foo	/^   set_to(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})$/;"	r
set_to_transpose_of	mat{cpx}.foo	/^   set_to_transpose_of(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})$/;"	r
set_to_transpose_of	mat{cpx}.foo	/^   set_to_transpose_of(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})$/;"	r
to_transpose	mat{cpx}.foo	/^   to_transpose ::: get_from(MAT{INTRINSIC})$/;"	r
plus	mat{cpx}.foo	/^   plus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})$/;"	r
plus	mat{cpx}.foo	/^   plus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})$/;"	r
minus	mat{cpx}.foo	/^   minus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})$/;"	r
minus	mat{cpx}.foo	/^   minus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})$/;"	r
to_scaled	mat{cpx}.foo	/^   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)$/;"	r
to_scaled	mat{cpx}.foo	/^   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)$/;"	r
to_scaled	mat{cpx}.foo	/^   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
to_scaled	mat{cpx}.foo	/^   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
plus_scaled	mat{cpx}.foo	/^   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)$/;"	r
plus_scaled	mat{cpx}.foo	/^   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)$/;"	r
plus_scaled	mat{cpx}.foo	/^   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
plus_scaled	mat{cpx}.foo	/^   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
minus_scaled	mat{cpx}.foo	/^   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)$/;"	r
minus_scaled	mat{cpx}.foo	/^   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)$/;"	r
minus_scaled	mat{cpx}.foo	/^   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
minus_scaled	mat{cpx}.foo	/^   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
to_product_of	mat{cpx}.foo	/^   to_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL})$/;"	r
to_product_of	mat{cpx}.foo	/^   to_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC})$/;"	r
to_product_of	mat{cpx}.foo	/^   to_product_of(a,b,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC})$/;"	r
to_product_of	mat{cpx}.foo	/^   to_product_of(a,b,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC})$/;"	r
plus_product_of	mat{cpx}.foo	/^   plus_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL})$/;"	r
plus_product_of	mat{cpx}.foo	/^   plus_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC})$/;"	r
plus_product_of	mat{cpx}.foo	/^   plus_product_of(a,b,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC})$/;"	r
plus_product_of	mat{cpx}.foo	/^   plus_product_of(a,b,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC})$/;"	r
to_scaled_product_of	mat{cpx}.foo	/^   to_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
to_scaled_product_of	mat{cpx}.foo	/^   to_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
to_scaled_product_of	mat{cpx}.foo	/^   to_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)$/;"	r
to_scaled_product_of	mat{cpx}.foo	/^   to_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)$/;"	r
to_scaled_product_of	mat{cpx}.foo	/^   to_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)$/;"	r
to_scaled_product_of	mat{cpx}.foo	/^   to_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)$/;"	r
to_scaled_product_of	mat{cpx}.foo	/^   to_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)$/;"	r
to_scaled_product_of	mat{cpx}.foo	/^   to_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)$/;"	r
plus_scaled_product_of	mat{cpx}.foo	/^   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
plus_scaled_product_of	mat{cpx}.foo	/^   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
plus_scaled_product_of	mat{cpx}.foo	/^   plus_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)$/;"	r
plus_scaled_product_of	mat{cpx}.foo	/^   plus_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)$/;"	r
plus_scaled_product_of	mat{cpx}.foo	/^   plus_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)$/;"	r
plus_scaled_product_of	mat{cpx}.foo	/^   plus_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)$/;"	r
plus_scaled_product_of	mat{cpx}.foo	/^   plus_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)$/;"	r
plus_scaled_product_of	mat{cpx}.foo	/^   plus_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)$/;"	r
to_product_with_diagonal	mat{cpx}.foo	/^   to_product_with_diagonal(a,diag,transpose_a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, DIAG_TYPE=>VEC{CPX})$/;"	r
to_product_with_diagonal	mat{cpx}.foo	/^   to_product_with_diagonal(a,diag,transpose_a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, DIAG_TYPE=>VEC{REAL})$/;"	r
to_product_with_diagonal	mat{cpx}.foo	/^   to_product_with_diagonal(a,diag,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DIAG_TYPE=>VEC{CPX})$/;"	r
to_product_with_diagonal	mat{cpx}.foo	/^   to_product_with_diagonal(a,diag,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DIAG_TYPE=>VEC{REAL})$/;"	r
to_product_with_diagonal	mat{cpx}.foo	/^   to_product_with_diagonal(dg,a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{CPX}, A_TYPE=>MAT{REAL})$/;"	r
to_product_with_diagonal	mat{cpx}.foo	/^   to_product_with_diagonal(dg,a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{REAL}, A_TYPE=>MAT{REAL})$/;"	r
to_product_with_diagonal	mat{cpx}.foo	/^   to_product_with_diagonal(dg,a,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{CPX})$/;"	r
to_product_with_diagonal	mat{cpx}.foo	/^   to_product_with_diagonal(dg,a,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{REAL})$/;"	r
trace	mat{cpx}.foo	/^   trace result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
trace_product_with	mat{cpx}.foo	/^   trace_product_with(a,transpose_a,dagger_a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})$/;"	r
trace_product_with	mat{cpx}.foo	/^   trace_product_with(a,transpose_a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, RES_TYPE=>REAL, CAST=>REALIFY)$/;"	r
trace_product_with	mat{cpx}.foo	/^   trace_product_with(a,b,c) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
trace_product_with	mat{cpx}.foo	/^   trace_product_with(a,b,c,d,e) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
dot	mat{cpx}.foo	/^   dot(a) result (res) $/;"	r
change_basis_using	mat{cpx}.foo	/^   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A)$/;"	r
change_basis_using	mat{cpx}.foo	/^   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})$/;"	r
change_basis_using	mat{cpx}.foo	/^   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>VEC{CPX})$/;"	r
change_basis_using	mat{cpx}.foo	/^   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>VEC{REAL})$/;"	r
change_basis_using	mat{cpx}.foo	/^   change_basis_using(L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{CPX})$/;"	r
change_basis_using	mat{cpx}.foo	/^   change_basis_using(L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{REAL})$/;"	r
change_basis_to	mat{cpx}.foo	/^   change_basis_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A)$/;"	r
change_basis_to	mat{cpx}.foo	/^   change_basis_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})$/;"	r
change_basis_to	mat{cpx}.foo	/^   change_basis_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A)$/;"	r
change_basis_to	mat{cpx}.foo	/^   change_basis_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{REAL})$/;"	r
back_transform_using	mat{cpx}.foo	/^   back_transform_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B)$/;"	r
back_transform_using	mat{cpx}.foo	/^   back_transform_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})$/;"	r
back_transform_to	mat{cpx}.foo	/^   back_transform_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B)$/;"	r
back_transform_to	mat{cpx}.foo	/^   back_transform_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})$/;"	r
back_transform_to	mat{cpx}.foo	/^   back_transform_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B)$/;"	r
back_transform_to	mat{cpx}.foo	/^   back_transform_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{REAL})$/;"	r
set_from_diagonal	mat{cpx}.foo	/^   set_from_diagonal(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{CPX})$/;"	r
set_from_diagonal	mat{cpx}.foo	/^   set_from_diagonal(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{REAL})$/;"	r
set_diagonal_to	mat{cpx}.foo	/^   set_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{CPX})$/;"	r
set_diagonal_to	mat{cpx}.foo	/^   set_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{REAL})$/;"	r
set_diagonal_to	mat{cpx}.foo	/^   set_diagonal_to(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>CPX)$/;"	r
set_diagonal_to	mat{cpx}.foo	/^   set_diagonal_to(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>REAL)$/;"	r
put_diagonal_to	mat{cpx}.foo	/^   put_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{CPX})$/;"	r
put_diagonal_to	mat{cpx}.foo	/^   put_diagonal_to(d)$/;"	r
increment_diagonal_by	mat{cpx}.foo	/^   increment_diagonal_by(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>CPX)$/;"	r
increment_diagonal_by	mat{cpx}.foo	/^   increment_diagonal_by(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>REAL)$/;"	r
scale_diagonal_by	mat{cpx}.foo	/^   scale_diagonal_by(fac) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)$/;"	r
scale_diagonal_by	mat{cpx}.foo	/^   scale_diagonal_by(fac) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)$/;"	r
zero_diagonal	mat{cpx}.foo	/^   zero_diagonal ::: get_from(MAT{INTRINSIC})$/;"	r
zero_off_diagonal	mat{cpx}.foo	/^   zero_off_diagonal ::: get_from(MAT{INTRINSIC})$/;"	r
max_abs_diagonal_element	mat{cpx}.foo	/^   max_abs_diagonal_element result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
symmetrize	mat{cpx}.foo	/^   symmetrize ::: get_from(MAT{INTRINSIC})$/;"	r
antisymmetrize	mat{cpx}.foo	/^   antisymmetrize ::: get_from(MAT{INTRINSIC})$/;"	r
symmetric_fold	mat{cpx}.foo	/^   symmetric_fold ::: get_from(MAT{INTRINSIC})$/;"	r
antisymmetric_fold	mat{cpx}.foo	/^   antisymmetric_fold ::: get_from(MAT{INTRINSIC})$/;"	r
symmetric_reflect	mat{cpx}.foo	/^   symmetric_reflect ::: get_from(MAT{INTRINSIC})$/;"	r
antisymmetric_reflect	mat{cpx}.foo	/^   antisymmetric_reflect ::: get_from(MAT{INTRINSIC})$/;"	r
symmetric_fold_to_triangle	mat{cpx}.foo	/^   symmetric_fold_to_triangle(tr) ::: get_from(MAT{INTRINSIC})$/;"	r
hermitianize	mat{cpx}.foo	/^   hermitianize$/;"	r
antihermitianize	mat{cpx}.foo	/^   antihermitianize$/;"	r
hermitian_fold	mat{cpx}.foo	/^   hermitian_fold$/;"	r
antihermitian_fold	mat{cpx}.foo	/^   antihermitian_fold$/;"	r
make_hermitian	mat{cpx}.foo	/^   make_hermitian$/;"	r
hermitian_reflect	mat{cpx}.foo	/^   hermitian_reflect$/;"	r
make_antihermitian	mat{cpx}.foo	/^   make_antihermitian$/;"	r
antihermitian_reflect	mat{cpx}.foo	/^   antihermitian_reflect$/;"	r
compress_to_square	mat{cpx}.foo	/^   compress_to_square(sq)$/;"	r
uncompress_from_square	mat{cpx}.foo	/^   uncompress_from_square(sq)$/;"	r
compress_to_triangle	mat{cpx}.foo	/^   compress_to_triangle(tr) ::: get_from(MAT{INTRINSIC})$/;"	r
uncompress_from_triangle	mat{cpx}.foo	/^   uncompress_from_triangle(tr)$/;"	r
tri_size	mat{cpx}.foo	/^   tri_size result (ltr) ::: get_from(MAT{INTRINSIC})$/;"	r
schmidt_orthonormalise	mat{cpx}.foo	/^   schmidt_orthonormalise(scale) ::: get_from(MAT{INTRINSIC})$/;"	r
schmidt_orthonormalise	mat{cpx}.foo	/^   schmidt_orthonormalise(S,scale) ::: get_from(MAT{INTRINSIC})$/;"	r
reverse_schmidt_orthonormalise	mat{cpx}.foo	/^   reverse_schmidt_orthonormalise(S) ::: get_from(MAT{INTRINSIC})$/;"	r
reverse_schmidt_orthogonalise	mat{cpx}.foo	/^   reverse_schmidt_orthogonalise ::: get_from(MAT{INTRINSIC}, CAST=>REALIFY)$/;"	r
symmetrically_orthonormalise	mat{cpx}.foo	/^   symmetrically_orthonormalise(S) ::: get_from(MAT{INTRINSIC})$/;"	r
make_diagonally_dominant	mat{cpx}.foo	/^   make_diagonally_dominant(permutation) ::: get_from(MAT{INTRINSIC})$/;"	r
make_real_eigenproblem	mat{cpx}.foo	/^   make_real_eigenproblem(eigenvalues,eigenvectors,eps)$/;"	r
diagonalise_by_jacobi	mat{cpx}.foo	/^   diagonalise_by_jacobi(eigenvalues,eigenvectors,eps,max_iterations)$/;"	r
jacobi_rotation	mat{cpx}.foo	/^   jacobi_rotation(p,q,v)$/;"	r
solve_eigenproblem	mat{cpx}.foo	/^   solve_eigenproblem(eigenvalues,eigenvectors,routine)$/;"	r
solve_eigenproblem_ESSL	mat{cpx}.foo	/^   solve_eigenproblem_ESSL(eigenvalues,eigenvectors,routine) ::: private$/;"	r
solve_eigenproblem_LAPACK	mat{cpx}.foo	/^   solve_eigenproblem_LAPACK(eigenvalues,eigenvectors,routine) ::: private$/;"	r
to_sqrt_of	mat{cpx}.foo	/^   to_sqrt_of(R)$/;"	r
to_inverse_sqrt_of	mat{cpx}.foo	/^   to_inverse_sqrt_of(R,tol)$/;"	r
to_inverse_sqrt_of_2	mat{cpx}.foo	/^   to_inverse_sqrt_of_2(R,tol)$/;"	r
to_power_series_inverse_of	mat{cpx}.foo	/^   to_power_series_inverse_of(S,tol,max_it) ::: get_from(MAT{INTRINSIC})$/;"	r
to_power_series_inv_sqrt_of	mat{cpx}.foo	/^   to_power_series_inv_sqrt_of(S,tol,prefactor,max_it) ::: get_from(MAT{INTRINSIC})$/;"	r
to_exponential_of	mat{cpx}.foo	/^   to_exponential_of(X,tol) ::: get_from(MAT{INTRINSIC})$/;"	r
exponentiate_to	mat{cpx}.foo	/^   exponentiate_to(U,tol) ::: get_from(MAT{INTRINSIC})$/;"	r
antisymmetric_exponential_to	mat{cpx}.foo	/^   antisymmetric_exponential_to(U,eval,evec) ::: get_from(MAT{INTRINSIC})$/;"	r
str_lengths_with_precision	mat{cpx}.foo	/^   str_lengths_with_precision(dp,spaces) result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
str_length_with_precision	mat{cpx}.foo	/^   str_length_with_precision(dp,spaces) result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
alpha_alpha	mat{cpx}.foo	/^   alpha_alpha result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
beta_alpha	mat{cpx}.foo	/^   beta_alpha result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
alpha_beta	mat{cpx}.foo	/^   alpha_beta result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
beta_beta	mat{cpx}.foo	/^   beta_beta result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
alpha_alpha_set_to	mat{cpx}.foo	/^   alpha_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})$/;"	r
beta_alpha_set_to	mat{cpx}.foo	/^   beta_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})$/;"	r
alpha_beta_set_to	mat{cpx}.foo	/^   alpha_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})$/;"	r
beta_beta_set_to	mat{cpx}.foo	/^   beta_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})$/;"	r
alpha_alpha_set_to	mat{cpx}.foo	/^   alpha_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
beta_alpha_set_to	mat{cpx}.foo	/^   beta_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
alpha_beta_set_to	mat{cpx}.foo	/^   alpha_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
beta_beta_set_to	mat{cpx}.foo	/^   beta_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
alpha_alpha_set_to	mat{cpx}.foo	/^   alpha_alpha_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)$/;"	r
beta_alpha_set_to	mat{cpx}.foo	/^   beta_alpha_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)$/;"	r
alpha_beta_set_to	mat{cpx}.foo	/^   alpha_beta_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)$/;"	r
beta_beta_set_to	mat{cpx}.foo	/^   beta_beta_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)$/;"	r
alpha_alpha_set_to	mat{cpx}.foo	/^   alpha_alpha_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)$/;"	r
beta_alpha_set_to	mat{cpx}.foo	/^   beta_alpha_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)$/;"	r
alpha_beta_set_to	mat{cpx}.foo	/^   alpha_beta_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)$/;"	r
beta_beta_set_to	mat{cpx}.foo	/^   beta_beta_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)$/;"	r
alpha_alpha_set_to	mat{cpx}.foo	/^   alpha_alpha_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
beta_alpha_set_to	mat{cpx}.foo	/^   beta_alpha_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
alpha_beta_set_to	mat{cpx}.foo	/^   alpha_beta_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
beta_beta_set_to	mat{cpx}.foo	/^   beta_beta_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
alpha_alpha_set_to	mat{cpx}.foo	/^   alpha_alpha_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
beta_alpha_set_to	mat{cpx}.foo	/^   beta_alpha_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
alpha_beta_set_to	mat{cpx}.foo	/^   alpha_beta_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
beta_beta_set_to	mat{cpx}.foo	/^   beta_beta_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
alpha_alpha_put_to	mat{cpx}.foo	/^   alpha_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, CAST=>)$/;"	r
beta_alpha_put_to	mat{cpx}.foo	/^   beta_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, CAST=>)$/;"	r
alpha_beta_put_to	mat{cpx}.foo	/^   alpha_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, CAST=>)$/;"	r
beta_beta_put_to	mat{cpx}.foo	/^   beta_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, CAST=>)$/;"	r
alpha_alpha_put_to	mat{cpx}.foo	/^   alpha_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, CAST=>REALIFY)$/;"	r
beta_alpha_put_to	mat{cpx}.foo	/^   beta_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, CAST=>REALIFY)$/;"	r
alpha_beta_put_to	mat{cpx}.foo	/^   alpha_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, CAST=>REALIFY)$/;"	r
beta_beta_put_to	mat{cpx}.foo	/^   beta_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, CAST=>REALIFY)$/;"	r
alpha_alpha_plus	mat{cpx}.foo	/^   alpha_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})$/;"	r
beta_alpha_plus	mat{cpx}.foo	/^   beta_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})$/;"	r
alpha_beta_plus	mat{cpx}.foo	/^   alpha_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})$/;"	r
beta_beta_plus	mat{cpx}.foo	/^   beta_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})$/;"	r
alpha_alpha_plus	mat{cpx}.foo	/^   alpha_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
beta_alpha_plus	mat{cpx}.foo	/^   beta_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
alpha_beta_plus	mat{cpx}.foo	/^   alpha_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
beta_beta_plus	mat{cpx}.foo	/^   beta_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
alpha_alpha_plus	mat{cpx}.foo	/^   alpha_alpha_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)$/;"	r
beta_alpha_plus	mat{cpx}.foo	/^   beta_alpha_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)$/;"	r
alpha_beta_plus	mat{cpx}.foo	/^   alpha_beta_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)$/;"	r
beta_beta_plus	mat{cpx}.foo	/^   beta_beta_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)$/;"	r
alpha_alpha_plus	mat{cpx}.foo	/^   alpha_alpha_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)$/;"	r
beta_alpha_plus	mat{cpx}.foo	/^   beta_alpha_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)$/;"	r
alpha_beta_plus	mat{cpx}.foo	/^   alpha_beta_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)$/;"	r
beta_beta_plus	mat{cpx}.foo	/^   beta_beta_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)$/;"	r
alpha_alpha_plus	mat{cpx}.foo	/^   alpha_alpha_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
beta_alpha_plus	mat{cpx}.foo	/^   beta_alpha_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
alpha_beta_plus	mat{cpx}.foo	/^   alpha_beta_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
beta_beta_plus	mat{cpx}.foo	/^   beta_beta_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)$/;"	r
alpha_alpha_plus	mat{cpx}.foo	/^   alpha_alpha_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
beta_alpha_plus	mat{cpx}.foo	/^   beta_alpha_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
alpha_beta_plus	mat{cpx}.foo	/^   alpha_beta_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
beta_beta_plus	mat{cpx}.foo	/^   beta_beta_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
create	mat{int}.foo	/^   create(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{int}.foo	/^   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{int}.foo	/^   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{int}.foo	/^   create(bounds1,bounds2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{int}.foo	/^   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create_copy	mat{int}.foo	/^   create_copy(matrix) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
destroy	mat{int}.foo	/^   destroy ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
created	mat{int}.foo	/^   created result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat{int}.foo	/^   destroyed result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
size	mat{int}.foo	/^   size result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat{int}.foo	/^   dim1 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat{int}.foo	/^   dim2 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat{int}.foo	/^   shape result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_same_shape_as	mat{int}.foo	/^   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}), pure$/;"	r
is_transposed_shape_of	mat{int}.foo	/^   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}), pure$/;"	r
is_square	mat{int}.foo	/^   is_square result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
shrink	mat{int}.foo	/^   shrink(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
expand	mat{int}.foo	/^   expand(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
shrink_columns	mat{int}.foo	/^   shrink_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
expand_columns	mat{int}.foo	/^   expand_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
append_columns	mat{int}.foo	/^   append_columns(cols) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
append_column	mat{int}.foo	/^   append_column(col) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
equals	mat{int}.foo	/^   equals(b) result (res)$/;"	r
same_as	mat{int}.foo	/^   same_as(b) result (res)$/;"	r
all_in_range	mat{int}.foo	/^   all_in_range(range) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
in_range	mat{int}.foo	/^   in_range(range) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
range	mat{int}.foo	/^   range result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_diagonal	mat{int}.foo	/^   is_diagonal result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
has_unit_diagonal	mat{int}.foo	/^   has_unit_diagonal result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
has_minus_unit_diagonal	mat{int}.foo	/^   has_minus_unit_diagonal result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_unit_matrix	mat{int}.foo	/^   is_unit_matrix result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_inversion_matrix	mat{int}.foo	/^   is_inversion_matrix result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_symmetric	mat{int}.foo	/^   is_symmetric result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_antisymmetric	mat{int}.foo	/^   is_antisymmetric result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_zero	mat{int}.foo	/^   is_zero result (res) ::: pure$/;"	r
has_column	mat{int}.foo	/^   has_column(c,col) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
column_index	mat{int}.foo	/^   column_index(c) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
swap_columns	mat{int}.foo	/^   swap_columns(col1,col2) ::: get_from(MAT{INTRINSIC})$/;"	r
swap_columns	mat{int}.foo	/^   swap_columns(list) ::: get_from(MAT{INTRINSIC})$/;"	r
column_norms	mat{int}.foo	/^   column_norms result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
get_column_norms	mat{int}.foo	/^   get_column_norms(res) ::: get_from(MAT{INTRINSIC})$/;"	r
get_column_dot_products	mat{int}.foo	/^   get_column_dot_products(res) ::: get_from(MAT{INTRINSIC})$/;"	r
index_of_minimum_column_norm	mat{int}.foo	/^   index_of_minimum_column_norm(offset) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
max_abs_column_difference	mat{int}.foo	/^   max_abs_column_difference result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
mean_column_vector	mat{int}.foo	/^   mean_column_vector result (res) $/;"	r
sum_column_vectors	mat{int}.foo	/^   sum_column_vectors result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
reverse_column_order	mat{int}.foo	/^   reverse_column_order ::: get_from(MAT{INTRINSIC})$/;"	r
sum_row_vectors	mat{int}.foo	/^   sum_row_vectors result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
row_norms	mat{int}.foo	/^   row_norms result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
swap_rows	mat{int}.foo	/^   swap_rows(row1,row2) ::: get_from(MAT{INTRINSIC})$/;"	r
swap_rows	mat{int}.foo	/^   swap_rows(list) ::: get_from(MAT{INTRINSIC})$/;"	r
determinant	mat{int}.foo	/^   determinant result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
cofactor	mat{int}.foo	/^   cofactor result (res) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
dot	mat{int}.foo	/^   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{INT}, RES_TYPE=>INT)$/;"	r
rotate	mat{int}.foo	/^   rotate(v) ::: get_from(MAT{INTRINSIC})$/;"	r
to_unit_matrix	mat{int}.foo	/^   to_unit_matrix ::: get_from(MAT{INTRINSIC})$/;"	r
to_inverse_unit_matrix	mat{int}.foo	/^   to_inverse_unit_matrix$/;"	r
set_to	mat{int}.foo	/^   set_to(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT})$/;"	r
set_to_transpose_of	mat{int}.foo	/^   set_to_transpose_of(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT})$/;"	r
to_transpose	mat{int}.foo	/^   to_transpose ::: get_from(MAT{INTRINSIC})$/;"	r
plus	mat{int}.foo	/^   plus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT})$/;"	r
minus	mat{int}.foo	/^   minus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT})$/;"	r
to_scaled	mat{int}.foo	/^   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}, FAC_TYPE=>INT)$/;"	r
plus_scaled	mat{int}.foo	/^   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}, FAC_TYPE=>INT)$/;"	r
minus_scaled	mat{int}.foo	/^   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}, FAC_TYPE=>INT)$/;"	r
to_product_of	mat{int}.foo	/^   to_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{INT})$/;"	r
plus_product_of	mat{int}.foo	/^   plus_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{INT})$/;"	r
to_scaled_product_of	mat{int}.foo	/^   to_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{INT}, FAC_TYPE=>INT)$/;"	r
plus_scaled_product_of	mat{int}.foo	/^   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{INT}, FAC_TYPE=>INT)$/;"	r
to_product_with_diagonal	mat{int}.foo	/^   to_product_with_diagonal(a,diag,transpose_a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}, DIAG_TYPE=>VEC{INT})$/;"	r
to_product_with_diagonal	mat{int}.foo	/^   to_product_with_diagonal(dg,a,transpose_a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}, DG_TYPE=>VEC{INT})$/;"	r
trace	mat{int}.foo	/^   trace result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
trace_product_with	mat{int}.foo	/^   trace_product_with(a,transpose_a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}, RES_TYPE=>INT, CAST=>)$/;"	r
trace_product_with	mat{int}.foo	/^   trace_product_with(a,b,c) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
trace_product_with	mat{int}.foo	/^   trace_product_with(a,b,c,d,e) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
set_from_diagonal	mat{int}.foo	/^   set_from_diagonal(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{INT})$/;"	r
set_diagonal_to	mat{int}.foo	/^   set_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{INT})$/;"	r
set_diagonal_to	mat{int}.foo	/^   set_diagonal_to(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>INT)$/;"	r
put_diagonal_to	mat{int}.foo	/^   put_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{INT})$/;"	r
increment_diagonal_by	mat{int}.foo	/^   increment_diagonal_by(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>INT)$/;"	r
scale_diagonal_by	mat{int}.foo	/^   scale_diagonal_by(fac) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>INT)$/;"	r
zero_diagonal	mat{int}.foo	/^   zero_diagonal ::: get_from(MAT{INTRINSIC})$/;"	r
zero_off_diagonal	mat{int}.foo	/^   zero_off_diagonal ::: get_from(MAT{INTRINSIC})$/;"	r
max_diagonal_element	mat{int}.foo	/^   max_diagonal_element result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
max_abs_diagonal_element	mat{int}.foo	/^   max_abs_diagonal_element result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
compress_to_triangle	mat{int}.foo	/^   compress_to_triangle(tr) ::: get_from(MAT{INTRINSIC})$/;"	r
uncompress_from_triangle	mat{int}.foo	/^   uncompress_from_triangle(tr) ::: get_from(MAT{INTRINSIC})$/;"	r
tri_size	mat{int}.foo	/^   tri_size result (ltr) ::: get_from(MAT{INTRINSIC})$/;"	r
str_lengths	mat{int}.foo	/^   str_lengths(spaces) result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
str_length	mat{int}.foo	/^   str_length(spaces) result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
make_diagonally_dominant	mat{int}.foo	/^   make_diagonally_dominant(permutation) ::: get_from(MAT{INTRINSIC})$/;"	r
to_gaussian_xyz_powers	mat{int}.foo	/^   to_gaussian_xyz_powers(l_max)$/;"	r
to_gaussian_xyz_powers	mat{int}.foo	/^   to_gaussian_xyz_powers(l_max,index)$/;"	r
bin_XY_data	mat{int}.foo	/^   bin_XY_data(X,Y,bin_side_length,data_count) ::: leaky$/;"	r
bin_XY_data	mat{int}.foo	/^   bin_XY_data(X,Y,XY_min,XY_max,bin_side_length,data_count) ::: leaky$/;"	r
diagonal_set_to	mat{intrinsic}.foo	/^   interface diagonal_set_to$/;"	i
diagonal_set_to	mat{intrinsic}.foo	/^   interface diagonal_set_to$/;"	i
diagonal_plus	mat{intrinsic}.foo	/^   interface diagonal_plus$/;"	i
diagonal_times	mat{intrinsic}.foo	/^   interface diagonal_times$/;"	i
diagonal_max	mat{intrinsic}.foo	/^   interface diagonal_max $/;"	i
diagonal_max_abs	mat{intrinsic}.foo	/^   interface diagonal_max_abs$/;"	i
create	mat{intrinsic}.foo	/^   create(dim1,dim2) ::: leaky$/;"	r
create	mat{intrinsic}.foo	/^   create(bounds) ::: leaky$/;"	r
create	mat{intrinsic}.foo	/^   create(lb1,ub1,lb2,ub2) ::: leaky$/;"	r
create	mat{intrinsic}.foo	/^   create(bounds1,bounds2) ::: leaky$/;"	r
create	mat{intrinsic}.foo	/^   create(bounds) ::: leaky$/;"	r
create_copy	mat{intrinsic}.foo	/^   create_copy(matrix) ::: leaky$/;"	r
destroy	mat{intrinsic}.foo	/^   destroy ::: leaky$/;"	r
created	mat{intrinsic}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	mat{intrinsic}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
size	mat{intrinsic}.foo	/^   size result (res) ::: inlined_by_foo$/;"	r
dim1	mat{intrinsic}.foo	/^   dim1 result (res) ::: inlined_by_foo$/;"	r
dim2	mat{intrinsic}.foo	/^   dim2 result (res) ::: inlined_by_foo$/;"	r
shape	mat{intrinsic}.foo	/^   shape result (res)$/;"	r
is_same_shape_as	mat{intrinsic}.foo	/^   is_same_shape_as(a) result (res) ::: pure$/;"	r
is_transposed_shape_of	mat{intrinsic}.foo	/^   is_transposed_shape_of(a) result (res) ::: pure$/;"	r
is_square	mat{intrinsic}.foo	/^   is_square result (res) ::: pure$/;"	r
shrink	mat{intrinsic}.foo	/^   shrink(dim1,dim2) ::: leaky$/;"	r
shrink_columns	mat{intrinsic}.foo	/^   shrink_columns(dim2) ::: leaky$/;"	r
expand	mat{intrinsic}.foo	/^   expand(dim1,dim2) ::: leaky$/;"	r
expand_columns	mat{intrinsic}.foo	/^   expand_columns(dim2) ::: leaky$/;"	r
append_columns	mat{intrinsic}.foo	/^   append_columns(cols) ::: leaky$/;"	r
append_column	mat{intrinsic}.foo	/^   append_column(col) ::: leaky$/;"	r
prune_column	mat{intrinsic}.foo	/^   prune_column(col) ::: leaky$/;"	r
equals	mat{intrinsic}.foo	/^   equals(b) result (res)$/;"	r
same_as	mat{intrinsic}.foo	/^   same_as(b,eps,diff) result (res)$/;"	r
all_in_range	mat{intrinsic}.foo	/^   all_in_range(range) result (res)$/;"	r
in_range	mat{intrinsic}.foo	/^   in_range(range) result (res)$/;"	r
range	mat{intrinsic}.foo	/^   range result (res)$/;"	r
is_diagonal	mat{intrinsic}.foo	/^   is_diagonal result (res)$/;"	r
self	mat{intrinsic}.foo	/^     self :: IN$/;"	a
res	mat{intrinsic}.foo	/^     res :: BIN$/;"	a
is_diagonal	mat{intrinsic}.foo	/^   is_diagonal(eps) result (res)$/;"	r
self	mat{intrinsic}.foo	/^     self :: IN$/;"	a
eps	mat{intrinsic}.foo	/^     eps :: REAL, IN, optional$/;"	a
res	mat{intrinsic}.foo	/^     res :: BIN$/;"	a
has_unit_diagonal	mat{intrinsic}.foo	/^   has_unit_diagonal result (res)$/;"	r
self	mat{intrinsic}.foo	/^     self :: IN$/;"	a
res	mat{intrinsic}.foo	/^     res :: BIN$/;"	a
has_unit_diagonal	mat{intrinsic}.foo	/^   has_unit_diagonal(eps) result (res)$/;"	r
self	mat{intrinsic}.foo	/^     self :: IN$/;"	a
eps	mat{intrinsic}.foo	/^     eps :: REAL, IN, optional$/;"	a
res	mat{intrinsic}.foo	/^     res :: BIN$/;"	a
has_minus_unit_diagonal	mat{intrinsic}.foo	/^   has_minus_unit_diagonal result (res)$/;"	r
is_unit_matrix	mat{intrinsic}.foo	/^   is_unit_matrix result (res)$/;"	r
self	mat{intrinsic}.foo	/^     self :: IN$/;"	a
res	mat{intrinsic}.foo	/^     res :: BIN$/;"	a
is_unit_matrix	mat{intrinsic}.foo	/^   is_unit_matrix(eps) result (res)$/;"	r
self	mat{intrinsic}.foo	/^     self :: IN$/;"	a
eps	mat{intrinsic}.foo	/^     eps :: REAL, IN, optional$/;"	a
res	mat{intrinsic}.foo	/^     res :: BIN$/;"	a
is_inversion_matrix	mat{intrinsic}.foo	/^   is_inversion_matrix result (res)$/;"	r
is_symmetric	mat{intrinsic}.foo	/^   is_symmetric result (res)$/;"	r
is_antisymmetric	mat{intrinsic}.foo	/^   is_antisymmetric result (res)$/;"	r
is_zero	mat{intrinsic}.foo	/^   is_zero(eps) result (res) ::: pure$/;"	r
has_column	mat{intrinsic}.foo	/^   has_column(c,col) result (res)$/;"	r
has_column	mat{intrinsic}.foo	/^   has_column(c,eps,col) result (res)$/;"	r
column_index	mat{intrinsic}.foo	/^   column_index(c) result (res)$/;"	r
column_index	mat{intrinsic}.foo	/^   column_index(c,eps) result (res)$/;"	r
compare_columns_with	mat{intrinsic}.foo	/^   compare_columns_with(m,col)$/;"	r
unique_columns	mat{intrinsic}.foo	/^   unique_columns(col)$/;"	r
unique_columns	mat{intrinsic}.foo	/^   unique_columns(col) ::: leaky$/;"	r
no_of_unique_columns	mat{intrinsic}.foo	/^   no_of_unique_columns result (res)$/;"	r
swap_columns	mat{intrinsic}.foo	/^   swap_columns(col1,col2)$/;"	r
swap_columns	mat{intrinsic}.foo	/^   swap_columns(list)$/;"	r
column_norms	mat{intrinsic}.foo	/^   column_norms result (res)$/;"	r
get_column_norms	mat{intrinsic}.foo	/^   get_column_norms(res)$/;"	r
get_column_dot_products	mat{intrinsic}.foo	/^   get_column_dot_products(res)$/;"	r
index_of_minimum_column_norm	mat{intrinsic}.foo	/^   index_of_minimum_column_norm(offset) result (res)$/;"	r
max_abs_column_difference	mat{intrinsic}.foo	/^   max_abs_column_difference result (res)$/;"	r
mean_column_vector	mat{intrinsic}.foo	/^   mean_column_vector result (res)$/;"	r
sum_column_vectors	mat{intrinsic}.foo	/^   sum_column_vectors result (res)$/;"	r
reverse_column_order	mat{intrinsic}.foo	/^   reverse_column_order$/;"	r
unique_rows	mat{intrinsic}.foo	/^   unique_rows(row)$/;"	r
unique_rows	mat{intrinsic}.foo	/^   unique_rows(row) ::: leaky$/;"	r
no_of_unique_rows	mat{intrinsic}.foo	/^   no_of_unique_rows result (res)$/;"	r
swap_rows	mat{intrinsic}.foo	/^   swap_rows(row1,row2)$/;"	r
swap_rows	mat{intrinsic}.foo	/^   swap_rows(list)$/;"	r
row_norms	mat{intrinsic}.foo	/^   row_norms result (res)$/;"	r
sum_row_vectors	mat{intrinsic}.foo	/^   sum_row_vectors result (res)$/;"	r
determinant	mat{intrinsic}.foo	/^   determinant result (res)$/;"	r
cofactor	mat{intrinsic}.foo	/^   cofactor result (res) ::: leaky$/;"	r
dot	mat{intrinsic}.foo	/^   dot(l,r) result (res)$/;"	r
rotate	mat{intrinsic}.foo	/^   rotate(v)$/;"	r
to_unit_matrix	mat{intrinsic}.foo	/^   to_unit_matrix$/;"	r
zero_small_values	mat{intrinsic}.foo	/^   zero_small_values(eps) ::: pure$/;"	r
set_to	mat{intrinsic}.foo	/^   set_to(a)$/;"	r
set_to_transpose_of	mat{intrinsic}.foo	/^   set_to_transpose_of(a)$/;"	r
to_transpose	mat{intrinsic}.foo	/^   to_transpose$/;"	r
plus	mat{intrinsic}.foo	/^   plus(a)$/;"	r
minus	mat{intrinsic}.foo	/^   minus(a)$/;"	r
to_scaled	mat{intrinsic}.foo	/^   to_scaled(a,fac)$/;"	r
plus_scaled	mat{intrinsic}.foo	/^   plus_scaled(a,fac)$/;"	r
minus_scaled	mat{intrinsic}.foo	/^   minus_scaled(a,fac)$/;"	r
to_product_of	mat{intrinsic}.foo	/^   to_product_of(a,b,transpose_a,transpose_b)$/;"	r
to_product_of	mat{intrinsic}.foo	/^   to_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b)$/;"	r
to_product_of	mat{intrinsic}.foo	/^   to_product_of(a,b,dagger_a,transpose_b)$/;"	r
to_product_of	mat{intrinsic}.foo	/^   to_product_of(a,b,transpose_a,dagger_b)$/;"	r
plus_product_of	mat{intrinsic}.foo	/^   plus_product_of(a,b,transpose_a,transpose_b)$/;"	r
plus_product_of	mat{intrinsic}.foo	/^   plus_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b)$/;"	r
plus_product_of	mat{intrinsic}.foo	/^   plus_product_of(a,b,dagger_a,transpose_b)$/;"	r
plus_product_of	mat{intrinsic}.foo	/^   plus_product_of(a,b,transpose_a,dagger_b)$/;"	r
to_scaled_product_of	mat{intrinsic}.foo	/^   to_scaled_product_of(a,b,fac,transpose_a,transpose_b)$/;"	r
to_scaled_product_of	mat{intrinsic}.foo	/^   to_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b)$/;"	r
to_scaled_product_of	mat{intrinsic}.foo	/^   to_scaled_product_of(a,b,fac,dagger_a,transpose_b)$/;"	r
to_scaled_product_of	mat{intrinsic}.foo	/^   to_scaled_product_of(a,b,fac,transpose_a,dagger_b)$/;"	r
plus_scaled_product_of	mat{intrinsic}.foo	/^   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b)$/;"	r
plus_scaled_product_of	mat{intrinsic}.foo	/^   plus_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b)$/;"	r
plus_scaled_product_of	mat{intrinsic}.foo	/^   plus_scaled_product_of(a,b,fac,dagger_a,transpose_b)$/;"	r
plus_scaled_product_of	mat{intrinsic}.foo	/^   plus_scaled_product_of(a,b,fac,transpose_a,dagger_b)$/;"	r
to_outer_product_of	mat{intrinsic}.foo	/^   to_outer_product_of(a,fac)$/;"	r
plus_outer_product_of	mat{intrinsic}.foo	/^   plus_outer_product_of(a,fac)$/;"	r
to_product_with_diagonal	mat{intrinsic}.foo	/^   to_product_with_diagonal(a,diag,transpose_a)$/;"	r
to_product_with_diagonal	mat{intrinsic}.foo	/^   to_product_with_diagonal(a,diag,dagger_a,transpose_a)$/;"	r
to_product_with_diagonal	mat{intrinsic}.foo	/^   to_product_with_diagonal(dg,a,transpose_a)$/;"	r
to_product_with_diagonal	mat{intrinsic}.foo	/^   to_product_with_diagonal(dg,a,dagger_a,transpose_a)$/;"	r
trace	mat{intrinsic}.foo	/^   trace result (res)$/;"	r
trace_product_with	mat{intrinsic}.foo	/^   trace_product_with(a,transpose_a) result (res)$/;"	r
trace_product_with	mat{intrinsic}.foo	/^   trace_product_with(a,transpose_a,dagger_a) result (res)$/;"	r
trace_product_with	mat{intrinsic}.foo	/^   trace_product_with(a,b,c) result (res)$/;"	r
trace_product_with	mat{intrinsic}.foo	/^   trace_product_with(a,b,c,d,e) result (res)$/;"	r
change_basis_using	mat{intrinsic}.foo	/^   change_basis_using(V)$/;"	r
change_basis_using	mat{intrinsic}.foo	/^   change_basis_using(V)$/;"	r
change_basis_using	mat{intrinsic}.foo	/^   change_basis_using(L,R)$/;"	r
change_basis_using	mat{intrinsic}.foo	/^   change_basis_using(L,R)$/;"	r
change_basis_to	mat{intrinsic}.foo	/^   change_basis_to(new,V)$/;"	r
change_basis_to	mat{intrinsic}.foo	/^   change_basis_to(new,V)$/;"	r
change_basis_to	mat{intrinsic}.foo	/^   change_basis_to(new,L,R)$/;"	r
back_transform_using	mat{intrinsic}.foo	/^   back_transform_using(V)$/;"	r
back_transform_to	mat{intrinsic}.foo	/^   back_transform_to(new,V)$/;"	r
back_transform_to	mat{intrinsic}.foo	/^   back_transform_to(new,V)$/;"	r
back_transform_to	mat{intrinsic}.foo	/^   back_transform_to(new,L,R)$/;"	r
similarity_transform	mat{intrinsic}.foo	/^   similarity_transform(V)$/;"	r
set_from_diagonal	mat{intrinsic}.foo	/^   set_from_diagonal(d)$/;"	r
set_diagonal_to	mat{intrinsic}.foo	/^   set_diagonal_to(d)$/;"	r
set_diagonal_to	mat{intrinsic}.foo	/^   set_diagonal_to(val)$/;"	r
put_diagonal_to	mat{intrinsic}.foo	/^   put_diagonal_to(d)$/;"	r
increment_diagonal_by	mat{intrinsic}.foo	/^   increment_diagonal_by(val)$/;"	r
increment_diagonal_by	mat{intrinsic}.foo	/^   increment_diagonal_by(d)$/;"	r
scale_diagonal_by	mat{intrinsic}.foo	/^   scale_diagonal_by(fac)$/;"	r
zero_diagonal	mat{intrinsic}.foo	/^   zero_diagonal$/;"	r
zero_off_diagonal	mat{intrinsic}.foo	/^   zero_off_diagonal$/;"	r
max_diagonal_element	mat{intrinsic}.foo	/^   max_diagonal_element result (res)$/;"	r
max_abs_diagonal_element	mat{intrinsic}.foo	/^   max_abs_diagonal_element result (res)$/;"	r
diagonal_set_to	mat{intrinsic}.foo	/^   diagonal_set_to(d)$/;"	r
diagonal_set_to	mat{intrinsic}.foo	/^   diagonal_set_to(val)$/;"	r
diagonal_set_to	mat{intrinsic}.foo	/^   diagonal_set_to(d)$/;"	r
diagonal_plus	mat{intrinsic}.foo	/^   diagonal_plus(val)$/;"	r
diagonal_plus	mat{intrinsic}.foo	/^   diagonal_plus(d)$/;"	r
diagonal_times	mat{intrinsic}.foo	/^   diagonal_times(fac)$/;"	r
diagonal_max	mat{intrinsic}.foo	/^   diagonal_max result (res)$/;"	r
diagonal_max_abs	mat{intrinsic}.foo	/^   diagonal_max_abs result (res)$/;"	r
symmetrize	mat{intrinsic}.foo	/^   symmetrize$/;"	r
antisymmetrize	mat{intrinsic}.foo	/^   antisymmetrize$/;"	r
symmetric_fold	mat{intrinsic}.foo	/^   symmetric_fold$/;"	r
antisymmetric_fold	mat{intrinsic}.foo	/^   antisymmetric_fold$/;"	r
symmetric_reflect	mat{intrinsic}.foo	/^   symmetric_reflect$/;"	r
antisymmetric_reflect	mat{intrinsic}.foo	/^   antisymmetric_reflect$/;"	r
symmetric_fold_to_triangle	mat{intrinsic}.foo	/^   symmetric_fold_to_triangle(tr)$/;"	r
compress_to_triangle	mat{intrinsic}.foo	/^   compress_to_triangle(tr)$/;"	r
uncompress_from_triangle	mat{intrinsic}.foo	/^   uncompress_from_triangle(tr)$/;"	r
uncompress_anti_triangle	mat{intrinsic}.foo	/^   uncompress_anti_triangle(tr)$/;"	r
tri_size	mat{intrinsic}.foo	/^   tri_size result (ltr)$/;"	r
unflatten	mat{intrinsic}.foo	/^   unflatten(vec_mat)$/;"	r
vec_mat	mat{intrinsic}.foo	/^     vec_mat :: VEC{MAT_{REAL}}*$/;"	a
counter	mat{intrinsic}.foo	/^     counter :: INT$/;"	a
schmidt_orthonormalise	mat{intrinsic}.foo	/^   schmidt_orthonormalise(S,scales)$/;"	r
scales	mat{intrinsic}.foo	/^     scales :: VEC{REAL}$/;"	a
fac	mat{intrinsic}.foo	/^     fac :: INTRINSIC$/;"	a
is_linearly_dependent	mat{intrinsic}.foo	/^   is_linearly_dependent(S,tol,col) result (res)$/;"	r
schmidt_orthonormalise	mat{intrinsic}.foo	/^   schmidt_orthonormalise(scale)$/;"	r
scale	mat{intrinsic}.foo	/^     scale :: REAL, optional$/;"	a
fac	mat{intrinsic}.foo	/^     fac :: INTRINSIC$/;"	a
norm	mat{intrinsic}.foo	/^     norm :: REAL$/;"	a
schmidt_orthonormalise	mat{intrinsic}.foo	/^   schmidt_orthonormalise(S,scale)$/;"	r
schmidt_orthonormalise	mat{intrinsic}.foo	/^   schmidt_orthonormalise(S,from,to)$/;"	r
reverse_schmidt_orthonormalise	mat{intrinsic}.foo	/^   reverse_schmidt_orthonormalise(S)$/;"	r
reverse_schmidt_orthogonalise	mat{intrinsic}.foo	/^   reverse_schmidt_orthogonalise$/;"	r
symmetrically_orthonormalise	mat{intrinsic}.foo	/^   symmetrically_orthonormalise(S)$/;"	r
make_diagonally_dominant	mat{intrinsic}.foo	/^   make_diagonally_dominant(permutation)$/;"	r
schmidt_orthonormalise	mat{intrinsic}.foo	/^   schmidt_orthonormalise(S,scale)$/;"	r
to_power_series_inverse_of	mat{intrinsic}.foo	/^   to_power_series_inverse_of(S,tol,max_it)$/;"	r
to_power_series_inv_sqrt_of	mat{intrinsic}.foo	/^   to_power_series_inv_sqrt_of(S,tol,prefactor,max_it)$/;"	r
to_exponential_of	mat{intrinsic}.foo	/^   to_exponential_of(X,tol)$/;"	r
exponentiate_to	mat{intrinsic}.foo	/^   exponentiate_to(U,tol)$/;"	r
antisymmetric_exponential_to	mat{intrinsic}.foo	/^   antisymmetric_exponential_to(U,eval,evec)$/;"	r
str_lengths	mat{intrinsic}.foo	/^   str_lengths(spaces) result (res) ::: pure$/;"	r
str_length	mat{intrinsic}.foo	/^   str_length(spaces) result (res) ::: pure$/;"	r
str_lengths_with_precision	mat{intrinsic}.foo	/^   str_lengths_with_precision(dp,spaces) result (res) ::: pure$/;"	r
str_length_with_precision	mat{intrinsic}.foo	/^   str_length_with_precision(dp,spaces) result (res) ::: pure$/;"	r
alpha_alpha	mat{intrinsic}.foo	/^   alpha_alpha result (res)$/;"	r
beta_alpha	mat{intrinsic}.foo	/^   beta_alpha result (res)$/;"	r
alpha_beta	mat{intrinsic}.foo	/^   alpha_beta result (res)$/;"	r
beta_beta	mat{intrinsic}.foo	/^   beta_beta result (res)$/;"	r
alpha_alpha_set_to	mat{intrinsic}.foo	/^   alpha_alpha_set_to(X)$/;"	r
beta_alpha_set_to	mat{intrinsic}.foo	/^   beta_alpha_set_to(X)$/;"	r
alpha_beta_set_to	mat{intrinsic}.foo	/^   alpha_beta_set_to(X)$/;"	r
beta_beta_set_to	mat{intrinsic}.foo	/^   beta_beta_set_to(X)$/;"	r
alpha_alpha_set_to	mat{intrinsic}.foo	/^   alpha_alpha_set_to(X,fac)$/;"	r
beta_alpha_set_to	mat{intrinsic}.foo	/^   beta_alpha_set_to(X,fac)$/;"	r
alpha_beta_set_to	mat{intrinsic}.foo	/^   alpha_beta_set_to(X,fac)$/;"	r
beta_beta_set_to	mat{intrinsic}.foo	/^   beta_beta_set_to(X,fac)$/;"	r
alpha_alpha_put_to	mat{intrinsic}.foo	/^   alpha_alpha_put_to(X)$/;"	r
beta_alpha_put_to	mat{intrinsic}.foo	/^   beta_alpha_put_to(X)$/;"	r
alpha_beta_put_to	mat{intrinsic}.foo	/^   alpha_beta_put_to(X)$/;"	r
beta_beta_put_to	mat{intrinsic}.foo	/^   beta_beta_put_to(X)$/;"	r
alpha_alpha_plus	mat{intrinsic}.foo	/^   alpha_alpha_plus(X)$/;"	r
beta_alpha_plus	mat{intrinsic}.foo	/^   beta_alpha_plus(X)$/;"	r
alpha_beta_plus	mat{intrinsic}.foo	/^   alpha_beta_plus(X)$/;"	r
beta_beta_plus	mat{intrinsic}.foo	/^   beta_beta_plus(X)$/;"	r
alpha_alpha_plus	mat{intrinsic}.foo	/^   alpha_alpha_plus(X,fac)$/;"	r
beta_alpha_plus	mat{intrinsic}.foo	/^   beta_alpha_plus(X,fac)$/;"	r
alpha_beta_plus	mat{intrinsic}.foo	/^   alpha_beta_plus(X,fac)$/;"	r
beta_beta_plus	mat{intrinsic}.foo	/^   beta_beta_plus(X,fac)$/;"	r
put_blocks_to	mat{intrinsic}.foo	/^   put_blocks_to(X,block_dim,block_list)$/;"	r
put_sub_blocks_to	mat{intrinsic}.foo	/^   put_sub_blocks_to(X,block_dim,X_block_dim,block_list,X_block_offset)$/;"	r
create	mat{mat_{intrinsic}}.foo	/^   create(dim1,dim2) ::: leaky$/;"	r
destroy	mat{mat_{intrinsic}}.foo	/^   destroy ::: leaky$/;"	r
nullify_ptr_part	mat{mat_{intrinsic}}.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	mat{mat_{intrinsic}}.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	mat{mat_{intrinsic}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	mat{mat_{intrinsic}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	mat{mat_{intrinsic}}.foo	/^   create_copy(m) ::: leaky$/;"	r
copy	mat{mat_{intrinsic}}.foo	/^   copy(m) ::: leaky$/;"	r
create	mat{mat_{real}}.foo	/^   create(dim1,dim2) ::: get_from(MAT{MAT_{INTRINSIC}}), leaky$/;"	r
destroy	mat{mat_{real}}.foo	/^   destroy ::: get_from(MAT{MAT_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	mat{mat_{real}}.foo	/^   nullify_ptr_part ::: get_from(MAT{MAT_{INTRINSIC}})$/;"	r
destroy_ptr_part	mat{mat_{real}}.foo	/^   destroy_ptr_part ::: get_from(MAT{MAT_{INTRINSIC}}), leaky$/;"	r
created	mat{mat_{real}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	mat{mat_{real}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	mat{mat_{real}}.foo	/^   create_copy(m) ::: get_from(MAT{MAT_{INTRINSIC}}), leaky$/;"	r
copy	mat{mat_{real}}.foo	/^   copy(m) ::: get_from(MAT{MAT_{INTRINSIC}}), leaky$/;"	r
create	mat{object}.foo	/^   create(dim1,dim2) ::: leaky$/;"	r
create	mat{object}.foo	/^   create(dim1,dim2) ::: leaky$/;"	r
create	mat{object}.foo	/^   create(lb1,ub1,lb2,ub2) ::: leaky$/;"	r
create	mat{object}.foo	/^   create(lb1,ub1,lb2,ub2) ::: leaky$/;"	r
destroy	mat{object}.foo	/^   destroy ::: leaky$/;"	r
created	mat{object}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	mat{object}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
nullify_ptr_part	mat{object}.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	mat{object}.foo	/^   destroy_ptr_part ::: leaky$/;"	r
create_copy	mat{object}.foo	/^   create_copy(matrix) ::: leaky$/;"	r
copy	mat{object}.foo	/^   copy(matrix) ::: leaky$/;"	r
set_defaults	mat{object}.foo	/^   set_defaults$/;"	r
size	mat{object}.foo	/^   size result (res) ::: inlined_by_foo$/;"	r
dim1	mat{object}.foo	/^   dim1 result (res) ::: inlined_by_foo$/;"	r
dim2	mat{object}.foo	/^   dim2 result (res) ::: inlined_by_foo$/;"	r
shape	mat{object}.foo	/^   shape result (res)$/;"	r
is_same_shape_as	mat{object}.foo	/^   is_same_shape_as(a) result (res) ::: pure$/;"	r
is_transposed_shape_of	mat{object}.foo	/^   is_transposed_shape_of(a) result (res) ::: pure$/;"	r
is_square	mat{object}.foo	/^   is_square result (res) ::: pure$/;"	r
saved_reference	mat{real}.foo	/^   saved_reference :: MAT{REAL}*, private   DEFAULT_NULL$/;"	g
saved_actual	mat{real}.foo	/^   saved_actual    :: MAT{REAL}*, private   DEFAULT_NULL$/;"	g
create	mat{real}.foo	/^   create(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{real}.foo	/^   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{real}.foo	/^   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{real}.foo	/^   create(bounds1,bounds2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{real}.foo	/^   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create_copy	mat{real}.foo	/^   create_copy(matrix) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
destroy	mat{real}.foo	/^   destroy ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
created	mat{real}.foo	/^   created result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat{real}.foo	/^   destroyed result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
size	mat{real}.foo	/^   size result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat{real}.foo	/^   dim1 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat{real}.foo	/^   dim2 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat{real}.foo	/^   shape result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_same_shape_as	mat{real}.foo	/^   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}), pure$/;"	r
is_transposed_shape_of	mat{real}.foo	/^   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}), pure$/;"	r
is_square	mat{real}.foo	/^   is_square result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
shrink	mat{real}.foo	/^   shrink(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
expand	mat{real}.foo	/^   expand(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
shrink_columns	mat{real}.foo	/^   shrink_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
expand_columns	mat{real}.foo	/^   expand_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
append_columns	mat{real}.foo	/^   append_columns(cols) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
append_column	mat{real}.foo	/^   append_column(col) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
prune_column	mat{real}.foo	/^   prune_column(col) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
equals	mat{real}.foo	/^   equals(b) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
same_as	mat{real}.foo	/^   same_as(b,eps,diff) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
all_in_range	mat{real}.foo	/^   all_in_range(range) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
in_range	mat{real}.foo	/^   in_range(range) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
range	mat{real}.foo	/^   range result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_diagonal	mat{real}.foo	/^   is_diagonal(eps) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
has_unit_diagonal	mat{real}.foo	/^   has_unit_diagonal(eps) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
has_minus_unit_diagonal	mat{real}.foo	/^   has_minus_unit_diagonal result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_unit_matrix	mat{real}.foo	/^   is_unit_matrix(eps) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_inversion_matrix	mat{real}.foo	/^   is_inversion_matrix result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_symmetric	mat{real}.foo	/^   is_symmetric result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_antisymmetric	mat{real}.foo	/^   is_antisymmetric result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_zero	mat{real}.foo	/^   is_zero(eps) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
has_column	mat{real}.foo	/^   has_column(c,eps,col) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
column_index	mat{real}.foo	/^   column_index(c,eps) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
compare_columns_with	mat{real}.foo	/^   compare_columns_with(m,col) ::: get_from(MAT{INTRINSIC})$/;"	r
unique_columns	mat{real}.foo	/^   unique_columns(col) ::: get_from(MAT{INTRINSIC})$/;"	r
unique_columns	mat{real}.foo	/^   unique_columns(col) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
no_of_unique_columns	mat{real}.foo	/^   no_of_unique_columns result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
swap_columns	mat{real}.foo	/^   swap_columns(col1,col2) ::: get_from(MAT{INTRINSIC})$/;"	r
swap_columns	mat{real}.foo	/^   swap_columns(list) ::: get_from(MAT{INTRINSIC})$/;"	r
column_norms	mat{real}.foo	/^   column_norms result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
get_column_norms	mat{real}.foo	/^   get_column_norms(res) ::: get_from(MAT{INTRINSIC})$/;"	r
get_column_dot_products	mat{real}.foo	/^   get_column_dot_products(res) ::: get_from(MAT{INTRINSIC})$/;"	r
index_of_minimum_column_norm	mat{real}.foo	/^   index_of_minimum_column_norm(offset) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
max_abs_column_difference	mat{real}.foo	/^   max_abs_column_difference result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
mean_column_vector	mat{real}.foo	/^   mean_column_vector result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
sum_column_vectors	mat{real}.foo	/^   sum_column_vectors result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
reverse_column_order	mat{real}.foo	/^   reverse_column_order ::: get_from(MAT{INTRINSIC})$/;"	r
unique_rows	mat{real}.foo	/^   unique_rows(row) ::: get_from(MAT{INTRINSIC})$/;"	r
unique_rows	mat{real}.foo	/^   unique_rows(row) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
no_of_unique_rows	mat{real}.foo	/^   no_of_unique_rows result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
swap_rows	mat{real}.foo	/^   swap_rows(row1,row2) ::: get_from(MAT{INTRINSIC})$/;"	r
swap_rows	mat{real}.foo	/^   swap_rows(list) ::: get_from(MAT{INTRINSIC})$/;"	r
row_norms	mat{real}.foo	/^   row_norms result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
sum_row_vectors	mat{real}.foo	/^   sum_row_vectors result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
determinant	mat{real}.foo	/^   determinant result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
cofactor	mat{real}.foo	/^   cofactor result (res) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
dot	mat{real}.foo	/^   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{REAL}, RES_TYPE=>REAL)$/;"	r
dot	mat{real}.foo	/^   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{CPX}, RES_TYPE=>CPX)$/;"	r
rotate	mat{real}.foo	/^   rotate(v) ::: get_from(MAT{INTRINSIC})$/;"	r
jacobi_rotation	mat{real}.foo	/^   jacobi_rotation(p,q)$/;"	r
jacobi_rotation	mat{real}.foo	/^   jacobi_rotation(p,q,v)$/;"	r
to_unit_matrix	mat{real}.foo	/^   to_unit_matrix ::: get_from(MAT{INTRINSIC})$/;"	r
to_3x3_rotation_matrix	mat{real}.foo	/^   to_3x3_rotation_matrix(axis,angle) $/;"	r
zero_small_values	mat{real}.foo	/^   zero_small_values(eps) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
set_to	mat{real}.foo	/^   set_to(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})$/;"	r
set_to_transpose_of	mat{real}.foo	/^   set_to_transpose_of(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})$/;"	r
to_transpose	mat{real}.foo	/^   to_transpose ::: get_from(MAT{INTRINSIC})$/;"	r
plus	mat{real}.foo	/^   plus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})$/;"	r
minus	mat{real}.foo	/^   minus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})$/;"	r
to_scaled	mat{real}.foo	/^   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
plus_scaled	mat{real}.foo	/^   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
minus_scaled	mat{real}.foo	/^   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
to_product_of	mat{real}.foo	/^   to_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL})$/;"	r
plus_product_of	mat{real}.foo	/^   plus_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL})$/;"	r
to_scaled_product_of	mat{real}.foo	/^   to_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
plus_scaled_product_of	mat{real}.foo	/^   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
to_outer_product_of	mat{real}.foo	/^   to_outer_product_of(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>REAL, FAC_TYPE=>REAL)$/;"	r
plus_outer_product_of	mat{real}.foo	/^   plus_outer_product_of(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>REAL, FAC_TYPE=>REAL)$/;"	r
to_product_with_diagonal	mat{real}.foo	/^   to_product_with_diagonal(a,diag,transpose_a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, DIAG_TYPE=>VEC{REAL})$/;"	r
to_product_with_diagonal	mat{real}.foo	/^   to_product_with_diagonal(dg,a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{REAL}, A_TYPE=>MAT{REAL})$/;"	r
trace	mat{real}.foo	/^   trace result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
trace_product_with	mat{real}.foo	/^   trace_product_with(a,transpose_a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, RES_TYPE=>REAL, CAST=>)$/;"	r
dot	mat{real}.foo	/^   dot(a) result (res) $/;"	r
trace_product_with	mat{real}.foo	/^   trace_product_with(a,b,c) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
trace_product_with	mat{real}.foo	/^   trace_product_with(a,b,c,d,e) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
change_basis_using	mat{real}.foo	/^   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})$/;"	r
change_basis_using	mat{real}.foo	/^   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>VEC{REAL})$/;"	r
change_basis_using	mat{real}.foo	/^   change_basis_using(L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{REAL})$/;"	r
change_basis_using	mat{real}.foo	/^   change_basis_using(L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{REAL})$/;"	r
change_basis_to	mat{real}.foo	/^   change_basis_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})$/;"	r
change_basis_to	mat{real}.foo	/^   change_basis_to(new,V) ::: get_from(MAT{INTRINSIC}, NEW_TYPE=>MAT{CPX}, V_TYPE=>MAT{CPX})$/;"	r
change_basis_to	mat{real}.foo	/^   change_basis_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{REAL})$/;"	r
back_transform_using	mat{real}.foo	/^   back_transform_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})$/;"	r
back_transform_to	mat{real}.foo	/^   back_transform_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})$/;"	r
back_transform_to	mat{real}.foo	/^   back_transform_to(new,V) ::: get_from(MAT{INTRINSIC}, NEW_TYPE=>MAT{CPX}, V_TYPE=>MAT{CPX})$/;"	r
back_transform_to	mat{real}.foo	/^   back_transform_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{REAL})$/;"	r
similarity_transform	mat{real}.foo	/^   similarity_transform(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})$/;"	r
to_tensor_change_basis_of	mat{real}.foo	/^   to_tensor_change_basis_of(V,reorder)$/;"	r
to_tensor_back_transform_of	mat{real}.foo	/^   to_tensor_back_transform_of(V,reorder)$/;"	r
set_from_diagonal	mat{real}.foo	/^   set_from_diagonal(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{REAL})$/;"	r
set_diagonal_to	mat{real}.foo	/^   set_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{REAL})$/;"	r
set_diagonal_to	mat{real}.foo	/^   set_diagonal_to(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>REAL)$/;"	r
put_diagonal_to	mat{real}.foo	/^   put_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{REAL})$/;"	r
increment_diagonal_by	mat{real}.foo	/^   increment_diagonal_by(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>REAL)$/;"	r
scale_diagonal_by	mat{real}.foo	/^   scale_diagonal_by(fac) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)$/;"	r
zero_diagonal	mat{real}.foo	/^   zero_diagonal ::: get_from(MAT{INTRINSIC})$/;"	r
zero_off_diagonal	mat{real}.foo	/^   zero_off_diagonal ::: get_from(MAT{INTRINSIC})$/;"	r
max_diagonal_element	mat{real}.foo	/^   max_diagonal_element result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
max_abs_diagonal_element	mat{real}.foo	/^   max_abs_diagonal_element result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
symmetrize	mat{real}.foo	/^   symmetrize ::: get_from(MAT{INTRINSIC})$/;"	r
antisymmetrize	mat{real}.foo	/^   antisymmetrize ::: get_from(MAT{INTRINSIC})$/;"	r
symmetric_fold	mat{real}.foo	/^   symmetric_fold ::: get_from(MAT{INTRINSIC})$/;"	r
antisymmetric_fold	mat{real}.foo	/^   antisymmetric_fold ::: get_from(MAT{INTRINSIC})$/;"	r
symmetric_reflect	mat{real}.foo	/^   symmetric_reflect ::: get_from(MAT{INTRINSIC})$/;"	r
antisymmetric_reflect	mat{real}.foo	/^   antisymmetric_reflect ::: get_from(MAT{INTRINSIC})$/;"	r
symmetric_fold_to_triangle	mat{real}.foo	/^   symmetric_fold_to_triangle(tr) ::: get_from(MAT{INTRINSIC})$/;"	r
compress_to_triangle	mat{real}.foo	/^   compress_to_triangle(tr) ::: get_from(MAT{INTRINSIC})$/;"	r
uncompress_from_triangle	mat{real}.foo	/^   uncompress_from_triangle(tr) ::: get_from(MAT{INTRINSIC})$/;"	r
uncompress_anti_triangle	mat{real}.foo	/^   uncompress_anti_triangle(tr) ::: get_from(MAT{INTRINSIC})$/;"	r
tri_size	mat{real}.foo	/^   tri_size result (ltr) ::: get_from(MAT{INTRINSIC})$/;"	r
flatten	mat{real}.foo	/^   flatten(vec)$/;"	r
vec	mat{real}.foo	/^     vec :: VEC{REAL}*$/;"	a
counter	mat{real}.foo	/^     counter :: INT$/;"	a
unflatten	mat{real}.foo	/^   unflatten(vec_mat)$/;"	r
vec_mat	mat{real}.foo	/^     vec_mat :: VEC{MAT_{REAL}}, INOUT$/;"	a
counter	mat{real}.foo	/^     counter :: INT$/;"	a
unflatten_triplets	mat{real}.foo	/^   unflatten_triplets(vec_mat)$/;"	r
vec_mat	mat{real}.foo	/^     vec_mat :: VEC{MAT_{REAL}}, INOUT$/;"	a
counter	mat{real}.foo	/^     counter :: INT$/;"	a
schmidt_orthonormalise	mat{real}.foo	/^   schmidt_orthonormalise(lambda)$/;"	r
lambda	mat{real}.foo	/^     lambda :: VEC{REAL}, IN$/;"	a
schmidt_orthonormalise	mat{real}.foo	/^   schmidt_orthonormalise(S,scales,n_dependent,ld_tol)$/;"	r
scales	mat{real}.foo	/^     scales :: VEC{REAL}, OUT$/;"	a
n_dependent	mat{real}.foo	/^     n_dependent :: INT, OUT$/;"	a
ld_tol	mat{real}.foo	/^     ld_tol :: REAL, optional$/;"	a
decreasing_vec	mat{real}.foo	/^     decreasing_vec :: MAT{REAL}*$/;"	a
keep	mat{real}.foo	/^     keep :: VEC{REAL}*$/;"	a
fac	mat{real}.foo	/^     fac :: REAL$/;"	a
tol	mat{real}.foo	/^     tol :: REAL$/;"	a
norm	mat{real}.foo	/^     norm :: REAL$/;"	a
skip	mat{real}.foo	/^     skip :: VEC{BIN}*$/;"	a
schmidt_orthonormalise	mat{real}.foo	/^   schmidt_orthonormalise(S,indices,scales,n_dependent,ld_tol) ::: leaky$/;"	r
indices	mat{real}.foo	/^     indices :: VEC{INT}*$/;"	a
scales	mat{real}.foo	/^     scales :: VEC{REAL}, OUT$/;"	a
n_dependent	mat{real}.foo	/^     n_dependent :: INT, OUT$/;"	a
ld_tol	mat{real}.foo	/^     ld_tol :: REAL, optional$/;"	a
decreasing_vec	mat{real}.foo	/^     decreasing_vec :: MAT{REAL}*$/;"	a
keep	mat{real}.foo	/^     keep :: VEC{REAL}*$/;"	a
fac	mat{real}.foo	/^     fac :: REAL$/;"	a
tol	mat{real}.foo	/^     tol :: REAL$/;"	a
norm	mat{real}.foo	/^     norm :: REAL$/;"	a
skip	mat{real}.foo	/^     skip :: VEC{BIN}*$/;"	a
schmidt_2orthonormalise	mat{real}.foo	/^   schmidt_2orthonormalise(S,scales,n_dependent,bra_vec)$/;"	r
bra_vec	mat{real}.foo	/^     bra_vec :: VEC{MAT_{REAL}}*$/;"	a
scales	mat{real}.foo	/^     scales :: VEC{REAL}, OUT$/;"	a
n_dependent	mat{real}.foo	/^     n_dependent :: INT, OUT$/;"	a
decreasing_vec	mat{real}.foo	/^     decreasing_vec :: MAT{REAL}*$/;"	a
keep	mat{real}.foo	/^     keep :: VEC{REAL}*$/;"	a
fac	mat{real}.foo	/^     fac :: REAL$/;"	a
tol	mat{real}.foo	/^     tol :: REAL$/;"	a
norm	mat{real}.foo	/^     norm :: REAL$/;"	a
skip	mat{real}.foo	/^     skip :: VEC{BIN}*$/;"	a
hybrid_orthonormalise	mat{real}.foo	/^   hybrid_orthonormalise(S,scales,n_dependent)$/;"	r
scales	mat{real}.foo	/^     scales :: VEC{REAL}, OUT$/;"	a
n_dependent	mat{real}.foo	/^     n_dependent :: INT, OUT$/;"	a
decreasing_vec	mat{real}.foo	/^     decreasing_vec :: MAT{REAL}*$/;"	a
keep	mat{real}.foo	/^     keep :: VEC{REAL}*$/;"	a
indices	mat{real}.foo	/^     indices :: VEC{INT}*$/;"	a
fac	mat{real}.foo	/^     fac :: REAL$/;"	a
tol	mat{real}.foo	/^     tol :: REAL$/;"	a
norm	mat{real}.foo	/^     norm :: REAL$/;"	a
hybrid_2orthonormalise	mat{real}.foo	/^   hybrid_2orthonormalise(S,scales,n_dependent,bra_vec)$/;"	r
bra_vec	mat{real}.foo	/^     bra_vec :: VEC{MAT_{REAL}}*$/;"	a
scales	mat{real}.foo	/^     scales :: VEC{REAL}, OUT$/;"	a
n_dependent	mat{real}.foo	/^     n_dependent :: INT, OUT$/;"	a
decreasing_vec	mat{real}.foo	/^     decreasing_vec :: MAT{REAL}*$/;"	a
keep	mat{real}.foo	/^     keep :: VEC{REAL}*$/;"	a
indices	mat{real}.foo	/^     indices :: VEC{INT}*$/;"	a
fac	mat{real}.foo	/^     fac :: REAL$/;"	a
tol	mat{real}.foo	/^     tol :: REAL$/;"	a
norm	mat{real}.foo	/^     norm :: REAL$/;"	a
schmidt_orthonormalise	mat{real}.foo	/^   schmidt_orthonormalise(S,scales) ::: get_from(MAT{INTRINSIC})$/;"	r
scales	mat{real}.foo	/^     scales :: VEC{REAL}$/;"	a
is_linearly_dependent	mat{real}.foo	/^   is_linearly_dependent(S,tol,col) result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
schmidt_orthonormalise	mat{real}.foo	/^   schmidt_orthonormalise(scale) ::: get_from(MAT{INTRINSIC})$/;"	r
schmidt_orthonormalise	mat{real}.foo	/^   schmidt_orthonormalise(S,scale) ::: get_from(MAT{INTRINSIC})$/;"	r
schmidt_orthonormalise	mat{real}.foo	/^   schmidt_orthonormalise(S,from,to) ::: get_from(MAT{INTRINSIC})$/;"	r
reverse_schmidt_orthonormalise	mat{real}.foo	/^   reverse_schmidt_orthonormalise(S) ::: get_from(MAT{INTRINSIC})$/;"	r
reverse_schmidt_orthogonalise	mat{real}.foo	/^   reverse_schmidt_orthogonalise ::: get_from(MAT{INTRINSIC}, CAST=>)$/;"	r
symmetrically_orthonormalise	mat{real}.foo	/^   symmetrically_orthonormalise(S) ::: get_from(MAT{INTRINSIC})$/;"	r
make_diagonally_dominant	mat{real}.foo	/^   make_diagonally_dominant(permutation) ::: get_from(MAT{INTRINSIC})$/;"	r
diagonalise_by_jacobi	mat{real}.foo	/^   diagonalise_by_jacobi(eigenvalues,eps,max_iterations)$/;"	r
diagonalise_by_jacobi	mat{real}.foo	/^   diagonalise_by_jacobi(eigenvalues,eigenvectors,eps,max_iterations)$/;"	r
solve_eigenproblem	mat{real}.foo	/^   solve_eigenproblem(eigenvalues,eigenvectors)$/;"	r
solve_symmetric_eigenproblem	mat{real}.foo	/^   solve_symmetric_eigenproblem(eigenvalues,eigenvectors)$/;"	r
solve_symm_eigenproblem_ESSL	mat{real}.foo	/^   solve_symm_eigenproblem_ESSL(eigenvalues,eigenvectors) ::: private$/;"	r
solve_symm_eigenproblem_LAPACK	mat{real}.foo	/^   solve_symm_eigenproblem_LAPACK(eigenvalues,eigenvectors) ::: private$/;"	r
internal_vectors	mat{real}.foo	/^   internal_vectors(eigenvectors2,iv_tol) ::: leaky$/;"	r
eigenvectors2	mat{real}.foo	/^     eigenvectors2 :: MAT{REAL}*$/;"	a
iv_tol	mat{real}.foo	/^     iv_tol :: REAL, optional$/;"	a
eigenvalues	mat{real}.foo	/^     eigenvalues :: VEC{REAL}* $/;"	a
eigenvectors	mat{real}.foo	/^     eigenvectors :: MAT{REAL}*$/;"	a
tol	mat{real}.foo	/^     tol :: REAL$/;"	a
solve_linear_equation	mat{real}.foo	/^   solve_linear_equation(rhs,solution,fail)$/;"	r
solve_linear_equation_ESSL	mat{real}.foo	/^   solve_linear_equation_ESSL(rhs,solution) ::: private$/;"	r
solve_linear_equation_LAPACK	mat{real}.foo	/^   solve_linear_equation_LAPACK(rhs,solution,fail) ::: private$/;"	r
solve_linear_equations	mat{real}.foo	/^   solve_linear_equations(rhs,solution)$/;"	r
solve_linear_equations_ESSL	mat{real}.foo	/^   solve_linear_equations_ESSL(rhs,solution) ::: private$/;"	r
solve_linear_equations_LAPACK	mat{real}.foo	/^   solve_linear_equations_LAPACK(rhs,solution) ::: private$/;"	r
solve_convex_linear_equation	mat{real}.foo	/^   solve_convex_linear_equation(rhs,solution,plist,keep0,keep1,fail)$/;"	r
solve_ill_linear_equations	mat{real}.foo	/^   solve_ill_linear_equations(rhs,solution,tol_0,n_0,tol_near_0,n_near_0,eval_near_0,evec_near_0,delta,inverse,CM) ::: leaky$/;"	r
to_inverse_of	mat{real}.foo	/^   to_inverse_of(R)$/;"	r
to_inverse_of_ESSL	mat{real}.foo	/^   to_inverse_of_ESSL(R) ::: private$/;"	r
to_inverse_of_LAPACK	mat{real}.foo	/^   to_inverse_of_LAPACK(R) ::: private$/;"	r
to_sqrt_of	mat{real}.foo	/^   to_sqrt_of(R)$/;"	r
to_sqrt_of	mat{real}.foo	/^   to_sqrt_of(R_eval,R_evec,tol)$/;"	r
to_inverse_sqrt_of	mat{real}.foo	/^   to_inverse_sqrt_of(R,tol,n_small)$/;"	r
to_inverse_sqrt_of	mat{real}.foo	/^   to_inverse_sqrt_of(R_eval,R_evec,tol,n_small)$/;"	r
to_power_series_inverse_of	mat{real}.foo	/^   to_power_series_inverse_of(S,tol,max_it) ::: get_from(MAT{INTRINSIC})$/;"	r
to_power_series_inv_sqrt_of	mat{real}.foo	/^   to_power_series_inv_sqrt_of(S,tol,prefactor,max_it) ::: get_from(MAT{INTRINSIC})$/;"	r
to_power_product_inverse_of	mat{real}.foo	/^   to_power_product_inverse_of(S,tol,prefactor,max_it)$/;"	r
to_power_product_inv_sqrt_of	mat{real}.foo	/^   to_power_product_inv_sqrt_of(S,tol,prefactor,max_it)$/;"	r
to_exponential_of	mat{real}.foo	/^   to_exponential_of(X,tol) ::: get_from(MAT{INTRINSIC})$/;"	r
exponentiate_to	mat{real}.foo	/^   exponentiate_to(U,tol) ::: get_from(MAT{INTRINSIC})$/;"	r
antisymmetric_exponential_to	mat{real}.foo	/^   antisymmetric_exponential_to(U,eval,evec) ::: get_from(MAT{INTRINSIC})$/;"	r
to_matching_rotation	mat{real}.foo	/^   to_matching_rotation(reference,actual,L,fail)$/;"	r
match_vectors	mat{real}.foo	/^   match_vectors(Xv,L,dL) ::: selfless, public$/;"	r
str_lengths_with_precision	mat{real}.foo	/^   str_lengths_with_precision(dp,spaces) result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
str_length_with_precision	mat{real}.foo	/^   str_length_with_precision(dp,spaces) result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
alpha_alpha	mat{real}.foo	/^   alpha_alpha result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
beta_alpha	mat{real}.foo	/^   beta_alpha result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
alpha_beta	mat{real}.foo	/^   alpha_beta result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
beta_beta	mat{real}.foo	/^   beta_beta result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
alpha_alpha_set_to	mat{real}.foo	/^   alpha_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
beta_alpha_set_to	mat{real}.foo	/^   beta_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
alpha_beta_set_to	mat{real}.foo	/^   alpha_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
beta_beta_set_to	mat{real}.foo	/^   beta_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
alpha_alpha_set_to	mat{real}.foo	/^   alpha_alpha_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
beta_alpha_set_to	mat{real}.foo	/^   beta_alpha_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
alpha_beta_set_to	mat{real}.foo	/^   alpha_beta_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
beta_beta_set_to	mat{real}.foo	/^   beta_beta_set_to(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
alpha_alpha_put_to	mat{real}.foo	/^   alpha_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, CAST=>)$/;"	r
beta_alpha_put_to	mat{real}.foo	/^   beta_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, CAST=>)$/;"	r
alpha_beta_put_to	mat{real}.foo	/^   alpha_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, CAST=>)$/;"	r
beta_beta_put_to	mat{real}.foo	/^   beta_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, CAST=>)$/;"	r
alpha_alpha_plus	mat{real}.foo	/^   alpha_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
beta_alpha_plus	mat{real}.foo	/^   beta_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
alpha_beta_plus	mat{real}.foo	/^   alpha_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
beta_beta_plus	mat{real}.foo	/^   beta_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
alpha_alpha_plus	mat{real}.foo	/^   alpha_alpha_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
beta_alpha_plus	mat{real}.foo	/^   beta_alpha_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
alpha_beta_plus	mat{real}.foo	/^   alpha_beta_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
beta_beta_plus	mat{real}.foo	/^   beta_beta_plus(X,fac) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)$/;"	r
put_blocks_to	mat{real}.foo	/^   put_blocks_to(X,block_dim,block_list) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
put_sub_blocks_to	mat{real}.foo	/^   put_sub_blocks_to(X,block_dim,X_block_dim,block_list,X_block_offset) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})$/;"	r
convert_to	mat{real}.foo	/^   convert_to(units)$/;"	r
convert_from	mat{real}.foo	/^   convert_from(units)$/;"	r
gaussian_d_xyz_matrix	mat{real}.foo	/^   gaussian_d_xyz_matrix result (dtr)$/;"	r
gaussian_f_xyz_matrix	mat{real}.foo	/^   gaussian_f_xyz_matrix result (ftr)$/;"	r
gaussian_g_xyz_matrix	mat{real}.foo	/^   gaussian_g_xyz_matrix result (gtr)$/;"	r
make_enclosing_sphere	mat{real}.foo	/^   make_enclosing_sphere(pos,radius) $/;"	r
make_corresponding_orbitals	mat{real}.foo	/^   make_corresponding_orbitals(left,right,theta,p)$/;"	r
to_multipole_W_translation_mx	mat{real}.foo	/^   to_multipole_W_translation_mx(R,l_max)$/;"	r
add_multipole_W_translation_mx	mat{real}.foo	/^   add_multipole_W_translation_mx(R,l_max)$/;"	r
to_multipole_T_interaction_mx	mat{real}.foo	/^   to_multipole_T_interaction_mx(R,l_max,j_max)$/;"	r
add_multipole_T_interaction_mx	mat{real}.foo	/^   add_multipole_T_interaction_mx(R,l_max,j_max)$/;"	r
to_R_mu_multipole_mx	mat{real}.foo	/^   to_R_mu_multipole_mx(points,l_max)$/;"	r
create	mat{rms2_indices}.foo	/^   create(dim1,dim2) ::: get_from(MAT{OBJECT}), leaky$/;"	r
create	mat{rms2_indices}.foo	/^   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{OBJECT}), leaky$/;"	r
destroy	mat{rms2_indices}.foo	/^   destroy ::: get_from(MAT{OBJECT}), leaky$/;"	r
created	mat{rms2_indices}.foo	/^   created result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
destroyed	mat{rms2_indices}.foo	/^   destroyed result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
nullify_ptr_part	mat{rms2_indices}.foo	/^   nullify_ptr_part ::: get_from(MAT{OBJECT})$/;"	r
destroy_ptr_part	mat{rms2_indices}.foo	/^   destroy_ptr_part ::: get_from(MAT{OBJECT}), leaky$/;"	r
dim1	mat{rms2_indices}.foo	/^   dim1 result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
dim2	mat{rms2_indices}.foo	/^   dim2 result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
set_indices	mat{rms2_indices}.foo	/^   set_indices(l_max,rms_indices,nx,ny,nz) ::: leaky$/;"	r
n_comp_up_to	mat{rms2_indices}.foo	/^   n_comp_up_to(l) result (res) ::: selfless, always_pure, private$/;"	r
create	mat{rms_indices}.foo	/^   create(dim1,dim2) ::: get_from(MAT{OBJECT}), leaky$/;"	r
create	mat{rms_indices}.foo	/^   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{OBJECT}), leaky$/;"	r
destroy	mat{rms_indices}.foo	/^   destroy ::: get_from(MAT{OBJECT}), leaky$/;"	r
created	mat{rms_indices}.foo	/^   created result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
destroyed	mat{rms_indices}.foo	/^   destroyed result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
nullify_ptr_part	mat{rms_indices}.foo	/^   nullify_ptr_part ::: get_from(MAT{OBJECT})$/;"	r
destroy_ptr_part	mat{rms_indices}.foo	/^   destroy_ptr_part ::: get_from(MAT{OBJECT}), leaky$/;"	r
dim1	mat{rms_indices}.foo	/^   dim1 result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
dim2	mat{rms_indices}.foo	/^   dim2 result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
set_indices	mat{rms_indices}.foo	/^   set_indices(l_max,nx,ny,nz,px,py,pz) ::: leaky$/;"	r
n_comp_up_to	mat{rms_indices}.foo	/^   n_comp_up_to(l) result (res) ::: selfless, always_pure, private$/;"	r
create	mat{shell1pair}.foo	/^   create(dim1,dim2) ::: get_from(MAT{OBJECT}), leaky$/;"	r
destroy	mat{shell1pair}.foo	/^   destroy ::: get_from(MAT{OBJECT}), leaky$/;"	r
created	mat{shell1pair}.foo	/^   created result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
destroyed	mat{shell1pair}.foo	/^   destroyed result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
nullify_ptr_part	mat{shell1pair}.foo	/^   nullify_ptr_part ::: get_from(MAT{OBJECT})$/;"	r
destroy_ptr_part	mat{shell1pair}.foo	/^   destroy_ptr_part ::: get_from(MAT{OBJECT}), leaky$/;"	r
create_copy	mat{shell1pair}.foo	/^   create_copy(matrix) ::: get_from(MAT{OBJECT}), leaky$/;"	r
copy	mat{shell1pair}.foo	/^   copy(matrix) ::: get_from(MAT{OBJECT}), leaky$/;"	r
size	mat{shell1pair}.foo	/^   size result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
dim1	mat{shell1pair}.foo	/^   dim1 result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
dim2	mat{shell1pair}.foo	/^   dim2 result (res) ::: get_from(MAT{OBJECT}), inlined_by_foo$/;"	r
shape	mat{shell1pair}.foo	/^   shape result (res) ::: get_from(MAT{OBJECT})$/;"	r
is_same_shape_as	mat{shell1pair}.foo	/^   is_same_shape_as(a) result (res) ::: get_from(MAT{OBJECT}), pure$/;"	r
is_transposed_shape_of	mat{shell1pair}.foo	/^   is_transposed_shape_of(a) result (res) ::: get_from(MAT{OBJECT}), pure$/;"	r
is_square	mat{shell1pair}.foo	/^   is_square result (res) ::: get_from(MAT{OBJECT}), pure$/;"	r
create	mat{str}.foo	/^   create(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{str}.foo	/^   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{str}.foo	/^   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{str}.foo	/^   create(bounds1,bounds2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create	mat{str}.foo	/^   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
create_copy	mat{str}.foo	/^   create_copy(matrix) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
destroy	mat{str}.foo	/^   destroy ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
created	mat{str}.foo	/^   created result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	mat{str}.foo	/^   destroyed result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
size	mat{str}.foo	/^   size result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
dim1	mat{str}.foo	/^   dim1 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
dim2	mat{str}.foo	/^   dim2 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo$/;"	r
shape	mat{str}.foo	/^   shape result (res) ::: get_from(MAT{INTRINSIC})$/;"	r
is_same_shape_as	mat{str}.foo	/^   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{STR}), pure$/;"	r
is_transposed_shape_of	mat{str}.foo	/^   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{STR}), pure$/;"	r
is_square	mat{str}.foo	/^   is_square result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
shrink	mat{str}.foo	/^   shrink(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
expand	mat{str}.foo	/^   expand(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
shrink_columns	mat{str}.foo	/^   shrink_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
expand_columns	mat{str}.foo	/^   expand_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
append_columns	mat{str}.foo	/^   append_columns(cols) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
append_column	mat{str}.foo	/^   append_column(col) ::: get_from(MAT{INTRINSIC}), leaky$/;"	r
equals	mat{str}.foo	/^   equals(b) result (res)$/;"	r
same_as	mat{str}.foo	/^   same_as(b) result (res)$/;"	r
str_lengths	mat{str}.foo	/^   str_lengths(spaces) result (res) ::: pure$/;"	r
str_length	mat{str}.foo	/^   str_length(spaces) result (res) ::: get_from(MAT{INTRINSIC}), pure$/;"	r
ENSURE	molecule.foo	/^#  define ENSURE(X,Y)       ENSURE0(X,Y)$/;"	m
saved_self	molecule.foo	/^   saved_self :: MOLECULE*, private$/;"	g
debug_list	molecule.foo	/^   debug_list :: VEC{STR}*, private  DEFAULT_NULL$/;"	g
create	molecule.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	molecule.foo	/^   destroy ::: get_from(OBJECT), leaky, recursive$/;"	r
nullify_ptr_part	molecule.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	molecule.foo	/^   destroy_ptr_part ::: recursive, leaky$/;"	r
destroy_matrices	molecule.foo	/^   destroy_matrices ::: leaky$/;"	r
created	molecule.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	molecule.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
save	molecule.foo	/^   save ::: leaky$/;"	r
unsave	molecule.foo	/^   unsave ::: leaky$/;"	r
create_copy	molecule.foo	/^   create_copy(mol) ::: leaky$/;"	r
copy	molecule.foo	/^   copy(mol) ::: leaky$/;"	r
set_defaults	molecule.foo	/^   set_defaults ::: leaky$/;"	r
set_saved_self	molecule.foo	/^   set_saved_self ::: get_from(OBJECT)$/;"	r
set_atom_info	molecule.foo	/^   set_atom_info ::: leaky$/;"	r
resolve_basis_info	molecule.foo	/^   resolve_basis_info ::: leaky$/;"	r
resolve_gaussianbases	molecule.foo	/^   resolve_gaussianbases ::: leaky$/;"	r
resolve_slaterbases	molecule.foo	/^   resolve_slaterbases ::: leaky$/;"	r
resolve_coppensbases	molecule.foo	/^   resolve_coppensbases ::: leaky$/;"	r
resolve_axis_system	molecule.foo	/^   resolve_axis_system$/;"	r
change_axis_system_to	molecule.foo	/^   change_axis_system_to$/;"	r
set_basis_info	molecule.foo	/^   set_basis_info ::: leaky$/;"	r
set_basis_name	molecule.foo	/^   set_basis_name(name) ::: leaky$/;"	r
set_slaterbasis_name	molecule.foo	/^   set_slaterbasis_name(name) ::: leaky$/;"	r
set_coppensbasis_name	molecule.foo	/^   set_coppensbasis_name(name) ::: leaky$/;"	r
assign_NOs_to_MOs	molecule.foo	/^   assign_NOs_to_MOs ::: leaky$/;"	r
assign_MOs_to_NOs	molecule.foo	/^   assign_MOs_to_NOs ::: leaky$/;"	r
set_scf_occupations	molecule.foo	/^   set_scf_occupations(NO_kind)$/;"	r
default_spin_multiplicity	molecule.foo	/^   default_spin_multiplicity result (res)$/;"	r
nuclear_repulsion_energy	molecule.foo	/^   nuclear_repulsion_energy result (res)$/;"	r
chemical_formula	molecule.foo	/^   chemical_formula(with_spaces) result (res)$/;"	r
centre_of_mass	molecule.foo	/^   centre_of_mass result(centre)$/;"	r
centre_of_atoms	molecule.foo	/^   centre_of_atoms result(centre)$/;"	r
change_to_principal_axes	molecule.foo	/^   change_to_principal_axes$/;"	r
change_to_principal_top_axes	molecule.foo	/^   change_to_principal_top_axes$/;"	r
molecular_weight	molecule.foo	/^   molecular_weight result (res)$/;"	r
reduced_mass	molecule.foo	/^   reduced_mass result (res)$/;"	r
move_origin_to_centre_of_mass	molecule.foo	/^   move_origin_to_centre_of_mass$/;"	r
move_origin_to_centre_of_atoms	molecule.foo	/^   move_origin_to_centre_of_atoms$/;"	r
move_origin	molecule.foo	/^   move_origin$/;"	r
atom_index_from_pos	molecule.foo	/^   atom_index_from_pos(pos) result (res)$/;"	r
get_geometry	molecule.foo	/^   get_geometry(g)$/;"	r
get_crystal_geometry	molecule.foo	/^   get_crystal_geometry(g)$/;"	r
get_shell	molecule.foo	/^   get_shell(shell,index) ::: leaky$/;"	r
get_shell	molecule.foo	/^   get_shell(shell,index) ::: leaky$/;"	r
get_shell	molecule.foo	/^   get_shell(shell,index,fa,la) ::: leaky$/;"	r
get_shell	molecule.foo	/^   get_shell(shell,index,fa,la,na) ::: leaky$/;"	r
get_atom_pair_indices	molecule.foo	/^   get_atom_pair_indices(index,a,b,fa,la,na,fb,lb,nb) $/;"	r
set_atom_pair_grid_info	molecule.foo	/^   set_atom_pair_grid_info(a,b,n_pt) ::: leaky$/;"	r
is_overlapping_atom	molecule.foo	/^   is_overlapping_atom(a,b) result (res)$/;"	r
is_overlapping_atom	molecule.foo	/^   is_overlapping_atom(a,list) result (res)$/;"	r
overlapping_atoms_for	molecule.foo	/^   overlapping_atoms_for(list) result (res) ::: leaky$/;"	r
make_max_S_for_shell_pairs	molecule.foo	/^   make_max_S_for_shell_pairs(max_S)$/;"	r
make_overlapping_atoms	molecule.foo	/^   make_overlapping_atoms ::: leaky$/;"	r
get_shell_pair_indices	molecule.foo	/^   get_shell_pair_indices(index,a,b,fa,la,na,fb,lb,nb)$/;"	r
get_shell_pair_indices	molecule.foo	/^   get_shell_pair_indices(index,a,b,fa,la,na,fb,lb,nb,atom_a,atom_b)$/;"	r
get_precomputed_shell_pair	molecule.foo	/^   get_precomputed_shell_pair(shell,index,fa,la,na,fb,lb,nb) ::: leaky$/;"	r
get_precomputed_shell_pair	molecule.foo	/^   get_precomputed_shell_pair(shell,index,fa,la,na,fb,lb,nb,atom_a,atom_b) ::: leaky$/;"	r
get_shell_quartet_indices	molecule.foo	/^   get_shell_quartet_indices(index,fa,la,fb,lb,fc,lc,fd,ld) ::: leaky$/;"	r
get_shell_quartet_indexes	molecule.foo	/^   get_shell_quartet_indexes(index,a,b,c,d,atom_a,atom_b,atom_c,atom_d)$/;"	r
copy_shell_quartet	molecule.foo	/^   copy_shell_quartet(shell,a,b,c,d) ::: leaky$/;"	r
copy_shell_quartet	molecule.foo	/^   copy_shell_quartet(shell,index,a,b,c,d) ::: leaky$/;"	r
copy_shell_quartet	molecule.foo	/^   copy_shell_quartet(shell,index,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld) ::: leaky$/;"	r
copy_shell_quartet	molecule.foo	/^   copy_shell_quartet(shell,index,a,b,c,d,atom_a,atom_b,atom_c,atom_d) ::: leaky$/;"	r
copy_shell_quartet_ab	molecule.foo	/^   copy_shell_quartet_ab(shell,a,b) ::: leaky$/;"	r
copy_shell_quartet_cd	molecule.foo	/^   copy_shell_quartet_cd(shell,c,d) ::: leaky$/;"	r
set_new_shell_quartet_ab	molecule.foo	/^   set_new_shell_quartet_ab(shell,a,b,skip) ::: leaky$/;"	r
set_new_shell_quartet_cd	molecule.foo	/^   set_new_shell_quartet_cd(shell,c,d,skip) ::: leaky$/;"	r
make_contraction_matrix	molecule.foo	/^   make_contraction_matrix(cc_mat)$/;"	r
make_normalised_contraction_mx	molecule.foo	/^   make_normalised_contraction_mx(cc_mat)$/;"	r
make_shell_info	molecule.foo	/^   make_shell_info ::: leaky$/;"	r
make_precomputed_shellpairs	molecule.foo	/^   make_precomputed_shellpairs ::: leaky$/;"	r
first_basis_shell_for_atom	molecule.foo	/^   first_basis_shell_for_atom(atom) result (res)$/;"	r
make_basis_shell_for_shell	molecule.foo	/^   make_basis_shell_for_shell ::: leaky$/;"	r
make_scf_density_matrix	molecule.foo	/^   make_scf_density_matrix(damp,n_a,method) ::: leaky$/;"	r
make_finite_T_density_matrix	molecule.foo	/^   make_finite_T_density_matrix(D,MO,F,T,n_e) ::: leaky$/;"	r
make_ao_density_matrix	molecule.foo	/^   make_ao_density_matrix ::: leaky$/;"	r
make_ao_density_matrix	molecule.foo	/^   make_ao_density_matrix(D) ::: leaky$/;"	r
make_ao_density_matrix	molecule.foo	/^   make_ao_density_matrix(P)$/;"	r
make_ao_sz_density_matrix	molecule.foo	/^   make_ao_sz_density_matrix ::: leaky$/;"	r
make_ao_sz_density_matrix	molecule.foo	/^   make_ao_sz_density_matrix(D) ::: leaky$/;"	r
make_ao_sz_density_matrix	molecule.foo	/^   make_ao_sz_density_matrix(P) ::: leaky$/;"	r
make_scf_density_matrix	molecule.foo	/^   make_scf_density_matrix(n,nb)$/;"	r
make_progroup_density_matrix	molecule.foo	/^   make_progroup_density_matrix ::: leaky$/;"	r
make_group_density_matrix	molecule.foo	/^   make_group_density_matrix ::: leaky$/;"	r
symorthonormalise_occupied_MOs	molecule.foo	/^   symorthonormalise_occupied_MOs ::: leaky$/;"	r
make_density_matrix	molecule.foo	/^   make_density_matrix ::: leaky$/;"	r
no_of_electrons	molecule.foo	/^   no_of_electrons result (res)$/;"	r
no_of_alpha_electrons	molecule.foo	/^   no_of_alpha_electrons result (res)$/;"	r
no_of_beta_electrons	molecule.foo	/^   no_of_beta_electrons result (res)$/;"	r
has_valid_no_of_beta_electrons	molecule.foo	/^   has_valid_no_of_beta_electrons result (res)$/;"	r
no_of_unpaired_electrons	molecule.foo	/^   no_of_unpaired_electrons result (res)$/;"	r
no_of_atom_pairs	molecule.foo	/^   no_of_atom_pairs result (res)$/;"	r
no_of_shell_pairs	molecule.foo	/^   no_of_shell_pairs result (res)$/;"	r
n_shell_quartets	molecule.foo	/^   n_shell_quartets result (res)$/;"	r
no_of_occupied_NOs	molecule.foo	/^   no_of_occupied_NOs(genre,tol) result (res)$/;"	r
make_natural_orbitals	molecule.foo	/^   make_natural_orbitals(genre) ::: leaky$/;"	r
make_restricted_NOs	molecule.foo	/^   make_restricted_NOs ::: leaky$/;"	r
make_unrestricted_NOs	molecule.foo	/^   make_unrestricted_NOs ::: leaky$/;"	r
make_r_NOs	molecule.foo	/^   make_r_NOs(NO,occupation,P)$/;"	r
make_restricted_complex_NOs	molecule.foo	/^   make_restricted_complex_NOs ::: leaky$/;"	r
make_general_complex_NOs	molecule.foo	/^   make_general_complex_NOs ::: leaky$/;"	r
read_debug_on	molecule.foo	/^   read_debug_on ::: get_from(DEBUG), leaky$/;"	r
read_debug_off	molecule.foo	/^   read_debug_off ::: get_from(DEBUG), leaky$/;"	r
debugging	molecule.foo	/^   debugging(name) result (res) ::: get_from(DEBUG)$/;"	r
put_debug_list	molecule.foo	/^   put_debug_list ::: get_from(DEBUG)$/;"	r
put_debug	molecule.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>STR)$/;"	r
put_debug	molecule.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>BIN)$/;"	r
put_debug	molecule.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>INT)$/;"	r
put_debug	molecule.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)$/;"	r
put_debug	molecule.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{INT})$/;"	r
put_debug	molecule.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})$/;"	r
put_debug	molecule.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})$/;"	r
put_debug	molecule.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{CPX})$/;"	r
put_debug	molecule.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>SHELL2)$/;"	r
put_debug	molecule.foo	/^   put_debug(X,name) ::: get_from(DEBUG)$/;"	r
get_overlap_matrix	molecule.foo	/^   get_overlap_matrix ::: leaky$/;"	r
make_overlap_matrix	molecule.foo	/^   make_overlap_matrix(S)$/;"	r
make_overlap_sqrt	molecule.foo	/^   make_overlap_sqrt(S_sqrt) ::: leaky$/;"	r
make_overlap_inverse_sqrt	molecule.foo	/^   make_overlap_inverse_sqrt(S_inv) ::: leaky$/;"	r
make_primitive_overlap_matrix	molecule.foo	/^   make_primitive_overlap_matrix(S)$/;"	r
get_kinetic_energy_mx	molecule.foo	/^   get_kinetic_energy_mx(T)$/;"	r
make_kinetic_matrix	molecule.foo	/^   make_kinetic_matrix(T)$/;"	r
make_NDDO_kinetic_matrix	molecule.foo	/^   make_NDDO_kinetic_matrix(T)$/;"	r
make_NUDO_kinetic_matrix	molecule.foo	/^   make_NUDO_kinetic_matrix(T)$/;"	r
make_primitive_kinetic_matrix	molecule.foo	/^   make_primitive_kinetic_matrix(T)$/;"	r
get_nuclear_attraction_mx	molecule.foo	/^   get_nuclear_attraction_mx(Z)$/;"	r
make_nuclear_attraction_mx	molecule.foo	/^   make_nuclear_attraction_mx(Z)$/;"	r
make_nuclear_attraction_mx	molecule.foo	/^   make_nuclear_attraction_mx(Z,nuclei)$/;"	r
make_NDDO_nuclear_matrix	molecule.foo	/^   make_NDDO_nuclear_matrix(Z)$/;"	r
make_NDDO_nuclear_matrix	molecule.foo	/^   make_NDDO_nuclear_matrix(Z,nuclei)$/;"	r
make_NUDO_nuclear_matrix	molecule.foo	/^   make_NUDO_nuclear_matrix(Z)$/;"	r
make_NUDO_nuclear_matrix	molecule.foo	/^   make_NUDO_nuclear_matrix(Z,nuclei)$/;"	r
make_nuclear_attraction_mx	molecule.foo	/^   make_nuclear_attraction_mx(Z,charges,points)$/;"	r
make_primitive_nuclear_matrix	molecule.foo	/^   make_primitive_nuclear_matrix(Z)$/;"	r
get_core_matrix	molecule.foo	/^   get_core_matrix ::: leaky$/;"	r
get_r_core_matrix	molecule.foo	/^   get_r_core_matrix ::: leaky$/;"	r
make_r_core_matrix	molecule.foo	/^   make_r_core_matrix(H)$/;"	r
get_gc_core_matrix	molecule.foo	/^   get_gc_core_matrix ::: leaky$/;"	r
add_gc_DKH_core_matrix	molecule.foo	/^   add_gc_DKH_core_matrix$/;"	r
add_gc_ZORA_core_matrix	molecule.foo	/^   add_gc_ZORA_core_matrix$/;"	r
set_gc_IOTC_core_matrix	molecule.foo	/^   set_gc_IOTC_core_matrix$/;"	r
add_gc_Pauli_core_matrix	molecule.foo	/^   add_gc_Pauli_core_matrix$/;"	r
add_gc_core_matrix	molecule.foo	/^   add_gc_core_matrix$/;"	r
make_pt_charge_matrix	molecule.foo	/^   make_pt_charge_matrix(Z) ::: leaky$/;"	r
make_Lorentz_core	molecule.foo	/^   make_Lorentz_core(Z) ::: leaky$/;"	r
make_Lorentz_fields	molecule.foo	/^   make_Lorentz_fields(F) $/;"	r
make_Lorentz_interactions	molecule.foo	/^   make_Lorentz_interactions(I0,I1) $/;"	r
get_dipole_matrices	molecule.foo	/^   get_dipole_matrices(Dx,Dy,Dz)$/;"	r
make_dipole_matrices	molecule.foo	/^   make_dipole_matrices(Dx,Dy,Dz)$/;"	r
electronic_dipole_moment	molecule.foo	/^   electronic_dipole_moment result (res)$/;"	r
nuclear_dipole_moment	molecule.foo	/^   nuclear_dipole_moment result (res)$/;"	r
get_quadrupole_matrices	molecule.foo	/^   get_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)$/;"	r
make_quadrupole_matrices	molecule.foo	/^   make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)$/;"	r
electronic_quadrupole_moment	molecule.foo	/^   electronic_quadrupole_moment result (res)$/;"	r
nuclear_quadrupole_moment	molecule.foo	/^   nuclear_quadrupole_moment result (res)$/;"	r
get_octupole_matrices	molecule.foo	/^   get_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)$/;"	r
make_octupole_matrices	molecule.foo	/^   make_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)$/;"	r
electronic_octupole_moment	molecule.foo	/^   electronic_octupole_moment result (res)$/;"	r
nuclear_octupole_moment	molecule.foo	/^   nuclear_octupole_moment result (res)$/;"	r
make_electric_field_matrices	molecule.foo	/^   make_electric_field_matrices(Ex,Ey,Ez,c)$/;"	r
electronic_E_field_at_nuclei	molecule.foo	/^   electronic_E_field_at_nuclei result (res)$/;"	r
nuclear_E_field_at_nuclei	molecule.foo	/^   nuclear_E_field_at_nuclei result (res)$/;"	r
make_EFG_matrices	molecule.foo	/^   make_EFG_matrices(Exx,Eyy,Ezz,Exy,Exz,Eyz,c)$/;"	r
electronic_EFG_at_nuclei	molecule.foo	/^   electronic_EFG_at_nuclei result (res)$/;"	r
nuclear_EFG_at_nuclei	molecule.foo	/^   nuclear_EFG_at_nuclei result (res)$/;"	r
get_L_matrices	molecule.foo	/^   get_L_matrices(Lx,Ly,Lz)$/;"	r
make_L_matrices	molecule.foo	/^   make_L_matrices(Lx,Ly,Lz)$/;"	r
get_spin_orbit_matrices	molecule.foo	/^   get_spin_orbit_matrices(SOx,SOy,SOz)$/;"	r
make_spin_orbit_matrices	molecule.foo	/^   make_spin_orbit_matrices(SOx,SOy,SOz)$/;"	r
get_spin_orbit_B_matrices	molecule.foo	/^   get_spin_orbit_B_matrices(SOBx,SOBy,SOBz)$/;"	r
make_spin_orbit_B_matrices	molecule.foo	/^   make_spin_orbit_B_matrices(SOBx,SOBy,SOBz)$/;"	r
get_spin_orbit_Q_matrices	molecule.foo	/^   get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)$/;"	r
make_spin_orbit_Q_matrices	molecule.foo	/^   make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)$/;"	r
nuclear_potential	molecule.foo	/^   nuclear_potential(values,pts)$/;"	r
electric_potential	molecule.foo	/^   electric_potential(values,grid,charges,positions) ::: selfless$/;"	r
ZORA_potential	molecule.foo	/^   ZORA_potential(values,pts)$/;"	r
get_1e_ZORA_matrices	molecule.foo	/^   get_1e_ZORA_matrices(T,SOx,SOy,SOz)$/;"	r
make_1e_ZORA_matrices	molecule.foo	/^   make_1e_ZORA_matrices(T,Zx,Zy,Zz)$/;"	r
make_ENA_matrix	molecule.foo	/^   make_ENA_matrix(Z)$/;"	r
make_primitive_DKH_matrices	molecule.foo	/^   make_primitive_DKH_matrices(T,SOx,SOy,SOz)$/;"	r
make_primitive_DK3_ppZpp_mx	molecule.foo	/^   make_primitive_DK3_ppZpp_mx(ppZpp)$/;"	r
ex	molecule.foo	/^     ex :: VEC{REAL}*$/;"	a
atom	molecule.foo	/^     atom :: ATOM*$/;"	a
Tc	molecule.foo	/^     Tc :: MAT{REAL}*$/;"	a
make_fd_DKH_matrix	molecule.foo	/^   make_fd_DKH_matrix(T,SOx,SOy,SOz)$/;"	r
make_ft	molecule.foo	/^   make_ft(res,dens,k_pts)$/;"	r
make_ft	molecule.foo	/^   make_ft(res,dens,k_pts)$/;"	r
make_ft_deriv_U	molecule.foo	/^   make_ft_deriv_U(res,dens,k_pts)$/;"	r
make_ft_deriv_U	molecule.foo	/^   make_ft_deriv_U(res,dens,k_pts)$/;"	r
make_ft_pair	molecule.foo	/^   make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)$/;"	r
make_partition_factors	molecule.foo	/^   make_partition_factors(p,sh,atom_a,atom_b,is_zero)$/;"	r
thermal_smearing_correction	molecule.foo	/^   thermal_smearing_correction(res,k_pts,a,b,sh)$/;"	r
ft_thermally_smear	molecule.foo	/^   ft_thermally_smear(ft_ab,k_pts,a,b)$/;"	r
add_dispersion_correction	molecule.foo	/^   add_dispersion_correction(ft,k_pts)$/;"	r
check_dispersion_correction	molecule.foo	/^   check_dispersion_correction$/;"	r
get_ft_ints	molecule.foo	/^   get_ft_ints$/;"	r
make_ft_ints	molecule.foo	/^   make_ft_ints$/;"	r
make_x_structure_factors	molecule.foo	/^   make_x_structure_factors$/;"	r
make_xf_structure_factors	molecule.foo	/^   make_xf_structure_factors$/;"	r
make_x_structure_factors_p	molecule.foo	/^   make_x_structure_factors_p ::: private$/;"	r
make_x_structure_factors_h	molecule.foo	/^   make_x_structure_factors_h(D)$/;"	r
make_n_structure_factors	molecule.foo	/^   make_n_structure_factors$/;"	r
make_nf_structure_factors	molecule.foo	/^   make_nf_structure_factors$/;"	r
make_n_structure_factors_p	molecule.foo	/^   make_n_structure_factors_p ::: private$/;"	r
make_H_structure_factors	molecule.foo	/^   make_H_structure_factors(output) ::: leaky$/;"	r
make_H_Sz_structure_factors	molecule.foo	/^   make_H_Sz_structure_factors(output) ::: leaky$/;"	r
symmetrise	molecule.foo	/^   symmetrise(mat,orb_kind)$/;"	r
symmetrise	molecule.foo	/^   symmetrise(mat) ::: template$/;"	r
symmetrise	molecule.foo	/^   symmetrise(mat) ::: get_from(MOLECULE, TYPE=>REAL)$/;"	r
symmetrise	molecule.foo	/^   symmetrise(mat) ::: get_from(MOLECULE, TYPE=>CPX)$/;"	r
make_image_of_shell	molecule.foo	/^   make_image_of_shell(res)$/;"	r
stabilize	molecule.foo	/^   stabilize(mat,orb_kind) ::: get_from(MOLECULE, symmetrise=>stabilize)$/;"	r
stabilize	molecule.foo	/^   stabilize(mat) ::: template$/;"	r
stabilize	molecule.foo	/^   stabilize(mat) ::: get_from(MOLECULE, TYPE=>REAL)$/;"	r
stabilize	molecule.foo	/^   stabilize(mat) ::: get_from(MOLECULE, TYPE=>CPX)$/;"	r
make_image_of_stabilizer	molecule.foo	/^   make_image_of_stabilizer(res)$/;"	r
read_name	molecule.foo	/^   read_name$/;"	r
read_spin_multiplicity	molecule.foo	/^   read_spin_multiplicity$/;"	r
read_charge	molecule.foo	/^   read_charge$/;"	r
read_E_field	molecule.foo	/^   read_E_field$/;"	r
read_B_field	molecule.foo	/^   read_B_field$/;"	r
read_gauge_origin	molecule.foo	/^   read_gauge_origin$/;"	r
read_optimise_thermals	molecule.foo	/^   read_optimise_thermals$/;"	r
delete_gauge_integrals	molecule.foo	/^   delete_gauge_integrals$/;"	r
read_plot_grid	molecule.foo	/^   read_plot_grid ::: leaky$/;"	r
read_isosurface	molecule.foo	/^   read_isosurface ::: leaky$/;"	r
read_CX_isosurface	molecule.foo	/^   read_CX_isosurface ::: leaky$/;"	r
read_becke_grid	molecule.foo	/^   read_becke_grid ::: leaky$/;"	r
read_crystal	molecule.foo	/^   read_crystal ::: leaky$/;"	r
read_pointgroup	molecule.foo	/^   read_pointgroup ::: leaky$/;"	r
read_scfdata	molecule.foo	/^   read_scfdata ::: leaky$/;"	r
read_robydata	molecule.foo	/^   read_robydata ::: leaky$/;"	r
read_atoms	molecule.foo	/^   read_atoms ::: leaky$/;"	r
read_basis_directory	molecule.foo	/^   read_basis_directory$/;"	r
read_basis_name	molecule.foo	/^   read_basis_name ::: leaky$/;"	r
read_slaterbasis_name	molecule.foo	/^   read_slaterbasis_name ::: leaky$/;"	r
read_coppensbasis_name	molecule.foo	/^   read_coppensbasis_name ::: leaky$/;"	r
read_saved_basis_name	molecule.foo	/^   read_saved_basis_name ::: leaky$/;"	r
read_saved_slaterbasis_name	molecule.foo	/^   read_saved_slaterbasis_name ::: leaky$/;"	r
read_saved_coppensbasis_name	molecule.foo	/^   read_saved_coppensbasis_name ::: leaky$/;"	r
read_basis_sets	molecule.foo	/^   read_basis_sets ::: leaky$/;"	r
read_slaterbasis_sets	molecule.foo	/^   read_slaterbasis_sets ::: leaky$/;"	r
read_coppensbasis_sets	molecule.foo	/^   read_coppensbasis_sets ::: leaky$/;"	r
read_atom_groups	molecule.foo	/^   read_atom_groups ::: leaky$/;"	r
read_archive	molecule.foo	/^   read_archive ::: leaky$/;"	r
read_archive	molecule.foo	/^   read_archive(name,orb_kind) ::: leaky$/;"	r
read_ascii_archive	molecule.foo	/^   read_ascii_archive ::: leaky$/;"	r
read_gaussian_FChk_file	molecule.foo	/^   read_gaussian_FChk_file(name) ::: leaky$/;"	r
read_g09_FChk_file	molecule.foo	/^   read_g09_FChk_file(name) ::: leaky$/;"	r
swap_g94_orbital_order	molecule.foo	/^   swap_g94_orbital_order(X,swap)$/;"	r
write_morphy98_wfn_file	molecule.foo	/^   write_morphy98_wfn_file ::: leaky$/;"	r
write_aim2000_wfn_file	molecule.foo	/^   write_aim2000_wfn_file ::: leaky$/;"	r
write_archive	molecule.foo	/^   write_archive$/;"	r
write_ascii_archive	molecule.foo	/^   write_ascii_archive$/;"	r
put	molecule.foo	/^   put$/;"	r
put_basics	molecule.foo	/^   put_basics$/;"	r
put_atoms	molecule.foo	/^   put_atoms$/;"	r
put_principal_axes	molecule.foo	/^   put_principal_axes$/;"	r
put_bases	molecule.foo	/^   put_bases$/;"	r
put_slaterbases	molecule.foo	/^   put_slaterbases$/;"	r
put_coppensbases	molecule.foo	/^   put_coppensbases$/;"	r
put_atom_thermal_tensors	molecule.foo	/^   put_atom_thermal_tensors$/;"	r
put_atom_groups	molecule.foo	/^   put_atom_groups$/;"	r
put_overlapping_atoms	molecule.foo	/^   put_overlapping_atoms$/;"	r
put_overlapping_atoms_4_atom	molecule.foo	/^   put_overlapping_atoms_4_atom$/;"	r
put_pointgroup	molecule.foo	/^   put_pointgroup$/;"	r
put_plot_grid	molecule.foo	/^   put_plot_grid$/;"	r
put_becke_grid	molecule.foo	/^   put_becke_grid$/;"	r
put_crystal	molecule.foo	/^   put_crystal$/;"	r
put_cluster	molecule.foo	/^   put_cluster$/;"	r
put_crystal_reflection_data	molecule.foo	/^   put_crystal_reflection_data$/;"	r
put_crystal_F_statistics	molecule.foo	/^   put_crystal_F_statistics$/;"	r
put_molecular_orbitals	molecule.foo	/^   put_molecular_orbitals$/;"	r
put_mos_and_energies	molecule.foo	/^   put_mos_and_energies$/;"	r
put_mo_energies	molecule.foo	/^   put_mo_energies$/;"	r
put_natural_orbitals	molecule.foo	/^   put_natural_orbitals$/;"	r
put_density_matrix	molecule.foo	/^   put_density_matrix$/;"	r
put_fock_matrix	molecule.foo	/^   put_fock_matrix$/;"	r
put_PND_sf	molecule.foo	/^   put_PND_sf$/;"	r
put_current_time	molecule.foo	/^   put_current_time(timer)$/;"	r
put_time_taken	molecule.foo	/^   put_time_taken(timer)$/;"	r
put_vrml	molecule.foo	/^   put_vrml$/;"	r
put_1e_properties	molecule.foo	/^   put_1e_properties ::: leaky$/;"	r
put_mulliken_populations	molecule.foo	/^   put_mulliken_populations ::: leaky$/;"	r
put_mulliken_populations	molecule.foo	/^   put_mulliken_populations(mulliken_matrix, diagonals)$/;"	r
put_mulliken_spins	molecule.foo	/^   put_mulliken_spins(mulliken_matrix,diagonals)$/;"	r
put_dipole	molecule.foo	/^   put_dipole$/;"	r
put_Hirshfeld_atom_info	molecule.foo	/^   put_Hirshfeld_atom_info ::: leaky$/;"	r
make_Hirshfeld_atom_info	molecule.foo	/^   make_Hirshfeld_atom_info(output) ::: leaky$/;"	r
make_Hirshfeld_rho_grid	molecule.foo	/^   make_Hirshfeld_rho_grid(N0,pt,wt,c,D) ::: leaky$/;"	r
make_Hirshfeld_atom_info_old	molecule.foo	/^   make_Hirshfeld_atom_info_old(output) ::: leaky$/;"	r
make_Hirshfeld_atom_info_orig	molecule.foo	/^   make_Hirshfeld_atom_info_orig(output) ::: leaky$/;"	r
put_uHirshfeld_atom_info	molecule.foo	/^   put_uHirshfeld_atom_info $/;"	r
make_uHirshfeld_atom_info	molecule.foo	/^   make_uHirshfeld_atom_info(output) ::: leaky$/;"	r
set_up_Hirshfeld_info	molecule.foo	/^   set_up_Hirshfeld_info(skip_NOs) ::: leaky$/;"	r
put_quadrupole	molecule.foo	/^   put_quadrupole$/;"	r
put_octupole	molecule.foo	/^   put_octupole$/;"	r
put_E_field_at_nuclei	molecule.foo	/^   put_E_field_at_nuclei$/;"	r
put_EFG_at_nuclei	molecule.foo	/^   put_EFG_at_nuclei$/;"	r
make_atom_group_info	molecule.foo	/^   make_atom_group_info ::: leaky$/;"	r
update_atom_group_info	molecule.foo	/^   update_atom_group_info ::: leaky$/;"	r
set_scf_defaults	molecule.foo	/^   set_scf_defaults(scfdata) ::: leaky$/;"	r
make_molecule_from_atom	molecule.foo	/^   make_molecule_from_atom(n,mol) ::: leaky$/;"	r
make_molecule_from_atom_group	molecule.foo	/^   make_molecule_from_atom_group(n,mol) ::: leaky$/;"	r
set_basis_data_from	molecule.foo	/^   set_basis_data_from(mol) ::: leaky$/;"	r
set_ANO_data_from	molecule.foo	/^   set_ANO_data_from(mol,list)$/;"	r
set_scf_guess_defaults_from	molecule.foo	/^   set_scf_guess_defaults_from(scfdata) ::: leaky$/;"	r
scf	molecule.foo	/^   scf ::: recursive, leaky$/;"	r
usual_scf	molecule.foo	/^   usual_scf ::: recursive, leaky$/;"	r
put_scf_results	molecule.foo	/^   put_scf_results$/;"	r
initialise_scfdata	molecule.foo	/^   initialise_scfdata$/;"	r
update_scfdata	molecule.foo	/^   update_scfdata$/;"	r
initialise_scfdata_error	molecule.foo	/^   initialise_scfdata_error$/;"	r
update_scfdata_error	molecule.foo	/^   update_scfdata_error$/;"	r
initialise_max_I	molecule.foo	/^   initialise_max_I ::: leaky$/;"	r
initialise_scf	molecule.foo	/^   initialise_scf ::: leaky, recursive$/;"	r
initialise_usual_scf	molecule.foo	/^   initialise_usual_scf ::: leaky, recursive$/;"	r
initialise_constrained_scf	molecule.foo	/^   initialise_constrained_scf ::: leaky$/;"	r
initialise_DFT_grids	molecule.foo	/^   initialise_DFT_grids ::: leaky$/;"	r
constrained_scf	molecule.foo	/^   constrained_scf ::: leaky$/;"	r
make_constraint_data	molecule.foo	/^   make_constraint_data$/;"	r
add_constraint_to_fock_matrix	molecule.foo	/^   add_constraint_to_fock_matrix$/;"	r
make_constraint	molecule.foo	/^   make_constraint(C)$/;"	r
make_r_constraint	molecule.foo	/^   make_r_constraint(C)$/;"	r
k_pts	molecule.foo	/^     k_pts :: MAT{REAL}*$/;"	a
Fc	molecule.foo	/^     Fc :: VEC{CPX}*$/;"	a
sh	molecule.foo	/^     sh :: SHELL2$/;"	a
make_H_r_constraint	molecule.foo	/^   make_H_r_constraint(constraint)$/;"	r
make_pnd_constraint	molecule.foo	/^   make_pnd_constraint(C)$/;"	r
reset_for_next_lambda	molecule.foo	/^   reset_for_next_lambda$/;"	r
schmidt_orthonormalise_MOs	molecule.foo	/^   schmidt_orthonormalise_MOs$/;"	r
schmidt_orthonormalise	molecule.foo	/^   schmidt_orthonormalise(MO,scale)$/;"	r
symmetrically_orthonormalise	molecule.foo	/^   symmetrically_orthonormalise(MO) ::: leaky$/;"	r
update_molecular_orbitals	molecule.foo	/^   update_molecular_orbitals$/;"	r
MO_eigen_update	molecule.foo	/^   MO_eigen_update$/;"	r
MO_r_eigen_update	molecule.foo	/^   MO_r_eigen_update(MO_energies,MO,F)$/;"	r
shift_dependence_from_r	molecule.foo	/^   shift_dependence_from_r(F)$/;"	r
decouple_and_shift_r	molecule.foo	/^   decouple_and_shift_r(F,evec,n,shift)$/;"	r
shift_linear_dependence_in_ngcm_from	molecule.foo	/^   shift_linear_dependence_in_ngcm_from(F,Fnew)$/;"	r
shift_linear_dependence_in_ngcm_from	molecule.foo	/^   shift_linear_dependence_in_ngcm_from(F)$/;"	r
MO_gc_eigen_update	molecule.foo	/^   MO_gc_eigen_update(MO_energies,MO,F)$/;"	r
MO_gc_reorder	molecule.foo	/^   MO_gc_reorder(MO_energies,MO)$/;"	r
MO_gradient_update	molecule.foo	/^   MO_gradient_update$/;"	r
make_MO_r_gradient	molecule.foo	/^   make_MO_r_gradient(g,F,P,c)$/;"	r
put_scf_energy	molecule.foo	/^   put_scf_energy$/;"	r
kinetic_energy	molecule.foo	/^   kinetic_energy result (res)$/;"	r
nuclear_attraction_energy	molecule.foo	/^   nuclear_attraction_energy result (res)$/;"	r
scf_energy	molecule.foo	/^   scf_energy result (res)$/;"	r
scf_energy	molecule.foo	/^   scf_energy(P,F) result (res)$/;"	r
scf_electronic_energy	molecule.foo	/^   scf_electronic_energy(P,core) result (res)$/;"	r
scf_electronic_energy	molecule.foo	/^   scf_electronic_energy(P,F,core) result (res)$/;"	r
scf_electronic_energies	molecule.foo	/^   scf_electronic_energies result (res) ::: leaky$/;"	r
scf_electronic_energies	molecule.foo	/^   scf_electronic_energies(P,F) result (res) ::: leaky$/;"	r
expectation	molecule.foo	/^   expectation(X) result (res)$/;"	r
archive	molecule.foo	/^   archive(opmatrix,archive_name,genre,with_lambda)$/;"	r
archive	molecule.foo	/^   archive(opvector,archive_name,genre,with_lambda)$/;"	r
archive	molecule.foo	/^   archive(item,archive_name,genre,with_lambda)$/;"	r
archive_scf_results	molecule.foo	/^   archive_scf_results$/;"	r
unarchive	molecule.foo	/^   unarchive(opmatrix,archive_name,genre) ::: leaky$/;"	r
unarchive	molecule.foo	/^   unarchive(opvector,archive_name,genre) ::: leaky$/;"	r
unarchive	molecule.foo	/^   unarchive(item,archive_name,genre) ::: leaky$/;"	r
unarchive	molecule.foo	/^   unarchive(archive_name,genre) ::: template$/;"	r
archive_exists	molecule.foo	/^   archive_exists(archive_name,genre) result (res)$/;"	r
archive_doesnt_exist	molecule.foo	/^   archive_doesnt_exist(archive_name,genre) result (res)$/;"	r
cleanup_scf	molecule.foo	/^   cleanup_scf ::: leaky$/;"	r
destroy_scf_results	molecule.foo	/^   destroy_scf_results(keep_MOs,keep_DM) ::: leaky$/;"	r
delete_scf_archives	molecule.foo	/^   delete_scf_archives(keep_MOs,keep_DM) ::: recursive$/;"	r
delete_lambda_scf_archives	molecule.foo	/^   delete_lambda_scf_archives(keep_MOs)$/;"	r
delete_atom_scf_archives	molecule.foo	/^   delete_atom_scf_archives ::: recursive, leaky$/;"	r
delete_group_scf_archives	molecule.foo	/^   delete_group_scf_archives ::: recursive$/;"	r
delete_tmp_scf_archives	molecule.foo	/^   delete_tmp_scf_archives$/;"	r
delete_old_scf_archives	molecule.foo	/^   delete_old_scf_archives$/;"	r
delete_scf_MO_archive	molecule.foo	/^   delete_scf_MO_archive$/;"	r
delete_scf_integrals	molecule.foo	/^   delete_scf_integrals ::: leaky$/;"	r
delete_n_pole_integrals	molecule.foo	/^   delete_n_pole_integrals ::: leaky$/;"	r
delete_archive	molecule.foo	/^   delete_archive(name)$/;"	r
delete_old_scf_matrices	molecule.foo	/^   delete_old_scf_matrices$/;"	r
canonicalize_MOs	molecule.foo	/^   canonicalize_MOs$/;"	r
canonicalize_r_MO	molecule.foo	/^   canonicalize_r_MO(MO_energies,MO,F,n)$/;"	r
get_initial_guess	molecule.foo	/^   get_initial_guess ::: leaky, recursive$/;"	r
get_initial_MOs	molecule.foo	/^   get_initial_MOs ::: leaky$/;"	r
read_old_MOs_guess	molecule.foo	/^   read_old_MOs_guess ::: leaky$/;"	r
make_atom_MOs_guess	molecule.foo	/^   make_atom_MOs_guess ::: leaky$/;"	r
get_initial_density	molecule.foo	/^   get_initial_density ::: leaky, recursive$/;"	r
make_density_guess	molecule.foo	/^   make_density_guess ::: leaky$/;"	r
make_core_guess	molecule.foo	/^   make_core_guess ::: leaky$/;"	r
make_r_guess_from	molecule.foo	/^   make_r_guess_from(fock_matrix,MO_energies,MO) ::: private$/;"	r
make_gc_guess_from	molecule.foo	/^   make_gc_guess_from(fock_matrix,MO_energies,MO) ::: private$/;"	r
make_promolecule_guess	molecule.foo	/^   make_promolecule_guess ::: leaky$/;"	r
get_promolecule_density	molecule.foo	/^   get_promolecule_density ::: leaky$/;"	r
add_ANO_densities	molecule.foo	/^   add_ANO_densities ::: leaky$/;"	r
get_promolecule_density_old	molecule.foo	/^   get_promolecule_density_old ::: leaky$/;"	r
make_promolecule_density	molecule.foo	/^   make_promolecule_density ::: leaky$/;"	r
make_progroup_guess	molecule.foo	/^   make_progroup_guess ::: leaky$/;"	r
get_progroup_density	molecule.foo	/^   get_progroup_density ::: leaky$/;"	r
make_progroup_density	molecule.foo	/^   make_progroup_density(MOs,output) ::: leaky$/;"	r
make_group_energies	molecule.foo	/^   make_group_energies(g,E_SCF,E_T,E_Z,E_C,E_K,fac)$/;"	r
make_fock_guess	molecule.foo	/^   make_fock_guess ::: leaky$/;"	r
make_gc_fock_guess	molecule.foo	/^   make_gc_fock_guess(MO_energies,MO,fock_matrix)$/;"	r
make_diis_error_length	molecule.foo	/^   make_diis_error_length(length)$/;"	r
accelerate_fock_matrix	molecule.foo	/^   accelerate_fock_matrix$/;"	r
make_gc_diis_error	molecule.foo	/^   make_gc_diis_error(error,F,P)$/;"	r
get_fock_matrix	molecule.foo	/^   get_fock_matrix ::: leaky$/;"	r
make_fock_matrix	molecule.foo	/^   make_fock_matrix(core,r12) ::: leaky$/;"	r
make_fock_matrix	molecule.foo	/^   make_fock_matrix(P,F,core,r12,xc) ::: leaky$/;"	r
add_core_hamiltonian	molecule.foo	/^   add_core_hamiltonian(F)$/;"	r
make_r_fock	molecule.foo	/^   make_r_fock(P,F,direct,core,r12) ::: leaky$/;"	r
make_r_KS_fock	molecule.foo	/^   make_r_KS_fock(P,F,direct,core,r12,xc) ::: leaky$/;"	r
make_u_fock	molecule.foo	/^   make_u_fock(P,F,direct,core,r12) ::: leaky$/;"	r
make_u_KS_fock	molecule.foo	/^   make_u_KS_fock(P,F,core,r12,xc) ::: leaky$/;"	r
make_ro_fock	molecule.foo	/^   make_ro_fock(P,F,direct,core,r12) ::: leaky$/;"	r
make_gc_fock	molecule.foo	/^   make_gc_fock(P,F,direct,core,r12) ::: leaky$/;"	r
add_gc_so_fock	molecule.foo	/^   add_gc_so_fock(P,F,direct) ::: leaky$/;"	r
in_same_atom_group	molecule.foo	/^   in_same_atom_group(atom_a,atom_b,group) result (res)$/;"	r
in_same_atom_group	molecule.foo	/^   in_same_atom_group(atom_a,atom_b,atom_c,atom_d) result (res)$/;"	r
schwarz_inequality_test	molecule.foo	/^   schwarz_inequality_test(cutoff,ab,cd,a,b,c,d,P_max,I_max) result(skip)$/;"	r
schwarz_test	molecule.foo	/^   schwarz_test(skip_J,skip_K,cutoff,JP_cut,KP_cut,ab,cd,a,b,c,d,P_max,I_max)$/;"	r
schwarz_J_test	molecule.foo	/^   schwarz_J_test(skip_J,cutoff,ab,cd,P_max,I_max)$/;"	r
schwarz_K_test	molecule.foo	/^   schwarz_K_test(skip_K,cutoff,ab,cd,a,b,c,d,P_max,I_max)$/;"	r
make_max_density_elements	molecule.foo	/^   make_max_density_elements(P_max,P)$/;"	r
make_max_density_elements	molecule.foo	/^   make_max_density_elements(P_max,Pa,Pb)$/;"	r
make_max_abab_integrals	molecule.foo	/^   make_max_abab_integrals(I_max)$/;"	r
make_max_abab_so_integrals	molecule.foo	/^   make_max_abab_so_integrals(I_max)$/;"	r
make_max_S_integrals	molecule.foo	/^   make_max_S_integrals(S_max)$/;"	r
reverse_transfer	molecule.foo	/^   reverse_transfer(P,PP) ::: leaky$/;"	r
forward_transfer	molecule.foo	/^   forward_transfer(JJ,J) ::: leaky$/;"	r
create_transfer	molecule.foo	/^   create_transfer(JJ) ::: leaky$/;"	r
make_r_JK_direct	molecule.foo	/^   make_r_JK_direct(J,K,P)$/;"	r
make_r_JK_direct2	molecule.foo	/^   make_r_JK_direct2(J,K,P)$/;"	r
make_r_J_direct	molecule.foo	/^   make_r_J_direct(J,P)$/;"	r
make_r_K_direct	molecule.foo	/^   make_r_K_direct(K,P)$/;"	r
make_r_JK_disk	molecule.foo	/^   make_r_JK_disk(J,K,P)$/;"	r
make_r_J_disk	molecule.foo	/^   make_r_J_disk(J,P)$/;"	r
make_r_K_disk	molecule.foo	/^   make_r_K_disk(K,P)$/;"	r
make_r_JK_nosym	molecule.foo	/^   make_r_JK_nosym(J,K,P)$/;"	r
make_u_JK_direct	molecule.foo	/^   make_u_JK_direct(J,K,P)$/;"	r
make_u_JK_direct2	molecule.foo	/^   make_u_JK_direct2(J,K,P)$/;"	r
make_u_JK_disk	molecule.foo	/^   make_u_JK_disk(J,Ka,Kb,P,Pa,Pb)$/;"	r
make_gc_JK_direct	molecule.foo	/^   make_gc_JK_direct(J,Ka,Kb,Kba,P,Pa,Pb,Pba)$/;"	r
make_gc_JK_disk	molecule.foo	/^   make_gc_JK_disk(J,Ka,Kb,Kba,P,Pa,Pb,Pba)$/;"	r
make_gc_so_JK_direct	molecule.foo	/^   make_gc_so_JK_direct(JS,KS,JO,KO,P)$/;"	r
make_gc_so_JK_disk	molecule.foo	/^   make_gc_so_JK_disk(JS,KS,JO,KO,P,component)$/;"	r
weight_diagonal_blocks	molecule.foo	/^   weight_diagonal_blocks(X,fac) ::: pure$/;"	r
weight_diagonal_blocks	molecule.foo	/^   weight_diagonal_blocks(X,fac) ::: pure$/;"	r
set_diagonal_blocks	molecule.foo	/^   set_diagonal_blocks(X,fac) ::: pure$/;"	r
blockwise_symmetric_fold	molecule.foo	/^   blockwise_symmetric_fold(X)$/;"	r
blockwise_hermitian_fold	molecule.foo	/^   blockwise_hermitian_fold(X)$/;"	r
add_XC_matrix	molecule.foo	/^   add_XC_matrix(K) ::: leaky$/;"	r
add_XC_matrix	molecule.foo	/^   add_XC_matrix(K)$/;"	r
add_LDA_XC_matrix	molecule.foo	/^   add_LDA_XC_matrix(K,E) ::: leaky$/;"	r
add_LDA_XC_matrix	molecule.foo	/^   add_LDA_XC_matrix(V,E,V0,E0,bf_skip,bf_grid0,c,D)$/;"	r
make_rho_becke_atom_grid	molecule.foo	/^   make_rho_becke_atom_grid(N0,pt,wt,bf_skip,bf_grid0,c,D) ::: leaky$/;"	r
add_LDA_XC_matrix_old	molecule.foo	/^   add_LDA_XC_matrix_old(K,E)$/;"	r
add_GGA_XC_matrix	molecule.foo	/^   add_GGA_XC_matrix(K,E) ::: leaky$/;"	r
add_GGA_XC_matrix	molecule.foo	/^   add_GGA_XC_matrix(V,E,V0,Vx,Vy,Vz,E0,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,D)$/;"	r
make_rho_becke_atom_grid	molecule.foo	/^   make_rho_becke_atom_grid(N0,Nx,Ny,Nz,pt,wt,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,D) ::: leaky$/;"	r
add_GGA_XC_matrix_old	molecule.foo	/^   add_GGA_XC_matrix_old(K,E)$/;"	r
new_set_r_XC_energy_density	molecule.foo	/^   new_set_r_XC_energy_density(E,N0,Nx,Ny,Nz)$/;"	r
new_set_r_XC_potentials	molecule.foo	/^   new_set_r_XC_potentials(V0,N0,Vx,Vy,Vz,Nx,Ny,Nz)$/;"	r
add_XC_matrix	molecule.foo	/^   add_XC_matrix(Ka,Kb)$/;"	r
add_LDA_XC_matrix	molecule.foo	/^   add_LDA_XC_matrix(Ka,Kb,E,Ea,Eb) ::: leaky$/;"	r
add_LDA_XC_matrix	molecule.foo	/^   add_LDA_XC_matrix(Va,Vb,Ea,Eb,V0a,V0b,E0,bf_skip,bf_grid0,c,Da,Db)$/;"	r
make_rho_becke_atom_grid	molecule.foo	/^   make_rho_becke_atom_grid(N0a,N0b,pt,wt,bf_skip,bf_grid0,c,Da,Db) ::: leaky$/;"	r
add_LDA_XC_matrix_old	molecule.foo	/^   add_LDA_XC_matrix_old(Ka,Kb,E,Ea,Eb)$/;"	r
add_GGA_XC_matrix	molecule.foo	/^   add_GGA_XC_matrix(Ka,Kb,E,Ea,Eb) ::: leaky$/;"	r
add_GGA_XC_matrix	molecule.foo	/^   add_GGA_XC_matrix(Va,Vb,Ea,Eb,V0a,V0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,E0,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,Da,Db)$/;"	r
make_rho_becke_atom_grid	molecule.foo	/^   make_rho_becke_atom_grid(N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb,pt,wt,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,Da,Db) ::: leaky$/;"	r
add_GGA_XC_matrix_old	molecule.foo	/^   add_GGA_XC_matrix_old(Ka,Kb,E,Ea,Eb)$/;"	r
new_set_u_XC_energy_density	molecule.foo	/^   new_set_u_XC_energy_density(E,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)$/;"	r
new_set_u_XC_potentials	molecule.foo	/^   new_set_u_XC_potentials(V0a,V0b,N0a,N0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,Nxa,Nya,Nza,Nxb,Nyb,Nzb)$/;"	r
get_ERI_integrals	molecule.foo	/^   get_ERI_integrals$/;"	r
make_eri_integrals	molecule.foo	/^   make_eri_integrals(eri_archive,eri_index)$/;"	r
get_spin_orbit_integrals	molecule.foo	/^   get_spin_orbit_integrals$/;"	r
make_spin_orbit_integrals	molecule.foo	/^   make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)$/;"	r
put_scf_energy_in_mo_pairs	molecule.foo	/^   put_scf_energy_in_mo_pairs$/;"	r
put_AO_energy_partition	molecule.foo	/^   put_AO_energy_partition$/;"	r
put_SAO_energy_partition	molecule.foo	/^   put_SAO_energy_partition$/;"	r
put_MO_energy_partition	molecule.foo	/^   put_MO_energy_partition$/;"	r
put_energy_partition	molecule.foo	/^   put_energy_partition(Y)$/;"	r
put_roby_smo_energy_partition	molecule.foo	/^   put_roby_smo_energy_partition$/;"	r
put_roby_mmo_energy_partition	molecule.foo	/^   put_roby_mmo_energy_partition$/;"	r
put_roby_energy_partition	molecule.foo	/^   put_roby_energy_partition(symorthonormalise) ::: leaky$/;"	r
put_roby_energy_parts	molecule.foo	/^   put_roby_energy_parts(E_T,E_K,E_C,E_Z,E_N,E_int,E_prom) ::: private$/;"	r
atom_group_AO_subspace_set	molecule.foo	/^   atom_group_AO_subspace_set(P,Q,row_group,col_group)$/;"	r
AO_subspace_set	molecule.foo	/^   AO_subspace_set(A,B,row_atom,col_atom) ::: private$/;"	r
AO_subspace_zero	molecule.foo	/^   AO_subspace_zero(B,row_atom,col_atom) ::: private$/;"	r
AO_subspace_put	molecule.foo	/^   AO_subspace_put(B,A,row_atom,col_atom) ::: private$/;"	r
make_monomer_MOs	molecule.foo	/^   make_monomer_MOs ::: leaky$/;"	r
make_promol_MOs	molecule.foo	/^   make_promol_MOs ::: leaky$/;"	r
make_density_grid	molecule.foo	/^   make_density_grid(density_grid,pt,sgn)$/;"	r
make_density_grid	molecule.foo	/^   make_density_grid(p_a,p_b,pt)$/;"	r
make_density_grid_r	molecule.foo	/^   make_density_grid_r(density_grid,pt)$/;"	r
make_density_grid_u	molecule.foo	/^   make_density_grid_u(density_grid,pt,sgn)$/;"	r
make_density_grid_c	molecule.foo	/^   make_density_grid_c(density_grid,pt)$/;"	r
make_density_grid_gc	molecule.foo	/^   make_density_grid_gc(density_grid,pt)$/;"	r
make_density_grid_r	molecule.foo	/^   make_density_grid_r(density_grid,pt,NO,occ)$/;"	r
make_orbital_density_grid	molecule.foo	/^   make_orbital_density_grid$/;"	r
make_orbital_grid	molecule.foo	/^   make_orbital_grid$/;"	r
make_orbital_grid_r	molecule.foo	/^   make_orbital_grid_r(g,orb,pt,square)$/;"	r
make_orbital_grid_c	molecule.foo	/^   make_orbital_grid_c(g,orb,pt,square)$/;"	r
make_orbital_grid_gc	molecule.foo	/^   make_orbital_grid_gc(g,orb,pt,square)$/;"	r
make_orbital_grid_gc	molecule.foo	/^   make_orbital_grid_gc(gu,gd,orb,pt)$/;"	r
make_nabla_density_grid	molecule.foo	/^   make_nabla_density_grid(nabla_grid,pts)$/;"	r
make_nabla_density_grid	molecule.foo	/^   make_nabla_density_grid(nabla_grid,grid,pts)$/;"	r
make_nabla_density_grid_r	molecule.foo	/^   make_nabla_density_grid_r(nabla_grid,pts)$/;"	r
make_nabla_density_grid_r	molecule.foo	/^   make_nabla_density_grid_r(nabla_grid,grid,pts)$/;"	r
make_nabla_orbital_grid_r	molecule.foo	/^   make_nabla_orbital_grid_r(g,h,orb,pt)$/;"	r
make_nabla_orbital_grid_c	molecule.foo	/^   make_nabla_orbital_grid_c(g,h,orb,pt)$/;"	r
make_laplacian_orbital_grid_r	molecule.foo	/^   make_laplacian_orbital_grid_r(g,h,i,orb,pt)$/;"	r
make_laplacian_orbital_grid_c	molecule.foo	/^   make_laplacian_orbital_grid_c(g,h,i,orb,pt)$/;"	r
make_density_grid_r_B	molecule.foo	/^   make_density_grid_r_B(rho0,pt,atoms,a0,b0)$/;"	r
make_density_grid_u_B	molecule.foo	/^   make_density_grid_u_B(rho0a,rho0b,pt,atoms,a0,b0)$/;"	r
make_nabla_density_grid_r_B	molecule.foo	/^   make_nabla_density_grid_r_B(grid1,grid0,pt,atoms)$/;"	r
make_nabla_density_grid_r_B	molecule.foo	/^   make_nabla_density_grid_r_B(rho1,rho0,pt,atoms,a1,a0,b1,b0,ma,mb,n_occ,bf_cutoff)$/;"	r
make_nabla_density_grid_r_C	molecule.foo	/^   make_nabla_density_grid_r_C(rho1,rho0,pt,atoms,a1,a0,b1,b0,ma,mb,cutoff)$/;"	r
make_nabla_density_grid_u_A	molecule.foo	/^   make_nabla_density_grid_u_A(rho1a,rho1b,rho0a,rho0b,pt,atoms,aa1,aa0,bb1,bb0,cutoff)$/;"	r
make_nabla_density_grid_u_B	molecule.foo	/^   make_nabla_density_grid_u_B(rho1a,rho1b,rho0a,rho0b,pt,atoms,a1,a0,b1,b0,ma,mb,cutoff)$/;"	r
make_nabla_density_grid	molecule.foo	/^   make_nabla_density_grid(np_a,np_b,pt)$/;"	r
make_nabla_density_grid	molecule.foo	/^   make_nabla_density_grid(np_a,np_b,p_a,p_b,pt)$/;"	r
plot	molecule.foo	/^   plot ::: leaky$/;"	r
do_plot	molecule.foo	/^   do_plot ::: leaky$/;"	r
bounding_cube_width	molecule.foo	/^   bounding_cube_width result(width)$/;"	r
make_crystal_error_map	molecule.foo	/^   make_crystal_error_map ::: leaky$/;"	r
make_crystal_error_map	molecule.foo	/^   make_crystal_error_map(map)$/;"	r
make_oscillator_orbital_grid	molecule.foo	/^   make_oscillator_orbital_grid$/;"	r
make_oscillator_orbital_grid_r	molecule.foo	/^   make_oscillator_orbital_grid_r(g,ind,pt,square)$/;"	r
make_p_oscillator_orb_grid_r	molecule.foo	/^   make_p_oscillator_orb_grid_r(g,ind,pt,square)$/;"	r
density_grid	molecule.foo	/^   density_grid ::: template$/;"	r
deformation_grid	molecule.foo	/^   deformation_grid(grid,pt) ::: template$/;"	r
pro_grid	molecule.foo	/^   pro_grid(density_grid,pt) ::: template$/;"	r
pro_dft_grid	molecule.foo	/^   pro_dft_grid(density_grid,pt) ::: template$/;"	r
dump_plot_grid	molecule.foo	/^   dump_plot_grid(grid,name)$/;"	r
delete_plot_grid	molecule.foo	/^   delete_plot_grid(name)$/;"	r
delete_plot_grid	molecule.foo	/^   delete_plot_grid$/;"	r
make_electron_density_grid	molecule.foo	/^   make_electron_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_density_grid, LABEL=>"electron_density_grid")$/;"	r
make_deformation_density_grid	molecule.foo	/^   make_deformation_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_deformation_density_grid, LABEL=>"deformation_density_grid")$/;"	r
make_deformation_density_grid	molecule.foo	/^   make_deformation_density_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_density_grid, MAKE_PRO_GRID=>.make_promolecule_density_grid)$/;"	r
make_spin_density_grid	molecule.foo	/^   make_spin_density_grid$/;"	r
make_def_bond_density_grid	molecule.foo	/^   make_def_bond_density_grid$/;"	r
make_def_bond_density_grid	molecule.foo	/^   make_def_bond_density_grid(density_grid,pt,bond_density_atom)$/;"	r
make_def_bond_density_grid	molecule.foo	/^   make_def_bond_density_grid(density_grid,pt,bond_density_atom,def_density_grid)$/;"	r
make_bond_weight_grid	molecule.foo	/^   make_bond_weight_grid$/;"	r
make_bond_weight_grid	molecule.foo	/^   make_bond_weight_grid(density_grid,pt,bond_density_atom)$/;"	r
make_bond_density_atom_grid	molecule.foo	/^   make_bond_density_atom_grid$/;"	r
make_bond_density_atom_grid	molecule.foo	/^   make_bond_density_atom_grid(density_grid,pt,a)$/;"	r
make_local_ionisation_grid	molecule.foo	/^   make_local_ionisation_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_local_ionisation_grid, LABEL=>"local_ionisation_energy_grid")$/;"	r
make_local_ionisation_grid	molecule.foo	/^   make_local_ionisation_grid(grid,pt)$/;"	r
make_local_ionisation_grid_r	molecule.foo	/^   make_local_ionisation_grid_r(grid,pt)$/;"	r
make_laplacian_grid	molecule.foo	/^   make_laplacian_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_laplacian_grid, LABEL=>"laplacian_grid")$/;"	r
make_laplacian_grid	molecule.foo	/^   make_laplacian_grid(laplacian_grid,pt)$/;"	r
make_laplacian_grid_r	molecule.foo	/^   make_laplacian_grid_r(laplacian_grid,pt)$/;"	r
make_def_laplacian_grid	molecule.foo	/^   make_def_laplacian_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_laplacian_grid, LABEL=>"deformation_laplacian_grid")$/;"	r
make_def_laplacian_grid	molecule.foo	/^   make_def_laplacian_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_laplacian_grid, MAKE_PRO_GRID=>.make_pro_laplacian_grid)$/;"	r
make_pro_laplacian_grid	molecule.foo	/^   make_pro_laplacian_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_laplacian_grid)$/;"	r
make_neg_laplacian_grid	molecule.foo	/^   make_neg_laplacian_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_neg_laplacian_grid, LABEL=>"negative_laplacian_grid")$/;"	r
make_neg_laplacian_grid	molecule.foo	/^   make_neg_laplacian_grid(laplacian_grid,pt)$/;"	r
make_rL_grid	molecule.foo	/^   make_rL_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rL_grid, LABEL=>"reduced_laplacian_grid")$/;"	r
make_rL_grid	molecule.foo	/^   make_rL_grid(laplacian_grid,pt)$/;"	r
make_rL_grid_r	molecule.foo	/^   make_rL_grid_r(laplacian_grid,pt)$/;"	r
make_K_kinetic_energy_grid	molecule.foo	/^   make_K_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_K_kinetic_energy_grid, LABEL=>"K_kinetic_energy_grid")$/;"	r
make_K_kinetic_energy_grid	molecule.foo	/^   make_K_kinetic_energy_grid(K_grid,pt)$/;"	r
make_K_kinetic_density_grid_r	molecule.foo	/^   make_K_kinetic_density_grid_r(K_grid,pt)$/;"	r
make_def_K_kinetic_grid	molecule.foo	/^   make_def_K_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_K_kinetic_grid, LABEL=>"deformation_K_kinetic_grid")$/;"	r
make_def_K_kinetic_grid	molecule.foo	/^   make_def_K_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_K_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_K_kinetic_grid)$/;"	r
make_pro_K_kinetic_grid	molecule.foo	/^   make_pro_K_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_K_kinetic_energy_grid)$/;"	r
make_rK_kinetic_energy_grid	molecule.foo	/^   make_rK_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rK_kinetic_energy_grid, LABEL=>"reduced_K_kinetic_energy_grid")$/;"	r
make_rK_kinetic_energy_grid	molecule.foo	/^   make_rK_kinetic_energy_grid(K_grid,pt)$/;"	r
make_rK_kinetic_density_grid_r	molecule.foo	/^   make_rK_kinetic_density_grid_r(K_grid,pt)$/;"	r
make_def_rK_kinetic_grid	molecule.foo	/^   make_def_rK_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rK_kinetic_grid, LABEL=>"deformation_reduced_K_kinetic_grid")$/;"	r
make_def_rK_kinetic_grid	molecule.foo	/^   make_def_rK_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rK_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_rK_kinetic_grid)$/;"	r
make_pro_rK_kinetic_grid	molecule.foo	/^   make_pro_rK_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rK_kinetic_energy_grid)$/;"	r
make_G_kinetic_energy_grid	molecule.foo	/^   make_G_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_G_kinetic_energy_grid, LABEL=>"G_kinetic_energy_grid")$/;"	r
make_G_kinetic_energy_grid	molecule.foo	/^   make_G_kinetic_energy_grid(G_grid,pt)$/;"	r
make_G_kinetic_density_grid_r	molecule.foo	/^   make_G_kinetic_density_grid_r(G_grid,pt)$/;"	r
make_G_Kirzhnits_grid	molecule.foo	/^   make_G_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_G_Kirzhnits_grid, LABEL=>"G_Kirzhnits_grid")$/;"	r
make_G_Kirzhnits_grid	molecule.foo	/^   make_G_Kirzhnits_grid(G_grid,pt)$/;"	r
make_G_Kirzhnits_grid_r	molecule.foo	/^   make_G_Kirzhnits_grid_r(G_grid,pt)$/;"	r
make_def_G_kinetic_grid	molecule.foo	/^   make_def_G_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_G_kinetic_grid, LABEL=>"deformation_G_kinetic_grid")$/;"	r
make_def_G_kinetic_grid	molecule.foo	/^   make_def_G_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_G_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_G_kinetic_grid)$/;"	r
make_pro_G_kinetic_grid	molecule.foo	/^   make_pro_G_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_G_kinetic_energy_grid)$/;"	r
make_def_G_Kirzhnits_grid	molecule.foo	/^   make_def_G_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_G_Kirzhnits_grid, LABEL=>"deformation_G_Kirzhnits_grid")$/;"	r
make_def_G_Kirzhnits_grid	molecule.foo	/^   make_def_G_Kirzhnits_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_G_Kirzhnits_grid, MAKE_PRO_GRID=>.make_pro_G_Kirzhnits_grid)$/;"	r
make_pro_G_Kirzhnits_grid	molecule.foo	/^   make_pro_G_Kirzhnits_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_G_Kirzhnits_grid)$/;"	r
make_rG_kinetic_energy_grid	molecule.foo	/^   make_rG_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rG_kinetic_energy_grid, LABEL=>"reduced_G_kinetic_energy_grid")$/;"	r
make_rG_kinetic_energy_grid	molecule.foo	/^   make_rG_kinetic_energy_grid(G_grid,pt)$/;"	r
make_rG_kinetic_density_grid_r	molecule.foo	/^   make_rG_kinetic_density_grid_r(G_grid,pt)$/;"	r
make_def_rG_kinetic_grid	molecule.foo	/^   make_def_rG_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rG_kinetic_grid, LABEL=>"deformation_reduced_G_kinetic_grid")$/;"	r
make_def_rG_kinetic_grid	molecule.foo	/^   make_def_rG_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rG_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_rG_kinetic_grid)$/;"	r
make_pro_rG_kinetic_grid	molecule.foo	/^   make_pro_rG_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rG_kinetic_energy_grid)$/;"	r
make_G_and_K_kinetic_grids	molecule.foo	/^   make_G_and_K_kinetic_grids(G_grid,K_grid,pt)$/;"	r
make_G_and_K_kinetic_grids_r	molecule.foo	/^   make_G_and_K_kinetic_grids_r(G_grid,K_grid,pt)$/;"	r
make_E_hf_dens_from_rho_grid	molecule.foo	/^   make_E_hf_dens_from_rho_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_E_hf_dens_from_rho_grid, LABEL=>"E_hf_density_from_rho_grid")$/;"	r
make_E_hf_dens_from_rho_grid	molecule.foo	/^   make_E_hf_dens_from_rho_grid(E_grid,pt)$/;"	r
make_def_E_hf_from_rho_grid	molecule.foo	/^   make_def_E_hf_from_rho_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_E_hf_dens_from_rho_grid, MAKE_PRO_GRID=>.make_E_hf_dens_from_rho_grid)$/;"	r
make_H_from_virial_grid	molecule.foo	/^   make_H_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_H_from_virial_grid, LABEL=>"H_from_virial_energy_grid")$/;"	r
make_H_from_virial_grid	molecule.foo	/^   make_H_from_virial_grid(H_grid,pt)$/;"	r
make_def_H_from_virial_grid	molecule.foo	/^   make_def_H_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_H_from_virial_grid, LABEL=>"deformation_H_from_virial_energy_grid")$/;"	r
make_def_H_from_virial_grid	molecule.foo	/^   make_def_H_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_H_from_virial_grid, MAKE_PRO_GRID=>.make_pro_H_from_virial_grid)$/;"	r
make_pro_H_from_virial_grid	molecule.foo	/^   make_pro_H_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_H_from_virial_grid)$/;"	r
make_H_Kirzhnits_grid	molecule.foo	/^   make_H_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_H_Kirzhnits_grid, LABEL=>"H_Kirzhnits_energy_grid")$/;"	r
make_H_Kirzhnits_grid	molecule.foo	/^   make_H_Kirzhnits_grid(H_grid,pt)$/;"	r
make_def_H_Kirzhnits_grid	molecule.foo	/^   make_def_H_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_H_Kirzhnits_grid, LABEL=>"deformation_H_Kirzhnits_energy_grid")$/;"	r
make_def_H_Kirzhnits_grid	molecule.foo	/^   make_def_H_Kirzhnits_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_H_Kirzhnits_grid, MAKE_PRO_GRID=>.make_pro_H_Kirzhnits_grid)$/;"	r
make_pro_H_Kirzhnits_grid	molecule.foo	/^   make_pro_H_Kirzhnits_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_H_Kirzhnits_grid)$/;"	r
make_rH_from_virial_grid	molecule.foo	/^   make_rH_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rH_from_virial_grid, LABEL=>"reduced_H_from_virial_energy_grid")$/;"	r
make_rH_from_virial_grid	molecule.foo	/^   make_rH_from_virial_grid(H_grid,pt)$/;"	r
make_def_rH_from_virial_grid	molecule.foo	/^   make_def_rH_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rH_from_virial_grid, LABEL=>"deformation_reduced_H_from_virial_energy_grid")$/;"	r
make_def_rH_from_virial_grid	molecule.foo	/^   make_def_rH_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rH_from_virial_grid, MAKE_PRO_GRID=>.make_pro_rH_from_virial_grid)$/;"	r
make_pro_rH_from_virial_grid	molecule.foo	/^   make_pro_rH_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rH_from_virial_grid)$/;"	r
make_V_from_virial_grid	molecule.foo	/^   make_V_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_V_from_virial_grid, LABEL=>"V_from_virial_energy_grid")$/;"	r
make_V_from_virial_grid	molecule.foo	/^   make_V_from_virial_grid(V,pt)$/;"	r
make_def_V_from_virial_grid	molecule.foo	/^   make_def_V_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_V_from_virial_grid, LABEL=>"deformation_V_from_virial_energy_grid")$/;"	r
make_def_V_from_virial_grid	molecule.foo	/^   make_def_V_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_V_from_virial_grid, MAKE_PRO_GRID=>.make_pro_V_from_virial_grid)$/;"	r
make_pro_V_from_virial_grid	molecule.foo	/^   make_pro_V_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_V_from_virial_grid)$/;"	r
make_V_Kirzhnits_grid	molecule.foo	/^   make_V_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_V_Kirzhnits_grid, LABEL=>"V_Kirzhnits_energy_grid")$/;"	r
make_V_Kirzhnits_grid	molecule.foo	/^   make_V_Kirzhnits_grid(V,pt)$/;"	r
make_def_V_Kirzhnits_grid	molecule.foo	/^   make_def_V_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_V_Kirzhnits_grid, LABEL=>"deformation_V_Kirzhnits_energy_grid")$/;"	r
make_def_V_Kirzhnits_grid	molecule.foo	/^   make_def_V_Kirzhnits_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_V_Kirzhnits_grid, MAKE_PRO_GRID=>.make_pro_V_Kirzhnits_grid)$/;"	r
make_pro_V_Kirzhnits_grid	molecule.foo	/^   make_pro_V_Kirzhnits_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_V_Kirzhnits_grid)$/;"	r
make_rV_from_virial_grid	molecule.foo	/^   make_rV_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rV_from_virial_grid, LABEL=>"reduced_V_from_virial_energy_grid")$/;"	r
make_rV_from_virial_grid	molecule.foo	/^   make_rV_from_virial_grid(V,pt)$/;"	r
make_def_rV_from_virial_grid	molecule.foo	/^   make_def_rV_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rV_from_virial_grid, LABEL=>"deformation_reduced_V_from_virial_energy_grid")$/;"	r
make_def_rV_from_virial_grid	molecule.foo	/^   make_def_rV_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rV_from_virial_grid, MAKE_PRO_GRID=>.make_pro_rV_from_virial_grid)$/;"	r
make_pro_rV_from_virial_grid	molecule.foo	/^   make_pro_rV_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rV_from_virial_grid)$/;"	r
make_electric_potential_grid	molecule.foo	/^   make_electric_potential_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_electric_potential_grid, LABEL=>"electric_potential_grid")$/;"	r
make_electric_potential_grid	molecule.foo	/^   make_electric_potential_grid(pot_grid,pt)$/;"	r
make_electric_potential_grid_r	molecule.foo	/^   make_electric_potential_grid_r(pot_grid,pt,dens)$/;"	r
make_electric_potential_grid_c	molecule.foo	/^   make_electric_potential_grid_c(pot_grid,pt,dens)$/;"	r
make_electronic_pot_grid	molecule.foo	/^   make_electronic_pot_grid(pot_grid,pt)$/;"	r
make_electronic_pot_grid_r	molecule.foo	/^   make_electronic_pot_grid_r(pot_grid,pt,dens)$/;"	r
make_electronic_pot_grid_c	molecule.foo	/^   make_electronic_pot_grid_c(pot_grid,pt,dens)$/;"	r
make_def_e_pot_grid	molecule.foo	/^   make_def_e_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_e_pot_grid, LABEL=>"deformation_electric_potential_grid")$/;"	r
make_def_e_pot_grid	molecule.foo	/^   make_def_e_pot_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_electric_potential_grid, MAKE_PRO_GRID=>.make_pro_e_pot_grid)$/;"	r
make_pro_e_pot_grid	molecule.foo	/^   make_pro_e_pot_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_electric_potential_grid)$/;"	r
make_dft_xc_pot_grid	molecule.foo	/^   make_dft_xc_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_dft_xc_pot_grid, LABEL=>trim(.scfdata.DFT_functional_name)\/\/"_potential_grid")$/;"	r
make_dft_xc_pot_grid	molecule.foo	/^   make_dft_xc_pot_grid(V,pt)$/;"	r
make_def_dft_xc_pot_grid	molecule.foo	/^   make_def_dft_xc_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_dft_xc_pot_grid, LABEL=>"deformation_"\/\/trim(.scfdata.DFT_functional_name)\/\/"_potential_grid")$/;"	r
make_def_dft_xc_pot_grid	molecule.foo	/^   make_def_dft_xc_pot_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_dft_xc_pot_grid, MAKE_PRO_GRID=>.make_pro_dft_xc_pot_grid)$/;"	r
make_pro_dft_xc_pot_grid	molecule.foo	/^   make_pro_dft_xc_pot_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_dft_xc_pot_grid)$/;"	r
make_dft_eff_pot_grid	molecule.foo	/^   make_dft_eff_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_dft_eff_pot_grid, LABEL=>trim(.scfdata.DFT_functional_name)\/\/"_eff_potential_grid")$/;"	r
make_dft_eff_pot_grid	molecule.foo	/^   make_dft_eff_pot_grid(V,pt)$/;"	r
make_def_dft_eff_pot_grid	molecule.foo	/^   make_def_dft_eff_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_dft_eff_pot_grid, LABEL=>"deformation_"\/\/trim(.scfdata.DFT_functional_name)\/\/"_eff_potential_grid")$/;"	r
make_def_dft_eff_pot_grid	molecule.foo	/^   make_def_dft_eff_pot_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_dft_eff_pot_grid, MAKE_PRO_GRID=>.make_pro_dft_eff_pot_grid)$/;"	r
make_pro_dft_eff_pot_grid	molecule.foo	/^   make_pro_dft_eff_pot_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_dft_eff_pot_grid)$/;"	r
make_dft_energy_grid	molecule.foo	/^   make_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_dft_energy_grid, LABEL=>trim(.scfdata.DFT_functional_name)\/\/"_energy_grid")$/;"	r
make_dft_energy_grid	molecule.foo	/^   make_dft_energy_grid(V,pt)$/;"	r
make_def_dft_energy_grid	molecule.foo	/^   make_def_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_dft_energy_grid, LABEL=>"deformation_"\/\/trim(.scfdata.DFT_functional_name)\/\/"_energy_grid")$/;"	r
make_def_dft_energy_grid	molecule.foo	/^   make_def_dft_energy_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_dft_energy_grid, MAKE_PRO_GRID=>.make_pro_dft_energy_grid)$/;"	r
make_pro_dft_energy_grid	molecule.foo	/^   make_pro_dft_energy_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_dft_energy_grid)$/;"	r
make_H_dft_energy_grid	molecule.foo	/^   make_H_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_H_dft_energy_grid, LABEL=>"H_"\/\/trim(.scfdata.DFT_functional_name)\/\/"_energy_grid")$/;"	r
make_H_dft_energy_grid	molecule.foo	/^   make_H_dft_energy_grid(H_grid,pt)$/;"	r
make_def_H_dft_energy_grid	molecule.foo	/^   make_def_H_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_H_dft_energy_grid, LABEL=>"deformation_H_"\/\/trim(.scfdata.DFT_functional_name)\/\/"_energy_grid")$/;"	r
make_def_H_dft_energy_grid	molecule.foo	/^   make_def_H_dft_energy_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_H_dft_energy_grid, MAKE_PRO_GRID=>.make_pro_H_dft_energy_grid)$/;"	r
make_pro_H_dft_energy_grid	molecule.foo	/^   make_pro_H_dft_energy_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_H_dft_energy_grid)$/;"	r
make_Hirshfeld_density_grid	molecule.foo	/^   make_Hirshfeld_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_Hirshfeld_density_grid, LABEL=>"stockholder_density_grid")$/;"	r
make_Hirshfeld_density_grid	molecule.foo	/^   make_Hirshfeld_density_grid(density_grid,pt)$/;"	r
make_stockholder_density_grid	molecule.foo	/^   make_stockholder_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_stockholder_density_grid, LABEL=>"stockholder_density_grid")$/;"	r
make_stockholder_density_grid	molecule.foo	/^   make_stockholder_density_grid(density_grid,pt)$/;"	r
make_Hirshfeld_atom_grid	molecule.foo	/^   make_Hirshfeld_atom_grid$/;"	r
make_Hirshfeld_atom_grid	molecule.foo	/^   make_Hirshfeld_atom_grid(N0,pt,c,D)$/;"	r
make_stockholder_atom_grid	molecule.foo	/^   make_stockholder_atom_grid(grid,a,pt)$/;"	r
make_stockholder_atom_grid	molecule.foo	/^   make_stockholder_atom_grid(grid,a,pt,overlapping_atom)$/;"	r
make_promolecule_density_grid	molecule.foo	/^   make_promolecule_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_promolecule_density_grid, LABEL=>"promolecule_density_grid")$/;"	r
make_promolecule_density_grid	molecule.foo	/^   make_promolecule_density_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_density_grid)$/;"	r
make_spherical_atom_grid	molecule.foo	/^   make_spherical_atom_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_spherical_atom_grid, LABEL=>"spherical_atom_grid")$/;"	r
make_spherical_atom_grid	molecule.foo	/^   make_spherical_atom_grid(density_grid,pt)$/;"	r
make_grad_rho_on_rho_grid	molecule.foo	/^   make_grad_rho_on_rho_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_grad_rho_on_rho_grid, LABEL=>"grad_rho_on_rho_grid")$/;"	r
make_grad_rho_on_rho_grid	molecule.foo	/^   make_grad_rho_on_rho_grid(grid,pt)$/;"	r
make_ELI_D_grid	molecule.foo	/^   make_ELI_D_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_ELI_D_grid, LABEL=>"ELI_D_grid")$/;"	r
make_ELI_D_grid	molecule.foo	/^   make_ELI_D_grid(ELI_grid,pt)$/;"	r
ELI_grid	molecule.foo	/^     ELI_grid :: VEC{REAL}$/;"	a
pt	molecule.foo	/^     pt :: MAT{REAL}$/;"	a
make_ELI_D_grid_r	molecule.foo	/^   make_ELI_D_grid_r(ELI_grid,pt)$/;"	r
make_ELF_grid	molecule.foo	/^   make_ELF_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_ELF_grid, LABEL=>"ELF_grid")$/;"	r
make_ELF_grid	molecule.foo	/^   make_ELF_grid(ELF_grid,pt)$/;"	r
make_ELF_grid_r	molecule.foo	/^   make_ELF_grid_r(ELF_grid,pt)$/;"	r
make_ELF_grid_c	molecule.foo	/^   make_ELF_grid_c(ELF_grid,pt)$/;"	r
make_Tsirelson_ELF_grid	molecule.foo	/^   make_Tsirelson_ELF_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_Tsirelson_ELF_grid, LABEL=>"Tsirelson-Stash_ELF_grid")$/;"	r
make_Tsirelson_ELF_grid	molecule.foo	/^   make_Tsirelson_ELF_grid(ELF_grid,pt)$/;"	r
make_Tsirelson_ELF_grid_r	molecule.foo	/^   make_Tsirelson_ELF_grid_r(ELF_grid,pt)$/;"	r
make_Tsirelson_ELF_grid_c	molecule.foo	/^   make_Tsirelson_ELF_grid_c(ELF_grid,pt)$/;"	r
make_fermi_mobility_grid	molecule.foo	/^   make_fermi_mobility_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_fermi_mobility_grid, LABEL=>"fermi_mobility_grid")$/;"	r
make_fermi_mobility_grid	molecule.foo	/^   make_fermi_mobility_grid(f,pt)$/;"	r
make_fermi_mobility_grid_r	molecule.foo	/^   make_fermi_mobility_grid_r(f,pt)$/;"	r
make_true_fermi_mobility_grid	molecule.foo	/^   make_true_fermi_mobility_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_true_fermi_mobility_grid, LABEL=>"true_fermi_mobility_grid")$/;"	r
make_true_fermi_mobility_grid	molecule.foo	/^   make_true_fermi_mobility_grid(f,pt)$/;"	r
make_true_fermi_mobil_grid_r	molecule.foo	/^   make_true_fermi_mobil_grid_r(f,pt)$/;"	r
make_j_grid	molecule.foo	/^   make_j_grid$/;"	r
get_jd_density_grid	molecule.foo	/^   get_jd_density_grid(jd)$/;"	r
make_jd_grid	molecule.foo	/^   make_jd_grid$/;"	r
get_jp_density_grid	molecule.foo	/^   get_jp_density_grid(jp)$/;"	r
make_jp_grid	molecule.foo	/^   make_jp_grid$/;"	r
make_jp_grid	molecule.foo	/^   make_jp_grid(jp)$/;"	r
make_solenoidal_jp_grid	molecule.foo	/^   make_solenoidal_jp_grid$/;"	r
make_solenoidal_jp_grid	molecule.foo	/^   make_solenoidal_jp_grid(jp,dens)$/;"	r
make_irrotational_jp_grid	molecule.foo	/^   make_irrotational_jp_grid$/;"	r
make_irrotational_jp_grid	molecule.foo	/^   make_irrotational_jp_grid(jp,dens)$/;"	r
make_div_jp_grid	molecule.foo	/^   make_div_jp_grid$/;"	r
make_div_jp_grid	molecule.foo	/^   make_div_jp_grid(div_jp)$/;"	r
set_interpolator_info	molecule.foo	/^   set_interpolator_info(plot_kind) ::: leaky$/;"	r
make_interpolator_sqrt	molecule.foo	/^   make_interpolator_sqrt(interpolator) ::: leaky$/;"	r
make_interpolator_sqrt_x1x	molecule.foo	/^   make_interpolator_sqrt_x1x(interpolator) ::: leaky$/;"	r
make_slater_interpolators	molecule.foo	/^   make_slater_interpolators ::: leaky$/;"	r
make_coppens_interpolators	molecule.foo	/^   make_coppens_interpolators ::: leaky$/;"	r
set_atom_plot_info	molecule.foo	/^   set_atom_plot_info(plot_kind) ::: leaky$/;"	r
isosurface_plot	molecule.foo	/^   isosurface_plot ::: leaky$/;"	r
saved_isosurface_plot	molecule.foo	/^   saved_isosurface_plot ::: leaky$/;"	r
do_isosurface_plot	molecule.foo	/^   do_isosurface_plot ::: private$/;"	r
plot_on_isosurface	molecule.foo	/^   plot_on_isosurface ::: leaky$/;"	r
saved_plot_on_isosurface	molecule.foo	/^   saved_plot_on_isosurface ::: leaky$/;"	r
do_plot_on_isosurface	molecule.foo	/^   do_plot_on_isosurface ::: private$/;"	r
bond_density_atom_grid	molecule.foo	/^   bond_density_atom_grid(g,pt) ::: selfless$/;"	r
bond_weight_grid	molecule.foo	/^   bond_weight_grid(g,pt) ::: selfless$/;"	r
deformation_bond_density_grid	molecule.foo	/^   deformation_bond_density_grid(g,pt) ::: selfless$/;"	r
deformation_density_grid	molecule.foo	/^   deformation_density_grid(g,pt) ::: selfless$/;"	r
def_e_pot_grid	molecule.foo	/^   def_e_pot_grid(g,pt) ::: selfless$/;"	r
def_H_dft_energy_grid	molecule.foo	/^   def_H_dft_energy_grid(g,pt) ::: selfless$/;"	r
def_G_kinetic_grid	molecule.foo	/^   def_G_kinetic_grid(g,pt) ::: selfless$/;"	r
def_K_kinetic_grid	molecule.foo	/^   def_K_kinetic_grid(g,pt) ::: selfless$/;"	r
def_laplacian_grid	molecule.foo	/^   def_laplacian_grid(g,pt) ::: selfless$/;"	r
def_dft_eff_pot_grid	molecule.foo	/^   def_dft_eff_pot_grid(g,pt) ::: selfless$/;"	r
def_dft_xc_pot_grid	molecule.foo	/^   def_dft_xc_pot_grid(g,pt) ::: selfless$/;"	r
def_dft_energy_grid	molecule.foo	/^   def_dft_energy_grid(g,pt) ::: selfless$/;"	r
electron_density_grid	molecule.foo	/^   electron_density_grid(g,pt) ::: selfless$/;"	r
spin_density_grid	molecule.foo	/^   spin_density_grid(g,pt) ::: selfless$/;"	r
G_kinetic_energy_grid	molecule.foo	/^   G_kinetic_energy_grid(g,pt) ::: selfless$/;"	r
K_kinetic_energy_grid	molecule.foo	/^   K_kinetic_energy_grid(g,pt) ::: selfless$/;"	r
H_dft_energy_grid	molecule.foo	/^   H_dft_energy_grid(g,pt) ::: selfless$/;"	r
laplacian_grid	molecule.foo	/^   laplacian_grid(g,pt) ::: selfless$/;"	r
dft_eff_pot_grid	molecule.foo	/^   dft_eff_pot_grid(g,pt) ::: selfless$/;"	r
dft_xc_pot_grid	molecule.foo	/^   dft_xc_pot_grid(g,pt) ::: selfless$/;"	r
dft_energy_grid	molecule.foo	/^   dft_energy_grid(g,pt) ::: selfless$/;"	r
local_ionisation_grid	molecule.foo	/^   local_ionisation_grid(g,pt) ::: selfless$/;"	r
orbital_density_grid	molecule.foo	/^   orbital_density_grid(g,pt) ::: selfless$/;"	r
orbital_grid	molecule.foo	/^   orbital_grid(g,pt) ::: selfless$/;"	r
oscillator_orbital_grid	molecule.foo	/^   oscillator_orbital_grid(g,pt) ::: selfless$/;"	r
ELI_D_grid	molecule.foo	/^   ELI_D_grid(g,pt) ::: selfless$/;"	r
ELF_grid	molecule.foo	/^   ELF_grid(g,pt) ::: selfless$/;"	r
grad_rho_on_rho_grid	molecule.foo	/^   grad_rho_on_rho_grid(g,pt) ::: selfless$/;"	r
Tsirelson_ELF_grid	molecule.foo	/^   Tsirelson_ELF_grid(g,pt) ::: selfless$/;"	r
fermi_mobility_grid	molecule.foo	/^   fermi_mobility_grid(g,pt) ::: selfless$/;"	r
true_fermi_mobility_grid	molecule.foo	/^   true_fermi_mobility_grid(g,pt) ::: selfless$/;"	r
electric_potential_grid	molecule.foo	/^   electric_potential_grid(g,pt) ::: selfless$/;"	r
stockholder_density_grid	molecule.foo	/^   stockholder_density_grid(g,pt) ::: selfless$/;"	r
Hirshfeld_density_grid	molecule.foo	/^   Hirshfeld_density_grid(g,pt) ::: selfless$/;"	r
promolecule_density_grid	molecule.foo	/^   promolecule_density_grid(g,pt) ::: selfless$/;"	r
get_vib_averaged_rho_grid	molecule.foo	/^   get_vib_averaged_rho_grid(density_grid)$/;"	r
make_vib_averaged_rho_grid	molecule.foo	/^   make_vib_averaged_rho_grid$/;"	r
integrate_rho_grid	molecule.foo	/^   integrate_rho_grid(res,a,b,accuracy,fa0,fb0) ::: recursive$/;"	r
make_rho_grid_at	molecule.foo	/^   make_rho_grid_at(q,rho)$/;"	r
roby_analysis	molecule.foo	/^   roby_analysis ::: leaky$/;"	r
make_ANO_data	molecule.foo	/^   make_ANO_data ::: leaky$/;"	r
make_ANO_data_for_atom	molecule.foo	/^   make_ANO_data_for_atom(a) ::: leaky, private$/;"	r
destroy_ANO_data	molecule.foo	/^   destroy_ANO_data ::: leaky$/;"	r
make_ANO_interpolators	molecule.foo	/^   make_ANO_interpolators ::: leaky$/;"	r
destroy_ANO_interpolators	molecule.foo	/^   destroy_ANO_interpolators ::: leaky$/;"	r
destroy_interpolators	molecule.foo	/^   destroy_interpolators ::: leaky$/;"	r
make_atom_shell_info	molecule.foo	/^   make_atom_shell_info ::: leaky$/;"	r
destroy_atom_shell_info	molecule.foo	/^   destroy_atom_shell_info ::: leaky$/;"	r
make_core_structure_factors	molecule.foo	/^   make_core_structure_factors ::: leaky$/;"	r
get_spherical_atoms	molecule.foo	/^   get_spherical_atoms ::: leaky$/;"	r
spherically_average_atom	molecule.foo	/^   spherically_average_atom(a,D) ::: leaky, private$/;"	r
destroy_spherical_atom_data	molecule.foo	/^   destroy_spherical_atom_data ::: leaky$/;"	r
read_cluster	molecule.foo	/^   read_cluster ::: leaky$/;"	r
create_cluster	molecule.foo	/^   create_cluster ::: leaky$/;"	r
destroy_cluster	molecule.foo	/^   destroy_cluster ::: leaky$/;"	r
make_weak_force_energy_shift	molecule.foo	/^   make_weak_force_energy_shift$/;"	r
put_g_tensor_information	molecule.foo	/^   put_g_tensor_information$/;"	r
make_ready_da_gcm_tr	molecule.foo	/^   make_ready_da_gcm_tr(M,m_out,n_gcm)  $/;"	r
make_ready_da_gcm_tr2	molecule.foo	/^   make_ready_da_gcm_tr2(m_out,n_gcm) $/;"	r
get_da_gcm_now	molecule.foo	/^   get_da_gcm_now(M,M_gcm,m_out,n_gcm)  $/;"	r
get_back_prim_now	molecule.foo	/^   get_back_prim_now(M_gcm,M,m_out,n_gcm)  $/;"	r
get_da_gcm_now	molecule.foo	/^   get_da_gcm_now(M,M_gcm,m_out,n_gcm)  $/;"	r
get_back_prim_now	molecule.foo	/^   get_back_prim_now(M_gcm,M,m_out,n_gcm)  $/;"	r
make_r_DKH_matrix	molecule.foo	/^   make_r_DKH_matrix(H)$/;"	r
make_r_DKH_matrix2	molecule.foo	/^   make_r_DKH_matrix2(H)$/;"	r
make_r_DKH_matrix3	molecule.foo	/^   make_r_DKH_matrix3(H)$/;"	r
make_DKH_matrices	molecule.foo	/^   make_DKH_matrices(H,Lx,Ly,Lz)$/;"	r
make_DKH_density_norm	molecule.foo	/^   make_DKH_density_norm$/;"	r
density_DKH_norm	molecule.foo	/^   density_DKH_norm(g,norm,D,no)$/;"	r
make_DENSITY_norm	molecule.foo	/^   make_DENSITY_norm(D,YU,Ap,Ep,P2,m_out,n_gcm)$/;"	r
get_n_gcm	molecule.foo	/^   get_n_gcm(m_out,n)$/;"	r
m_out	molecule.foo	/^     m_out :: MAT{INT} , OUT $/;"	a
make_SO_fdff	molecule.foo	/^   make_SO_fdff(T)$/;"	r
make_DKH_mxs4	molecule.foo	/^   make_DKH_mxs4(PPZPP,YU)$/;"	r
make_DKH_mxs3	molecule.foo	/^   make_DKH_mxs3(Z,PZP,Lx,Ly,Lz,YU)$/;"	r
make_DKH_mxs2	molecule.foo	/^   make_DKH_mxs2(Z,PZP,YU)$/;"	r
make_DKH_mxs	molecule.foo	/^   make_DKH_mxs(YU,Ap,Ep,P2)$/;"	r
YU	molecule.foo	/^     YU :: MAT{REAL} $/;"	a
m_out	molecule.foo	/^     m_out :: MAT{INT}* $/;"	a
make_DKH_mxs3_2	molecule.foo	/^   make_DKH_mxs3_2(Z,PZP,Lx,Ly,Lz,YU)$/;"	r
make_DKH_mxs_2	molecule.foo	/^   make_DKH_mxs_2(YU,Ap,Ep,P2)$/;"	r
YU	molecule.foo	/^     YU :: MAT{REAL} $/;"	a
m_out	molecule.foo	/^     m_out :: MAT{INT}* $/;"	a
make_DKH_density_grid	molecule.foo	/^   make_DKH_density_grid(density_grid,pt,sgn)$/;"	r
density_grid	molecule.foo	/^     density_grid :: VEC{REAL} $/;"	a
pt	molecule.foo	/^     pt :: MAT{REAL}$/;"	a
sgn	molecule.foo	/^     sgn :: INT, IN, optional$/;"	a
fac	molecule.foo	/^     fac :: INT$/;"	a
CMO	molecule.foo	/^     CMO :: MAT{CPX}*$/;"	a
CD	molecule.foo	/^     CD :: MAT{CPX}*$/;"	a
density_DKH	molecule.foo	/^   density_DKH(density_grid,pt,D)$/;"	r
density_DKH_gc_old	molecule.foo	/^   density_DKH_gc_old(density_grid,pt,D)$/;"	r
density_DKH_gc	molecule.foo	/^   density_DKH_gc(density_grid,pt,D)$/;"	r
make_PCE_off	molecule.foo	/^   make_PCE_off(GG,YU,Ap,Ep,P2,xx,yy,zz,m_out,n_gcm,S,sZ,sPZP,met,PPZPP)$/;"	r
make_DENSITY_PCE_off	molecule.foo	/^   make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,xx,yy,zz,m_out,n_gcm,S,sZ,sPZP,PPZPP)$/;"	r
make_DENSITY_PCE_SO_off	molecule.foo	/^   make_DENSITY_PCE_SO_off(GG,GGx,GGy,GGz,YU,Ap,Ep,P2,xx,yy,zz,m_out,n_gcm,S,sZ,sPZP,sPZPx,sPZPy,sPZPz,PPZPP)$/;"	r
make_DENSITY_PCE_SO_off_2	molecule.foo	/^   make_DENSITY_PCE_SO_off_2(GG22,YU,Ap,Ep,P2,xx,yy,zz,m_out,n_gcm,S,sZ2,sPZP2,PPZPP)$/;"	r
make_DKH_orbital_grid_r	molecule.foo	/^   make_DKH_orbital_grid_r(density_grid,orb,pt,square)$/;"	r
density_grid	molecule.foo	/^     density_grid :: VEC{REAL}, OUT $/;"	a
orb	molecule.foo	/^     orb :: INT, IN$/;"	a
pt	molecule.foo	/^     pt :: MAT{REAL}, IN$/;"	a
square	molecule.foo	/^     square :: BIN, IN, optional$/;"	a
MO	molecule.foo	/^     MO :: MAT{REAL}*$/;"	a
make_DKH_orb_dens_grid_gc	molecule.foo	/^   make_DKH_orb_dens_grid_gc(density_grid,orb,pt)$/;"	r
density_DKH_orb_gc_old	molecule.foo	/^   density_DKH_orb_gc_old(density,pt,MO)$/;"	r
density_DKH_orb_gc	molecule.foo	/^   density_DKH_orb_gc(density,pt,MO)$/;"	r
make_DKH_orbital_grid_gc	molecule.foo	/^   make_DKH_orbital_grid_gc(gcu,gcd,orb,pt)$/;"	r
orbital_DKH_orb_gc	molecule.foo	/^   orbital_DKH_orb_gc(gcu,gcd,pt,MO)$/;"	r
density_DKH_orb_r	molecule.foo	/^   density_DKH_orb_r(density_grid,pt,MO,square)$/;"	r
make_primitive_density_matrix	molecule.foo	/^   make_primitive_density_matrix(D,x,y,z)$/;"	r
ex	molecule.foo	/^     ex :: VEC{REAL}*$/;"	a
make_primitive_pDp_matrix	molecule.foo	/^   make_primitive_pDp_matrix(T,x,y,z)$/;"	r
ex	molecule.foo	/^     ex :: VEC{REAL}*$/;"	a
make_primitive_ppDpp_matrix	molecule.foo	/^   make_primitive_ppDpp_matrix(T,x,y,z)$/;"	r
ex	molecule.foo	/^     ex :: VEC{REAL}*$/;"	a
make_primitive_pDp_SO_matrix	molecule.foo	/^   make_primitive_pDp_SO_matrix(Dx,Dy,Dz,x,y,z)$/;"	r
ex	molecule.foo	/^     ex :: VEC{REAL}*$/;"	a
make_ft_test	molecule.foo	/^   make_ft_test(sf,D,k_pts)$/;"	r
make_ft_DKH	molecule.foo	/^   make_ft_DKH(sf,D,k_pts)$/;"	r
make_primitive_ft_matrix	molecule.foo	/^   make_primitive_ft_matrix(ft,h1,h2,h3)$/;"	r
ex	molecule.foo	/^     ex :: VEC{REAL}*$/;"	a
ft_ab	molecule.foo	/^     ft_ab :: MAT{CPX}*$/;"	a
make_primitive_pftp_matrix	molecule.foo	/^   make_primitive_pftp_matrix(ft,h1,h2,h3)$/;"	r
ex	molecule.foo	/^     ex :: VEC{REAL}*$/;"	a
ft_ab	molecule.foo	/^     ft_ab :: MAT{CPX}*$/;"	a
make_part_and_therm_smear	molecule.foo	/^   make_part_and_therm_smear(ft,k_vec) $/;"	r
thermal_smearing_correction_pce	molecule.foo	/^   thermal_smearing_correction_pce(res,k_vec,a,b,sh)$/;"	r
test_IOTC	molecule.foo	/^   test_IOTC$/;"	r
make_r_IOTC_matrix	molecule.foo	/^   make_r_IOTC_matrix(H)$/;"	r
make_gc_IOTC_matrix	molecule.foo	/^   make_gc_IOTC_matrix(H)$/;"	r
make_gc_IOTC_matrix_cheated_norm	molecule.foo	/^   make_gc_IOTC_matrix_cheated_norm(H)$/;"	r
make_IOTC_density_grid	molecule.foo	/^   make_IOTC_density_grid(density_grid,pt,sgn)$/;"	r
density_grid	molecule.foo	/^     density_grid :: VEC{REAL} $/;"	a
pt	molecule.foo	/^     pt :: MAT{REAL}$/;"	a
sgn	molecule.foo	/^     sgn :: INT, IN, optional$/;"	a
fac	molecule.foo	/^     fac :: INT$/;"	a
CMO	molecule.foo	/^     CMO :: MAT{CPX}*$/;"	a
CD	molecule.foo	/^     CD :: MAT{CPX}*$/;"	a
make_IOTC_orbital_grid_r	molecule.foo	/^   make_IOTC_orbital_grid_r(density_grid,orb,pt,square)$/;"	r
density_grid	molecule.foo	/^     density_grid :: VEC{REAL}, OUT $/;"	a
orb	molecule.foo	/^     orb :: INT, IN$/;"	a
pt	molecule.foo	/^     pt :: MAT{REAL}, IN$/;"	a
square	molecule.foo	/^     square :: BIN, IN, optional$/;"	a
MO	molecule.foo	/^     MO :: MAT{REAL}*$/;"	a
make_IOTC_orb_dens_grid_gc	molecule.foo	/^   make_IOTC_orb_dens_grid_gc(density_grid,orb,pt)$/;"	r
density_grid	molecule.foo	/^   density_grid :: VEC{CPX}, OUT $/;"	g
orb	molecule.foo	/^   orb :: INT, IN$/;"	g
pt	molecule.foo	/^   pt :: MAT{REAL}, IN$/;"	g
CMO	molecule.foo	/^   CMO :: MAT{CPX}*$/;"	g
find_da_Y_iterative	molecule.foo	/^   find_da_Y_iterative(Y,PZP,Z,p,b,ep,eps)$/;"	r
eps	molecule.foo	/^   eps :: REAL, optional$/;"	g
fine	molecule.foo	/^   fine :: BIN$/;"	g
m_out	molecule.foo	/^   m_out :: MAT{INT}*$/;"	g
find_da_Y_iterative	molecule.foo	/^   find_da_Y_iterative(Y,PZP,Z,p,b,ep)$/;"	r
fine	molecule.foo	/^   fine :: BIN$/;"	g
m_out	molecule.foo	/^   m_out :: MAT{INT}*$/;"	g
build_da_Y	molecule.foo	/^   build_da_Y(Y,Yr0,PZP,Z,p,b,ep,n_gcm)$/;"	r
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
build_da_Y_old	molecule.foo	/^   build_da_Y_old(Y,Yr0,PZP,Z,p,b,ep,n_gcm)$/;"	r
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
build_da_Y_2_Rbased_corrupt	molecule.foo	/^   build_da_Y_2_Rbased_corrupt(Y,Yr0,PAP,A,p,b,ep,n_gcm)$/;"	r
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
build_da_Y_2	molecule.foo	/^   build_da_Y_2(Y,Yr0,PAP,A,p,b,ep,n_gcm)$/;"	r
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
build_da_Y_2_old	molecule.foo	/^   build_da_Y_2_old(Y,Yr0,PAP,A,p,b,ep,n_gcm)$/;"	r
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
build_da_IOTC_F	molecule.foo	/^   build_da_IOTC_F(F,Yr,PAP,A,p,bp,E,n_gcm,ppApp)$/;"	r
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
ppApp	molecule.foo	/^   ppApp :: MAT{REAL}, optional$/;"	g
build_da_IOTC_F_old	molecule.foo	/^   build_da_IOTC_F_old(F,Yr,PAP,A,p,bp,E,n_gcm,ppApp)$/;"	r
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
ppApp	molecule.foo	/^   ppApp :: MAT{REAL}, optional$/;"	g
build_da_IOTC_F	molecule.foo	/^   build_da_IOTC_F(F,Yr,PAP,A,p,bp,E,ppApp)$/;"	r
ppApp	molecule.foo	/^   ppApp :: MAT{CPX}, optional$/;"	g
build_da_IOTC_dens	molecule.foo	/^   build_da_IOTC_dens(F,Yr,PAP,A,p,bp,E,n_gcm,ppApp)$/;"	r
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
ppApp	molecule.foo	/^   ppApp :: MAT{REAL}, optional$/;"	g
build_da_IOTC_dens_old	molecule.foo	/^   build_da_IOTC_dens_old(F,Yr,PAP,A,p,bp,E,n_gcm,ppApp)$/;"	r
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
ppApp	molecule.foo	/^   ppApp :: MAT{REAL}, optional$/;"	g
build_da_IOTC_dens	molecule.foo	/^   build_da_IOTC_dens(F,Yr,PAP,A,p,bp,E,ppApp)$/;"	r
ppApp	molecule.foo	/^   ppApp :: MAT{CPX}, optional$/;"	g
build_da_IOTC_dens_old	molecule.foo	/^   build_da_IOTC_dens_old(F,Yr,PAP,A,p,bp,E,ppApp)$/;"	r
ppApp	molecule.foo	/^   ppApp :: MAT{CPX}, optional$/;"	g
density_IOTC	molecule.foo	/^   density_IOTC(density_grid,pt,D)$/;"	r
density_IOTC_orb_r	molecule.foo	/^   density_IOTC_orb_r(density_grid,pt,MO,square)$/;"	r
make_DENSITY_IOTC_PCE_off	molecule.foo	/^   make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,E,bp,p,ep,xx,yy,zz,m_out,n_gcm,S,O)$/;"	r
density_IOTC_gc	molecule.foo	/^   density_IOTC_gc(density_grid,pt,D)$/;"	r
density_IOTC_orb_gc	molecule.foo	/^   density_IOTC_orb_gc(density_grid,pt,MO)$/;"	r
make_DENSITY_IOTC_PCE_SO_off	molecule.foo	/^   make_DENSITY_IOTC_PCE_SO_off(GG,Yr,YU,Ap,E,bp,p,ep,xx,yy,zz,m_out,n_gcm,S,O)$/;"	r
make_S_Y	molecule.foo	/^   make_S_Y(S,Y)$/;"	r
m_out	molecule.foo	/^   m_out :: MAT{INT}*$/;"	g
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
make_U_P2	molecule.foo	/^   make_U_P2(U,P2,Y)$/;"	r
P2	molecule.foo	/^   P2 :: VEC{REAL}, OUT$/;"	g
m_out	molecule.foo	/^   m_out :: MAT{INT}*$/;"	g
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
make_R_to_YU	molecule.foo	/^   make_R_to_YU(R,XXX,YU)$/;"	r
XXX	molecule.foo	/^   XXX :: MAT{REAL}$/;"	g
YU	molecule.foo	/^   YU :: MAT{REAL}$/;"	g
m_out	molecule.foo	/^   m_out :: MAT{INT}*$/;"	g
n_gcm	molecule.foo	/^   n_gcm :: INT$/;"	g
ENSURE	molecule.main.foo	/^#  define ENSURE(X,Y)       ENSURE0(X,Y)$/;"	m
saved_self	molecule.main.foo	/^   saved_self :: MOLECULE*, private$/;"	g
saved_sf_n	molecule.main.foo	/^   saved_sf_n :: MAT{CPX}*, private$/;"	g
saved_arch	molecule.main.foo	/^   saved_arch :: TEXTFILE*, private$/;"	g
X_old	molecule.main.foo	/^   X_old :: VEC{REAL}*, private  DEFAULT_NULL$/;"	g
read_CIF	molecule.main.foo	/^   read_CIF ::: leaky$/;"	r
read_CX_file_name	molecule.main.foo	/^   read_CX_file_name $/;"	r
read_CX_uses_angstrom	molecule.main.foo	/^   read_CX_uses_angstrom $/;"	r
process_CIF	molecule.main.foo	/^   process_CIF ::: leaky$/;"	r
process_CIF_for_CX	molecule.main.foo	/^   process_CIF_for_CX ::: leaky$/;"	r
find_CIF_crystal_data_block	molecule.main.foo	/^   find_CIF_crystal_data_block(cif,found) $/;"	r
open_CIF_at_data_block	molecule.main.foo	/^   open_CIF_at_data_block(cif)$/;"	r
read_CIF_crystal	molecule.main.foo	/^   read_CIF_crystal(cif) ::: leaky$/;"	r
read_CIF_atoms	molecule.main.foo	/^   read_CIF_atoms(cif) ::: leaky$/;"	r
set_atoms_and_crystal	molecule.main.foo	/^   set_atoms_and_crystal(cif) ::: private, leaky$/;"	r
read_CIF_ADPs	molecule.main.foo	/^   read_CIF_ADPs(cif) ::: leaky$/;"	r
put_CX_data	molecule.main.foo	/^   put_CX_data$/;"	r
put_CX_data	molecule.main.foo	/^   put_CX_data(cif)$/;"	r
put_CX_data	molecule.main.foo	/^   put_CX_data(CX_file,cif)$/;"	r
read_rotate	molecule.main.foo	/^   read_rotate$/;"	r
rotate_by	molecule.main.foo	/^   rotate_by(R)$/;"	r
rotate_molecular_orbitals	molecule.main.foo	/^   rotate_molecular_orbitals(R)$/;"	r
rotate_orbitals	molecule.main.foo	/^   rotate_orbitals(MO,R)$/;"	r
read_rotate_group	molecule.main.foo	/^   read_rotate_group ::: leaky$/;"	r
rotate_group	molecule.main.foo	/^   rotate_group(g,axis,angle) ::: leaky$/;"	r
put_group_density_to	molecule.main.foo	/^   put_group_density_to(P,g,mol)$/;"	r
set_group_density_from	molecule.main.foo	/^   set_group_density_from(P,g,mol)$/;"	r
rotate_density_matrix	molecule.main.foo	/^   rotate_density_matrix(P,R)$/;"	r
optimise_orbitals	molecule.main.foo	/^   optimise_orbitals$/;"	r
the_r_hf_energy	molecule.main.foo	/^   the_r_hf_energy(MO) result (res) ::: selfless$/;"	r
r_hf_energy	molecule.main.foo	/^   r_hf_energy(MO) result (res)$/;"	r
e1_energy	molecule.main.foo	/^   e1_energy(P) result (res)$/;"	r
e2_energy	molecule.main.foo	/^   e2_energy(P) result (res)$/;"	r
the_r_hf_energy_MO_gradient	molecule.main.foo	/^   the_r_hf_energy_MO_gradient(MO) result(g) ::: selfless$/;"	r
r_hf_energy_MO_gradient	molecule.main.foo	/^   r_hf_energy_MO_gradient(MO,make_fock) result(g)$/;"	r
make_non_ortho_scf_density	molecule.main.foo	/^   make_non_ortho_scf_density ::: leaky$/;"	r
make_r_non_ortho_scf_density	molecule.main.foo	/^   make_r_non_ortho_scf_density(P,MO,N) ::: leaky$/;"	r
spherically_averaged_sf	molecule.main.foo	/^   spherically_averaged_sf$/;"	r
make_spherically_averaged_ft	molecule.main.foo	/^   make_spherically_averaged_ft(res,dens,k_values)$/;"	r
make_spherically_averaged_HAs	molecule.main.foo	/^   make_spherically_averaged_HAs ::: leaky$/;"	r
make_spherically_averaged_HA	molecule.main.foo	/^   make_spherically_averaged_HA(rho_av,eps,a,interpolator,l_max) $/;"	r
make_averaged_BDAs	molecule.main.foo	/^   make_averaged_BDAs ::: leaky$/;"	r
make_averaged_BDAs	molecule.main.foo	/^   make_averaged_BDAs(rho_av,eps,a,interpolator,l_max) $/;"	r
put_BDA_charges	molecule.main.foo	/^   put_BDA_charges$/;"	r
make_BDA_charges	molecule.main.foo	/^   make_BDA_charges(bond,bond_charge) ::: leaky$/;"	r
cleanup	molecule.main.foo	/^   cleanup ::: leaky$/;"	r
run	molecule.main.foo	/^   run$/;"	r
put_banner	molecule.main.foo	/^   put_banner$/;"	r
reset_molecule	molecule.main.foo	/^   reset_molecule ::: leaky$/;"	r
read_keywords	molecule.main.foo	/^   read_keywords ::: get_from(OBJECT, process_keyword=>MAIN:process_keyword), recursive, leaky$/;"	r
process_keyword	molecule.main.foo	/^   process_keyword(keyword) ::: recursive, leaky$/;"	r
read_output_style_options	molecule.main.foo	/^   read_output_style_options$/;"	r
read_memory_limit	molecule.main.foo	/^   read_memory_limit$/;"	r
read_invariom_directory	molecule.main.foo	/^   read_invariom_directory$/;"	r
read_invariom_refinement	molecule.main.foo	/^   read_invariom_refinement$/;"	r
read_use_interpolators	molecule.main.foo	/^   read_use_interpolators$/;"	r
read_use_spherical_basis	molecule.main.foo	/^   read_use_spherical_basis ::: leaky$/;"	r
read_interpolator	molecule.main.foo	/^   read_interpolator ::: leaky$/;"	r
locate_memory_leak	molecule.main.foo	/^   locate_memory_leak$/;"	r
redirect	molecule.main.foo	/^   redirect ::: leaky$/;"	r
redirect_stdout	molecule.main.foo	/^   redirect_stdout ::: leaky$/;"	r
revert	molecule.main.foo	/^   revert ::: leaky$/;"	r
revert_stdout	molecule.main.foo	/^   revert_stdout ::: leaky$/;"	r
localise_MOs	molecule.main.foo	/^   localise_MOs ::: leaky$/;"	r
put_oscillator_overlaps	molecule.main.foo	/^   put_oscillator_overlaps$/;"	r
put_pdb	molecule.main.foo	/^   put_pdb$/;"	r
put_cif	molecule.main.foo	/^   put_cif$/;"	r
put_accurate_cif	molecule.main.foo	/^   put_accurate_cif$/;"	r
put_molecule_cif	molecule.main.foo	/^   put_molecule_cif$/;"	r
put_NKA_cartesian	molecule.main.foo	/^   put_NKA_cartesian$/;"	r
put_NKA_crystal	molecule.main.foo	/^   put_NKA_crystal$/;"	r
put_excel_crystal	molecule.main.foo	/^   put_excel_crystal$/;"	r
put_overlap_matrix	molecule.main.foo	/^   put_overlap_matrix$/;"	r
put_kinetic_energy_matrix	molecule.main.foo	/^   put_kinetic_energy_matrix$/;"	r
put_nuclear_attraction_matrix	molecule.main.foo	/^   put_nuclear_attraction_matrix$/;"	r
put_scf_energy_as_mo_parts	molecule.main.foo	/^   put_scf_energy_as_mo_parts$/;"	r
put_Hirshfeld_G_and_K_energy	molecule.main.foo	/^   put_Hirshfeld_G_and_K_energy$/;"	r
integrate_density_numerically	molecule.main.foo	/^   integrate_density_numerically$/;"	r
read_geminal_mf_scheme	molecule.main.foo	/^   read_geminal_mf_scheme ::: leaky $/;"	r
main	molecule.main.foo	/^     main :: MOLECULE.MAIN*$/;"	a
eri_archive	molecule.main.foo	/^     eri_archive :: ARCHIVE$/;"	a
do_geminal_mf_scheme	molecule.main.foo	/^   do_geminal_mf_scheme ::: leaky $/;"	r
main	molecule.main.foo	/^     main :: MOLECULE.MAIN*$/;"	a
eri_archive	molecule.main.foo	/^     eri_archive :: ARCHIVE$/;"	a
do_electric_dipole	molecule.main.foo	/^     do_electric_dipole :: BIN$/;"	a
restart_geminal_mf_scheme	molecule.main.foo	/^   restart_geminal_mf_scheme ::: leaky $/;"	r
main	molecule.main.foo	/^     main :: MOLECULE.MAIN*$/;"	a
eri_archive	molecule.main.foo	/^     eri_archive :: ARCHIVE$/;"	a
do_electric_dipole	molecule.main.foo	/^     do_electric_dipole :: BIN$/;"	a
make_eri_integrals	molecule.main.foo	/^   make_eri_integrals(v)$/;"	r
sh4n	molecule.main.foo	/^     sh4n :: SHELL1QUARTET$/;"	a
val	molecule.main.foo	/^     val :: REAL$/;"	a
make_mo_eri_integrals	molecule.main.foo	/^   make_mo_eri_integrals(v,eri_archive,add_core,new_n_bf)$/;"	r
eri_archive	molecule.main.foo	/^     eri_archive :: ARCHIVE$/;"	a
add_core	molecule.main.foo	/^     add_core :: BIN, optional$/;"	a
new_n_bf	molecule.main.foo	/^     new_n_bf :: INT, optional$/;"	a
new_v	molecule.main.foo	/^     new_v :: MAT4{REAL}*$/;"	a
core	molecule.main.foo	/^     core :: BIN$/;"	a
make_mo_edm_integrals	molecule.main.foo	/^   make_mo_edm_integrals(new_n_bf)$/;"	r
new_n_bf	molecule.main.foo	/^     new_n_bf :: INT, optional$/;"	a
n_bf	molecule.main.foo	/^     n_bf :: INT$/;"	a
make_read_mo_eri_integrals	molecule.main.foo	/^   make_read_mo_eri_integrals(v,eri_archive,add_core,new_n_bf) $/;"	r
eri_archive	molecule.main.foo	/^     eri_archive :: ARCHIVE$/;"	a
add_core	molecule.main.foo	/^     add_core :: BIN, optional$/;"	a
new_n_bf	molecule.main.foo	/^     new_n_bf :: INT, optional$/;"	a
new_v	molecule.main.foo	/^     new_v :: MAT4{REAL}*$/;"	a
core	molecule.main.foo	/^     core :: BIN$/;"	a
in	molecule.main.foo	/^     in :: TEXTFILE*$/;"	a
make_read_mo_edm_integrals	molecule.main.foo	/^   make_read_mo_edm_integrals(new_n_bf)$/;"	r
new_n_bf	molecule.main.foo	/^     new_n_bf :: INT, optional$/;"	a
n_bf	molecule.main.foo	/^     n_bf :: INT$/;"	a
in	molecule.main.foo	/^     in :: TEXTFILE*$/;"	a
fit_Hirshfeld_atom_kappas	molecule.main.foo	/^   fit_Hirshfeld_atom_kappas ::: leaky$/;"	r
put_Hirshfeld_G_and_K_energy	molecule.main.foo	/^   put_Hirshfeld_G_and_K_energy(kappa,skip_NOs)$/;"	r
make_scaled_stockholder_derivs	molecule.main.foo	/^   make_scaled_stockholder_derivs(G,H,kappa,delta,skip_NOs) ::: private$/;"	r
make_stockholder_atom_grid	molecule.main.foo	/^   make_stockholder_atom_grid(grid,a,kappa,pt)$/;"	r
make_d_stockholder_atom_grid	molecule.main.foo	/^   make_d_stockholder_atom_grid(grid,a,kappa,pt)$/;"	r
make_d2_stockholder_atom_grid	molecule.main.foo	/^   make_d2_stockholder_atom_grid(grid,a,kappa,pt)$/;"	r
put_sylvain_csizmadia_tensors	molecule.main.foo	/^   put_sylvain_csizmadia_tensors$/;"	r
put_sos_dipole_polarisability	molecule.main.foo	/^   put_sos_dipole_polarisability ::: leaky$/;"	r
put_uc_dipole_polarisability	molecule.main.foo	/^   put_uc_dipole_polarisability ::: leaky$/;"	r
make_uc_dipole_polarisability	molecule.main.foo	/^   make_uc_dipole_polarisability(uc_alpha) ::: leaky$/;"	r
put_uc_dipole_hyperpolar	molecule.main.foo	/^   put_uc_dipole_hyperpolar ::: leaky$/;"	r
put_uc_refractive_index	molecule.main.foo	/^   put_uc_refractive_index ::: leaky$/;"	r
put_refractive_indices	molecule.main.foo	/^   put_refractive_indices(chi1) ::: private$/;"	r
put_refractive_indices	molecule.main.foo	/^   put_refractive_indices(chi2,chi1) ::: private$/;"	r
make_scf_dipole_polarisability	molecule.main.foo	/^   make_scf_dipole_polarisability ::: leaky$/;"	r
put_scf_dipole_polarisability	molecule.main.foo	/^   put_scf_dipole_polarisability ::: leaky$/;"	r
put_dipole_polarisability	molecule.main.foo	/^   put_dipole_polarisability(alpha) ::: leaky$/;"	r
put_big_dipole_pol_contr	molecule.main.foo	/^   put_big_dipole_pol_contr ::: leaky$/;"	r
make_scf_dipole_hyperpolarisa	molecule.main.foo	/^   make_scf_dipole_hyperpolarisa ::: leaky$/;"	r
put_scf_dipole_hyperpolarisa	molecule.main.foo	/^   put_scf_dipole_hyperpolarisa ::: leaky$/;"	r
make_scf_atomic_polarisability	molecule.main.foo	/^   make_scf_atomic_polarisability $/;"	r
put_scf_atomic_polarisability	molecule.main.foo	/^   put_scf_atomic_polarisability $/;"	r
make_U_electric_dipole	molecule.main.foo	/^   make_U_electric_dipole ::: leaky$/;"	r
make_perturbed_densities	molecule.main.foo	/^   make_perturbed_densities(D,U,MO,n_occ) ::: leaky$/;"	r
get_MO_dipole_matrices	molecule.main.foo	/^   get_MO_dipole_matrices(D_mo)$/;"	r
get_VO_MO_dipole_matrices	molecule.main.foo	/^   get_VO_MO_dipole_matrices(D_mo)$/;"	r
set_CPHF_DIIS	molecule.main.foo	/^   set_CPHF_DIIS ::: leaky $/;"	r
solve_CPHF_equations	molecule.main.foo	/^   solve_CPHF_equations(U,rhs) $/;"	r
make_A_times_U	molecule.main.foo	/^   make_A_times_U(AU,U) $/;"	r
add_A_times_U	molecule.main.foo	/^   add_A_times_U(AU,U) ::: private$/;"	r
put_mikes_polarisability	molecule.main.foo	/^   put_mikes_polarisability $/;"	r
alpha	molecule.main.foo	/^   alpha :: MAT{REAL}(3,3)$/;"	g
U_old	molecule.main.foo	/^   U_old :: MAT3{REAL}*$/;"	g
AU	molecule.main.foo	/^   AU :: MAT3{REAL}*$/;"	g
Ubar	molecule.main.foo	/^   Ubar :: MAT3{REAL}*$/;"	g
MO	molecule.main.foo	/^   MO :: MAT{REAL}*$/;"	g
do	molecule.main.foo	/^   do$/;"	r
zero_overlap_density	molecule.main.foo	/^   zero_overlap_density$/;"	r
make_file_delta_density_grid	molecule.main.foo	/^   make_file_delta_density_grid  $/;"	r
make_file_delta_spin_grid	molecule.main.foo	/^   make_file_delta_spin_grid  $/;"	r
put_overlap_eigenvalues	molecule.main.foo	/^   put_overlap_eigenvalues$/;"	r
put_slater_interpolators	molecule.main.foo	/^   put_slater_interpolators $/;"	r
put_coppens_interpolators	molecule.main.foo	/^   put_coppens_interpolators ::: get_from(MOLECULE.MAIN:put_slater_interpolators, SLATERBASIS=>COPPENSBASIS)$/;"	r
put_diff_slater_interpolators	molecule.main.foo	/^   put_diff_slater_interpolators $/;"	r
put_diff_coppens_slater_ints	molecule.main.foo	/^   put_diff_coppens_slater_ints $/;"	r
put_smiles_invariom_labels	molecule.main.foo	/^   put_smiles_invariom_labels$/;"	r
put_invariom_labels	molecule.main.foo	/^   put_invariom_labels$/;"	r
put_invariom_label	molecule.main.foo	/^   put_invariom_label$/;"	r
put_next_neighbour_handedness	molecule.main.foo	/^   put_next_neighbour_handedness$/;"	r
fit_Hirshfeld_atoms	molecule.main.foo	/^   fit_Hirshfeld_atoms ::: leaky$/;"	r
get_unique_Hirshfeld_atom_SFs	molecule.main.foo	/^   get_unique_Hirshfeld_atom_SFs(sf_n) ::: leaky, private$/;"	r
get_unique_Voronoi_atom_SFs	molecule.main.foo	/^   get_unique_Voronoi_atom_SFs(sf_n) ::: leaky, private$/;"	r
get_unique_invariom_SFs	molecule.main.foo	/^   get_unique_invariom_SFs(sf_n) ::: private$/;"	r
get_asym_atom_param_shifts	molecule.main.foo	/^   get_asym_atom_param_shifts(dX,X,sf_n) ::: leaky, private$/;"	r
get_asym_atom_params_into	molecule.main.foo	/^   get_asym_atom_params_into(X) ::: private$/;"	r
set_from_asym_atom_params	molecule.main.foo	/^   set_from_asym_atom_params(X) ::: private$/;"	r
stabilize_uniq_atom_shifts	molecule.main.foo	/^   stabilize_uniq_atom_shifts(dX) ::: private$/;"	r
uniq_to_asym_atom_params	molecule.main.foo	/^   uniq_to_asym_atom_params(X) ::: private$/;"	r
uniq_to_asym_atom_shifts	molecule.main.foo	/^   uniq_to_asym_atom_shifts(dX) ::: private$/;"	r
fit_Hirshfeld_atoms_BFGS	molecule.main.foo	/^   fit_Hirshfeld_atoms_BFGS ::: leaky$/;"	r
d_chi2H_dX	molecule.main.foo	/^   d_chi2H_dX(X,chi2,dchi2) ::: public, selfless$/;"	r
force_thermal_symmetry	molecule.main.foo	/^   force_thermal_symmetry$/;"	r
zero_off_atom_density	molecule.main.foo	/^   zero_off_atom_density$/;"	r
zero_off_atom_blocks	molecule.main.foo	/^   zero_off_atom_blocks(P)$/;"	r
create	mo_localiser.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	mo_localiser.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	mo_localiser.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	mo_localiser.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	mo_localiser.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	mo_localiser.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	mo_localiser.foo	/^   set_defaults(MO,dipole,quadrupole) ::: leaky$/;"	r
set_accuracy	mo_localiser.foo	/^   set_accuracy(acc)$/;"	r
set_algorithm	mo_localiser.foo	/^   set_algorithm(alg)$/;"	r
set_max_iterations	mo_localiser.foo	/^   set_max_iterations(maxit)$/;"	r
set_MO	mo_localiser.foo	/^   set_MO(MO)$/;"	r
read_keywords	mo_localiser.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	mo_localiser.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_accuracy	mo_localiser.foo	/^   read_accuracy$/;"	r
read_algorithm	mo_localiser.foo	/^   read_algorithm$/;"	r
read_max_iterations	mo_localiser.foo	/^   read_max_iterations$/;"	r
boys_localise	mo_localiser.foo	/^   boys_localise$/;"	r
boys_SOS	mo_localiser.foo	/^   boys_SOS result (res)$/;"	r
boys_centroid_SOS	mo_localiser.foo	/^   boys_centroid_SOS result (res)$/;"	r
kleier_gradient_norm	mo_localiser.foo	/^   kleier_gradient_norm result (grad)$/;"	r
kleier_gradient	mo_localiser.foo	/^   kleier_gradient(grad)$/;"	r
put_boys_results	mo_localiser.foo	/^   put_boys_results(sos,diff,converged,exceeded_maxit,sos_decreases)$/;"	r
update_MOs	mo_localiser.foo	/^   update_MOs$/;"	r
get_orbital_centroids	mo_localiser.foo	/^   get_orbital_centroids(c)$/;"	r
get_spread_matrix	mo_localiser.foo	/^   get_spread_matrix(rsq,rtr,ran)$/;"	r
put_centroids	mo_localiser.foo	/^   put_centroids$/;"	r
put_analysis	mo_localiser.foo	/^   put_analysis$/;"	r
put_moments	mo_localiser.foo	/^   put_moments$/;"	r
put_MOs	mo_localiser.foo	/^   put_MOs$/;"	r
put_TM	mo_localiser.foo	/^   put_TM$/;"	r
put_LMOs	mo_localiser.foo	/^   put_LMOs$/;"	r
put_gradient	mo_localiser.foo	/^   put_gradient$/;"	r
put_dipoles	mo_localiser.foo	/^   put_dipoles$/;"	r
put_quadrupoles	mo_localiser.foo	/^   put_quadrupoles$/;"	r
debug_list	multi_t_adp.foo	/^   debug_list :: VEC{STR}*, private  DEFAULT_NULL$/;"	g
create	multi_t_adp.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	multi_t_adp.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	multi_t_adp.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	multi_t_adp.foo	/^   destroy_ptr_part ::: leaky$/;"	r
destroy_data_ptr_part	multi_t_adp.foo	/^   destroy_data_ptr_part ::: leaky$/;"	r
created	multi_t_adp.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	multi_t_adp.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	multi_t_adp.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	multi_t_adp.foo	/^   copy(object) ::: leaky$/;"	r
set_defaults	multi_t_adp.foo	/^   set_defaults$/;"	r
set_fit_method	multi_t_adp.foo	/^   set_fit_method(method)$/;"	r
set_tol_shift_convergence	multi_t_adp.foo	/^   set_tol_shift_convergence(val)$/;"	r
set_use_translations	multi_t_adp.foo	/^   set_use_translations(val)$/;"	r
set_use_librations	multi_t_adp.foo	/^   set_use_librations(val)$/;"	r
set_use_V_linear_term	multi_t_adp.foo	/^   set_use_V_linear_term(val)$/;"	r
set_use_fixed_H_modes	multi_t_adp.foo	/^   set_use_fixed_H_modes(val)$/;"	r
set_use_fixed_non_H_modes	multi_t_adp.foo	/^   set_use_fixed_non_H_modes(val)$/;"	r
set_n_internal	multi_t_adp.foo	/^   set_n_internal(n)$/;"	r
set_n_project	multi_t_adp.foo	/^   set_n_project(n)$/;"	r
set_project_onto_init_modes	multi_t_adp.foo	/^   set_project_onto_init_modes(val)$/;"	r
set_max_allowed_shift	multi_t_adp.foo	/^   set_max_allowed_shift(val)$/;"	r
set_max_iterations	multi_t_adp.foo	/^   set_max_iterations(m)$/;"	r
set_min_iterations	multi_t_adp.foo	/^   set_min_iterations(m)$/;"	r
set_min_correlation	multi_t_adp.foo	/^   set_min_correlation(val)$/;"	r
set_show_correlations	multi_t_adp.foo	/^   set_show_correlations(val)$/;"	r
set_V_expansion_order	multi_t_adp.foo	/^   set_V_expansion_order(n)$/;"	r
read_keywords	multi_t_adp.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	multi_t_adp.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	multi_t_adp.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_cif_file_names	multi_t_adp.foo	/^   read_cif_file_names ::: leaky$/;"	r
read_fit_method	multi_t_adp.foo	/^   read_fit_method$/;"	r
read_max_allowed_shift	multi_t_adp.foo	/^   read_max_allowed_shift$/;"	r
read_max_iterations	multi_t_adp.foo	/^   read_max_iterations$/;"	r
read_min_iterations	multi_t_adp.foo	/^   read_min_iterations$/;"	r
read_n_internal	multi_t_adp.foo	/^   read_n_internal$/;"	r
read_n_project	multi_t_adp.foo	/^   read_n_project$/;"	r
read_show_correlations	multi_t_adp.foo	/^   read_show_correlations$/;"	r
read_tol_shift_convergence	multi_t_adp.foo	/^   read_tol_shift_convergence$/;"	r
read_use_librations	multi_t_adp.foo	/^   read_use_librations$/;"	r
read_use_translations	multi_t_adp.foo	/^   read_use_translations$/;"	r
read_use_fixed_H_modes	multi_t_adp.foo	/^   read_use_fixed_H_modes$/;"	r
read_use_fixed_non_H_modes	multi_t_adp.foo	/^   read_use_fixed_non_H_modes$/;"	r
read_project_onto_init_modes	multi_t_adp.foo	/^   read_project_onto_init_modes$/;"	r
read_use_V_linear_term	multi_t_adp.foo	/^   read_use_V_linear_term$/;"	r
read_V_expansion_order	multi_t_adp.foo	/^   read_V_expansion_order$/;"	r
put	multi_t_adp.foo	/^   put$/;"	r
read_cifs	multi_t_adp.foo	/^   read_cifs ::: leaky$/;"	r
initialise_modes	multi_t_adp.foo	/^   initialise_modes ::: leaky$/;"	r
initialise_modes	multi_t_adp.foo	/^   initialise_modes(translations,librations,fixed_H_modes,n_internal) ::: leaky$/;"	r
initialise_translations	multi_t_adp.foo	/^   initialise_translations(L)$/;"	r
initialise_librations	multi_t_adp.foo	/^   initialise_librations(L)$/;"	r
initialise_random_internal	multi_t_adp.foo	/^   initialise_random_internal(L,n_internal)$/;"	r
put_model_parameters_into	multi_t_adp.foo	/^   put_model_parameters_into(X) $/;"	r
set_model_parameters_from	multi_t_adp.foo	/^   set_model_parameters_from(X) $/;"	r
make_V_expansion_coeffs	multi_t_adp.foo	/^   make_V_expansion_coeffs ::: leaky$/;"	r
fitted_V	multi_t_adp.foo	/^   fitted_V(t) result (res)$/;"	r
Delta_V	multi_t_adp.foo	/^   Delta_V(t) result (res)$/;"	r
fitted_V_residual2	multi_t_adp.foo	/^   fitted_V_residual2 result (res)$/;"	r
put_unit_cell_volumes	multi_t_adp.foo	/^   put_unit_cell_volumes$/;"	r
least_squares	multi_t_adp.foo	/^   least_squares$/;"	r
make_least_squares	multi_t_adp.foo	/^   make_least_squares(LL,GG,HH,MM) $/;"	r
put_refinement_params	multi_t_adp.foo	/^   put_refinement_params$/;"	r
put_iteration_header	multi_t_adp.foo	/^   put_iteration_header$/;"	r
put_iteration_results	multi_t_adp.foo	/^   put_iteration_results$/;"	r
put_iteration_footer	multi_t_adp.foo	/^   put_iteration_footer$/;"	r
refinement_finished	multi_t_adp.foo	/^   refinement_finished(chi2_increased,too_many,converged) result (res)$/;"	r
n_parameters	multi_t_adp.foo	/^   n_parameters result (res) ::: pure$/;"	r
n_total_parameters	multi_t_adp.foo	/^   n_total_parameters result (res) ::: pure$/;"	r
n_independent_parameters	multi_t_adp.foo	/^   n_independent_parameters result (res) ::: pure$/;"	r
omega_bar	multi_t_adp.foo	/^   omega_bar(i,t) result (res)$/;"	r
amplitude	multi_t_adp.foo	/^   amplitude(i,t) result (res)$/;"	r
Delta	multi_t_adp.foo	/^   Delta(a,b,c,t) result (res)$/;"	r
make_Delta	multi_t_adp.foo	/^   make_Delta(Delta) $/;"	r
make_Welta	multi_t_adp.foo	/^   make_Welta(Welta,Delta)$/;"	r
Lagrangian	multi_t_adp.foo	/^   Lagrangian(Delta,Welta) result (res)$/;"	r
the_chi2	multi_t_adp.foo	/^   the_chi2(Delta,Welta) result (res)$/;"	r
the_chi2	multi_t_adp.foo	/^   the_chi2 result (res)$/;"	r
make_d_Welta	multi_t_adp.foo	/^   make_d_Welta(d_Welta,d_Delta) $/;"	r
add_d_Delta_gradient	multi_t_adp.foo	/^   add_d_Delta_gradient(GG,d_Delta,Welta) $/;"	r
add_d_C_d_L	multi_t_adp.foo	/^   add_d_C_d_L(GG) $/;"	r
add_d_C_d_lambda	multi_t_adp.foo	/^   add_d_C_d_lambda(GG) $/;"	r
add_d_Delta_hessian	multi_t_adp.foo	/^   add_d_Delta_hessian(HH,d_Delta,d_Welta) $/;"	r
make_d_Delta_d_L	multi_t_adp.foo	/^   make_d_Delta_d_L(d_Delta) $/;"	r
make_d_Delta_d_w	multi_t_adp.foo	/^   make_d_Delta_d_w(d_Delta) $/;"	r
make_d_Delta_d_G	multi_t_adp.foo	/^   make_d_Delta_d_G(d_Delta) $/;"	r
d_U_d_L	multi_t_adp.foo	/^   d_U_d_L(a,b,c,t,g,i) result (res)$/;"	r
d_U_d_w	multi_t_adp.foo	/^   d_U_d_w(a,b,c,t,i) result (res)$/;"	r
d_amplitude_d_w	multi_t_adp.foo	/^   d_amplitude_d_w(i,t) result (res)$/;"	r
d_amplitude_d_wb	multi_t_adp.foo	/^   d_amplitude_d_wb(i,t) result (res)$/;"	r
d_wb_d_w	multi_t_adp.foo	/^   d_wb_d_w(i,t) result (res)$/;"	r
d_U_d_G	multi_t_adp.foo	/^   d_U_d_G(a,b,c,t,i) result (res)$/;"	r
d_amplitude_d_G	multi_t_adp.foo	/^   d_amplitude_d_G(i,t) result (res)$/;"	r
d_wb_d_G	multi_t_adp.foo	/^   d_wb_d_G(i,t) result (res)$/;"	r
d_C_d_L	multi_t_adp.foo	/^   d_C_d_L(g,i) result (res)$/;"	r
d_C_d_lambda	multi_t_adp.foo	/^   d_C_d_lambda(p,q) result (res)$/;"	r
add_d2_Delta_d2_L	multi_t_adp.foo	/^   add_d2_Delta_d2_L(HH,Welta) $/;"	r
add_d2_Delta_d2_w	multi_t_adp.foo	/^   add_d2_Delta_d2_w(HH,Welta) $/;"	r
add_d2_Delta_d2_G	multi_t_adp.foo	/^   add_d2_Delta_d2_G(HH,Welta) $/;"	r
add_d2_Delta_d_L_d_w	multi_t_adp.foo	/^   add_d2_Delta_d_L_d_w(HH,Welta) $/;"	r
add_d2_Delta_d_L_d_G	multi_t_adp.foo	/^   add_d2_Delta_d_L_d_G(HH,Welta) $/;"	r
add_d2_Delta_d_w_d_G	multi_t_adp.foo	/^   add_d2_Delta_d_w_d_G(HH,Welta) $/;"	r
add_d2_C_d_L_d_lambda	multi_t_adp.foo	/^   add_d2_C_d_L_d_lambda(HH) $/;"	r
d2_U_d2_L	multi_t_adp.foo	/^   d2_U_d2_L(a,b,c,t,g,i,h,j) result (res)$/;"	r
d2_U_d2_w	multi_t_adp.foo	/^   d2_U_d2_w(a,b,c,t,i) result (res)$/;"	r
d2_amplitude_d2_w	multi_t_adp.foo	/^   d2_amplitude_d2_w(i,t) result (res)$/;"	r
d2_amplitude_d2_wb	multi_t_adp.foo	/^   d2_amplitude_d2_wb(i,t) result (res)$/;"	r
d2_U_d2_G	multi_t_adp.foo	/^   d2_U_d2_G(a,b,c,t,i) result (res)$/;"	r
d2_amplitude_d2_G	multi_t_adp.foo	/^   d2_amplitude_d2_G(i,t) result (res)$/;"	r
d2_U_d_L_d_w	multi_t_adp.foo	/^   d2_U_d_L_d_w(a,b,c,t,g,i) result (res)$/;"	r
d2_U_d_L_d_G	multi_t_adp.foo	/^   d2_U_d_L_d_G(a,b,c,t,g,i) result (res)$/;"	r
d2_U_d_w_d_G	multi_t_adp.foo	/^   d2_U_d_w_d_G(a,b,c,t,i) result (res)$/;"	r
d2_amplitude_d_w_d_G	multi_t_adp.foo	/^   d2_amplitude_d_w_d_G(i,t) result (res)$/;"	r
d2_wb_d_w_d_G	multi_t_adp.foo	/^   d2_wb_d_w_d_G(t) result (res)$/;"	r
d2_C_d2_L	multi_t_adp.foo	/^   d2_C_d2_L(g,i,h,j) result (res)$/;"	r
d2_C_d_L_d_lambda	multi_t_adp.foo	/^   d2_C_d_L_d_lambda(g,i,p,q) result (res)$/;"	r
read_debug_on	multi_t_adp.foo	/^   read_debug_on ::: get_from(DEBUG), leaky$/;"	r
read_debug_off	multi_t_adp.foo	/^   read_debug_off ::: get_from(DEBUG), leaky$/;"	r
debugging	multi_t_adp.foo	/^   debugging(name) result (res) ::: get_from(DEBUG)$/;"	r
put_debug_list	multi_t_adp.foo	/^   put_debug_list ::: get_from(DEBUG)$/;"	r
put_debug	multi_t_adp.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)$/;"	r
put_debug	multi_t_adp.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})$/;"	r
put_debug	multi_t_adp.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})$/;"	r
keys	object.foo	/^   keys :: VEC{STR}*, private DEFAULT_NULL$/;"	g
create	object.foo	/^   create ::: leaky$/;"	r
create	object.foo	/^   create ::: leaky$/;"	r
create	object.foo	/^   create ::: leaky$/;"	r
create	object.foo	/^   create ::: leaky$/;"	r
create_copy	object.foo	/^   create_copy(object) ::: leaky$/;"	r
destroy	object.foo	/^   destroy ::: leaky$/;"	r
destroy	object.foo	/^   destroy ::: leaky$/;"	r
created	object.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	object.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
set	object.foo	/^   set(object)$/;"	r
set	object.foo	/^   set(val)$/;"	r
set_saved_self	object.foo	/^   set_saved_self $/;"	r
set_saved_self	object.foo	/^   set_saved_self $/;"	r
redirect	object.foo	/^   redirect ::: leaky$/;"	r
revert	object.foo	/^   revert ::: leaky$/;"	r
redirect	object.foo	/^   redirect ::: leaky$/;"	r
revert	object.foo	/^   revert ::: leaky$/;"	r
read_keywords	object.foo	/^   read_keywords ::: recursive, leaky$/;"	r
read_keywords	object.foo	/^   read_keywords ::: recursive, leaky$/;"	r
read_units	object.foo	/^   read_units ::: selfless$/;"	r
read_junk	object.foo	/^   read_junk ::: selfless$/;"	r
read_and_set	object.foo	/^   read_and_set$/;"	r
read_and_set	object.foo	/^   read_and_set$/;"	r
put_table_footer	object.foo	/^   put_table_footer$/;"	r
read_keys	object.foo	/^   read_keys$/;"	r
process_keys	object.foo	/^   process_keys ::: leaky$/;"	r
keys_created	object.foo	/^   keys_created result (res)$/;"	r
set_keys	object.foo	/^   set_keys(the_keys)$/;"	r
clear_keys	object.foo	/^   clear_keys$/;"	r
create	opmatrix.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	opmatrix.foo	/^   create(n_bf) ::: leaky$/;"	r
create	opmatrix.foo	/^   create(n_bf,genre) ::: leaky$/;"	r
create_copy	opmatrix.foo	/^   create_copy(m) ::: leaky$/;"	r
destroy	opmatrix.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
create	opmatrix.foo	/^   create(genre) ::: leaky$/;"	r
destroy	opmatrix.foo	/^   destroy(genre) ::: leaky$/;"	r
nullify_ptr_part	opmatrix.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	opmatrix.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	opmatrix.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
created	opmatrix.foo	/^   created(genre) result (res)$/;"	r
destroyed	opmatrix.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	opmatrix.foo	/^   destroyed(genre) result (res)$/;"	r
any_created	opmatrix.foo	/^   any_created result (res)$/;"	r
all_destroyed	opmatrix.foo	/^   all_destroyed result (res)$/;"	r
set_defaults	opmatrix.foo	/^   set_defaults$/;"	r
set	opmatrix.foo	/^   set(n_bf)$/;"	r
set_to	opmatrix.foo	/^   set_to(m) ::: leaky$/;"	r
same_spinorbital_kind_as	opmatrix.foo	/^   same_spinorbital_kind_as(X) result (res)$/;"	r
spinorbital_kind	opmatrix.foo	/^   spinorbital_kind result (res)$/;"	r
number_kind	opmatrix.foo	/^   number_kind result (res)$/;"	r
guess_scf_kind	opmatrix.foo	/^   guess_scf_kind result (res)$/;"	r
set_to_zero	opmatrix.foo	/^   set_to_zero$/;"	r
convert_to	opmatrix.foo	/^   convert_to(newkind,factor,destroy_original) ::: leaky$/;"	r
convert_to	opmatrix.foo	/^   convert_to(newkind,na,nb,quantization_axis) ::: leaky$/;"	r
l_compress	opmatrix.foo	/^   l_compress(genre) result (res)$/;"	r
compress	opmatrix.foo	/^   compress(genre) ::: leaky$/;"	r
uncompress	opmatrix.foo	/^   uncompress ::: leaky$/;"	r
schmidt_orthonormalise	opmatrix.foo	/^   schmidt_orthonormalise(S,scale)$/;"	r
symmetrically_orthonormalise	opmatrix.foo	/^   symmetrically_orthonormalise(S)$/;"	r
plus	opmatrix.foo	/^   plus(X)$/;"	r
minus	opmatrix.foo	/^   minus(X)$/;"	r
to_scaled	opmatrix.foo	/^   to_scaled(X,fac)$/;"	r
plus_scaled	opmatrix.foo	/^   plus_scaled(X,fac)$/;"	r
damp	opmatrix.foo	/^   damp(old,mix)$/;"	r
expectation	opmatrix.foo	/^   expectation(X) result (res)$/;"	r
create	opvector.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	opvector.foo	/^   create(n_bf) ::: leaky$/;"	r
create	opvector.foo	/^   create(n_bf,genre) ::: leaky$/;"	r
destroy	opvector.foo	/^   destroy$/;"	r
create	opvector.foo	/^   create(genre) ::: leaky$/;"	r
destroy	opvector.foo	/^   destroy(genre) ::: leaky$/;"	r
nullify_ptr_part	opvector.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	opvector.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	opvector.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	opvector.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
created	opvector.foo	/^   created(genre) result (res)$/;"	r
destroyed	opvector.foo	/^   destroyed(genre) result (res)$/;"	r
any_created	opvector.foo	/^   any_created result (res)$/;"	r
all_destroyed	opvector.foo	/^   all_destroyed result (res)$/;"	r
create_copy	opvector.foo	/^   create_copy(v)$/;"	r
set_defaults	opvector.foo	/^   set_defaults$/;"	r
set	opvector.foo	/^   set(n_bf)$/;"	r
set_to	opvector.foo	/^   set_to(v) ::: leaky$/;"	r
spinorbital_kind	opvector.foo	/^   spinorbital_kind result (res)$/;"	r
set_to_zero	opvector.foo	/^   set_to_zero$/;"	r
convert_to	opvector.foo	/^   convert_to(newkind) ::: leaky$/;"	r
no_of_occupied	opvector.foo	/^   no_of_occupied(genre,tol) result (res)$/;"	r
initialise	parallel.foo	/^   initialise$/;"	r
finalise	parallel.foo	/^   finalise$/;"	r
is_master_processor	parallel.foo	/^   is_master_processor result (res) ::: pure$/;"	r
master_processor	parallel.foo	/^   master_processor result (res) ::: pure$/;"	r
this_processor	parallel.foo	/^   this_processor result (res) ::: pure$/;"	r
parallel_do_start	parallel.foo	/^   parallel_do_start(first,stride) result (res) ::: pure$/;"	r
parallel_do_stride	parallel.foo	/^   parallel_do_stride(stride) result (res) ::: pure$/;"	r
do_in_parallel	parallel.foo	/^   do_in_parallel result (res) ::: pure$/;"	r
lock_parallel_do	parallel.foo	/^   lock_parallel_do(name)$/;"	r
unlock_parallel_do	parallel.foo	/^   unlock_parallel_do(name)$/;"	r
parallel_vector_sum	parallel.foo	/^   parallel_vector_sum(vec,dim) ::: template$/;"	r
parallel_vector_sum	parallel.foo	/^   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{BIN}, MPI_TYPE=>MPI_LOGICAL), public$/;"	r
parallel_vector_sum	parallel.foo	/^   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{INT}, MPI_TYPE=>MPI_INTEGER), public$/;"	r
parallel_vector_sum	parallel.foo	/^   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION), public$/;"	r
parallel_vector_sum	parallel.foo	/^   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX), public$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(vec) ::: template$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{BIN}, MPI_TYPE=>MPI_LOGICAL)$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{INT}, MPI_TYPE=>MPI_INTEGER)$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: template$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)$/;"	r
parallel_symmetric_sum	parallel.foo	/^   parallel_symmetric_sum(mat)$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: template$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT3{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT3{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: template$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT4{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT4{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: template$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT5{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)$/;"	r
parallel_sum	parallel.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT5{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)$/;"	r
compress_to_triangle	parallel.foo	/^   compress_to_triangle(tr,mat)$/;"	r
uncompress_from_triangle	parallel.foo	/^   uncompress_from_triangle(tr,mat)$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: template$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>STR, MPI_TYPE=>MPI_CHARACTER, LEN=>len(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>BIN, MPI_TYPE=>MPI_LOGICAL, LEN=>1)$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>INT, MPI_TYPE=>MPI_INTEGER, LEN=>1)$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>REAL, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>1)$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>CPX, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>1)$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{STR}, MPI_TYPE=>MPI_CHARACTER, LEN=>size(var)*len(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{BIN}, MPI_TYPE=>MPI_LOGICAL, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{STR}, MPI_TYPE=>MPI_CHARACTER, LEN=>size(var)*len(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{BIN}, MPI_TYPE=>MPI_LOGICAL, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{BIN}, MPI_TYPE=>MPI_LOGICAL, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT4{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT4{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT4{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT5{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))$/;"	r
broadcast	parallel.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT5{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))$/;"	r
IO_is_allowed	parallel.foo	/^   IO_is_allowed result (res)$/;"	r
synchronise_processors	parallel.foo	/^   synchronise_processors$/;"	r
set_max_n_skip_proc	parallel.foo	/^   set_max_n_skip_proc(n)$/;"	r
get_2d_processor_grid	parallel.foo	/^   get_2d_processor_grid(nprocx,nprocy,nproc)$/;"	r
init_2d_proc_grid	parallel.foo	/^   init_2d_proc_grid$/;"	r
done_proc_grid	parallel.foo	/^   done_proc_grid$/;"	r
n_this_row	parallel.foo	/^   n_this_row(n) result (res)$/;"	r
n_this_col	parallel.foo	/^   n_this_col(n)$/;"	r
create	plot_grid.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	plot_grid.foo	/^   create(atom) ::: leaky$/;"	r
create_copy	plot_grid.foo	/^   create_copy(grid) ::: leaky$/;"	r
copy	plot_grid.foo	/^   copy(grid)$/;"	r
destroy	plot_grid.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	plot_grid.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	plot_grid.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	plot_grid.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	plot_grid.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	plot_grid.foo	/^   set_defaults$/;"	r
set_defaults	plot_grid.foo	/^   set_defaults(atom,destroy_atom)$/;"	r
set_atom_defaults	plot_grid.foo	/^   set_atom_defaults(atom,destroy_atom)$/;"	r
reset_defaults	plot_grid.foo	/^   reset_defaults$/;"	r
set_bounding_box	plot_grid.foo	/^   set_bounding_box(atom)$/;"	r
set_bounding_box_and_axes	plot_grid.foo	/^   set_bounding_box_and_axes(atom)$/;"	r
set_points_widths_origin	plot_grid.foo	/^   set_points_widths_origin$/;"	r
set_desired_separation	plot_grid.foo	/^   set_desired_separation(del)$/;"	r
set_centre_from_atom_list	plot_grid.foo	/^   set_centre_from_atom_list(atom)$/;"	r
offset_centre	plot_grid.foo	/^   offset_centre$/;"	r
set_origin	plot_grid.foo	/^   set_origin$/;"	r
set_x_axis_from_atom_list	plot_grid.foo	/^   set_x_axis_from_atom_list(atom)$/;"	r
set_y_axis_from_atom_list	plot_grid.foo	/^   set_y_axis_from_atom_list(atom)$/;"	r
set_z_axis_from_atom_list	plot_grid.foo	/^   set_z_axis_from_atom_list(atom)$/;"	r
set_xyz_axes_from_x_axis	plot_grid.foo	/^   set_xyz_axes_from_x_axis$/;"	r
set_xyz_axes_from_y_axis	plot_grid.foo	/^   set_xyz_axes_from_y_axis$/;"	r
set_xyz_axes_from_z_axis	plot_grid.foo	/^   set_xyz_axes_from_z_axis$/;"	r
x_or_y_axes_defined	plot_grid.foo	/^   x_or_y_axes_defined result (res)$/;"	r
orthonormalise_x_y_to_z_axis	plot_grid.foo	/^   orthonormalise_x_y_to_z_axis$/;"	r
orthonormalise_y_z_to_x_axis	plot_grid.foo	/^   orthonormalise_y_z_to_x_axis$/;"	r
update_for_marching_cubes	plot_grid.foo	/^   update_for_marching_cubes$/;"	r
make_math_pos	plot_grid.foo	/^   make_math_pos(math_pos,z_range,valid) ::: leaky$/;"	r
read_keywords	plot_grid.foo	/^   read_keywords ::: get_from(OBJECT), leaky$/;"	r
process_keyword	plot_grid.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	plot_grid.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_plot_units	plot_grid.foo	/^   read_plot_units $/;"	r
read_plot_format	plot_grid.foo	/^   read_plot_format$/;"	r
read_plot_max	plot_grid.foo	/^   read_plot_max$/;"	r
read_plot_min	plot_grid.foo	/^   read_plot_min$/;"	r
read_use_plot_max	plot_grid.foo	/^   read_use_plot_max$/;"	r
read_use_plot_min	plot_grid.foo	/^   read_use_plot_min$/;"	r
read_kind	plot_grid.foo	/^   read_kind$/;"	r
read_desired_separation	plot_grid.foo	/^   read_desired_separation$/;"	r
read_max_x_points	plot_grid.foo	/^   read_max_x_points$/;"	r
read_min_x_points	plot_grid.foo	/^   read_min_x_points$/;"	r
read_x_points	plot_grid.foo	/^   read_x_points$/;"	r
read_offset	plot_grid.foo	/^   read_offset$/;"	r
read_orbital	plot_grid.foo	/^   read_orbital$/;"	r
read_HOMO_orbital_plus	plot_grid.foo	/^   read_HOMO_orbital_plus$/;"	r
read_HOMO_orbital_minus	plot_grid.foo	/^   read_HOMO_orbital_minus$/;"	r
read_LUMO_orbital_plus	plot_grid.foo	/^   read_LUMO_orbital_plus$/;"	r
read_centre_atom	plot_grid.foo	/^   read_centre_atom$/;"	r
read_centre_atoms	plot_grid.foo	/^   read_centre_atoms$/;"	r
read_centre	plot_grid.foo	/^   read_centre$/;"	r
read_x_axis	plot_grid.foo	/^   read_x_axis$/;"	r
read_x_axis_atoms	plot_grid.foo	/^   read_x_axis_atoms$/;"	r
read_x_axis_atom_list	plot_grid.foo	/^   read_x_axis_atom_list$/;"	r
read_y_axis	plot_grid.foo	/^   read_y_axis$/;"	r
read_y_axis_atoms	plot_grid.foo	/^   read_y_axis_atoms$/;"	r
read_y_axis_atom_list	plot_grid.foo	/^   read_y_axis_atom_list$/;"	r
read_z_axis	plot_grid.foo	/^   read_z_axis$/;"	r
read_z_axis_atoms	plot_grid.foo	/^   read_z_axis_atoms$/;"	r
read_x_width	plot_grid.foo	/^   read_x_width$/;"	r
read_y_width	plot_grid.foo	/^   read_y_width$/;"	r
read_z_width	plot_grid.foo	/^   read_z_width$/;"	r
read_bond_density_atoms	plot_grid.foo	/^   read_bond_density_atoms ::: leaky$/;"	r
read_box_scale_factor	plot_grid.foo	/^   read_box_scale_factor$/;"	r
set_box_scale_factor	plot_grid.foo	/^   set_box_scale_factor(factor)$/;"	r
use_bounding_box	plot_grid.foo	/^   use_bounding_box$/;"	r
use_bounding_cube	plot_grid.foo	/^   use_bounding_cube$/;"	r
use_bounding_box_and_axes	plot_grid.foo	/^   use_bounding_box_and_axes$/;"	r
use_bounding_cube_and_axes	plot_grid.foo	/^   use_bounding_cube_and_axes$/;"	r
set_bbox_from_unit_cell	plot_grid.foo	/^   set_bbox_from_unit_cell(unit_cell)$/;"	r
set_box_from_widths	plot_grid.foo	/^   set_box_from_widths$/;"	r
set_cube_from_widths	plot_grid.foo	/^   set_cube_from_widths$/;"	r
plot_axes	plot_grid.foo	/^   plot_axes result (res)$/;"	r
has_orthogonal_plot_axes	plot_grid.foo	/^   has_orthogonal_plot_axes result (res)$/;"	r
has_equal_spacing	plot_grid.foo	/^   has_equal_spacing result (res)$/;"	r
transposed_plot_axes	plot_grid.foo	/^   transposed_plot_axes result (res)$/;"	r
make_points	plot_grid.foo	/^   make_points(x_pt,y_pt,z_pt)$/;"	r
make_points	plot_grid.foo	/^   make_points(pt,first_pt,last_pt)$/;"	r
make_points	plot_grid.foo	/^   make_points(pt,fx,lx,fy,ly,fz,lz)$/;"	r
point	plot_grid.foo	/^   point(x,y,z) result (res)$/;"	r
make_cube_of_points	plot_grid.foo	/^   make_cube_of_points(p,f,l,del_x,del_y,del_z,x,y,z,eval) ::: public$/;"	r
put	plot_grid.foo	/^   put(output)$/;"	r
use_bond_axis_as_z_axis	plot_grid.foo	/^   use_bond_axis_as_z_axis$/;"	r
get_bond_atoms_on_z_axis	plot_grid.foo	/^   get_bond_atoms_on_z_axis(pos,Z,theta) ::: leaky$/;"	r
align_to_bond	plot_grid.foo	/^   align_to_bond$/;"	r
create	pointgroup.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	pointgroup.foo	/^   create(symbol,use_spherical_basis) ::: leaky$/;"	r
destroy	pointgroup.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	pointgroup.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	pointgroup.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
nullify_ptr_part	pointgroup.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	pointgroup.foo	/^   destroy_ptr_part ::: leaky$/;"	r
create_copy	pointgroup.foo	/^   create_copy(pg)$/;"	r
copy	pointgroup.foo	/^   copy(pg) ::: leaky$/;"	r
set_symbol	pointgroup.foo	/^   set_symbol(symbol)$/;"	r
set_defaults	pointgroup.foo	/^   set_defaults$/;"	r
read_keywords	pointgroup.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	pointgroup.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_symbol	pointgroup.foo	/^   read_symbol$/;"	r
analyse	pointgroup.foo	/^   analyse ::: leaky, private$/;"	r
analyse_symbol	pointgroup.foo	/^   analyse_symbol ::: private$/;"	r
make_rep_matrices	pointgroup.foo	/^   make_rep_matrices ::: leaky, private$/;"	r
times_ci	pointgroup.foo	/^   times_ci(n) ::: private$/;"	r
times_sigma_h	pointgroup.foo	/^   times_sigma_h(n) ::: private$/;"	r
times_sigma_v	pointgroup.foo	/^   times_sigma_v(n) ::: private$/;"	r
times_sigma_d	pointgroup.foo	/^   times_sigma_d(n) ::: private$/;"	r
times_c2x	pointgroup.foo	/^   times_c2x(n) ::: private$/;"	r
times_c4z	pointgroup.foo	/^   times_c4z(n) ::: private$/;"	r
make_cn_matrices	pointgroup.foo	/^   make_cn_matrices ::: private$/;"	r
make_sn_matrices	pointgroup.foo	/^   make_sn_matrices(n) ::: private$/;"	r
make_t_matrices	pointgroup.foo	/^   make_t_matrices ::: private$/;"	r
make_xyz_matrices	pointgroup.foo	/^   make_xyz_matrices ::: leaky, private$/;"	r
xyz_matrix	pointgroup.foo	/^   xyz_matrix(n,l) result (res)$/;"	r
make_inverse	pointgroup.foo	/^   make_inverse ::: leaky, private$/;"	r
make_table	pointgroup.foo	/^   make_table ::: leaky, private$/;"	r
make_irrep_matrices	pointgroup.foo	/^   make_irrep_matrices ::: leaky, private$/;"	r
make_C_type_irreps	pointgroup.foo	/^   make_C_type_irreps ::: leaky, private$/;"	r
make_cnh_gen	pointgroup.foo	/^   make_cnh_gen(e,gen1,gen2) ::: private$/;"	r
make_sigma_x_gen	pointgroup.foo	/^   make_sigma_x_gen(e,gen2) ::: private$/;"	r
make_cn_gen	pointgroup.foo	/^   make_cn_gen(e,gen1,axis_order) ::: private$/;"	r
make_T_type_irreps	pointgroup.foo	/^   make_T_type_irreps ::: leaky, private$/;"	r
make_character_table	pointgroup.foo	/^   make_character_table ::: leaky, private$/;"	r
make_irrep_labels	pointgroup.foo	/^   make_irrep_labels ::: private$/;"	r
put	pointgroup.foo	/^   put(output)$/;"	r
create	quadrature2.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create_copy	quadrature2.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	quadrature2.foo	/^   copy(c) ::: leaky$/;"	r
destroy	quadrature2.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	quadrature2.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	quadrature2.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	quadrature2.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	quadrature2.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	quadrature2.foo	/^   set_defaults $/;"	r
read_keywords	quadrature2.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	quadrature2.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_x_quadrature	quadrature2.foo	/^   read_x_quadrature$/;"	r
read_y_quadrature	quadrature2.foo	/^   read_y_quadrature$/;"	r
finalise	quadrature2.foo	/^   finalise ::: leaky$/;"	r
put	quadrature2.foo	/^   put$/;"	r
create	quadrature.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	quadrature.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	quadrature.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	quadrature.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	quadrature.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	quadrature.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	quadrature.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	quadrature.foo	/^   copy(q) ::: leaky$/;"	r
set_defaults	quadrature.foo	/^   set_defaults $/;"	r
set_eps	quadrature.foo	/^   set_eps(eps)$/;"	r
set_maxit	quadrature.foo	/^   set_maxit(maxit)$/;"	r
set_kind	quadrature.foo	/^   set_kind(kind)$/;"	r
set_n_points	quadrature.foo	/^   set_n_points(n_points)$/;"	r
set_gauss_laguerre_alpha	quadrature.foo	/^   set_gauss_laguerre_alpha(alpha)$/;"	r
set_gauss_jacobi_alpha	quadrature.foo	/^   set_gauss_jacobi_alpha(alpha)$/;"	r
set_gauss_jacobi_beta	quadrature.foo	/^   set_gauss_jacobi_beta(beta)$/;"	r
set_quadrature_points	quadrature.foo	/^   set_quadrature_points ::: leaky$/;"	r
set_limits	quadrature.foo	/^   set_limits(limits)$/;"	r
rescale_points_and_weights	quadrature.foo	/^   rescale_points_and_weights ::: private$/;"	r
rescale_m1p1	quadrature.foo	/^   rescale_m1p1 ::: private$/;"	r
rescale_z0p1	quadrature.foo	/^   rescale_z0p1 ::: private$/;"	r
set_roots_and_weights	quadrature.foo	/^   set_roots_and_weights ::: leaky, private$/;"	r
set_gauss_chebyshev_1st	quadrature.foo	/^   set_gauss_chebyshev_1st ::: private$/;"	r
set_gauss_chebyshev_2nd	quadrature.foo	/^   set_gauss_chebyshev_2nd ::: private$/;"	r
set_gauss_chebyshev_3rd	quadrature.foo	/^   set_gauss_chebyshev_3rd ::: private$/;"	r
set_gauss_laguerre	quadrature.foo	/^   set_gauss_laguerre ::: private$/;"	r
set_gauss_legendre	quadrature.foo	/^   set_gauss_legendre ::: private$/;"	r
set_gauss_hermite	quadrature.foo	/^   set_gauss_hermite ::: private$/;"	r
set_gauss_jacobi	quadrature.foo	/^   set_gauss_jacobi ::: private$/;"	r
set_points_and_weights	quadrature.foo	/^   set_points_and_weights ::: leaky, private$/;"	r
set_open_rectangle	quadrature.foo	/^   set_open_rectangle ::: private$/;"	r
set_extended_trapezoid	quadrature.foo	/^   set_extended_trapezoid ::: private$/;"	r
set_open_extended_trapezoid	quadrature.foo	/^   set_open_extended_trapezoid ::: private$/;"	r
set_extended_simpson	quadrature.foo	/^   set_extended_simpson ::: private$/;"	r
set_open_extended_simpson	quadrature.foo	/^   set_open_extended_simpson ::: private$/;"	r
quadrate	quadrature.foo	/^   quadrate(func) result (res)$/;"	r
test_sin	quadrature.foo	/^   test_sin(x) result (res) ::: selfless, public$/;"	r
test_x2	quadrature.foo	/^   test_x2(x) result (res) ::: selfless, public$/;"	r
test_x3	quadrature.foo	/^   test_x3(x) result (res) ::: selfless, public$/;"	r
test_x4	quadrature.foo	/^   test_x4(x) result (res) ::: selfless, public$/;"	r
ln_gamma_coefficients	real.foo	/^   ln_gamma_coefficients :: VEC{REAL}(0:6) , private$/;"	g
erf	real.foo	/^   interface erf$/;"	i
erfc	real.foo	/^   interface erfc$/;"	i
plus	real.foo	/^   plus(val) ::: pure$/;"	r
minus	real.foo	/^   minus(val) ::: pure$/;"	r
times	real.foo	/^   times(val) ::: pure$/;"	r
raised_to	real.foo	/^   raised_to(n) result (res) ::: pure$/;"	r
swap_with	real.foo	/^   swap_with(x)$/;"	r
str_length	real.foo	/^   str_length(spaces) result (res) ::: get_from(INTRINSIC, FMT=>*), pure$/;"	r
str_length_with_precision	real.foo	/^   str_length_with_precision(dp,spaces) result (res) ::: pure$/;"	r
to_str	real.foo	/^   to_str result (string) ::: get_from(INTRINSIC, FMT=>*), pure$/;"	r
to_str	real.foo	/^   to_str(format,left_justify) result (string) ::: get_from(INTRINSIC), pure$/;"	r
to_str	real.foo	/^   to_str(style,width,precision,left_justify) result (string) ::: get_from(INTRINSIC), pure$/;"	r
to_str_no_zeros	real.foo	/^   to_str_no_zeros result (string) ::: pure$/;"	r
convert_with_precision	real.foo	/^   convert_with_precision(error,p,v,d,n,e,units) $/;"	r
equals	real.foo	/^   equals(x,eps) result (res) ::: pure$/;"	r
same_as	real.foo	/^   same_as(x,eps) result (res) ::: pure$/;"	r
is_zero	real.foo	/^   is_zero(eps) result (res) ::: pure$/;"	r
is_one	real.foo	/^   is_one(eps) result (res) ::: pure$/;"	r
is_minus_one	real.foo	/^   is_minus_one(eps) result (res) ::: pure$/;"	r
is_int	real.foo	/^   is_int(eps) result (res) ::: pure$/;"	r
is_in_range	real.foo	/^   is_in_range(range) result (res) ::: pure$/;"	r
integral	real.foo	/^   integral(a,b,accuracy) result (res) ::: recursive, functional$/;"	r
integrate_adaptive_trapezoid	real.foo	/^   integrate_adaptive_trapezoid(a,b,accuracy) result (res) ::: recursive, functional$/;"	r
integrate_adaptive_simpson	real.foo	/^   integrate_adaptive_simpson(a,b,accuracy) result (res) ::: recursive, functional$/;"	r
self	real.foo	/^   self(x) result (res)$/;"	r
arccos	real.foo	/^   arccos result (res) ::: pure$/;"	r
arcsin	real.foo	/^   arcsin result (res) ::: pure$/;"	r
arcsinh	real.foo	/^   arcsinh result (res) ::: pure$/;"	r
my_sin	real.foo	/^   my_sin result (res) ::: public$/;"	r
z_from_p	real.foo	/^   z_from_p result (res) ::: pure$/;"	r
cumulative_poisson	real.foo	/^   cumulative_poisson(x,k) result (res) ::: selfless$/;"	r
chi2	real.foo	/^   chi2(x2,nu) result (res) ::: selfless$/;"	r
error_function	real.foo	/^   error_function result (res) $/;"	r
complementary_error_function	real.foo	/^   complementary_error_function result (res) $/;"	r
incomplete_gamma	real.foo	/^   incomplete_gamma(a,x) result (res) ::: selfless$/;"	r
incomplete_gamma_series	real.foo	/^   incomplete_gamma_series(a,x) result (res) ::: selfless$/;"	r
incomplete_gamma_cfrac	real.foo	/^   incomplete_gamma_cfrac(a,x) result (res) ::: selfless$/;"	r
ln_gamma	real.foo	/^   ln_gamma result (res) $/;"	r
ln_gamma_v2	real.foo	/^   ln_gamma_v2 result (res)$/;"	r
hermite_polynomial	real.foo	/^   hermite_polynomial(n,normalise) result (res)$/;"	r
harmonic_vibrational_fn	real.foo	/^   harmonic_vibrational_fn(n) result (res)$/;"	r
convert_to	real.foo	/^   convert_to(units)$/;"	r
to_units	real.foo	/^   to_units(units) result (res)$/;"	r
convert_from	real.foo	/^   convert_from(units)$/;"	r
from_units	real.foo	/^   from_units(units) result (res)$/;"	r
bracket_root	real.foo	/^   bracket_root(x1,x2,factor,max_it) ::: routinal$/;"	r
find_root_brent	real.foo	/^   find_root_brent(x1,x2,root,tol,val,max_it) ::: routinal$/;"	r
bracket_minimum	real.foo	/^   bracket_minimum(a,b,c,fa,fb,fc) ::: routinal$/;"	r
minimise_golden	real.foo	/^   minimise_golden(a,b,c,xmin,f,tol) ::: routinal$/;"	r
minimise_brent	real.foo	/^   minimise_brent(a,b,c,xmin,f,tol) ::: routinal$/;"	r
to_random_normal	real.foo	/^   to_random_normal$/;"	r
wavelength	reflection.foo	/^   wavelength :: REAL, private$/;"	g
create	reflection.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	reflection.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	reflection.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	reflection.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	reflection.foo	/^   create_copy(r) ::: leaky$/;"	r
copy	reflection.foo	/^   copy(r)$/;"	r
set_defaults	reflection.foo	/^   set_defaults$/;"	r
set_wavelength	reflection.foo	/^   set_wavelength(val) ::: selfless, public$/;"	r
read_keywords	reflection.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	reflection.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	reflection.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_junk	reflection.foo	/^   read_junk ::: get_from(OBJECT), selfless, private$/;"	r
read_group	reflection.foo	/^   read_group$/;"	r
read_h	reflection.foo	/^   read_h$/;"	r
read_k	reflection.foo	/^   read_k$/;"	r
read_l	reflection.foo	/^   read_l$/;"	r
read_indices	reflection.foo	/^   read_indices$/;"	r
read_F_exp	reflection.foo	/^   read_F_exp$/;"	r
read_F2_exp	reflection.foo	/^   read_F2_exp$/;"	r
add_to_F_exp	reflection.foo	/^   add_to_F_exp$/;"	r
read_F_calc	reflection.foo	/^   read_F_calc$/;"	r
add_to_F_calc	reflection.foo	/^   add_to_F_calc$/;"	r
read_F_pred	reflection.foo	/^   read_F_pred$/;"	r
read_F2_pred	reflection.foo	/^   read_F2_pred$/;"	r
add_to_F_pred	reflection.foo	/^   add_to_F_pred$/;"	r
read_F_sigma	reflection.foo	/^   read_F_sigma$/;"	r
read_F2_sigma	reflection.foo	/^   read_F2_sigma$/;"	r
derive_F_sigma_from_F2_sigma	reflection.foo	/^   derive_F_sigma_from_F2_sigma$/;"	r
add_to_F_sigma	reflection.foo	/^   add_to_F_sigma$/;"	r
add_to_F2_sigma	reflection.foo	/^   add_to_F2_sigma$/;"	r
read_I_exp	reflection.foo	/^   read_I_exp$/;"	r
add_to_I_exp	reflection.foo	/^   add_to_I_exp$/;"	r
read_I_pred	reflection.foo	/^   read_I_pred$/;"	r
add_to_I_pred	reflection.foo	/^   add_to_I_pred$/;"	r
read_I_sigma	reflection.foo	/^   read_I_sigma$/;"	r
add_to_I_sigma	reflection.foo	/^   add_to_I_sigma$/;"	r
read_keys	reflection.foo	/^   read_keys ::: get_from(OBJECT)$/;"	r
process_keys	reflection.foo	/^   process_keys ::: get_from(OBJECT), leaky$/;"	r
keys_created	reflection.foo	/^   keys_created result (res) ::: get_from(OBJECT)$/;"	r
set_keys	reflection.foo	/^   set_keys(the_keys) ::: get_from(OBJECT)$/;"	r
clear_keys	reflection.foo	/^   clear_keys ::: get_from(OBJECT)$/;"	r
put_table_footer	reflection.foo	/^   put_table_footer ::: get_from(OBJECT)$/;"	r
put_table_header	reflection.foo	/^   put_table_header$/;"	r
table_width	reflection.foo	/^   table_width result (res)$/;"	r
F_z	reflection.foo	/^   F_z result (res) ::: elemental$/;"	r
F2_z	reflection.foo	/^   F2_z result (res) ::: elemental$/;"	r
F_z2	reflection.foo	/^   F_z2 result (res) ::: elemental$/;"	r
F_r	reflection.foo	/^   F_r result (res) ::: elemental$/;"	r
I_z	reflection.foo	/^   I_z result (res) ::: elemental$/;"	r
F_phase	reflection.foo	/^   F_phase result (res) ::: elemental$/;"	r
F_exp_on_sigma	reflection.foo	/^   F_exp_on_sigma result (res) ::: elemental$/;"	r
F2_exp_on_sigma	reflection.foo	/^   F2_exp_on_sigma result (res) ::: elemental$/;"	r
sin_theta_on_lambda	reflection.foo	/^   sin_theta_on_lambda result (res) ::: elemental$/;"	r
stl	reflection.foo	/^   stl result (res) ::: elemental$/;"	r
has_weak_F_exp	reflection.foo	/^   has_weak_F_exp(cutoff) result (res) ::: elemental$/;"	r
has_weak_F2_exp	reflection.foo	/^   has_weak_F2_exp(cutoff) result (res) ::: elemental$/;"	r
has_small_F_exp	reflection.foo	/^   has_small_F_exp(cutoff) result (res) ::: elemental$/;"	r
has_small_F2_exp	reflection.foo	/^   has_small_F2_exp(cutoff) result (res) ::: elemental$/;"	r
has_large_F_z	reflection.foo	/^   has_large_F_z(cutoff) result (res) ::: elemental$/;"	r
has_high_stl	reflection.foo	/^   has_high_stl(cutoff) result (res) ::: elemental$/;"	r
has_low_stl	reflection.foo	/^   has_low_stl(cutoff) result (res) ::: elemental$/;"	r
create	rms2_indices.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	rms2_indices.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	rms2_indices.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	rms2_indices.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	rms2_indices.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	rms2_indices.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_indices	rms2_indices.foo	/^   set_indices(er,fr,ex,ey,ez,fx,fy,fz,ab_l_sum) ::: leaky$/;"	r
create	rms_indices.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	rms_indices.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	rms_indices.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	rms_indices.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	rms_indices.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	rms_indices.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_indices	rms_indices.foo	/^   set_indices(l_min,l_max,nx,ny,nz,px,py,pz) ::: leaky$/;"	r
n_comp_up_to	rms_indices.foo	/^   n_comp_up_to(l) result (res) ::: selfless, always_pure, private$/;"	r
create	roby.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	roby.foo	/^   create(mol,S) ::: leaky$/;"	r
destroy	roby.foo	/^   destroy ::: leaky$/;"	r
created	roby.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	roby.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
nullify_ptr_part	roby.foo	/^   nullify_ptr_part$/;"	r
nullify_ptr_data	roby.foo	/^   nullify_ptr_data$/;"	r
destroy_ptr_part	roby.foo	/^   destroy_ptr_part ::: leaky$/;"	r
set_defaults	roby.foo	/^   set_defaults$/;"	r
set_defaults	roby.foo	/^   set_defaults(mol,S)$/;"	r
read_keywords	roby.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	roby.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
finalize	roby.foo	/^   finalize ::: leaky$/;"	r
read_kind	roby.foo	/^   read_kind$/;"	r
read_atom_list	roby.foo	/^   read_atom_list ::: leaky$/;"	r
read_atom_groups	roby.foo	/^   read_atom_groups ::: leaky$/;"	r
read_covalent_cutoff	roby.foo	/^   read_covalent_cutoff$/;"	r
read_ionic_cutoff	roby.foo	/^   read_ionic_cutoff$/;"	r
read_pi_on_2_cutoff	roby.foo	/^   read_pi_on_2_cutoff$/;"	r
read_zero_cutoff	roby.foo	/^   read_zero_cutoff$/;"	r
read_output_theta_info	roby.foo	/^   read_output_theta_info$/;"	r
read_analyse_all_atom_pairs	roby.foo	/^   read_analyse_all_atom_pairs$/;"	r
read_bond_scale_factor	roby.foo	/^   read_bond_scale_factor$/;"	r
is_homoleptic	roby.foo	/^   is_homoleptic result (res)$/;"	r
skip_pair	roby.foo	/^   skip_pair(a,b) result (res) ::: private$/;"	r
n_bf	roby.foo	/^   n_bf(group) result (res) ::: private$/;"	r
n_bf_a	roby.foo	/^   n_bf_a result (res) ::: private$/;"	r
n_bf_b	roby.foo	/^   n_bf_b result (res) ::: private$/;"	r
n_bf_ab	roby.foo	/^   n_bf_ab result (res) ::: private$/;"	r
n_group	roby.foo	/^   n_group result (res) ::: private$/;"	r
no_of_occupied_ANOs	roby.foo	/^   no_of_occupied_ANOs(group,tol) result (res) ::: private$/;"	r
unique_tags	roby.foo	/^   unique_tags(group) result (res) ::: leaky$/;"	r
atom_populations	roby.foo	/^   atom_populations ::: leaky$/;"	r
group_populations	roby.foo	/^   group_populations ::: leaky$/;"	r
atom_pair_populations	roby.foo	/^   atom_pair_populations ::: leaky$/;"	r
group_pair_populations	roby.foo	/^   group_pair_populations ::: leaky$/;"	r
atom_bond_analysis	roby.foo	/^   atom_bond_analysis ::: leaky$/;"	r
group_bond_analysis	roby.foo	/^   group_bond_analysis ::: leaky$/;"	r
atom_shared_population	roby.foo	/^   atom_shared_population ::: leaky$/;"	r
group_shared_population	roby.foo	/^   group_shared_population ::: leaky$/;"	r
make_single_atom_groups	roby.foo	/^   make_single_atom_groups ::: leaky, private$/;"	r
make_populations	roby.foo	/^   make_populations ::: leaky, private$/;"	r
make_pair_populations	roby.foo	/^   make_pair_populations ::: leaky, private$/;"	r
population	roby.foo	/^   population(group,ANO) result (res) ::: private$/;"	r
subpopulation	roby.foo	/^   subpopulation(subgroup,group,ANO) result (res) ::: private$/;"	r
make_shared_population	roby.foo	/^   make_shared_population ::: leaky, private$/;"	r
shared_population	roby.foo	/^   shared_population(group_list,pop_groups) result (res) ::: private$/;"	r
make_summed_pair_pops	roby.foo	/^   make_summed_pair_pops ::: leaky, private$/;"	r
make_summed_triple_pops	roby.foo	/^   make_summed_triple_pops ::: leaky, private$/;"	r
bond_analysis	roby.foo	/^   bond_analysis ::: leaky, private$/;"	r
gould_bond_index	roby.foo	/^   gould_bond_index(pcc) result (bond_index) ::: leaky, private$/;"	r
make_theta_info	roby.foo	/^   make_theta_info ::: leaky, private$/;"	r
destroy_theta_info	roby.foo	/^   destroy_theta_info ::: leaky, private$/;"	r
match_pair	roby.foo	/^   match_pair(arg1,arg2) result (res) ::: selfless, private$/;"	r
make_theta_populations	roby.foo	/^   make_theta_populations(pop,theta) ::: private$/;"	r
make_theta_atom_populations	roby.foo	/^   make_theta_atom_populations(pop_a,pop_b,theta) ::: private$/;"	r
make_theta_angles	roby.foo	/^   make_theta_angles ::: private$/;"	r
make_gould_covalent_orbitals	roby.foo	/^   make_gould_covalent_orbitals ::: private$/;"	r
make_gould_ionic_orbitals	roby.foo	/^   make_gould_ionic_orbitals ::: private$/;"	r
charge_analysis	roby.foo	/^   charge_analysis ::: leaky, private$/;"	r
make_atom_proportions	roby.foo	/^   make_atom_proportions(rsa,rsb) ::: leaky, private$/;"	r
make_projection_matrix	roby.foo	/^   make_projection_matrix(P,group,ANO) ::: private$/;"	r
make_ANO_matrix	roby.foo	/^   make_ANO_matrix(ANO,group,tol) ::: private$/;"	r
make_shared_operator	roby.foo	/^   make_shared_operator(R) ::: private$/;"	r
make_ionic_operator	roby.foo	/^   make_ionic_operator(I) ::: private$/;"	r
diagonalise_V_AB_operator	roby.foo	/^   diagonalise_V_AB_operator(X,eigenvectors,eigenvalues) ::: private$/;"	r
make_projected_density	roby.foo	/^   make_projected_density(rho,density,ANO) ::: private$/;"	r
expectation	roby.foo	/^   expectation(X,group,rho) result (res) ::: private$/;"	r
project	roby.foo	/^   project(X,P,Y,row_atom,col_atom) ::: private$/;"	r
overlap_transform	roby.foo	/^   overlap_transform(X,Y,row_atom,col_atom) ::: private$/;"	r
right_overlap_transform	roby.foo	/^   right_overlap_transform(X,Y,row_atom,col_atom) ::: private$/;"	r
make_overlap_matrix	roby.foo	/^   make_overlap_matrix(SS,row_atom,col_atom) ::: private$/;"	r
AO_subspace_set	roby.foo	/^   AO_subspace_set(A,B,A_row_atom,A_col_atom,B_row_atom,B_col_atom) ::: private$/;"	r
put	roby.foo	/^   put$/;"	r
put_all_info	roby.foo	/^   put_all_info$/;"	r
put_populations	roby.foo	/^   put_populations$/;"	r
put_pair_populations	roby.foo	/^   put_pair_populations$/;"	r
put_bond_indices	roby.foo	/^   put_bond_indices$/;"	r
put_charges	roby.foo	/^   put_charges$/;"	r
put_dipole_moments	roby.foo	/^   put_dipole_moments$/;"	r
put_unique_tags	roby.foo	/^   put_unique_tags(group,name)$/;"	r
put_theta_info	roby.foo	/^   put_theta_info$/;"	r
put_theta_bond_info	roby.foo	/^   put_theta_bond_info$/;"	r
put_theta_atom_pops	roby.foo	/^   put_theta_atom_pops$/;"	r
put_shared_population	roby.foo	/^   put_shared_population$/;"	r
TONTO_INITIALISE	run_basis.foo	/^   TONTO_INITIALISE$/;"	r
TONTO_SET_STDERR	run_basis.foo	/^   TONTO_SET_STDERR(stdout)$/;"	r
real	run_buffer.foo	/^   real :: REAL$/;"	g
int	run_buffer.foo	/^   int :: INT$/;"	g
TONTO_CREATE	run_buffer.foo	/^   TONTO_CREATE$/;"	r
TONTO_REPORT	run_buffer.foo	/^   TONTO_REPORT$/;"	r
TONTO_DESTROY	run_buffer.foo	/^   TONTO_DESTROY$/;"	r
colour	run_colour.foo	/^   colour :: COLOUR$/;"	g
TONTO_INITIALISE	run_colour.foo	/^   TONTO_INITIALISE$/;"	r
TONTO_SET_STDERR	run_colour.foo	/^   TONTO_SET_STDERR(stdout)$/;"	r
TONTO_REPORT	run_colour.foo	/^   TONTO_REPORT$/;"	r
TONTO_FINALISE	run_colour.foo	/^   TONTO_FINALISE$/;"	r
out	run_cpx.foo	/^   out :: TEXTFILE*$/;"	g
val	run_cpx.foo	/^   val :: CPX$/;"	g
iso_value	run_csq.foo	/^   iso_value :: REAL$/;"	g
csq	run_csq.foo	/^   csq :: CAPPING_SQUARE*$/;"	g
pos	run_csq.foo	/^   pos :: MAT{REAL}(3,4) $/;"	g
values	run_csq.foo	/^   values :: VEC{REAL}(4) $/;"	g
edge_index	run_csq.foo	/^   edge_index :: VEC{INT}(4)$/;"	g
point	run_csq.foo	/^   point :: MAT{REAL}(3,4)$/;"	g
point_gradient	run_csq.foo	/^   point_gradient :: MAT{REAL}(3,4)$/;"	g
cap	run_csq.foo	/^   cap :: MAT{INT}(3,4)$/;"	g
TONTO_CREATE	run_csq.foo	/^   TONTO_CREATE$/;"	r
TONTO_DESTROY	run_csq.foo	/^   TONTO_DESTROY$/;"	r
this	run_file.foo	/^   this :: FILE*$/;"	g
step	run_gaussian2.foo	/^   step :: REAL$/;"	g
TONTO_CREATE	run_gaussian2.foo	/^   TONTO_CREATE$/;"	r
TONTO_SET_STDERR	run_gaussian2.foo	/^   TONTO_SET_STDERR(stdout)$/;"	r
TONTO_REPORT	run_gaussian2.foo	/^   TONTO_REPORT$/;"	r
TONTO_DESTROY	run_gaussian2.foo	/^   TONTO_DESTROY$/;"	r
mat	run_gaussian_data.foo	/^   mat :: VEC{MAT_{REAL}}*$/;"	g
norm	run_gaussian_data.foo	/^   norm :: VEC{REAL}*$/;"	g
fac	run_gaussian_data.foo	/^   fac :: REAL$/;"	g
TONTO_CREATE	run_gaussian_data.foo	/^   TONTO_CREATE$/;"	r
TONTO_REPORT	run_gaussian_data.foo	/^   TONTO_REPORT$/;"	r
TONTO_DESTROY	run_gaussian_data.foo	/^   TONTO_DESTROY$/;"	r
TONTO_CREATE	run_int.foo	/^   TONTO_CREATE$/;"	r
TONTO_REPORT	run_int.foo	/^   TONTO_REPORT$/;"	r
TONTO_DESTROY	run_int.foo	/^   TONTO_DESTROY$/;"	r
axis	run_mat{real}.foo	/^   axis :: VEC{REAL}(3)$/;"	g
angle	run_mat{real}.foo	/^   angle :: REAL$/;"	g
TONTO_CREATE	run_mat{real}.foo	/^   TONTO_CREATE$/;"	r
TONTO_DESTROY	run_mat{real}.foo	/^   TONTO_DESTROY$/;"	r
TONTO_CREATE	run_molecule.foo	/^   TONTO_CREATE$/;"	r
TONTO_REPORT	run_molecule.foo	/^   TONTO_REPORT$/;"	r
TONTO_DESTROY	run_molecule.foo	/^   TONTO_DESTROY$/;"	r
TONTO_CREATE	run_multi_t_adp.foo	/^   TONTO_CREATE$/;"	r
TONTO_REPORT	run_multi_t_adp.foo	/^   TONTO_REPORT$/;"	r
TONTO_DESTROY	run_multi_t_adp.foo	/^   TONTO_DESTROY$/;"	r
cif	run_pdbconvert.foo	/^   cif :: CIF*$/;"	g
atom	run_pdbconvert.foo	/^   atom :: VEC{ATOM}*$/;"	g
crystal	run_pdbconvert.foo	/^   crystal :: CRYSTAL*$/;"	g
pdbfile	run_pdbconvert.foo	/^   pdbfile :: TEXTFILE*$/;"	g
TONTO_CREATE	run_pdbconvert.foo	/^   TONTO_CREATE$/;"	r
nullify	run_pdbconvert.foo	/^   nullify(atom)$/;"	r
nullify	run_pdbconvert.foo	/^   nullify(crystal)$/;"	r
TONTO_REPORT	run_pdbconvert.foo	/^   TONTO_REPORT$/;"	r
TONTO_DESTROY	run_pdbconvert.foo	/^   TONTO_DESTROY$/;"	r
TONTO_CREATE	run_pi.foo	/^   TONTO_CREATE$/;"	r
TONTO_DESTROY	run_pi.foo	/^   TONTO_DESTROY$/;"	r
pg	run_pointgroup.foo	/^   pg :: POINTGROUP$/;"	g
sh	run_shell1.foo	/^   sh :: SHELL1*$/;"	g
s4	run_shell1quartet.foo	/^   s4 :: SHELL1QUARTET*$/;"	g
maxi	run_shell1quartet.foo	/^   maxi :: REAL$/;"	g
TONTO_CREATE	run_shell1quartet.foo	/^   TONTO_CREATE$/;"	r
TONTO_REPORT	run_shell1quartet.foo	/^   TONTO_REPORT$/;"	r
TONTO_DESTROY	run_shell1quartet.foo	/^   TONTO_DESTROY$/;"	r
maxi	run_shell4.foo	/^   maxi :: REAL$/;"	g
TONTO_CREATE	run_shell4.foo	/^   TONTO_CREATE$/;"	r
TONTO_REPORT	run_shell4.foo	/^   TONTO_REPORT$/;"	r
TONTO_DESTROY	run_shell4.foo	/^   TONTO_DESTROY$/;"	r
sh	run_shell.foo	/^   sh :: SHELL*$/;"	g
sg	run_spacegroup.foo	/^   sg :: SPACEGROUP$/;"	g
TONTO_CREATE	run_spacegroup.foo	/^   TONTO_CREATE$/;"	r
TONTO_REPORT	run_spacegroup.foo	/^   TONTO_REPORT$/;"	r
TONTO_DESTROY	run_spacegroup.foo	/^   TONTO_DESTROY$/;"	r
in	run_textfile.foo	/^   in :: TEXTFILE*$/;"	g
TONTO_CREATE	run_textfile.foo	/^   TONTO_CREATE$/;"	r
TONTO_DESTROY	run_textfile.foo	/^   TONTO_DESTROY$/;"	r
directions	run_vec{real}.foo	/^   directions :: MAT{REAL}(2,2)$/;"	g
algorithm	run_vec{real}.foo	/^   algorithm :: STR$/;"	g
sh	run_vec{shell}.foo	/^   sh :: VEC{SHELL}*$/;"	g
sqrt_pie4	rys.foo	/^   sqrt_pie4 :: REAL, parameter, private = 8.862269254527578D-01$/;"	g
r12	rys.foo	/^   r12 :: REAL, parameter, private = 2.75255128608411d-01$/;"	g
r22	rys.foo	/^   r22 :: REAL, parameter, private = 2.72474487139158d+00$/;"	g
r13	rys.foo	/^   r13 :: REAL, parameter, private = 1.90163509193487d-01$/;"	g
r23	rys.foo	/^   r23 :: REAL, parameter, private = 1.78449274854325d+00$/;"	g
r33	rys.foo	/^   r33 :: REAL, parameter, private = 5.52534374226326d+00$/;"	g
w22	rys.foo	/^   w22 :: REAL, parameter, private = 9.17517095361369d-02$/;"	g
w23	rys.foo	/^   w23 :: REAL, parameter, private = 1.77231492083829d-01$/;"	g
w33	rys.foo	/^   w33 :: REAL, parameter, private = 5.11156880411248d-03$/;"	g
r14	rys.foo	/^   r14 :: REAL, parameter, private = 1.45303521503316d-01$/;"	g
r24	rys.foo	/^   r24 :: REAL, parameter, private = 1.33909728812636d+00$/;"	g
r34	rys.foo	/^   r34 :: REAL, parameter, private = 3.92696350135829d+00$/;"	g
r44	rys.foo	/^   r44 :: REAL, parameter, private = 8.58863568901199d+00$/;"	g
w24	rys.foo	/^   w24 :: REAL, parameter, private = 2.34479815323517d-01$/;"	g
w34	rys.foo	/^   w34 :: REAL, parameter, private = 1.92704402415764d-02$/;"	g
w44	rys.foo	/^   w44 :: REAL, parameter, private = 2.25229076750736d-04$/;"	g
r15	rys.foo	/^   r15 :: REAL, parameter, private = 1.17581320211778d-01$/;"	g
r25	rys.foo	/^   r25 :: REAL, parameter, private = 1.07456201243690d+00$/;"	g
r35	rys.foo	/^   r35 :: REAL, parameter, private = 3.08593744371754d+00$/;"	g
r45	rys.foo	/^   r45 :: REAL, parameter, private = 6.41472973366203d+00$/;"	g
r55	rys.foo	/^   r55 :: REAL, parameter, private = 1.18071894899717d+01$/;"	g
w25	rys.foo	/^   w25 :: REAL, parameter, private = 2.70967405960535d-01$/;"	g
w35	rys.foo	/^   w35 :: REAL, parameter, private = 3.82231610015404d-02$/;"	g
w45	rys.foo	/^   w45 :: REAL, parameter, private = 1.51614186862443d-03$/;"	g
w55	rys.foo	/^   w55 :: REAL, parameter, private = 8.62130526143657d-06$/;"	g
create	rys.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	rys.foo	/^   create(n_roots)$/;"	r
destroy	rys.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	rys.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	rys.foo	/^   destroy_ptr_part$/;"	r
created	rys.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	rys.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	rys.foo	/^   create_copy(rys)$/;"	r
copy	rys.foo	/^   copy(rys) ::: leaky$/;"	r
get_weights_and_t2_roots	rys.foo	/^   get_weights_and_t2_roots(X,only_weight)$/;"	r
get_weights_and_u_roots	rys.foo	/^   get_weights_and_u_roots(X,only_weight)$/;"	r
get_only_weight	rys.foo	/^   get_only_weight(x) ::: pure, private$/;"	r
get_weights1	rys.foo	/^   get_weights1(x) ::: pure, private$/;"	r
get_weights1_t2	rys.foo	/^   get_weights1_t2(x) ::: pure, private$/;"	r
get_weights2	rys.foo	/^   get_weights2(x) ::: pure, private$/;"	r
get_weights2_t2	rys.foo	/^   get_weights2_t2(x) ::: pure, private$/;"	r
get_weights3	rys.foo	/^   get_weights3(x) ::: pure, private$/;"	r
get_weights3_t2	rys.foo	/^   get_weights3_t2(x) ::: pure, private$/;"	r
get_weights4	rys.foo	/^   get_weights4(x) ::: pure, private$/;"	r
get_weights5	rys.foo	/^   get_weights5(x) ::: pure, private$/;"	r
get_weights6	rys.foo	/^   get_weights6(x) ::: private$/;"	r
rysfun	rys.foo	/^   rysfun(x,n,ff) ::: pure, private$/;"	r
rysnod	rys.foo	/^   rysnod(a,rt,k) ::: private$/;"	r
ryssmt	rys.foo	/^   ryssmt(c,s,n) ::: private$/;"	r
create	scfdata.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	scfdata.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	scfdata.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	scfdata.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
nullify_ptr_part	scfdata.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	scfdata.foo	/^   destroy_ptr_part ::: leaky$/;"	r
create_copy	scfdata.foo	/^   create_copy(scfdata) ::: leaky$/;"	r
copy	scfdata.foo	/^   copy(scfdata) ::: leaky$/;"	r
set_defaults	scfdata.foo	/^   set_defaults ::: leaky$/;"	r
set_pauli_terms_on	scfdata.foo	/^   set_pauli_terms_on $/;"	r
set_pauli_terms_off	scfdata.foo	/^   set_pauli_terms_off$/;"	r
set_energy	scfdata.foo	/^   set_energy(energy,crystal)$/;"	r
set_penalty	scfdata.foo	/^   set_penalty$/;"	r
reset	scfdata.foo	/^   reset$/;"	r
reset_iteration_count	scfdata.foo	/^   reset_iteration_count$/;"	r
update_lambda	scfdata.foo	/^   update_lambda$/;"	r
update_iteration	scfdata.foo	/^   update_iteration$/;"	r
update_energy	scfdata.foo	/^   update_energy(energy,crystal)$/;"	r
set_1e_sl_factor	scfdata.foo	/^   set_1e_sl_factor(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.sl_1e_factor)$/;"	r
set_2e_sl_factor	scfdata.foo	/^   set_2e_sl_factor(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.sl_2e_factor)$/;"	r
set_atom_overlap_cutoff	scfdata.foo	/^   set_atom_overlap_cutoff(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.atom_overlap_cutoff)$/;"	r
set_delete_scf_archives	scfdata.foo	/^   set_delete_scf_archives(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.delete_scf_archives)$/;"	r
set_cluster_radius	scfdata.foo	/^   set_cluster_radius(val)$/;"	r
set_convergence	scfdata.foo	/^   set_convergence(val)$/;"	r
set_damp_factor	scfdata.foo	/^   set_damp_factor(val)$/;"	r
set_damp_finish	scfdata.foo	/^   set_damp_finish(val) ::: get_from(OBJECT:set, TYPE=>INT, VAL=>.damp_finish)$/;"	r
set_correlation_functional	scfdata.foo	/^   set_correlation_functional(val)$/;"	r
set_exchange_functional	scfdata.foo	/^   set_exchange_functional(val)$/;"	r
set_diis_error	scfdata.foo	/^   set_diis_error(val)$/;"	r
set_diis_error_temp_cutoff	scfdata.foo	/^   set_diis_error_temp_cutoff(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.diis_error_temp_cutoff)$/;"	r
set_eri_bf_overlap_cutoff	scfdata.foo	/^   set_eri_bf_overlap_cutoff(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.eri_bf_overlap_cutoff)$/;"	r
set_eri_disk_cutoff	scfdata.foo	/^   set_eri_disk_cutoff(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.eri_disk_cutoff)$/;"	r
set_eri_J_density_cutoff	scfdata.foo	/^   set_eri_J_density_cutoff(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.eri_J_density_cutoff)$/;"	r
set_eri_K_density_cutoff	scfdata.foo	/^   set_eri_K_density_cutoff(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.eri_K_density_cutoff)$/;"	r
set_eri_primitive_pair_cutoff	scfdata.foo	/^   set_eri_primitive_pair_cutoff(val)$/;"	r
set_eri_schwarz_cutoff	scfdata.foo	/^   set_eri_schwarz_cutoff(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.eri_schwarz_cutoff)$/;"	r
set_guess_output	scfdata.foo	/^   set_guess_output(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.guess_output)$/;"	r
set_initial_density	scfdata.foo	/^   set_initial_density(val)$/;"	r
set_initial_lambda	scfdata.foo	/^   set_initial_lambda(val)$/;"	r
set_initial_MOs	scfdata.foo	/^   set_initial_MOs(val)$/;"	r
set_initial_Us	scfdata.foo	/^   set_initial_Us(val)$/;"	r
set_is_guess	scfdata.foo	/^   set_is_guess(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.is_guess)$/;"	r
set_scf_kind	scfdata.foo	/^   set_scf_kind(val)$/;"	r
set_lambda_max	scfdata.foo	/^   set_lambda_max(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.lambda_max)$/;"	r
set_lambda_step	scfdata.foo	/^   set_lambda_step(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.lambda_step)$/;"	r
set_level_shift	scfdata.foo	/^   set_level_shift(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.level_shift)$/;"	r
set_level_shift_finish	scfdata.foo	/^   set_level_shift_finish(val) ::: get_from(OBJECT:set, TYPE=>INT, VAL=>.level_shift_finish)$/;"	r
set_linear_dependence_shift	scfdata.foo	/^   set_linear_dependence_shift(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.linear_dependence_shift)$/;"	r
set_linear_dependence_tol	scfdata.foo	/^   set_linear_dependence_tol(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.linear_dependence_tol)$/;"	r
set_min_iterations	scfdata.foo	/^   set_min_iterations(val)$/;"	r
set_max_iterations	scfdata.foo	/^   set_max_iterations(val)$/;"	r
set_max_update_stepsize	scfdata.foo	/^   set_max_update_stepsize(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.max_update_stepsize)$/;"	r
set_MO_gradient_stepsize	scfdata.foo	/^   set_MO_gradient_stepsize(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.MO_gradient_stepsize)$/;"	r
set_output	scfdata.foo	/^   set_output(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.output)$/;"	r
set_quantization_axis	scfdata.foo	/^   set_quantization_axis(val) ::: get_from(OBJECT:set, TYPE=>VEC{REAL}(3), VAL=>.quantization_axis)$/;"	r
set_relativity_kind	scfdata.foo	/^   set_relativity_kind(val)$/;"	r
set_save_cluster_charges	scfdata.foo	/^   set_save_cluster_charges(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.save_cluster_charges)$/;"	r
set_stabilize_density	scfdata.foo	/^   set_stabilize_density(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.stabilize_density)$/;"	r
set_test	scfdata.foo	/^   set_test(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.test)$/;"	r
set_using_1e_sl_term	scfdata.foo	/^   set_using_1e_sl_term(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_1e_sl_term)$/;"	r
set_using_1e_srxa_term	scfdata.foo	/^   set_using_1e_srxa_term(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_1e_srxa_term)$/;"	r
set_using_1e_zora_term	scfdata.foo	/^   set_using_1e_zora_term(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_1e_zora_term)$/;"	r
set_using_2e_sl_term	scfdata.foo	/^   set_using_2e_sl_term(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_2e_sl_term)$/;"	r
set_using_aa_term	scfdata.foo	/^   set_using_aa_term(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_aa_term)$/;"	r
set_using_bl_term	scfdata.foo	/^   set_using_bl_term(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_bl_term)$/;"	r
set_using_bs_term	scfdata.foo	/^   set_using_bs_term(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_bs_term)$/;"	r
set_using_bs_t_term	scfdata.foo	/^   set_using_bs_t_term(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_bs_t_term)$/;"	r
set_using_CPHF_diis	scfdata.foo	/^   set_using_CPHF_diis(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_CPHF_diis)$/;"	r
set_using_cluster_charges	scfdata.foo	/^   set_using_cluster_charges(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_cluster_charges)$/;"	r
set_using_damping	scfdata.foo	/^   set_using_damping(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_damping)$/;"	r
set_use_default_guess_options	scfdata.foo	/^   set_use_default_guess_options(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.use_default_guess_options)$/;"	r
set_using_delta_build	scfdata.foo	/^   set_using_delta_build(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_delta_build)$/;"	r
set_using_direct_scf	scfdata.foo	/^   set_using_direct_scf(val)$/;"	r
set_using_DK1	scfdata.foo	/^   set_using_DK1(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.DK1)$/;"	r
set_using_DK2	scfdata.foo	/^   set_using_DK2(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.DK2)$/;"	r
set_using_DK3	scfdata.foo	/^   set_using_DK3(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.DK3)$/;"	r
set_using_DK1_PCE	scfdata.foo	/^   set_using_DK1_PCE(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.DK1_PCE)$/;"	r
set_using_DK2_PCE	scfdata.foo	/^   set_using_DK2_PCE(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.DK2_PCE)$/;"	r
set_using_exponential_update	scfdata.foo	/^   set_using_exponential_update(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_exponential_update)$/;"	r
set_using_fock_diis	scfdata.foo	/^   set_using_fock_diis(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_fock_diis)$/;"	r
set_using_level_shift	scfdata.foo	/^   set_using_level_shift(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_level_shift)$/;"	r
set_using_MO_diis	scfdata.foo	/^   set_using_MO_diis(val)$/;"	r
set_using_MO_gradient_update	scfdata.foo	/^   set_using_MO_gradient_update(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_MO_gradient_update)$/;"	r
set_using_NDDO	scfdata.foo	/^   set_using_NDDO(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_NDDO)$/;"	r
set_using_NUDO	scfdata.foo	/^   set_using_NUDO(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_NUDO)$/;"	r
set_using_orbital_locking	scfdata.foo	/^   set_using_orbital_locking(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_orbital_locking)$/;"	r
set_using_PCE_correction	scfdata.foo	/^   set_using_PCE_correction(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.PCE_CORR)$/;"	r
set_using_PIE	scfdata.foo	/^   set_using_PIE(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_PIE)$/;"	r
set_using_ppzpp_method	scfdata.foo	/^   set_using_ppzpp_method(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_ppzpp)$/;"	r
set_using_previous_diis_info	scfdata.foo	/^   set_using_previous_diis_info(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_previous_diis_info)$/;"	r
set_using_pFON_damping	scfdata.foo	/^   set_using_pFON_damping(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_pFON)$/;"	r
set_using_qq_cluster_charges	scfdata.foo	/^   set_using_qq_cluster_charges(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_qq_cluster_charges)$/;"	r
set_using_SC_cluster_charges	scfdata.foo	/^   set_using_SC_cluster_charges(val)$/;"	r
set_using_SC_Lorentz_fields	scfdata.foo	/^   set_using_SC_Lorentz_fields(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_SC_Lorentz_fields)$/;"	r
set_using_SO_FDFF_method	scfdata.foo	/^   set_using_SO_FDFF_method(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.using_SO_FDFF)$/;"	r
set_XC_atom_separation_cutoff	scfdata.foo	/^   set_XC_atom_separation_cutoff(val)$/;"	r
set_zero_oo_constraint_block	scfdata.foo	/^   set_zero_oo_constraint_block(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.zero_oo_constraint_block)$/;"	r
read_keywords	scfdata.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	scfdata.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
finalize	scfdata.foo	/^   finalize$/;"	r
read_1e_sl_factor	scfdata.foo	/^   read_1e_sl_factor ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_1e_sl_factor), private$/;"	r
read_2e_sl_factor	scfdata.foo	/^   read_2e_sl_factor ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_2e_sl_factor), private$/;"	r
read_atom_overlap_cutoff	scfdata.foo	/^   read_atom_overlap_cutoff ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_atom_overlap_cutoff), private$/;"	r
read_cluster_radius	scfdata.foo	/^   read_cluster_radius ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_cluster_radius), private$/;"	r
read_convergence	scfdata.foo	/^   read_convergence ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_convergence), private$/;"	r
read_damp_factor	scfdata.foo	/^   read_damp_factor ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_damp_factor), private$/;"	r
read_damp_finish	scfdata.foo	/^   read_damp_finish ::: get_from(OBJECT:read_and_set, TYPE=>INT, SET=>.set_damp_finish), private$/;"	r
read_delete_scf_archives	scfdata.foo	/^   read_delete_scf_archives ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_delete_scf_archives), private$/;"	r
read_correlation_functional	scfdata.foo	/^   read_correlation_functional ::: get_from(OBJECT:read_and_set, TYPE=>STR, SET=>.set_correlation_functional), private$/;"	r
read_exchange_functional	scfdata.foo	/^   read_exchange_functional ::: get_from(OBJECT:read_and_set, TYPE=>STR, SET=>.set_exchange_functional), private$/;"	r
read_diis	scfdata.foo	/^   read_diis ::: private$/;"	r
read_diis_error_temp_cutoff	scfdata.foo	/^   read_diis_error_temp_cutoff ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_diis_error_temp_cutoff), private$/;"	r
read_eri_bf_overlap_cutoff	scfdata.foo	/^   read_eri_bf_overlap_cutoff ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_eri_bf_overlap_cutoff), private$/;"	r
read_eri_disk_cutoff	scfdata.foo	/^   read_eri_disk_cutoff ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_eri_disk_cutoff), private$/;"	r
read_eri_J_density_cutoff	scfdata.foo	/^   read_eri_J_density_cutoff ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_eri_J_density_cutoff), private$/;"	r
read_eri_K_density_cutoff	scfdata.foo	/^   read_eri_K_density_cutoff ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_eri_K_density_cutoff), private$/;"	r
read_eri_primitive_pair_cutoff	scfdata.foo	/^   read_eri_primitive_pair_cutoff ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_eri_primitive_pair_cutoff), private$/;"	r
read_eri_schwarz_cutoff	scfdata.foo	/^   read_eri_schwarz_cutoff ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_eri_schwarz_cutoff), private$/;"	r
read_guess_output	scfdata.foo	/^   read_guess_output ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_guess_output), private$/;"	r
read_initial_density	scfdata.foo	/^   read_initial_density ::: get_from(OBJECT:read_and_set, TYPE=>STR, SET=>.set_initial_density), private$/;"	r
read_initial_lambda	scfdata.foo	/^   read_initial_lambda ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_initial_lambda), private$/;"	r
read_initial_MOs	scfdata.foo	/^   read_initial_MOs ::: get_from(OBJECT:read_and_set, TYPE=>STR, SET=>.set_initial_MOs), private$/;"	r
read_initial_Us	scfdata.foo	/^   read_initial_Us ::: get_from(OBJECT:read_and_set, TYPE=>STR, SET=>.set_initial_Us), private$/;"	r
read_lambda_max	scfdata.foo	/^   read_lambda_max ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_lambda_max), private$/;"	r
read_lambda_step	scfdata.foo	/^   read_lambda_step ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_lambda_step), private$/;"	r
read_level_shift	scfdata.foo	/^   read_level_shift ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_level_shift), private$/;"	r
read_level_shift_finish	scfdata.foo	/^   read_level_shift_finish ::: get_from(OBJECT:read_and_set, TYPE=>INT, SET=>.set_level_shift_finish), private$/;"	r
read_linear_dependence_shift	scfdata.foo	/^   read_linear_dependence_shift ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_linear_dependence_shift), private$/;"	r
read_linear_dependence_tol	scfdata.foo	/^   read_linear_dependence_tol ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_linear_dependence_tol), private$/;"	r
read_min_iterations	scfdata.foo	/^   read_min_iterations ::: get_from(OBJECT:read_and_set, TYPE=>INT, SET=>.set_min_iterations), private$/;"	r
read_max_iterations	scfdata.foo	/^   read_max_iterations ::: get_from(OBJECT:read_and_set, TYPE=>INT, SET=>.set_max_iterations), private$/;"	r
read_max_update_stepsize	scfdata.foo	/^   read_max_update_stepsize ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_max_update_stepsize), private$/;"	r
read_MO_gradient_stepsize	scfdata.foo	/^   read_MO_gradient_stepsize ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_MO_gradient_stepsize), private$/;"	r
read_output	scfdata.foo	/^   read_output ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_output), private$/;"	r
read_quantization_axis	scfdata.foo	/^   read_quantization_axis ::: get_from(OBJECT:read_and_set, TYPE=>VEC{REAL}(3), SET=>.set_quantization_axis), private$/;"	r
read_relativity_kind	scfdata.foo	/^   read_relativity_kind ::: get_from(OBJECT:read_and_set, TYPE=>STR, SET=>.set_relativity_kind), private$/;"	r
read_save_cluster_charges	scfdata.foo	/^   read_save_cluster_charges ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_save_cluster_charges), private$/;"	r
read_scf_kind	scfdata.foo	/^   read_scf_kind ::: get_from(OBJECT:read_and_set, TYPE=>STR, SET=>.set_scf_kind), private$/;"	r
read_stabilize_density	scfdata.foo	/^   read_stabilize_density ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_stabilize_density), private$/;"	r
read_test	scfdata.foo	/^   read_test ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_test), private$/;"	r
read_using_1e_sl_term	scfdata.foo	/^   read_using_1e_sl_term ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_1e_sl_term), private$/;"	r
read_using_1e_srxa_term	scfdata.foo	/^   read_using_1e_srxa_term ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_1e_srxa_term), private$/;"	r
read_using_1e_zora_term	scfdata.foo	/^   read_using_1e_zora_term ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_1e_zora_term), private$/;"	r
read_using_2e_sl_term	scfdata.foo	/^   read_using_2e_sl_term ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_2e_sl_term), private$/;"	r
read_using_aa_term	scfdata.foo	/^   read_using_aa_term ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_aa_term), private$/;"	r
read_using_bl_term	scfdata.foo	/^   read_using_bl_term ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_bl_term), private$/;"	r
read_using_bs_term	scfdata.foo	/^   read_using_bs_term ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_bs_term), private$/;"	r
read_using_bs_t_term	scfdata.foo	/^   read_using_bs_t_term ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_bs_t_term), private$/;"	r
read_using_CPHF_diis	scfdata.foo	/^   read_using_CPHF_diis ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_CPHF_diis), private$/;"	r
read_using_cluster_charges	scfdata.foo	/^   read_using_cluster_charges ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_cluster_charges), private$/;"	r
read_using_damping	scfdata.foo	/^   read_using_damping ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_damping), private$/;"	r
read_use_default_guess_options	scfdata.foo	/^   read_use_default_guess_options ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_use_default_guess_options), private$/;"	r
read_using_delta_build	scfdata.foo	/^   read_using_delta_build ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_delta_build), private$/;"	r
read_using_direct_scf	scfdata.foo	/^   read_using_direct_scf ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_direct_scf), private$/;"	r
read_using_DK1	scfdata.foo	/^   read_using_DK1 ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_DK1), private$/;"	r
read_using_DK2	scfdata.foo	/^   read_using_DK2 ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_DK2), private$/;"	r
read_using_DK3	scfdata.foo	/^   read_using_DK3 ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_DK3), private$/;"	r
read_using_DK1_PCE	scfdata.foo	/^   read_using_DK1_PCE ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_DK1_PCE), private$/;"	r
read_using_DK2_PCE	scfdata.foo	/^   read_using_DK2_PCE ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_DK2_PCE), private$/;"	r
read_using_exponential_update	scfdata.foo	/^   read_using_exponential_update ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_exponential_update), private$/;"	r
read_using_fock_diis	scfdata.foo	/^   read_using_fock_diis ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_fock_diis), private$/;"	r
read_using_level_shift	scfdata.foo	/^   read_using_level_shift ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_level_shift), private$/;"	r
read_using_MO_diis	scfdata.foo	/^   read_using_MO_diis ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_MO_diis), private$/;"	r
read_using_MO_gradient_update	scfdata.foo	/^   read_using_MO_gradient_update ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_MO_gradient_update), private$/;"	r
read_using_NDDO	scfdata.foo	/^   read_using_NDDO ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_NDDO), private$/;"	r
read_using_NUDO	scfdata.foo	/^   read_using_NUDO ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_NUDO), private$/;"	r
read_using_orbital_locking	scfdata.foo	/^   read_using_orbital_locking ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_orbital_locking), private$/;"	r
read_using_PCE_correction	scfdata.foo	/^   read_using_PCE_correction ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_PCE_correction), private$/;"	r
read_using_PIE	scfdata.foo	/^   read_using_PIE ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_PIE), private$/;"	r
read_using_ppzpp_method	scfdata.foo	/^   read_using_ppzpp_method ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_ppzpp_method), private$/;"	r
read_using_previous_diis_info	scfdata.foo	/^   read_using_previous_diis_info ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_previous_diis_info), private$/;"	r
read_using_pFON_damping	scfdata.foo	/^   read_using_pFON_damping ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_pFON_damping), private$/;"	r
read_using_qq_cluster_charges	scfdata.foo	/^   read_using_qq_cluster_charges ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_qq_cluster_charges), private$/;"	r
read_using_SC_cluster_charges	scfdata.foo	/^   read_using_SC_cluster_charges ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_SC_cluster_charges), private$/;"	r
read_using_SC_Lorentz_fields	scfdata.foo	/^   read_using_SC_Lorentz_fields ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_SC_Lorentz_fields), private$/;"	r
read_using_SO_FDFF_method	scfdata.foo	/^   read_using_SO_FDFF_method ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_using_SO_fdff_method), private$/;"	r
read_XC_atom_separation_cutoff	scfdata.foo	/^   read_XC_atom_separation_cutoff ::: get_from(OBJECT:read_and_set, TYPE=>REAL, SET=>.set_XC_atom_separation_cutoff), private$/;"	r
read_zero_oo_constraint_block	scfdata.foo	/^   read_zero_oo_constraint_block ::: get_from(OBJECT:read_and_set, TYPE=>BIN, SET=>.set_zero_oo_constraint_block), private$/;"	r
spinorbital_kind	scfdata.foo	/^   spinorbital_kind(scf_kind) result (res)$/;"	r
molecular_orbital_kind	scfdata.foo	/^   molecular_orbital_kind(scf_kind) result (res)$/;"	r
orbital_energy_kind	scfdata.foo	/^   orbital_energy_kind(scf_kind) result (res)$/;"	r
orbital_energies_kind	scfdata.foo	/^   orbital_energies_kind(scf_kind) result (res)$/;"	r
number_kind	scfdata.foo	/^   number_kind result (res)$/;"	r
is_DFT_calculation	scfdata.foo	/^   is_DFT_calculation(scf_kind) result (res)$/;"	r
DFT_functional_name	scfdata.foo	/^   DFT_functional_name result (res)$/;"	r
temperature_for_pFON	scfdata.foo	/^   temperature_for_pFON result (res)$/;"	r
apply_pFON	scfdata.foo	/^   apply_pFON result (res)$/;"	r
scf_done	scfdata.foo	/^   scf_done result (res)$/;"	r
converged	scfdata.foo	/^   converged result (res)$/;"	r
energy_difference_converged	scfdata.foo	/^   energy_difference_converged result (res)$/;"	r
exceeded_max_it	scfdata.foo	/^   exceeded_max_it result (res)$/;"	r
exceeded_min_it	scfdata.foo	/^   exceeded_min_it result (res)$/;"	r
exceeded_lambda_max	scfdata.foo	/^   exceeded_lambda_max result (res)$/;"	r
do_delta_build	scfdata.foo	/^   do_delta_build result (res)$/;"	r
using_GGA_functional	scfdata.foo	/^   using_GGA_functional result (res)$/;"	r
is_constrained_scf	scfdata.foo	/^   is_constrained_scf result (res)$/;"	r
apply_fock_diis	scfdata.foo	/^   apply_fock_diis result (res)$/;"	r
apply_MO_diis	scfdata.foo	/^   apply_MO_diis result (res)$/;"	r
using_diis	scfdata.foo	/^   using_diis result (res)$/;"	r
apply_diis	scfdata.foo	/^   apply_diis result (res)$/;"	r
apply_damping	scfdata.foo	/^   apply_damping result (res)$/;"	r
apply_level_shifting	scfdata.foo	/^   apply_level_shifting result (res)$/;"	r
fitting	scfdata.foo	/^   fitting result (res)$/;"	r
reset_for_next_lambda	scfdata.foo	/^   reset_for_next_lambda(F,S)$/;"	r
put_banner	scfdata.foo	/^   put_banner$/;"	r
put_summary	scfdata.foo	/^   put_summary ::: private$/;"	r
real_width	scfdata.foo	/^     real_width :: BIN$/;"	a
put_table_head	scfdata.foo	/^   put_table_head ::: private$/;"	r
put_results	scfdata.foo	/^   put_results$/;"	r
put_table_foot	scfdata.foo	/^   put_table_foot ::: private$/;"	r
put_crystal_fit_info	scfdata.foo	/^   put_crystal_fit_info$/;"	r
put_constrained_scf_results	scfdata.foo	/^   put_constrained_scf_results(out)$/;"	r
put_cluster	scfdata.foo	/^   put_cluster$/;"	r
put_cluster_charges	scfdata.foo	/^   put_cluster_charges$/;"	r
create	shell1.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	shell1.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	shell1.foo	/^   nullify_ptr_part ::: get_from(SHELL)$/;"	r
destroy_ptr_part	shell1.foo	/^   destroy_ptr_part ::: get_from(SHELL), leaky$/;"	r
created	shell1.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	shell1.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	shell1.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
create_copy	shell1.foo	/^   create_copy(shell,pos) ::: leaky$/;"	r
copy	shell1.foo	/^   copy(shell) ::: get_from(SHELL, SHELL=>SHELL1), leaky$/;"	r
copy	shell1.foo	/^   copy(shell,pos) ::: leaky$/;"	r
copy	shell1.foo	/^   copy(shell) ::: leaky$/;"	r
copy	shell1.foo	/^   copy(shell,pos) ::: leaky$/;"	r
set	shell1.foo	/^   set(object) ::: get_from(OBJECT)$/;"	r
set	shell1.foo	/^   set(shell,pos)$/;"	r
set_defaults	shell1.foo	/^   set_defaults$/;"	r
set_l	shell1.foo	/^   set_l(l) ::: get_from(SHELL, SHELL=>SHELL1)$/;"	r
set_n_comp	shell1.foo	/^   set_n_comp ::: get_from(SHELL, SHELL=>SHELL1)$/;"	r
set_spherical	shell1.foo	/^   set_spherical(val) ::: get_from(SHELL)$/;"	r
read_keywords	shell1.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	shell1.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	shell1.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_l	shell1.foo	/^   read_l ::: get_from(SHELL)$/;"	r
read_l_int	shell1.foo	/^   read_l_int ::: get_from(SHELL)$/;"	r
read_l_chr	shell1.foo	/^   read_l_chr ::: get_from(SHELL)$/;"	r
read_spherical	shell1.foo	/^   read_spherical ::: get_from(SHELL)$/;"	r
read_n_cc	shell1.foo	/^   read_n_cc ::: get_from(SHELL)$/;"	r
read_ex	shell1.foo	/^   read_ex ::: get_from(SHELL), leaky$/;"	r
read_cc	shell1.foo	/^   read_cc ::: get_from(SHELL), leaky$/;"	r
read_ex_cc	shell1.foo	/^   read_ex_cc ::: get_from(SHELL), leaky$/;"	r
read_junk_ex_cc	shell1.foo	/^   read_junk_ex_cc ::: get_from(SHELL), leaky$/;"	r
read_pos	shell1.foo	/^   read_pos$/;"	r
l_chr	shell1.foo	/^   l_chr(l) result (res) ::: get_from(SHELL), selfless, private$/;"	r
same_as	shell1.foo	/^   same_as(sh) result(same)$/;"	r
make_contraction_matrix	shell1.foo	/^   make_contraction_matrix(ccm,ccp) ::: get_from(SHELL)$/;"	r
norm	shell1.foo	/^   norm result (res) ::: get_from(SHELL), pure$/;"	r
unnormalise	shell1.foo	/^   unnormalise ::: get_from(SHELL)$/;"	r
renormalise	shell1.foo	/^   renormalise ::: get_from(SHELL)$/;"	r
n_prim	shell1.foo	/^   n_prim result (res) ::: get_from(SHELL)$/;"	r
put	shell1.foo	/^   put$/;"	r
r_max	shell1.foo	/^   r_max(cutoff) result (res)$/;"	r
r2_max	shell1.foo	/^   r2_max(cutoff) result (res)$/;"	r
make_skip_list	shell1.foo	/^   make_skip_list(skip,n_keep,r2,preskip,n_pt,cutoff) ::: public$/;"	r
make_significant_points	shell1.foo	/^   make_significant_points(x,y,z,r2,skip,pt,cutoff) ::: leaky$/;"	r
make_grid	shell1.foo	/^   make_grid(F,pt)$/;"	r
make_grid	shell1.foo	/^   make_grid(F,x,y,z)$/;"	r
make_grid_c	shell1.foo	/^   make_grid_c(f,x,y,z) ::: private$/;"	r
make_grid	shell1.foo	/^   make_grid(F,x,y,z,r2,cutoff)$/;"	r
make_grid_c	shell1.foo	/^   make_grid_c(F,x,y,z,r2,cutoff) ::: private$/;"	r
make_skip_grid	shell1.foo	/^   make_skip_grid(F,n_keep,n_comp,x,y,z,r2,skip,n_pt) ::: public$/;"	r
make_skip_grid_c	shell1.foo	/^   make_skip_grid_c(F,n_keep,n_comp,x,y,z,r2,skip,n_pt) ::: private$/;"	r
make_skip_nabla_grid	shell1.foo	/^   make_skip_nabla_grid(Gx,Gy,Gz,F0,n_keep,n_comp,x,y,z,r2,skip,n_pt) ::: public$/;"	r
make_skip_nabla_grid_c	shell1.foo	/^   make_skip_nabla_grid_c(Gx,Gy,Gz,F0,n_keep,n_comp,x,y,z,r2,skip,n_pt) ::: private$/;"	r
make_nabla_grid	shell1.foo	/^   make_nabla_grid(G,pt)$/;"	r
make_nabla_grid_c	shell1.foo	/^   make_nabla_grid_c(G,pt) ::: private$/;"	r
make_nabla_grid	shell1.foo	/^   make_nabla_grid(G,x,y,z,r2,cutoff) $/;"	r
make_nabla_grid_c	shell1.foo	/^   make_nabla_grid_c(G,x,y,z,r2,cutoff) ::: private$/;"	r
make_nabla_grid	shell1.foo	/^   make_nabla_grid(G,F,pt) $/;"	r
make_nabla_grid_c	shell1.foo	/^   make_nabla_grid_c(G,F,pt) ::: private$/;"	r
make_nabla_grid	shell1.foo	/^   make_nabla_grid(G,F,x,y,z,r2)$/;"	r
make_nabla_grid_c	shell1.foo	/^   make_nabla_grid_c(G,F,x,y,z,r2) ::: private$/;"	r
make_nabla_grid	shell1.foo	/^   make_nabla_grid(G,F,x,y,z,r2,cutoff)$/;"	r
make_nabla_grid_c	shell1.foo	/^   make_nabla_grid_c(G,F,x,y,z,r2,cutoff) ::: private$/;"	r
make_nabla_grid	shell1.foo	/^   make_nabla_grid(Gx,Gy,Gz,F,pt) $/;"	r
make_nabla_grid_c	shell1.foo	/^   make_nabla_grid_c(Gx,Gy,Gz,F,pt) ::: private$/;"	r
make_nabla_grid	shell1.foo	/^   make_nabla_grid(Gx,Gy,Gz,F,x,y,z,r2)$/;"	r
make_nabla_grid_c	shell1.foo	/^   make_nabla_grid_c(Gx,Gy,Gz,F,x,y,z,r2) ::: private$/;"	r
make_nabla_grid	shell1.foo	/^   make_nabla_grid(Gx,Gy,Gz,F0,skip_all,x,y,z,r2,cutoff)$/;"	r
make_nabla_grid_c	shell1.foo	/^   make_nabla_grid_c(Gx,Gy,Gz,F0,skip_all,x,y,z,r2,cutoff) ::: private$/;"	r
make_nabla_grid	shell1.foo	/^   make_nabla_grid(Gx,Gy,Gz,F,x,y,z,r2,cutoff)$/;"	r
make_nabla_grid_c	shell1.foo	/^   make_nabla_grid_c(Gx,Gy,Gz,F,x,y,z,r2,cutoff) ::: private$/;"	r
make_laplacian_grid	shell1.foo	/^   make_laplacian_grid(G,pt)$/;"	r
make_laplacian_grid_c	shell1.foo	/^   make_laplacian_grid_c(G,pt) ::: private$/;"	r
make_laplacian_grid	shell1.foo	/^   make_laplacian_grid(G,H,I,pt)$/;"	r
make_laplacian_grid_c	shell1.foo	/^   make_laplacian_grid_c(G,H,I,pt) ::: private$/;"	r
make_oscillator_orbital_mask	shell1.foo	/^   make_oscillator_orbital_mask(f,c,l,n,pt)$/;"	r
create	shell1pair.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	shell1pair.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	shell1pair.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	shell1pair.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	shell1pair.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	shell1pair.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	shell1pair.foo	/^   create_copy(ab) ::: leaky$/;"	r
copy	shell1pair.foo	/^   copy(ab) ::: leaky$/;"	r
copy_a	shell1pair.foo	/^   copy_a(shell_a) ::: leaky$/;"	r
copy_b	shell1pair.foo	/^   copy_b(shell_b) ::: leaky$/;"	r
copy_a	shell1pair.foo	/^   copy_a(shell_a) ::: leaky$/;"	r
copy_b	shell1pair.foo	/^   copy_b(shell_b) ::: leaky$/;"	r
unnormalise	shell1pair.foo	/^   unnormalise$/;"	r
make_precalculated_data	shell1pair.foo	/^   make_precalculated_data ::: leaky$/;"	r
pair_cutoff	shell1quartet.foo	/^   pair_cutoff :: REAL, private = SHELL1QUARTET_ERI_PAIR_CUTOFF$/;"	g
create	shell1quartet.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	shell1quartet.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	shell1quartet.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	shell1quartet.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
nullify_ptr_part	shell1quartet.foo	/^   nullify_ptr_part ::: leaky$/;"	r
destroy_ptr_part	shell1quartet.foo	/^   destroy_ptr_part ::: leaky$/;"	r
destroy_ab	shell1quartet.foo	/^   destroy_ab ::: leaky$/;"	r
destroy_cd	shell1quartet.foo	/^   destroy_cd ::: leaky$/;"	r
set_defaults	shell1quartet.foo	/^   set_defaults$/;"	r
set_spherical	shell1quartet.foo	/^   set_spherical(val)$/;"	r
unnormalise	shell1quartet.foo	/^   unnormalise$/;"	r
set_pair_cutoff	shell1quartet.foo	/^   set_pair_cutoff(cutoff)$/;"	r
set_ab_new	shell1quartet.foo	/^   set_ab_new(shellpr,pos_a,pos_b,same_center,skip) ::: leaky$/;"	r
set_cd_new	shell1quartet.foo	/^   set_cd_new(shellpr,pos_c,pos_d,same_center,skip) ::: leaky$/;"	r
make_ERI	shell1quartet.foo	/^   make_ERI(abcd) ::: public$/;"	r
make_ERI_c	shell1quartet.foo	/^   make_ERI_c(abcd)$/;"	r
change_to_spherical	shell1quartet.foo	/^   change_to_spherical(C,S) ::: leaky$/;"	r
make_esfs	shell1quartet.foo	/^   make_esfs(esfs)$/;"	r
make_esfs_general	shell1quartet.foo	/^   make_esfs_general(esfs) ::: private$/;"	r
make_esfs_ss_0000	shell1quartet.foo	/^   make_esfs_ss_0000(v11) ::: private$/;"	r
make_esfs_ss_ssss	shell1quartet.foo	/^   make_esfs_ss_ssss(esfs) ::: private$/;"	r
make_esfs_ps_psss	shell1quartet.foo	/^   make_esfs_ps_psss(esfs) ::: private$/;"	r
make_esfs_sp_ssps	shell1quartet.foo	/^   make_esfs_sp_ssps(esfs) ::: private$/;"	r
make_esfs_pp_psps	shell1quartet.foo	/^   make_esfs_pp_psps(esfs) ::: private$/;"	r
make_esfs_ds_dsss	shell1quartet.foo	/^   make_esfs_ds_dsss(esfs) ::: private$/;"	r
make_esfs_ds_ppss	shell1quartet.foo	/^   make_esfs_ds_ppss(esfs) ::: private$/;"	r
make_esfs_sd_ssds	shell1quartet.foo	/^   make_esfs_sd_ssds(esfs) ::: private$/;"	r
make_esfs_sd_sspp	shell1quartet.foo	/^   make_esfs_sd_sspp(esfs) ::: private$/;"	r
make_esfs_dp_dsps	shell1quartet.foo	/^   make_esfs_dp_dsps(esfs) ::: private$/;"	r
make_esfs_dp_ppps	shell1quartet.foo	/^   make_esfs_dp_ppps(esfs) ::: private$/;"	r
make_esfs_pd_psds	shell1quartet.foo	/^   make_esfs_pd_psds(esfs) ::: private$/;"	r
make_esfs_pd_pspp	shell1quartet.foo	/^   make_esfs_pd_pspp(esfs) ::: private$/;"	r
make_esfs_dd_dsds	shell1quartet.foo	/^   make_esfs_dd_dsds(esfs) ::: private$/;"	r
make_esfs_dd_dspp	shell1quartet.foo	/^   make_esfs_dd_dspp(esfs) ::: private$/;"	r
make_esfs_dd_ppds	shell1quartet.foo	/^   make_esfs_dd_ppds(esfs) ::: private$/;"	r
make_esfs_dd_pppp	shell1quartet.foo	/^   make_esfs_dd_pppp(esfs) ::: private$/;"	r
make_esfs_Xs	shell1quartet.foo	/^   make_esfs_Xs(esfs) ::: private$/;"	r
make_esfs_sX	shell1quartet.foo	/^   make_esfs_sX(esfs) ::: private$/;"	r
make_esfs_Xp	shell1quartet.foo	/^   make_esfs_Xp(esfs) ::: private$/;"	r
make_esfs_pX	shell1quartet.foo	/^   make_esfs_pX(esfs) ::: private$/;"	r
make_esfs_Xd	shell1quartet.foo	/^   make_esfs_Xd(esfs) ::: private$/;"	r
make_esfs_dX	shell1quartet.foo	/^   make_esfs_dX(esfs) ::: private$/;"	r
make_esfs_XX	shell1quartet.foo	/^   make_esfs_XX(esfs) ::: private$/;"	r
form_esfs	shell1quartet.foo	/^   form_esfs(esfs,Ix,Iy,Iz,wt) ::: private$/;"	r
form_esss	shell1quartet.foo	/^   form_esss(esfs,Ix,Iy,Iz,wt,n_sum) ::: private$/;"	r
form_ssfs	shell1quartet.foo	/^   form_ssfs(esfs,Ix,Iy,Iz,wt,n_sum) ::: private$/;"	r
transfer_cd	shell1quartet.foo	/^   transfer_cd(esfs,escd)$/;"	r
transfer_l_c_same	shell1quartet.foo	/^   transfer_l_c_same(esfs,escd) ::: private$/;"	r
transfer_l_d_same	shell1quartet.foo	/^   transfer_l_d_same(esfs,escd) ::: private$/;"	r
transfer_l_c_high	shell1quartet.foo	/^   transfer_l_c_high(esfs,escd) ::: private$/;"	r
transfer_l_d_high	shell1quartet.foo	/^   transfer_l_d_high(esfs,escd) ::: private$/;"	r
transfer_cd_s	shell1quartet.foo	/^   transfer_cd_s(esfs,escd)$/;"	r
transfer_l_c_same_s	shell1quartet.foo	/^   transfer_l_c_same_s(esfs,escd) ::: private$/;"	r
transfer_l_d_same_s	shell1quartet.foo	/^   transfer_l_d_same_s(esfs,escd) ::: private$/;"	r
transfer_l_c_high_s	shell1quartet.foo	/^   transfer_l_c_high_s(esfs,escd) ::: private$/;"	r
transfer_l_d_high_s	shell1quartet.foo	/^   transfer_l_d_high_s(esfs,escd) ::: private$/;"	r
transfer_cd_s_add	shell1quartet.foo	/^   transfer_cd_s_add(esfs,escd)$/;"	r
transfer_l_c_same_s_add	shell1quartet.foo	/^   transfer_l_c_same_s_add(esfs,escd) ::: private$/;"	r
transfer_l_d_same_s_add	shell1quartet.foo	/^   transfer_l_d_same_s_add(esfs,escd) ::: private$/;"	r
transfer_l_c_high_s_add	shell1quartet.foo	/^   transfer_l_c_high_s_add(esfs,escd) ::: private$/;"	r
transfer_l_d_high_s_add	shell1quartet.foo	/^   transfer_l_d_high_s_add(esfs,escd) ::: private$/;"	r
transfer_ab	shell1quartet.foo	/^   transfer_ab(escd,abcd)$/;"	r
transfer_l_a_same	shell1quartet.foo	/^   transfer_l_a_same(escd,abcd) ::: private$/;"	r
transfer_l_b_same	shell1quartet.foo	/^   transfer_l_b_same(escd,abcd) ::: private$/;"	r
transfer_l_a_high	shell1quartet.foo	/^   transfer_l_a_high(escd,abcd) ::: private$/;"	r
transfer_l_b_high	shell1quartet.foo	/^   transfer_l_b_high(escd,abcd) ::: private$/;"	r
transfer_ab_s	shell1quartet.foo	/^   transfer_ab_s(escd,abcd)$/;"	r
transfer_l_a_same_s	shell1quartet.foo	/^   transfer_l_a_same_s(escd,abcd) ::: private$/;"	r
transfer_l_b_same_s	shell1quartet.foo	/^   transfer_l_b_same_s(escd,abcd) ::: private$/;"	r
transfer_l_a_high_s	shell1quartet.foo	/^   transfer_l_a_high_s(escd,abcd) ::: private$/;"	r
transfer_l_b_high_s	shell1quartet.foo	/^   transfer_l_b_high_s(escd,abcd) ::: private$/;"	r
transfer_ab_s_add	shell1quartet.foo	/^   transfer_ab_s_add(escd,abcd)$/;"	r
transfer_l_a_same_s_add	shell1quartet.foo	/^   transfer_l_a_same_s_add(escd,abcd) ::: private$/;"	r
transfer_l_b_same_s_add	shell1quartet.foo	/^   transfer_l_b_same_s_add(escd,abcd) ::: private$/;"	r
transfer_l_a_high_s_add	shell1quartet.foo	/^   transfer_l_a_high_s_add(escd,abcd) ::: private$/;"	r
transfer_l_b_high_s_add	shell1quartet.foo	/^   transfer_l_b_high_s_add(escd,abcd) ::: private$/;"	r
make_r_J	shell1quartet.foo	/^   make_r_J(J,Pab,Pcd,factor,fa,la,fb,lb,fc,lc,fd,ld)$/;"	r
make_r_J_engine	shell1quartet.foo	/^   make_r_J_engine(Jab,Jcd,Pab,Pcd,factor,same)$/;"	r
make_r_JK_engine	shell1quartet.foo	/^   make_r_JK_engine(Jab,Jcd,Pab,Pcd,K,P,skip_J,skip_K,same,factor,fa,la,fb,lb,fc,lc,fd,ld)$/;"	r
make_r_JK_engine	shell1quartet.foo	/^   make_r_JK_engine(JAab,JBab,JAcd,JBcd,PAab,PBab,PAcd,PBcd,Ka,Kb,Pa,Pb,skip_J,skip_K,same,factor,fa,la,fb,lb,fc,lc,fd,ld)$/;"	r
put	shell1quartet.foo	/^   put$/;"	r
pair_cutoff	shell2.foo	/^   pair_cutoff :: REAL, private = SHELL2_PAIR_CUTOFF$/;"	g
create	shell2.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	shell2.foo	/^   create(shell_a,shell_b) ::: leaky$/;"	r
create	shell2.foo	/^   create(shell_a,shell_b,pos_a,pos_b) ::: leaky$/;"	r
create	shell2.foo	/^   create(shell_a,shell_b,pos_a,pos_b) ::: leaky$/;"	r
destroy	shell2.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	shell2.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	shell2.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	shell2.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	shell2.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	shell2.foo	/^   create_copy(shell) ::: leaky$/;"	r
copy	shell2.foo	/^   copy(shell) ::: leaky$/;"	r
copy	shell2.foo	/^   copy(shell_a,shell_b) ::: leaky$/;"	r
copy	shell2.foo	/^   copy(shell_a,shell_b,pos_a,pos_b) ::: leaky$/;"	r
copy	shell2.foo	/^   copy(shell_a,shell_b,pos_a,pos_b) ::: leaky$/;"	r
set_spherical	shell2.foo	/^   set_spherical(val)$/;"	r
set_pair_cutoff	shell2.foo	/^   set_pair_cutoff(cutoff)$/;"	r
set_and_precompute_from	shell2.foo	/^   set_and_precompute_from(shellpr,pos_a,pos_b,same_center,skip) ::: leaky$/;"	r
precalculate	shell2.foo	/^   precalculate ::: leaky$/;"	r
skip_ft	shell2.foo	/^   skip_ft(cutoff) result (res)$/;"	r
skip_ft	shell2.foo	/^   skip_ft(Pmax,cutoff) result (res)$/;"	r
make_ft	shell2.foo	/^   make_ft(res,k_pts)$/;"	r
make_ft_old	shell2.foo	/^   make_ft_old(res,k_pts)$/;"	r
make_ft_v1	shell2.foo	/^   make_ft_v1(res,k_pts)$/;"	r
make_ft	shell2.foo	/^   make_ft(res,k_pts,thermal,partition)$/;"	r
make_ft_old	shell2.foo	/^   make_ft_old(res,k_pts,thermal,partition)$/;"	r
make_ft_old2	shell2.foo	/^   make_ft_old2(res,k_pts,thermal,partition)$/;"	r
make_ft_v0	shell2.foo	/^   make_ft_v0(res,k_pts,thermal,partition)$/;"	r
make_ft_v1	shell2.foo	/^   make_ft_v1(res,k_pts,thermal,partition)$/;"	r
make_ft_v2	shell2.foo	/^   make_ft_v2(res,k_pts,thermal,partition)$/;"	r
make_ft_v3	shell2.foo	/^   make_ft_v3(res,k_pts,thermal,partition)$/;"	r
make_ft_rms_v1	shell2.foo	/^   make_ft_rms_v1(es,Ix,Iy,Iz,wt) $/;"	r
make_ft_rms_v2	shell2.foo	/^   make_ft_rms_v2(es,Ix,Iy,Iz,wt) $/;"	r
make_ft_es	shell2.foo	/^   make_ft_es(es,R,ex_a,ex_b,g1,g2,k_pts,k_max)$/;"	r
make_ft_es	shell2.foo	/^   make_ft_es(es,R,ex_a,ex_b,g1,g2,k_pts,k_max,prefac)$/;"	r
make_e_coeff_es	shell2.foo	/^   make_e_coeff_es(e,R,ex_a,ex_b,g1,g2) $/;"	r
make_ft_component	shell2.foo	/^   make_ft_component(res,R,ex_a,ex_b,g1,g2,k_pts,k_max)$/;"	r
make_e_coeff	shell2.foo	/^   make_e_coeff(e,R,ex_a,ex_b,g1,g2) $/;"	r
make_gaussian_partition	shell2.foo	/^   make_gaussian_partition(res,factor_a,factor_b)$/;"	r
make_tanaka_thermal_smearing	shell2.foo	/^   make_tanaka_thermal_smearing(res,k_pts,Ua,Ub)$/;"	r
make_ft_nabla	shell2.foo	/^   make_ft_nabla(res,k_pts)$/;"	r
make_ft_nabla	shell2.foo	/^   make_ft_nabla(res,k_pts,thermal,partition)$/;"	r
make_ft_r	shell2.foo	/^   make_ft_r(res,k_pts)$/;"	r
make_spherically_averaged_ft	shell2.foo	/^   make_spherically_averaged_ft(res,k_values)$/;"	r
make_z_circularly_averaged_ft	shell2.foo	/^   make_z_circularly_averaged_ft(res,k_values,n_theta)$/;"	r
make_generic_ints	shell2.foo	/^   make_generic_ints(I) ::: template$/;"	r
make_overlap_ints	shell2.foo	/^   make_overlap_ints(I) ::: get_from(SHELL2:make_generic_ints, make_ints_c=>make_overlap_ints_c)$/;"	r
make_overlap_ints_c	shell2.foo	/^   make_overlap_ints_c(S)$/;"	r
make_weighted_overlap_ints	shell2.foo	/^   make_weighted_overlap_ints(Sa,Sb,fab)$/;"	r
make_oscillator_overlap_ints	shell2.foo	/^   make_oscillator_overlap_ints(S,c,d,lc_min,lc_max,ld_min,ld_max)$/;"	r
make_S_1st_deriv_ints	shell2.foo	/^   make_S_1st_deriv_ints(Ax,Ay,Az)$/;"	r
make_T_1st_deriv_ints	shell2.foo	/^   make_T_1st_deriv_ints(Ax,Ay,Az)$/;"	r
make_NA_1st_deriv_ints	shell2.foo	/^   make_NA_1st_deriv_ints(Ax,Ay,Az,Bx,By,Bz,c)$/;"	r
make_dipole_ints	shell2.foo	/^   make_dipole_ints(Dx,Dy,Dz,origin)$/;"	r
make_weighted_dipole_ints	shell2.foo	/^   make_weighted_dipole_ints(Ax,Ay,Az,Bx,By,Bz)$/;"	r
make_quadrupole_ints	shell2.foo	/^   make_quadrupole_ints(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz,origin)$/;"	r
make_octupole_ints	shell2.foo	/^   make_octupole_ints(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz,origin)$/;"	r
make_nuclear_attraction_ints	shell2.foo	/^   make_nuclear_attraction_ints(N,c)$/;"	r
make_E_field_ints	shell2.foo	/^   make_E_field_ints(Ex,Ey,Ez,p)$/;"	r
make_E_gradient_ints	shell2.foo	/^   make_E_gradient_ints(Exx,Eyy,Ezz,Exy,Exz,Eyz,c)$/;"	r
make_spin_orbit_ints	shell2.foo	/^   make_spin_orbit_ints(Lx,Ly,Lz,c)$/;"	r
make_spin_orbit_B_ints	shell2.foo	/^   make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,c,origin)$/;"	r
make_L_ints	shell2.foo	/^   make_L_ints(Lx,Ly,Lz,origin)$/;"	r
make_solenoidal_jp_ints	shell2.foo	/^   make_solenoidal_jp_ints(Jx,Jy,Jz,c)$/;"	r
make_irrotational_jp_ints	shell2.foo	/^   make_irrotational_jp_ints(Jx,Jy,Jz,c)$/;"	r
make_magnetic_jp_ints	shell2.foo	/^   make_magnetic_jp_ints(Jx,Jy,Jz,c)$/;"	r
make_magnetic_S_ints	shell2.foo	/^   make_magnetic_S_ints(Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz,c)$/;"	r
make_magnetic_S_ints	shell2.foo	/^   make_magnetic_S_ints(M,c)$/;"	r
make_overlap	shell2.foo	/^   make_overlap(I) ::: get_from(SHELL2:make_generic_ints, make_ints_c=>make_overlap_c)$/;"	r
make_overlap_c	shell2.foo	/^   make_overlap_c(ab)$/;"	r
make_overlap_es	shell2.foo	/^   make_overlap_es(es) ::: private$/;"	r
form_overlap_es	shell2.foo	/^   form_overlap_es(es,ea,eb,r2ab,i) ::: private$/;"	r
get_kei	shell2.foo	/^   get_kei(kei)$/;"	r
get_kei	shell2.foo	/^   get_kei(kei,overlap)$/;"	r
make_kei_c	shell2.foo	/^   make_kei_c(kei,overlap)$/;"	r
form_overlap_mat_a	shell2.foo	/^   form_overlap_mat_a(kei,overlap,PA,PB,zinv2,zeta,ea,eb,r2ab) ::: private$/;"	r
form_overlap_mat_b	shell2.foo	/^   form_overlap_mat_b(kei,overlap,PA,PB,zinv2,zeta,ea,eb,r2ab) ::: private$/;"	r
get_nuc	shell2.foo	/^   get_nuc(ab,mass_c,pos_c)$/;"	r
get_nuc_c	shell2.foo	/^   get_nuc_c(ab,mass_c,pos_c)$/;"	r
make_nuc_es	shell2.foo	/^   make_nuc_es(es,mass_c,pos_c) ::: private$/;"	r
combine_nuc_2d_ints	shell2.foo	/^   combine_nuc_2d_ints(es,Ix,Iy,Iz,wt) ::: private$/;"	r
make_nuc_dp	shell2.foo	/^   make_nuc_dp(dp,mass_c,pos_c) ::: private$/;"	r
make_nuc_ds	shell2.foo	/^   make_nuc_ds(ds,mass_c,pos_c) ::: private$/;"	r
make_nuc_pp	shell2.foo	/^   make_nuc_pp(pp,mass_c,pos_c) ::: private$/;"	r
make_nuc_ps	shell2.foo	/^   make_nuc_ps(ps,mass_c,pos_c) ::: private$/;"	r
make_nuc_ss	shell2.foo	/^   make_nuc_ss(es,mass_c,pos_c) ::: private$/;"	r
transfer	shell2.foo	/^   transfer(es,ab)$/;"	r
transfer_l_a_same	shell2.foo	/^   transfer_l_a_same(es,ab) ::: private$/;"	r
transfer_l_b_same	shell2.foo	/^   transfer_l_b_same(es,ab) ::: private$/;"	r
transfer_l_a_high	shell2.foo	/^   transfer_l_a_high(es,ab) ::: private$/;"	r
transfer_l_b_high	shell2.foo	/^   transfer_l_b_high(es,ab) ::: private$/;"	r
transfer_ft	shell2.foo	/^   transfer_ft(es,ab)$/;"	r
transfer_l_a_same_ft	shell2.foo	/^   transfer_l_a_same_ft(es,ab) ::: private$/;"	r
transfer_l_b_same_ft	shell2.foo	/^   transfer_l_b_same_ft(es,ab) ::: private$/;"	r
transfer_l_a_high_ft	shell2.foo	/^   transfer_l_a_high_ft(es,ab) ::: private$/;"	r
transfer_l_b_high_ft	shell2.foo	/^   transfer_l_b_high_ft(es,ab) ::: private$/;"	r
change_to_spherical	shell2.foo	/^   change_to_spherical(C,S)$/;"	r
change_to_spherical	shell2.foo	/^   change_to_spherical(C,S)$/;"	r
change_to_spherical	shell2.foo	/^   change_to_spherical(C,S)$/;"	r
put	shell2.foo	/^   put$/;"	r
create	shell4.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
create	shell4.foo	/^   create(shell_a,shell_b,shell_c,shell_d) ::: leaky$/;"	r
create	shell4.foo	/^   create(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) ::: leaky$/;"	r
destroy	shell4.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	shell4.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	shell4.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
nullify_ptr_part	shell4.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	shell4.foo	/^   destroy_ptr_part ::: leaky$/;"	r
destroy_ab	shell4.foo	/^   destroy_ab ::: leaky$/;"	r
destroy_cd	shell4.foo	/^   destroy_cd ::: leaky$/;"	r
create_copy	shell4.foo	/^   create_copy(shell) ::: leaky$/;"	r
copy	shell4.foo	/^   copy(shell) ::: leaky$/;"	r
copy	shell4.foo	/^   copy(shell_a,shell_b,shell_c,shell_d) ::: leaky$/;"	r
copy	shell4.foo	/^   copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) ::: leaky$/;"	r
copy_ab	shell4.foo	/^   copy_ab(shell_a,shell_b,pos_a,pos_b) ::: leaky$/;"	r
copy_cd	shell4.foo	/^   copy_cd(shell_c,shell_d,pos_c,pos_d) ::: leaky$/;"	r
set_spherical	shell4.foo	/^   set_spherical(val)$/;"	r
unnormalise	shell4.foo	/^   unnormalise$/;"	r
ab_kappa_max	shell4.foo	/^   ab_kappa_max result (res) ::: pure$/;"	r
cd_kappa_max	shell4.foo	/^   cd_kappa_max result (res) ::: pure$/;"	r
skip_ERI	shell4.foo	/^   skip_ERI result (res) ::: pure$/;"	r
skip_ERI	shell4.foo	/^   skip_ERI(cutoff) result (res) ::: pure$/;"	r
make_ERI_ints	shell4.foo	/^   make_ERI_ints(I)$/;"	r
make_spin_orbit_ints	shell4.foo	/^   make_spin_orbit_ints(S,O)$/;"	r
make_spin_orbit_ints	shell4.foo	/^   make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)$/;"	r
make_spin_spin_dipole_ints	shell4.foo	/^   make_spin_spin_dipole_ints(Dxx,Dyy,Dzz,Dxy,Dxz,Dyz)$/;"	r
make_ERI_derivatives	shell4.foo	/^   make_ERI_derivatives(AA,BB,CC,DD)$/;"	r
get_ERI	shell4.foo	/^   get_ERI(abcd)$/;"	r
make_esfs	shell4.foo	/^   make_esfs(esfs) ::: private$/;"	r
form_3d_ints	shell4.foo	/^   form_3d_ints(Ix,Iy,Iz,esfs,eub,fub,n_sum) ::: private$/;"	r
form_3d_ints_rm	shell4.foo	/^   form_3d_ints_rm(Ix,Iy,Iz,esfs,eub,fub,n_sum) ::: private$/;"	r
form_3d_ints_no_rm	shell4.foo	/^   form_3d_ints_no_rm(Ix,Iy,Iz,esfs,eub,fub) ::: private$/;"	r
transfer_cd	shell4.foo	/^   transfer_cd(esfs,escd)$/;"	r
transfer_ab	shell4.foo	/^   transfer_ab(escd,abcd)$/;"	r
transfer_ab	shell4.foo	/^   transfer_ab(escd,abcd)$/;"	r
transfer_l_c_highest	shell4.foo	/^   transfer_l_c_highest(esfs,escd) ::: private$/;"	r
transfer_l_d_highest	shell4.foo	/^   transfer_l_d_highest(esfs,escd) ::: private$/;"	r
transfer_l_a_highest	shell4.foo	/^   transfer_l_a_highest(escd,abcd) ::: private$/;"	r
transfer_l_b_highest	shell4.foo	/^   transfer_l_b_highest(escd,abcd) ::: private$/;"	r
transfer_l_a_highest	shell4.foo	/^   transfer_l_a_highest(escd,abcd) ::: private$/;"	r
transfer_l_b_highest	shell4.foo	/^   transfer_l_b_highest(escd,abcd) ::: private$/;"	r
add_to_component	shell4.foo	/^   add_to_component(x,y,z,j) ::: private, always_pure$/;"	r
subtract_from_component	shell4.foo	/^   subtract_from_component(x,y,z,j) ::: private, always_pure$/;"	r
make_r_JK	shell4.foo	/^   make_r_JK(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)$/;"	r
make_r_J	shell4.foo	/^   make_r_J(J,P,factor,fa,la,fb,lb,fc,lc,fd,ld)$/;"	r
put	shell4.foo	/^   put$/;"	r
keys	shell.foo	/^   keys :: VEC{STR}*, private DEFAULT_NULL$/;"	g
create	shell.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	shell.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	shell.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	shell.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	shell.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	shell.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	shell.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	shell.foo	/^   copy(shell) ::: leaky$/;"	r
set	shell.foo	/^   set(object) ::: get_from(OBJECT)$/;"	r
set_defaults	shell.foo	/^   set_defaults$/;"	r
set_l	shell.foo	/^   set_l(l) ::: template$/;"	r
set_l	shell.foo	/^   set_l(l) ::: get_from(SHELL)$/;"	r
set_n_comp	shell.foo	/^   set_n_comp ::: template$/;"	r
set_n_comp	shell.foo	/^   set_n_comp ::: get_from(SHELL)$/;"	r
set_spherical	shell.foo	/^   set_spherical(val) ::: template$/;"	r
set_spherical	shell.foo	/^   set_spherical(val) ::: get_from(SHELL)$/;"	r
read_keywords	shell.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	shell.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	shell.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_l	shell.foo	/^   read_l$/;"	r
read_l_int	shell.foo	/^   read_l_int$/;"	r
read_l_chr	shell.foo	/^   read_l_chr$/;"	r
read_spherical	shell.foo	/^   read_spherical$/;"	r
read_n_cc	shell.foo	/^   read_n_cc$/;"	r
read_ex	shell.foo	/^   read_ex ::: leaky$/;"	r
read_cc	shell.foo	/^   read_cc ::: leaky$/;"	r
read_ex_cc	shell.foo	/^   read_ex_cc ::: leaky$/;"	r
read_junk_ex_cc	shell.foo	/^   read_junk_ex_cc ::: leaky$/;"	r
read_keys	shell.foo	/^   read_keys ::: get_from(OBJECT)$/;"	r
process_keys	shell.foo	/^   process_keys ::: get_from(OBJECT), leaky$/;"	r
keys_created	shell.foo	/^   keys_created result (res) ::: get_from(OBJECT)$/;"	r
set_keys	shell.foo	/^   set_keys(the_keys) ::: get_from(OBJECT)$/;"	r
clear_keys	shell.foo	/^   clear_keys ::: get_from(OBJECT)$/;"	r
put_table_footer	shell.foo	/^   put_table_footer ::: get_from(OBJECT)$/;"	r
put_table_header	shell.foo	/^   put_table_header$/;"	r
table_width	shell.foo	/^   table_width result (res)$/;"	r
l_chr	shell.foo	/^   l_chr(l) result (res) ::: selfless, private$/;"	r
same_as	shell.foo	/^   same_as(sh) result(same)$/;"	r
make_contraction_matrix	shell.foo	/^   make_contraction_matrix(ccm,ccp)$/;"	r
make_normalised_contraction_mx	shell.foo	/^   make_normalised_contraction_mx(ccm,ccp,sph)$/;"	r
make_normalised_contraction_mx	shell.foo	/^   make_normalised_contraction_mx(ccm,sph)$/;"	r
norm	shell.foo	/^   norm result (res) ::: pure$/;"	r
unnormalise	shell.foo	/^   unnormalise$/;"	r
renormalise	shell.foo	/^   renormalise$/;"	r
n_prim	shell.foo	/^   n_prim result (res) ::: pure$/;"	r
n_sph_prim	shell.foo	/^   n_sph_prim result (res) ::: pure$/;"	r
r_max	shell.foo	/^   r_max(cutoff) result (res)$/;"	r
r2_max	shell.foo	/^   r2_max(cutoff) result (res)$/;"	r
put	shell.foo	/^   put$/;"	r
keys	slaterbasis.foo	/^   keys :: VEC{STR}*, private DEFAULT_NULL$/;"	g
create	slaterbasis.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	slaterbasis.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	slaterbasis.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	slaterbasis.foo	/^   destroy_ptr_part  ::: leaky$/;"	r
created	slaterbasis.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	slaterbasis.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	slaterbasis.foo	/^   create_copy(b) ::: leaky$/;"	r
copy	slaterbasis.foo	/^   copy(b) ::: leaky$/;"	r
set_defaults	slaterbasis.foo	/^   set_defaults$/;"	r
update	slaterbasis.foo	/^   update ::: get_from(BASIS)$/;"	r
set_label	slaterbasis.foo	/^   set_label(label)$/;"	r
resolve_by_label	slaterbasis.foo	/^   resolve_by_label(label,basis,clobber,minlab,found) ::: get_from(BASIS, BASIS=>SLATERBASIS)$/;"	r
read_keywords	slaterbasis.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	slaterbasis.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	slaterbasis.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_label	slaterbasis.foo	/^   read_label ::: get_from(BASIS)$/;"	r
read_shell	slaterbasis.foo	/^   read_shell ::: get_from(BASIS), leaky$/;"	r
read_configuration	slaterbasis.foo	/^   read_configuration$/;"	r
read_interpolator	slaterbasis.foo	/^   read_interpolator ::: leaky$/;"	r
read_tonto_style	slaterbasis.foo	/^   read_tonto_style ::: leaky$/;"	r
analyse_configuration	slaterbasis.foo	/^   analyse_configuration $/;"	r
read_keys	slaterbasis.foo	/^   read_keys ::: get_from(OBJECT)$/;"	r
process_keys	slaterbasis.foo	/^   process_keys ::: get_from(OBJECT), leaky$/;"	r
keys_created	slaterbasis.foo	/^   keys_created result (res) ::: get_from(OBJECT)$/;"	r
set_keys	slaterbasis.foo	/^   set_keys(the_keys) ::: get_from(OBJECT)$/;"	r
clear_keys	slaterbasis.foo	/^   clear_keys ::: get_from(OBJECT)$/;"	r
put_table_footer	slaterbasis.foo	/^   put_table_footer ::: get_from(OBJECT)$/;"	r
put_table_header	slaterbasis.foo	/^   put_table_header$/;"	r
table_width	slaterbasis.foo	/^   table_width result (res)$/;"	r
is_resolved	slaterbasis.foo	/^   is_resolved result (res) ::: get_from(BASIS), pure$/;"	r
is_created_and_resolved	slaterbasis.foo	/^   is_created_and_resolved result (res) ::: get_from(BASIS)$/;"	r
is_created_and_has_label	slaterbasis.foo	/^   is_created_and_has_label result (res) ::: get_from(BASIS)$/;"	r
same_as	slaterbasis.foo	/^   same_as(b) result (res) ::: get_from(BASIS)$/;"	r
max_n_orb	slaterbasis.foo	/^   max_n_orb result (res) $/;"	r
no_of_shells	slaterbasis.foo	/^   no_of_shells result (res) ::: get_from(BASIS), pure$/;"	r
no_of_basis_functions	slaterbasis.foo	/^   no_of_basis_functions result (res) ::: get_from(BASIS), pure$/;"	r
no_of_primitives	slaterbasis.foo	/^   no_of_primitives result (res) ::: get_from(BASIS), pure$/;"	r
min_exponent	slaterbasis.foo	/^   min_exponent result (res) ::: get_from(BASIS), pure$/;"	r
shell_kinds_created	slaterbasis.foo	/^   shell_kinds_created result (res) $/;"	r
put	slaterbasis.foo	/^   put$/;"	r
make_density_grid	slaterbasis.foo	/^   make_density_grid(density_grid,pt,pos,occ)$/;"	r
add_density_grid	slaterbasis.foo	/^   add_density_grid(density_grid,pt,pos,occ)$/;"	r
make_normal_density_grid	slaterbasis.foo	/^   make_normal_density_grid(density_grid,pt,pos,occ)$/;"	r
add_normal_density_grid	slaterbasis.foo	/^   add_normal_density_grid(density_grid,pt,pos,occ)$/;"	r
make_interpolated_density	slaterbasis.foo	/^   make_interpolated_density(density,pt,pos,occ)$/;"	r
add_interpolated_density	slaterbasis.foo	/^   add_interpolated_density(density,pt,pos,occ)$/;"	r
density_at_radius	slaterbasis.foo	/^   density_at_radius(R) result (res)$/;"	r
make_interpolator	slaterbasis.foo	/^   make_interpolator(interpolator) ::: leaky$/;"	r
interpolator_table_length	slaterbasis.foo	/^   interpolator_table_length(tol) result (length)$/;"	r
unnormalise	slaterbasis.foo	/^   unnormalise$/;"	r
renormalise	slaterbasis.foo	/^   renormalise$/;"	r
keys	slatershell.foo	/^   keys :: VEC{STR}*, private DEFAULT_NULL$/;"	g
create	slatershell.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	slatershell.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	slatershell.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	slatershell.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	slatershell.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	slatershell.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	slatershell.foo	/^   set_defaults$/;"	r
copy	slatershell.foo	/^   copy(c) ::: leaky$/;"	r
set_l	slatershell.foo	/^   set_l(l)$/;"	r
set_n_comp	slatershell.foo	/^   set_n_comp$/;"	r
read_keywords	slatershell.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	slatershell.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_units	slatershell.foo	/^   read_units ::: get_from(OBJECT), selfless, private$/;"	r
read_junk	slatershell.foo	/^   read_junk ::: get_from(OBJECT), selfless, private$/;"	r
read_l	slatershell.foo	/^   read_l ::: get_from(SHELL)$/;"	r
read_l_int	slatershell.foo	/^   read_l_int ::: get_from(SHELL)$/;"	r
read_l_chr	slatershell.foo	/^   read_l_chr ::: get_from(SHELL), private$/;"	r
read_n_prim	slatershell.foo	/^   read_n_prim $/;"	r
read_n_orb	slatershell.foo	/^   read_n_orb$/;"	r
read_n	slatershell.foo	/^   read_n ::: leaky$/;"	r
read_c	slatershell.foo	/^   read_c ::: leaky$/;"	r
read_z	slatershell.foo	/^   read_z ::: leaky$/;"	r
read_orb_kinds	slatershell.foo	/^   read_orb_kinds ::: leaky$/;"	r
read_occupancy	slatershell.foo	/^   read_occupancy ::: leaky$/;"	r
read_l_orb_kinds_n_z_c_ptr	slatershell.foo	/^   read_l_orb_kinds_n_z_c_ptr ::: leaky$/;"	r
read_n_z_c_ptr	slatershell.foo	/^   read_n_z_c_ptr ::: leaky$/;"	r
read_keys	slatershell.foo	/^   read_keys ::: get_from(OBJECT)$/;"	r
process_keys	slatershell.foo	/^   process_keys ::: get_from(OBJECT), leaky$/;"	r
keys_created	slatershell.foo	/^   keys_created result (res) ::: get_from(OBJECT)$/;"	r
set_keys	slatershell.foo	/^   set_keys(the_keys) ::: get_from(OBJECT)$/;"	r
clear_keys	slatershell.foo	/^   clear_keys ::: get_from(OBJECT)$/;"	r
put_table_footer	slatershell.foo	/^   put_table_footer ::: get_from(OBJECT)$/;"	r
put_table_header	slatershell.foo	/^   put_table_header$/;"	r
table_width	slatershell.foo	/^   table_width result (res)$/;"	r
l_chr	slatershell.foo	/^   l_chr(l) result (res) ::: get_from(SHELL), selfless, private$/;"	r
same_as	slatershell.foo	/^   same_as(b) result (res)$/;"	r
no_of_basis_functions	slatershell.foo	/^   no_of_basis_functions result (res) ::: pure$/;"	r
no_of_primitives	slatershell.foo	/^   no_of_primitives result (res) ::: pure$/;"	r
density_at_radius	slatershell.foo	/^   density_at_radius(R) result (res)$/;"	r
densities_at_radii	slatershell.foo	/^   densities_at_radii(R) result (res)$/;"	r
density_d1_at_radius	slatershell.foo	/^   density_d1_at_radius(R) result (res)$/;"	r
densities_d1_at_radii	slatershell.foo	/^   densities_d1_at_radii(R) result (res)$/;"	r
density_d2_at_radius	slatershell.foo	/^   density_d2_at_radius(R) result (res)$/;"	r
densities_d2_at_radii	slatershell.foo	/^   densities_d2_at_radii(R) result (res)$/;"	r
unnormalise	slatershell.foo	/^   unnormalise $/;"	r
renormalise	slatershell.foo	/^   renormalise $/;"	r
put	slatershell.foo	/^   put$/;"	r
put_table	slatershell.foo	/^   put_table$/;"	r
bar_symbol	spacegroup.foo	/^   bar_symbol :: STR, private                 = "-"            ! Bar symbol, precedes axis orders$/;"	g
axis_order_symbols	spacegroup.foo	/^   axis_order_symbols :: STR, private         = "1234#6"       ! Symmetry axis orders$/;"	g
dash_symbol	spacegroup.foo	/^   dash_symbol :: STR, private                = "'"            !$/;"	g
double_dash_symbol	spacegroup.foo	/^   double_dash_symbol :: STR, private         = '"'            !$/;"	g
star_symbol	spacegroup.foo	/^   star_symbol :: STR, private                = "*"            !$/;"	g
axis_symbols	spacegroup.foo	/^   axis_symbols :: STR, private               = "xyz""'*"      ! Axis setting symbols$/;"	g
lattice_symbols	spacegroup.foo	/^   lattice_symbols :: STR, private            = "PABCIRHF"     ! Allowed lattice symbols$/;"	g
alpha_translation_symbols	spacegroup.foo	/^   alpha_translation_symbols  :: STR, private = "abcnuvwd"     ! Allowed alphabetical translation subscripts$/;"	g
number_translation_symbols	spacegroup.foo	/^   number_translation_symbols :: STR, private = "12345"        ! Allowed numerical translation subscripts$/;"	g
NN	spacegroup.foo	/^   NN :: MAT4{REAL}(3,3,3,8), private$/;"	g
T_alpha	spacegroup.foo	/^   T_alpha :: MAT{REAL}(3,8), private$/;"	g
n_implied_translations	spacegroup.foo	/^   n_implied_translations :: VEC{INT}(8), private$/;"	g
T_implied	spacegroup.foo	/^   T_implied :: MAT3{REAL}(3,4,8), private$/;"	g
spacegroup_conversion_table	spacegroup.foo	/^   spacegroup_conversion_table :: MAT{STR}(len=14,4,593), private$/;"	g
create	spacegroup.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	spacegroup.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	spacegroup.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	spacegroup.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	spacegroup.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	spacegroup.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	spacegroup.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	spacegroup.foo	/^   copy(sg) ::: leaky$/;"	r
set_defaults	spacegroup.foo	/^   set_defaults ::: leaky$/;"	r
set_IT_symbol	spacegroup.foo	/^   set_IT_symbol(IT_symbol)$/;"	r
set_HM_symbol	spacegroup.foo	/^   set_HM_symbol(HM_symbol)$/;"	r
set_Hall_symbol	spacegroup.foo	/^   set_Hall_symbol(Hall_symbol)$/;"	r
read_keywords	spacegroup.foo	/^   read_keywords ::: get_from(OBJECT), recursive, leaky$/;"	r
process_keyword	spacegroup.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_IT_symbol	spacegroup.foo	/^   read_IT_symbol ::: leaky$/;"	r
read_Hall_symbol	spacegroup.foo	/^   read_Hall_symbol ::: leaky$/;"	r
read_HM_symbol	spacegroup.foo	/^   read_HM_symbol ::: leaky$/;"	r
read_CIF	spacegroup.foo	/^   read_CIF(cif) ::: leaky$/;"	r
read_jones_faithful_symbols	spacegroup.foo	/^   read_jones_faithful_symbols ::: leaky$/;"	r
analyse	spacegroup.foo	/^   analyse ::: leaky$/;"	r
decode_Hall_symbol	spacegroup.foo	/^   decode_Hall_symbol$/;"	r
set_lattice_type	spacegroup.foo	/^   set_lattice_type$/;"	r
set_default_axis_symbol_info	spacegroup.foo	/^   set_default_axis_symbol_info$/;"	r
set_spacegroup_order	spacegroup.foo	/^   set_spacegroup_order$/;"	r
form_L_seitz	spacegroup.foo	/^   form_L_seitz$/;"	r
form_S_seitz	spacegroup.foo	/^   form_S_seitz$/;"	r
generate_seitz	spacegroup.foo	/^   generate_seitz$/;"	r
shift_origin	spacegroup.foo	/^   shift_origin$/;"	r
make_inverted_symops	spacegroup.foo	/^   make_inverted_symops ::: leaky, private$/;"	r
make_translated_symops	spacegroup.foo	/^   make_translated_symops ::: leaky, private$/;"	r
make_unique_SF_symops	spacegroup.foo	/^   make_unique_SF_symops ::: leaky, private$/;"	r
unique_SF_symop_mat	spacegroup.foo	/^   unique_SF_symop_mat(u) result (res)$/;"	r
decode_Jones_Faithful_symbols	spacegroup.foo	/^   decode_Jones_Faithful_symbols(symbols,mat)$/;"	r
decode_Jones_Faithful_symbol	spacegroup.foo	/^   decode_Jones_Faithful_symbol(symbol,mat)$/;"	r
recode_Jones_Faithful_symbol	spacegroup.foo	/^   recode_Jones_Faithful_symbol(jf,mat)$/;"	r
seitz_same_as	spacegroup.foo	/^   seitz_same_as(mat) result (res)$/;"	r
put_geometry_to_unit_cell	spacegroup.foo	/^   put_geometry_to_unit_cell(g)$/;"	r
put_position_to_unit_cell	spacegroup.foo	/^   put_position_to_unit_cell(p)$/;"	r
get_partition_factors	spacegroup.foo	/^   get_partition_factors(pfac,geometry,full) ::: leaky$/;"	r
get_full_geometry	spacegroup.foo	/^   get_full_geometry(full,geometry,pfac) ::: leaky$/;"	r
transform_geometry	spacegroup.foo	/^   transform_geometry(g,op)$/;"	r
transform_position	spacegroup.foo	/^   transform_position(p,op)$/;"	r
is_same_geometry	spacegroup.foo	/^   is_same_geometry(geom_i,geom_j) result (res)$/;"	r
make_phases_for_symop	spacegroup.foo	/^   make_phases_for_symop(u,phase,mask,refl)  ::: private$/;"	r
sum_unique_sf	spacegroup.foo	/^   sum_unique_sf(sf,unique_sf,refl)$/;"	r
sum_unique_sf_ints	spacegroup.foo	/^   sum_unique_sf_ints(sf_ints,unique_sf_ints,refl)$/;"	r
sum_unique_sf_derivs	spacegroup.foo	/^   sum_unique_sf_derivs(sf,unique_sf,refl)$/;"	r
sum_unique_sf_derivs_t	spacegroup.foo	/^   sum_unique_sf_derivs_t(sf,unique_sf,refl)$/;"	r
sum_unique_sf_pts	spacegroup.foo	/^   sum_unique_sf_pts(X,k_pts,pts,tf,Fr,Fc,refl)$/;"	r
put	spacegroup.foo	/^   put$/;"	r
put_spacegroup_name_info	spacegroup.foo	/^   put_spacegroup_name_info$/;"	r
put_seitz	spacegroup.foo	/^   put_seitz(mat)$/;"	r
put_inv_trans_symop_data	spacegroup.foo	/^   put_inv_trans_symop_data ::: private$/;"	r
put_matching_IT_symbols	spacegroup.foo	/^   put_matching_IT_symbols(symbol)$/;"	r
put_matching_HM_symbols	spacegroup.foo	/^   put_matching_HM_symbols(symbol)$/;"	r
put_cif	spacegroup.foo	/^   put_cif$/;"	r
put_cif_jf_symbols	spacegroup.foo	/^   put_cif_jf_symbols$/;"	r
SELF_TYPE_SIZE	str.foo	/^#  define SELF_TYPE_SIZE  *$/;"	m
trim	str.foo	/^   interface trim$/;"	i
scan	str.foo	/^   interface scan$/;"	i
verify	str.foo	/^   interface verify$/;"	i
n_items	str.foo	/^   n_items result (res)$/;"	r
item	str.foo	/^   item(n) result (res)$/;"	r
get_item	str.foo	/^   get_item(n,item,position)$/;"	r
get_next_item	str.foo	/^   get_next_item(item,first,last,comment_chars,quote_chars,ignore_unmatched_quotes)$/;"	r
get_next_item_position	str.foo	/^   get_next_item_position(first,last)$/;"	r
get_next_items	str.foo	/^   get_next_items(word)$/;"	r
quote_position	str.foo	/^   quote_position(quote_chars) result (pos) ::: private$/;"	r
index_of_matching_bracket	str.foo	/^   index_of_matching_bracket(symbol) result (res)$/;"	r
index_of_substring	str.foo	/^   index_of_substring(substring,backwards) result(ind)$/;"	r
is_included_in	str.foo	/^   is_included_in(string,at_start) result (res)$/;"	r
is_included_in_any	str.foo	/^   is_included_in_any(strvec) result (res)$/;"	r
includes	str.foo	/^   includes(string,at_start) result (res)$/;"	r
includes_any_in	str.foo	/^   includes_any_in(strvec) result (res)$/;"	r
does_not_include	str.foo	/^   does_not_include(string) result (res)$/;"	r
has_any_characters_in	str.foo	/^   has_any_characters_in(set) result (res)$/;"	r
has_all_characters_in	str.foo	/^   has_all_characters_in(set) result (res)$/;"	r
index_of	str.foo	/^   index_of(set,backwards) result(ind)$/;"	r
index_of_character_in	str.foo	/^   index_of_character_in(set,backwards) result(ind)$/;"	r
index_of_character_not_in	str.foo	/^   index_of_character_not_in(set,backwards) result(ind)$/;"	r
index_of_alphabetical	str.foo	/^   index_of_alphabetical result (res)$/;"	r
index_of_nonalphabetical	str.foo	/^   index_of_nonalphabetical result (res)$/;"	r
index_of_lcase_alphabetical	str.foo	/^   index_of_lcase_alphabetical result (res)$/;"	r
index_of_ucase_alphabetical	str.foo	/^   index_of_ucase_alphabetical result (res)$/;"	r
index_of_digit	str.foo	/^   index_of_digit result (res)$/;"	r
index_of_nondigit	str.foo	/^   index_of_nondigit result (res)$/;"	r
split	str.foo	/^   split result (res) ::: leaky$/;"	r
trim_blanks_from_end	str.foo	/^   trim_blanks_from_end result (res)$/;"	r
trim_blanks_from_start	str.foo	/^   trim_blanks_from_start result (res)$/;"	r
to_lower_case	str.foo	/^   to_lower_case ::: pure$/;"	r
lower_cased	str.foo	/^   lower_cased result (res) ::: pure$/;"	r
to_upper_case	str.foo	/^   to_upper_case ::: pure$/;"	r
upper_cased	str.foo	/^   upper_cased result (res) ::: pure$/;"	r
left_justify	str.foo	/^   left_justify ::: elemental$/;"	r
left_justified	str.foo	/^   left_justified result (res) ::: elemental$/;"	r
right_justify	str.foo	/^   right_justify ::: elemental$/;"	r
right_justified	str.foo	/^   right_justified result (res) ::: elemental$/;"	r
center_justify	str.foo	/^   center_justify ::: elemental$/;"	r
center_justified	str.foo	/^   center_justified result (res) ::: elemental$/;"	r
to_str	str.foo	/^   to_str(width,left_justify) result (string)$/;"	r
insert	str.foo	/^   insert(string,position)$/;"	r
replace_all	str.foo	/^   replace_all(a,b,repeatedly)$/;"	r
replace_first	str.foo	/^   replace_first(a,b)$/;"	r
remove_all	str.foo	/^   remove_all(a)$/;"	r
remove_blanks	str.foo	/^   remove_blanks$/;"	r
separate_all_characters	str.foo	/^   separate_all_characters$/;"	r
separate_before	str.foo	/^   separate_before(characters)$/;"	r
separate_after	str.foo	/^   separate_after(characters)$/;"	r
pad_with	str.foo	/^   pad_with(symbol,width,prepad)$/;"	r
filename_head	str.foo	/^   filename_head result (res)$/;"	r
filename_tail	str.foo	/^   filename_tail result (res)$/;"	r
filename_directory	str.foo	/^   filename_directory result (res)$/;"	r
equals	str.foo	/^   equals(string,ignore_case) result (same) ::: pure$/;"	r
same_as	str.foo	/^   same_as(string,ignore_case) result (same) ::: pure$/;"	r
is_real	str.foo	/^   is_real result (res)$/;"	r
is_cpx	str.foo	/^   is_cpx result (res)$/;"	r
is_a_true_cpx	str.foo	/^   is_a_true_cpx result (res)$/;"	r
is_a_real_pair	str.foo	/^   is_a_real_pair result (res)$/;"	r
is_int	str.foo	/^   is_int result (res)$/;"	r
is_a_true_int	str.foo	/^   is_a_true_int result (res)$/;"	r
is_bin	str.foo	/^   is_bin result (res)$/;"	r
is_imprecise_real	str.foo	/^   is_imprecise_real result (res)$/;"	r
is_alphabetical	str.foo	/^   is_alphabetical result (res)$/;"	r
is_lower_case	str.foo	/^   is_lower_case result (res)$/;"	r
is_upper_case	str.foo	/^   is_upper_case result (res)$/;"	r
is_numeric	str.foo	/^   is_numeric result (res)$/;"	r
is_alphanumeric	str.foo	/^   is_alphanumeric result (res)$/;"	r
has_some_alpha_characters	str.foo	/^   has_some_alpha_characters result (res)$/;"	r
has_some_alphanumeric_chars	str.foo	/^   has_some_alphanumeric_chars result (res)$/;"	r
str_length	str.foo	/^   str_length(spaces) result (res) ::: pure$/;"	r
to_real	str.foo	/^   to_real result(value)$/;"	r
frac_to_real	str.foo	/^   frac_to_real result(value)$/;"	r
to_cpx	str.foo	/^   to_cpx result(value)$/;"	r
to_int	str.foo	/^   to_int result (value)$/;"	r
to_bin	str.foo	/^   to_bin result(value)$/;"	r
to_imprecise_real	str.foo	/^   to_imprecise_real(value,error)$/;"	r
from_int	str.foo	/^   from_int(value)$/;"	r
from_bin	str.foo	/^   from_bin(value)$/;"	r
from_real	str.foo	/^   from_real(value)$/;"	r
from_cpx	str.foo	/^   from_cpx(value)$/;"	r
is_known_unit	str.foo	/^   is_known_unit result (res)$/;"	r
conversion_factor	str.foo	/^   conversion_factor result (res)$/;"	r
is_one_of	str.foo	/^   is_one_of(allowed) result (res)$/;"	r
tonto	system.foo	/^   tonto :: SYSTEM*, public$/;"	g
create	system.foo	/^   create ::: leaky$/;"	r
destroy	system.foo	/^   destroy ::: leaky$/;"	r
created	system.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	system.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
nullify_ptr_part	system.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	system.foo	/^   destroy_ptr_part$/;"	r
set_defaults	system.foo	/^   set_defaults(memory_limit)$/;"	r
initialise	system.foo	/^   initialise$/;"	r
finalise	system.foo	/^   finalise$/;"	r
unit_conversion_factor	system.foo	/^   unit_conversion_factor result (res) ::: private$/;"	r
reset_memory_limit	system.foo	/^   reset_memory_limit(limit)$/;"	r
set_error_output_unit	system.foo	/^   set_error_output_unit(number)$/;"	r
set_error_output_file	system.foo	/^   set_error_output_file(file)$/;"	r
set_keyword_echo	system.foo	/^   set_keyword_echo(echo)$/;"	r
die	system.foo	/^   die(message)$/;"	r
die_if	system.foo	/^   die_if(condition,message)$/;"	r
warn	system.foo	/^   warn(message,iostat,use_stack_name)$/;"	r
warn_if	system.foo	/^   warn_if(condition,message,iostat)$/;"	r
ensure	system.foo	/^   ensure(condition,message)$/;"	r
report_stack_see_info	system.foo	/^   report_stack_see_info ::: private$/;"	r
unknown	system.foo	/^   unknown(word,name,options)$/;"	r
unknown	system.foo	/^   unknown(word,name)$/;"	r
add_memory	system.foo	/^   add_memory(used) ::: pure$/;"	r
delete_memory	system.foo	/^   delete_memory(used) ::: pure$/;"	r
add_memory	system.foo	/^   add_memory(used,address) ::: pure$/;"	r
delete_memory	system.foo	/^   delete_memory(used,address) ::: pure$/;"	r
report_undeleted_memory	system.foo	/^   report_undeleted_memory(out) ::: private$/;"	r
stack	system.foo	/^   stack(routine_name)$/;"	r
unstack	system.foo	/^   unstack(routine_name)$/;"	r
check	system.foo	/^   check(routine_name)$/;"	r
will_exceed_memory_limit	system.foo	/^   will_exceed_memory_limit(amount) result (res)$/;"	r
check_exceeded	system.foo	/^   check_exceeded ::: private$/;"	r
check_if_leaky	system.foo	/^   check_if_leaky ::: private$/;"	r
ignore_memory_leak	system.foo	/^   ignore_memory_leak(memory_blocks_gained)$/;"	r
start_memory_trace	system.foo	/^   start_memory_trace(depth,show_call_stack)$/;"	r
end_memory_trace	system.foo	/^   end_memory_trace$/;"	r
expand_call_stacks	system.foo	/^   expand_call_stacks ::: private$/;"	r
report	system.foo	/^   report(out)$/;"	r
report_stack_info	system.foo	/^   report_stack_info(out,full_report) ::: private$/;"	r
report_io_file_info	system.foo	/^   report_io_file_info ::: private$/;"	r
report_keyword_info	system.foo	/^   report_keyword_info(options) ::: private$/;"	r
start_timer	system.foo	/^   start_timer(routine_name)$/;"	r
stop_timer	system.foo	/^   stop_timer$/;"	r
expand_time_stacks	system.foo	/^   expand_time_stacks(routine_name,start_time) ::: pure, leaky, private$/;"	r
index_for_routine	system.foo	/^   index_for_routine(routine_name) result (index) ::: pure, leaky, private$/;"	r
report_timing_info	system.foo	/^   report_timing_info(out,full_report) ::: private$/;"	r
flush_buffer	system.foo	/^   flush_buffer(unit)$/;"	r
expand_real	system.foo	/^   expand_real(stack,dim) ::: pure, leaky, private$/;"	r
expand_int	system.foo	/^   expand_int(stack,dim) ::: pure, leaky, private$/;"	r
expand_str	system.foo	/^   expand_str(stack,dim) ::: pure, leaky, private$/;"	r
quick_sort_decreasing	system.foo	/^   quick_sort_decreasing(vec,indices) ::: pure, recursive, private$/;"	r
parallel_initialise	system.foo	/^   parallel_initialise ::: get_from(PARALLEL:initialise)$/;"	r
parallel_finalise	system.foo	/^   parallel_finalise ::: get_from(PARALLEL:finalise)$/;"	r
is_master_processor	system.foo	/^   is_master_processor result (res) ::: get_from(PARALLEL), pure$/;"	r
master_processor	system.foo	/^   master_processor result (res) ::: get_from(PARALLEL), pure$/;"	r
this_processor	system.foo	/^   this_processor result (res) ::: get_from(PARALLEL), pure$/;"	r
parallel_do_start	system.foo	/^   parallel_do_start(first,stride) result (res) ::: get_from(PARALLEL), pure$/;"	r
parallel_do_stride	system.foo	/^   parallel_do_stride(stride) result (res) ::: get_from(PARALLEL), pure$/;"	r
do_in_parallel	system.foo	/^   do_in_parallel result (res) ::: get_from(PARALLEL), pure$/;"	r
lock_parallel_do	system.foo	/^   lock_parallel_do(name) ::: get_from(PARALLEL)$/;"	r
unlock_parallel_do	system.foo	/^   unlock_parallel_do(name) ::: get_from(PARALLEL)$/;"	r
parallel_vector_sum	system.foo	/^   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{BIN}, MPI_TYPE=>MPI_LOGICAL), public$/;"	r
parallel_vector_sum	system.foo	/^   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{INT}, MPI_TYPE=>MPI_INTEGER), public$/;"	r
parallel_vector_sum	system.foo	/^   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION), public$/;"	r
parallel_vector_sum	system.foo	/^   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX), public$/;"	r
parallel_sum	system.foo	/^   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{BIN}, MPI_TYPE=>MPI_LOGICAL)$/;"	r
parallel_sum	system.foo	/^   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{INT}, MPI_TYPE=>MPI_INTEGER)$/;"	r
parallel_sum	system.foo	/^   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)$/;"	r
parallel_sum	system.foo	/^   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)$/;"	r
parallel_sum	system.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)$/;"	r
parallel_sum	system.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)$/;"	r
parallel_symmetric_sum	system.foo	/^   parallel_symmetric_sum(mat) ::: get_from(PARALLEL)$/;"	r
parallel_sum	system.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT3{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)$/;"	r
parallel_sum	system.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT3{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)$/;"	r
parallel_sum	system.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT4{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)$/;"	r
parallel_sum	system.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT4{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)$/;"	r
parallel_sum	system.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT5{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)$/;"	r
parallel_sum	system.foo	/^   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT5{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)$/;"	r
compress_to_triangle	system.foo	/^   compress_to_triangle(tr,mat) ::: get_from(PARALLEL)$/;"	r
uncompress_from_triangle	system.foo	/^   uncompress_from_triangle(tr,mat) ::: get_from(PARALLEL)$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>STR, MPI_TYPE=>MPI_CHARACTER, LEN=>len(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>BIN, MPI_TYPE=>MPI_LOGICAL, LEN=>1)$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>INT, MPI_TYPE=>MPI_INTEGER, LEN=>1)$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>REAL, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>1)$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>CPX, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>1)$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{STR}, MPI_TYPE=>MPI_CHARACTER, LEN=>size(var)*len(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{BIN}, MPI_TYPE=>MPI_LOGICAL, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{STR}, MPI_TYPE=>MPI_CHARACTER, LEN=>size(var)*len(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{BIN}, MPI_TYPE=>MPI_LOGICAL, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{BIN}, MPI_TYPE=>MPI_LOGICAL, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT4{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT4{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT4{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT5{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))$/;"	r
broadcast	system.foo	/^   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT5{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))$/;"	r
IO_is_allowed	system.foo	/^   IO_is_allowed result (res)$/;"	r
synchronise_processors	system.foo	/^   synchronise_processors ::: get_from(PARALLEL)$/;"	r
create	table_column.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	table_column.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
nullify_ptr_part	table_column.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	table_column.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	table_column.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	table_column.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	table_column.foo	/^   create_copy(object) ::: get_from(OBJECT), leaky$/;"	r
copy	table_column.foo	/^   copy(column) ::: leaky$/;"	r
set_defaults	table_column.foo	/^   set_defaults$/;"	r
clear_column	table_column.foo	/^   clear_column$/;"	r
set_heading	table_column.foo	/^   set_heading(val)$/;"	r
set_subheading	table_column.foo	/^   set_subheading(val)$/;"	r
set_subhead	table_column.foo	/^   set_subhead(val)$/;"	r
set_sb3head	table_column.foo	/^   set_sb3head(val)$/;"	r
set_real_precision	table_column.foo	/^   set_real_precision(val)$/;"	r
set_spacing	table_column.foo	/^   set_spacing(val)$/;"	r
set_item_spacing	table_column.foo	/^   set_item_spacing(val)$/;"	r
set_spacer	table_column.foo	/^   set_spacer(val)$/;"	r
set_center	table_column.foo	/^   set_center(val)$/;"	r
set_left_justify	table_column.foo	/^   set_left_justify(val)$/;"	r
set_left	table_column.foo	/^   set_left(val)$/;"	r
set_width	table_column.foo	/^   set_width(val)$/;"	r
set_item_width	table_column.foo	/^   set_item_width(val)$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v) ::: template$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>BIN)$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>INT)$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>STR)$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{BIN})$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{INT})$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{STR})$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v) ::: template$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>REAL)$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{REAL})$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>MAT{REAL})$/;"	r
set_width_from	table_column.foo	/^   set_width_from(v)$/;"	r
set_values	table_column.foo	/^   set_values(v) ::: template$/;"	r
set_values	table_column.foo	/^   set_values(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{BIN}, VALUE=>b_value)$/;"	r
set_values	table_column.foo	/^   set_values(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{INT}, VALUE=>i_value)$/;"	r
set_values	table_column.foo	/^   set_values(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{VEC_{INT}}, VALUE=>iv_value)$/;"	r
set_values	table_column.foo	/^   set_values(v)$/;"	r
set_values	table_column.foo	/^   set_values(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{REAL}, VALUE=>r_value)$/;"	r
values_set	table_column.foo	/^   values_set result (res) ::: pure$/;"	r
n_rows	table_column.foo	/^   n_rows result (res) ::: pure$/;"	r
put_heading	table_column.foo	/^   put_heading$/;"	r
put_subheading	table_column.foo	/^   put_subheading$/;"	r
put_sb3heading	table_column.foo	/^   put_sb3heading$/;"	r
put_value	table_column.foo	/^   put_value(i)$/;"	r
stdin	textfile.foo	/^   stdin  :: TEXTFILE*, public DEFAULT_NULL$/;"	g
stdout	textfile.foo	/^   stdout :: TEXTFILE*, public DEFAULT_NULL$/;"	g
stderr	textfile.foo	/^   stderr :: TEXTFILE*, public DEFAULT_NULL$/;"	g
create_stdin	textfile.foo	/^   create_stdin ::: leaky$/;"	r
create_stdout	textfile.foo	/^   create_stdout ::: leaky$/;"	r
create_stderr	textfile.foo	/^   create_stderr ::: leaky$/;"	r
create	textfile.foo	/^   create(name) ::: leaky$/;"	r
create	textfile.foo	/^   create(internal) ::: leaky$/;"	r
destroy	textfile.foo	/^   destroy ::: leaky, recursive$/;"	r
nullify_ptr_part	textfile.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	textfile.foo	/^   destroy_ptr_part ::: leaky$/;"	r
destroy_replacement_list	textfile.foo	/^   destroy_replacement_list ::: leaky$/;"	r
created	textfile.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	textfile.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	textfile.foo	/^   create_copy(file) ::: recursive, leaky$/;"	r
copy	textfile.foo	/^   copy(file,copy_saved) ::: recursive, leaky$/;"	r
set_defaults	textfile.foo	/^   set_defaults $/;"	r
set_default_format	textfile.foo	/^   set_default_format$/;"	r
set_no_of_lines	textfile.foo	/^   set_no_of_lines$/;"	r
save	textfile.foo	/^   save ::: leaky$/;"	r
unsave	textfile.foo	/^   unsave ::: leaky$/;"	r
redirect	textfile.foo	/^   redirect(name) ::: leaky$/;"	r
redirect	textfile.foo	/^   redirect(internal) ::: leaky$/;"	r
revert	textfile.foo	/^   revert ::: leaky$/;"	r
use_style	textfile.foo	/^   use_style(saved) ::: private$/;"	r
open	textfile.foo	/^   open$/;"	r
open	textfile.foo	/^   open(for)$/;"	r
for	textfile.foo	/^     for :: STR$/;"	a
open_for_read	textfile.foo	/^   open_for_read ::: private$/;"	r
open_for_write	textfile.foo	/^   open_for_write ::: private$/;"	r
open_old_file_for_write	textfile.foo	/^   open_old_file_for_write ::: private$/;"	r
open_new_file_for_write	textfile.foo	/^   open_new_file_for_write ::: private$/;"	r
close	textfile.foo	/^   close$/;"	r
close_and_delete	textfile.foo	/^   close_and_delete$/;"	r
delete	textfile.foo	/^   delete$/;"	r
set_comment_chars	textfile.foo	/^   set_comment_chars(comment_chars)$/;"	r
set_quote_chars	textfile.foo	/^   set_quote_chars(quote_chars)$/;"	r
set_ignore_unmatched_quotes	textfile.foo	/^   set_ignore_unmatched_quotes(ignore)$/;"	r
set_eliminate_specials	textfile.foo	/^   set_eliminate_specials(eliminate)$/;"	r
set_replacement_list	textfile.foo	/^   set_replacement_list(list) ::: leaky$/;"	r
set_int_width	textfile.foo	/^   set_int_width(val)$/;"	r
set_real_width	textfile.foo	/^   set_real_width(val)$/;"	r
set_n_fields_per_line	textfile.foo	/^   set_n_fields_per_line(val)$/;"	r
set_spacing	textfile.foo	/^   set_spacing(val)$/;"	r
set_real_precision	textfile.foo	/^   set_real_precision(val)$/;"	r
set_real_style	textfile.foo	/^   set_real_style(val)$/;"	r
set_line_format	textfile.foo	/^   set_line_format(fmt)$/;"	r
set_using_fields	textfile.foo	/^   set_using_fields(val)$/;"	r
set_margin_width	textfile.foo	/^   set_margin_width(val)$/;"	r
set_using_array_labels	textfile.foo	/^   set_using_array_labels(using_array_labels)$/;"	r
set_default_units	textfile.foo	/^   set_default_units(units)$/;"	r
read_keywords	textfile.foo	/^   read_keywords(in)$/;"	r
process_keyword	textfile.foo	/^   process_keyword(keyword,infile) ::: leaky$/;"	r
exists	textfile.foo	/^   exists(name) result (res)$/;"	r
is_open	textfile.foo	/^   is_open result (res)$/;"	r
unit_used	textfile.foo	/^   unit_used result (res)$/;"	r
next_line_item	textfile.foo	/^   next_line_item result (res)$/;"	r
previous_line_item	textfile.foo	/^   previous_line_item  result (res)$/;"	r
last_line_item	textfile.foo	/^   last_line_item  result (res)$/;"	r
n_line_items	textfile.foo	/^   n_line_items result (res)$/;"	r
at_end_of_line	textfile.foo	/^   at_end_of_line result (res)$/;"	r
line_number	textfile.foo	/^   line_number result (res)$/;"	r
buffer_string	textfile.foo	/^   buffer_string result (res)$/;"	r
end_of_file	textfile.foo	/^   end_of_file result (res)$/;"	r
reverted	textfile.foo	/^   reverted result (res)$/;"	r
reset_io_status	textfile.foo	/^   reset_io_status$/;"	r
at_end_of_file	textfile.foo	/^   at_end_of_file result (res)$/;"	r
buffer_exhausted	textfile.foo	/^   buffer_exhausted result (res)$/;"	r
res	textfile.foo	/^     res :: BIN$/;"	a
read_line	textfile.foo	/^   read_line$/;"	r
read_line_internal	textfile.foo	/^   read_line_internal ::: private$/;"	r
read_line_external	textfile.foo	/^   read_line_external ::: private$/;"	r
update_line	textfile.foo	/^   update_line ::: private$/;"	r
revert_line	textfile.foo	/^   revert_line ::: private$/;"	r
skip_next_item	textfile.foo	/^   skip_next_item ::: leaky$/;"	r
move_to_previous_item	textfile.foo	/^   move_to_previous_item$/;"	r
move_to_last_item_on_line	textfile.foo	/^   move_to_last_item_on_line$/;"	r
move_to_previous_item_on_line	textfile.foo	/^   move_to_previous_item_on_line$/;"	r
move_to_line_item	textfile.foo	/^   move_to_line_item(number)$/;"	r
rest_of_line	textfile.foo	/^   rest_of_line result (res)$/;"	r
rewind	textfile.foo	/^   rewind$/;"	r
rewind_internal	textfile.foo	/^   rewind_internal ::: private$/;"	r
rewind_external	textfile.foo	/^   rewind_external ::: private$/;"	r
move_to_end	textfile.foo	/^   move_to_end$/;"	r
move_to_end_internal	textfile.foo	/^   move_to_end_internal ::: private$/;"	r
move_to_end_external	textfile.foo	/^   move_to_end_external ::: private$/;"	r
backspace_line	textfile.foo	/^   backspace_line$/;"	r
skip_line	textfile.foo	/^   skip_line$/;"	r
move_to_line	textfile.foo	/^   move_to_line(line)$/;"	r
move_to_record	textfile.foo	/^   move_to_record(rec)$/;"	r
move_to_record_internal	textfile.foo	/^   move_to_record_internal(rec) ::: private$/;"	r
move_to_record_external	textfile.foo	/^   move_to_record_external(rec) ::: private$/;"	r
look_for_item	textfile.foo	/^   look_for_item(item,from,until,end_tokens,exact_match,head_match,return_cursor,found)$/;"	r
look_backwards_for_item	textfile.foo	/^   look_backwards_for_item(item,from,until,end_tokens,exact_match,head_match,return_cursor,found)$/;"	r
look_for_any_item	textfile.foo	/^   look_for_any_item(item,from,until,end_tokens,exact_match,head_match,return_cursor,found)$/;"	r
look_for	textfile.foo	/^   look_for(item,from,until,first,found)$/;"	r
look_backwards_for	textfile.foo	/^   look_backwards_for(item,from,until,first,found)$/;"	r
has_string	textfile.foo	/^   has_string(search) result (res)$/;"	r
get_next_item	textfile.foo	/^   get_next_item(word) ::: private$/;"	r
next_item	textfile.foo	/^   next_item result(word) ::: leaky$/;"	r
next_str	textfile.foo	/^   next_str result(word) ::: leaky$/;"	r
read	textfile.foo	/^   read(value) ::: template$/;"	r
read	textfile.foo	/^   read(value) ::: get_from(TEXTFILE, TYPE=>STR)$/;"	r
read	textfile.foo	/^   read(value) ::: get_from(TEXTFILE, TYPE=>BIN)$/;"	r
read	textfile.foo	/^   read(value) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
read	textfile.foo	/^   read(value) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
read	textfile.foo	/^   read(value,format)$/;"	r
read	textfile.foo	/^   read(value,error)$/;"	r
read	textfile.foo	/^   read(value) ::: get_from(TEXTFILE, TYPE=>CPX)$/;"	r
read_quantity	textfile.foo	/^   read_quantity(value) ::: template$/;"	r
read_quantity	textfile.foo	/^   read_quantity(value) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
read_quantity	textfile.foo	/^   read_quantity(value) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
read	textfile.foo	/^   read(v) ::: template$/;"	r
read	textfile.foo	/^   read(v) ::: get_from(TEXTFILE, TYPE=>STR)$/;"	r
read	textfile.foo	/^   read(v) ::: get_from(TEXTFILE, TYPE=>BIN)$/;"	r
read	textfile.foo	/^   read(v) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
read	textfile.foo	/^   read(v) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
read	textfile.foo	/^   read(v) ::: get_from(TEXTFILE, TYPE=>CPX)$/;"	r
read_quantity	textfile.foo	/^   read_quantity(v) ::: template$/;"	r
read_quantity	textfile.foo	/^   read_quantity(v) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
read_quantity	textfile.foo	/^   read_quantity(v) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
list_length	textfile.foo	/^   list_length result (res) ::: leaky, private$/;"	r
read_ptr	textfile.foo	/^   read_ptr(v) ::: template$/;"	r
read_ptr	textfile.foo	/^   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>STR), leaky$/;"	r
read_ptr	textfile.foo	/^   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>BIN), leaky$/;"	r
read_ptr	textfile.foo	/^   read_ptr(v) ::: leaky$/;"	r
read_ptr_helper	textfile.foo	/^   read_ptr_helper(v) ::: get_from(TEXTFILE:read_ptr, TYPE=>INT), leaky, private$/;"	r
read_ptr	textfile.foo	/^   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>REAL), leaky$/;"	r
read_ptr	textfile.foo	/^   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>CPX), leaky$/;"	r
read_ptr_quantity	textfile.foo	/^   read_ptr_quantity(v) ::: template$/;"	r
read_ptr_quantity	textfile.foo	/^   read_ptr_quantity(v) ::: get_from(TEXTFILE, TYPE=>REAL), leaky$/;"	r
read	textfile.foo	/^   read(v1,v2) ::: template$/;"	r
read	textfile.foo	/^   read(v1,v2) ::: get_from(TEXTFILE, T1=>INT, T2=>INT)$/;"	r
read	textfile.foo	/^   read(v1,v2) ::: get_from(TEXTFILE, T1=>REAL, T2=>REAL)$/;"	r
read	textfile.foo	/^   read(v1,v2,v3) ::: template$/;"	r
read	textfile.foo	/^   read(v1,v2,v3) ::: get_from(TEXTFILE, T1=>REAL, T2=>REAL, T3=>REAL)$/;"	r
read	textfile.foo	/^   read(mx,by_column) ::: template$/;"	r
read	textfile.foo	/^   read(mx,by_column) ::: get_from(TEXTFILE, TYPE=>STR)$/;"	r
read	textfile.foo	/^   read(mx,by_column) ::: get_from(TEXTFILE, TYPE=>BIN)$/;"	r
read	textfile.foo	/^   read(mx,by_column) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
read	textfile.foo	/^   read(mx,by_column) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
read	textfile.foo	/^   read(mx,format,items_per_line)$/;"	r
mx	textfile.foo	/^     mx :: MAT{REAL}, OUT$/;"	a
format	textfile.foo	/^     format :: STR, IN$/;"	a
items_per_line	textfile.foo	/^     items_per_line :: INT, IN$/;"	a
read	textfile.foo	/^   read(mx,by_column) ::: get_from(TEXTFILE, TYPE=>CPX)$/;"	r
get_matrix_shape	textfile.foo	/^   get_matrix_shape(dim) ::: private$/;"	r
read_ptr	textfile.foo	/^   read_ptr(mx) ::: template$/;"	r
read_ptr	textfile.foo	/^   read_ptr(mx) ::: get_from(TEXTFILE, TYPE=>STR), leaky$/;"	r
read_ptr	textfile.foo	/^   read_ptr(mx) ::: get_from(TEXTFILE, TYPE=>BIN), leaky$/;"	r
read_ptr	textfile.foo	/^   read_ptr(mx) ::: get_from(TEXTFILE, TYPE=>INT), leaky$/;"	r
read_ptr	textfile.foo	/^   read_ptr(mx) ::: get_from(TEXTFILE, TYPE=>REAL), leaky$/;"	r
read_ptr	textfile.foo	/^   read_ptr(mx) ::: get_from(TEXTFILE, TYPE=>CPX), leaky$/;"	r
read	textfile.foo	/^   read(v) ::: template$/;"	r
read	textfile.foo	/^   read(v) ::: get_from(TEXTFILE, TYPE=>INT), leaky$/;"	r
read	textfile.foo	/^   read(v) ::: get_from(TEXTFILE, TYPE=>REAL), leaky$/;"	r
list_list_length	textfile.foo	/^   list_list_length result (res) ::: leaky, private$/;"	r
read_ptr	textfile.foo	/^   read_ptr(v) ::: template$/;"	r
read_ptr	textfile.foo	/^   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>INT), leaky$/;"	r
read_ptr	textfile.foo	/^   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>REAL), leaky$/;"	r
read	textfile.foo	/^   read(v) ::: template$/;"	r
read	textfile.foo	/^   read(v) ::: get_from(TEXTFILE, TYPE=>INT), leaky$/;"	r
read	textfile.foo	/^   read(v) ::: get_from(TEXTFILE, TYPE=>REAL), leaky$/;"	r
read	textfile.foo	/^   read(mx) ::: template$/;"	r
read	textfile.foo	/^   read(mx) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
read	textfile.foo	/^   read(mx) ::: get_from(TEXTFILE, TYPE=>CPX)$/;"	r
read	textfile.foo	/^   read(mx) ::: template$/;"	r
read	textfile.foo	/^   read(mx) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
read	textfile.foo	/^   read(mx) ::: get_from(TEXTFILE, TYPE=>CPX)$/;"	r
read	textfile.foo	/^   read(mx) ::: template$/;"	r
read	textfile.foo	/^   read(mx) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
read	textfile.foo	/^   read(mx) ::: get_from(TEXTFILE, TYPE=>CPX)$/;"	r
clear_and_put_margin	textfile.foo	/^   clear_and_put_margin$/;"	r
flush	textfile.foo	/^   flush$/;"	r
flush	textfile.foo	/^   flush(times)$/;"	r
times	textfile.foo	/^     times :: INT$/;"	a
tab	textfile.foo	/^   tab(real_fields,int_fields,bin_fields,width)$/;"	r
dash	textfile.foo	/^   dash(symbol,real_fields,int_fields,bin_fields,width)$/;"	r
text	textfile.foo	/^   text(string,real_width,int_width,flush)$/;"	r
put	textfile.foo	/^   put(string,left,center,int_width,width)$/;"	r
put	textfile.foo	/^   put(value,left,center,real_width,width) ::: template$/;"	r
put	textfile.foo	/^   put(value,left,center,real_width,width) ::: get_from(TEXTFILE:put, VALUE=>BIN)$/;"	r
put	textfile.foo	/^   put(value,left,center,real_width,width) ::: get_from(TEXTFILE:put, VALUE=>INT)$/;"	r
put_bit_string	textfile.foo	/^   put_bit_string(value,left,center,int_width,width)$/;"	r
put	textfile.foo	/^   put(value,left,center,int_width,style,width,precision)$/;"	r
put	textfile.foo	/^   put(value,left,center,int_width,style,width,precision)$/;"	r
put	textfile.foo	/^   put(value,error,units)$/;"	r
put	textfile.foo	/^   put(v,by_row,by_column,left) ::: template$/;"	r
put	textfile.foo	/^   put(v,by_row,by_column,left) ::: get_from(TEXTFILE, TYPE=>STR, LEN=>str_length, ARG=>.spacing)$/;"	r
put	textfile.foo	/^   put(v,by_row,by_column,left) ::: get_from(TEXTFILE, TYPE=>BIN, LEN=>str_length, ARG=>.spacing)$/;"	r
put	textfile.foo	/^   put(v,by_row,by_column,left) ::: get_from(TEXTFILE, TYPE=>INT, LEN=>str_length, ARG=>.spacing)$/;"	r
put	textfile.foo	/^   put(v,by_row,by_column,left) ::: get_from(TEXTFILE, TYPE=>REAL, LEN=>str_length_with_precision, ARG=>.real_precision,.spacing )$/;"	r
put	textfile.foo	/^   put(v,by_row,by_column,left) ::: get_from(TEXTFILE, TYPE=>CPX, LEN=>str_length_with_precision, ARG=>.real_precision,.spacing )$/;"	r
put	textfile.foo	/^   put(mx,by_row,by_column,transpose,left) ::: template$/;"	r
put	textfile.foo	/^   put(mx,by_row,by_column,transpose,left) ::: get_from(TEXTFILE, TYPE=>STR, LEN=>str_length, ARG=>.spacing)$/;"	r
put	textfile.foo	/^   put(mx,by_row,by_column,transpose,left) ::: get_from(TEXTFILE, TYPE=>BIN, LEN=>str_length, ARG=>.spacing)$/;"	r
put	textfile.foo	/^   put(mx,by_row,by_column,transpose,left) ::: get_from(TEXTFILE, TYPE=>INT, LEN=>str_length, ARG=>.spacing)$/;"	r
put	textfile.foo	/^   put(mx,by_row,by_column,transpose,left) ::: get_from(TEXTFILE, TYPE=>REAL, LEN=>str_length_with_precision, ARG=>.real_precision,.spacing )$/;"	r
put	textfile.foo	/^   put(mx,by_row,by_column,transpose,left) ::: get_from(TEXTFILE, TYPE=>CPX, LEN=>str_length_with_precision, ARG=>.real_precision,.spacing )$/;"	r
put	textfile.foo	/^   put(mx,by_dim3_matrices) ::: template$/;"	r
mx	textfile.foo	/^     mx :: MAT3{TYPE}, IN$/;"	a
by_dim3_matrices	textfile.foo	/^     by_dim3_matrices :: BIN, optional$/;"	a
by_d3_matrices	textfile.foo	/^     by_d3_matrices :: BIN$/;"	a
put	textfile.foo	/^   put(mx,by_dim3_matrices) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
put	textfile.foo	/^   put(mx,by_dim3_matrices) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
put	textfile.foo	/^   put(mx,by_dim3_matrices) ::: get_from(TEXTFILE, TYPE=>CPX)$/;"	r
put	textfile.foo	/^   put(mx) ::: template$/;"	r
mx	textfile.foo	/^     mx :: MAT4{TYPE}, IN$/;"	a
put	textfile.foo	/^   put(mx) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
put	textfile.foo	/^   put(mx) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
put	textfile.foo	/^   put(mx) ::: get_from(TEXTFILE, TYPE=>CPX)$/;"	r
put	textfile.foo	/^   put(mx) ::: template$/;"	r
mx	textfile.foo	/^     mx :: MAT5{TYPE}, IN$/;"	a
put	textfile.foo	/^   put(mx) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
put	textfile.foo	/^   put(mx) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
put	textfile.foo	/^   put(mx) ::: get_from(TEXTFILE, TYPE=>CPX)$/;"	r
put	textfile.foo	/^   put(v) ::: template$/;"	r
put	textfile.foo	/^   put(v) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
put	textfile.foo	/^   put(v) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
put	textfile.foo	/^   put(v) ::: template$/;"	r
put	textfile.foo	/^   put(v) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
put	textfile.foo	/^   put(v) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
put	textfile.foo	/^   put(v)$/;"	r
put	textfile.foo	/^   put(mx,by_row,by_column)$/;"	r
mx	textfile.foo	/^     mx :: OPMATRIX, IN$/;"	a
by_row	textfile.foo	/^     by_row :: BIN, IN, optional$/;"	a
by_column	textfile.foo	/^     by_column :: BIN, IN, optional$/;"	a
put_ppm	textfile.foo	/^   put_ppm(mx)$/;"	r
mx	textfile.foo	/^     mx :: MAT3{INT}$/;"	a
show	textfile.foo	/^   show(pretext,value,int_width)$/;"	r
show	textfile.foo	/^   show(pretext,value,real_width)$/;"	r
show	textfile.foo	/^   show(pretext,value,real_width)$/;"	r
show	textfile.foo	/^   show(pretext,value,precision)$/;"	r
show	textfile.foo	/^   show(pretext,value,precision)$/;"	r
show_bit_string	textfile.foo	/^   show_bit_string(pretext,value,int_width,width)$/;"	r
show	textfile.foo	/^   show(pretext,val1,val2) ::: template$/;"	r
show	textfile.foo	/^   show(pretext,val1,val2) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
show	textfile.foo	/^   show(pretext,val1,val2) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
show	textfile.foo	/^   show(pretext,val1,val2,val3) ::: template$/;"	r
show	textfile.foo	/^   show(pretext,val1,val2,val3) ::: get_from(TEXTFILE, TYPE=>BIN)$/;"	r
show	textfile.foo	/^   show(pretext,val1,val2,val3) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
show	textfile.foo	/^   show(pretext,val1,val2,val3) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
show	textfile.foo	/^   show(pretext,value) ::: template$/;"	r
show	textfile.foo	/^   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>STR)$/;"	r
show	textfile.foo	/^   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>BIN)$/;"	r
show	textfile.foo	/^   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>INT)$/;"	r
show	textfile.foo	/^   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>REAL)$/;"	r
put	textfile.foo	/^   put$/;"	r
update_system_info	textfile.foo	/^   update_system_info ::: private$/;"	r
std_time	time.foo	/^   std_time :: TIME, public$/;"	g
current_time8	time.foo	/^   current_time8 result (time)$/;"	r
current_time5	time.foo	/^   current_time5 result (res)$/;"	r
current_date	time.foo	/^   current_date(d,m,y)$/;"	r
current_date_YMD_str	time.foo	/^   current_date_YMD_str result (res)$/;"	r
current_date_DMY_str	time.foo	/^   current_date_DMY_str result (res)$/;"	r
current_time_message	time.foo	/^   current_time_message result (res)$/;"	r
current_time_str	time.foo	/^   current_time_str result (res)$/;"	r
current_cpu_time	time.foo	/^   current_cpu_time result (res)$/;"	r
start_timing	time.foo	/^   start_timing$/;"	r
stop_timing	time.foo	/^   stop_timing$/;"	r
start_time_message	time.foo	/^   start_time_message result (res)$/;"	r
start_time_str	time.foo	/^   start_time_str result (res)$/;"	r
stop_time_message	time.foo	/^   stop_time_message result (res)$/;"	r
stop_time_str	time.foo	/^   stop_time_str result (res)$/;"	r
elapsed_time_message	time.foo	/^   elapsed_time_message(task) result (res)$/;"	r
elapsed_time_str	time.foo	/^   elapsed_time_str result (res)$/;"	r
elapsed_time5	time.foo	/^   elapsed_time5 result (time)$/;"	r
elapsed_time	time.foo	/^   elapsed_time result (secs)$/;"	r
subtract_time5s	time.foo	/^   subtract_time5s(time1,time2) result (res) ::: private$/;"	r
elapsed_cpu_time_message	time.foo	/^   elapsed_cpu_time_message(task) result (res)$/;"	r
elapsed_cpu_time	time.foo	/^   elapsed_cpu_time result (res)$/;"	r
to_julian_day	time.foo	/^   to_julian_day(j,d,m,y)$/;"	r
from_julian_day	time.foo	/^   from_julian_day(j,d,m,y)$/;"	r
seconds_to_time5	time.foo	/^   seconds_to_time5(secs) result (res) ::: private$/;"	r
time5_to_seconds	time.foo	/^   time5_to_seconds(time) result (res) ::: private$/;"	r
time5_to_DMY_HMS_str	time.foo	/^   time5_to_DMY_HMS_str(time) result (res) ::: private$/;"	r
time5_to_DHMS_str	time.foo	/^   time5_to_DHMS_str(time) result (res) ::: private$/;"	r
number_with_units	time.foo	/^   number_with_units(number,unit,comma) result (res) ::: private$/;"	r
VEC_{BIN}	types.foo	/^   type VEC_{BIN}$/;"	t
element	types.foo	/^     element :: VEC{BIN}* DEFAULT_NULL$/;"	a
VEC_{INT}	types.foo	/^   type VEC_{INT}$/;"	t
element	types.foo	/^     element :: VEC{INT}* DEFAULT_NULL$/;"	a
VEC_{REAL}	types.foo	/^   type VEC_{REAL}$/;"	t
element	types.foo	/^     element :: VEC{REAL}* DEFAULT_NULL$/;"	a
VEC{VEC_{BIN}}	types.foo	/^   array type VEC{VEC_{BIN}}$/;"	v
VEC{VEC_{INT}}	types.foo	/^   array type VEC{VEC_{INT}}$/;"	v
VEC{VEC_{REAL}}	types.foo	/^   array type VEC{VEC_{REAL}}$/;"	v
MAT{VEC_{INT}}	types.foo	/^   array type MAT{VEC_{INT}}$/;"	v
MAT{VEC_{REAL}}	types.foo	/^   array type MAT{VEC_{REAL}}$/;"	v
MAT3{VEC_{BIN}}	types.foo	/^   array type MAT3{VEC_{BIN}}$/;"	v
MAT3{VEC_{INT}}	types.foo	/^   array type MAT3{VEC_{INT}}$/;"	v
MAT3{VEC_{REAL}}	types.foo	/^   array type MAT3{VEC_{REAL}}$/;"	v
VEC_{VEC_{INT}}	types.foo	/^   type VEC_{VEC_{INT}}$/;"	t
element	types.foo	/^     element :: VEC{VEC_{INT}}* DEFAULT_NULL$/;"	a
VEC_{VEC_{REAL}}	types.foo	/^   type VEC_{VEC_{REAL}}$/;"	t
element	types.foo	/^     element :: VEC{VEC_{REAL}}* DEFAULT_NULL$/;"	a
VEC{VEC_{VEC_{INT}}}	types.foo	/^   array type VEC{VEC_{VEC_{INT}}}$/;"	v
VEC{VEC_{VEC_{REAL}}}	types.foo	/^   array type VEC{VEC_{VEC_{REAL}}}$/;"	v
MAT_{INT}	types.foo	/^   type MAT_{INT}$/;"	t
element	types.foo	/^     element :: MAT{INT}* DEFAULT_NULL$/;"	a
MAT_{REAL}	types.foo	/^   type MAT_{REAL}$/;"	t
element	types.foo	/^     element :: MAT{REAL}* DEFAULT_NULL$/;"	a
VEC{MAT_{INT}}	types.foo	/^   array type VEC{MAT_{INT}}$/;"	v
VEC{MAT_{REAL}}	types.foo	/^   array type VEC{MAT_{REAL}}$/;"	v
MAT{MAT_{REAL}}	types.foo	/^   array type MAT{MAT_{REAL}}$/;"	v
MAT3_{REAL}	types.foo	/^   type MAT3_{REAL}$/;"	t
element	types.foo	/^     element :: MAT3{REAL}* DEFAULT_NULL$/;"	a
VEC{MAT3_{REAL}}	types.foo	/^   array type VEC{MAT3_{REAL}}$/;"	v
MAT4_{REAL}	types.foo	/^   type MAT4_{REAL}$/;"	t
element	types.foo	/^     element :: MAT4{REAL}* DEFAULT_NULL$/;"	a
VEC{MAT4_{REAL}}	types.foo	/^   array type VEC{MAT4_{REAL}}$/;"	v
OPVECTOR	types.foo	/^   type OPVECTOR$/;"	t
n_bf	types.foo	/^     n_bf :: INT$/;"	a
restricted	types.foo	/^     restricted :: VEC{REAL}* DEFAULT_NULL$/;"	a
alpha	types.foo	/^     alpha :: VEC{REAL}* DEFAULT_NULL$/;"	a
beta	types.foo	/^     beta :: VEC{REAL}* DEFAULT_NULL$/;"	a
general	types.foo	/^     general :: VEC{REAL}* DEFAULT_NULL$/;"	a
OPMATRIX	types.foo	/^   type OPMATRIX$/;"	t
n_bf	types.foo	/^     n_bf :: INT$/;"	a
restricted	types.foo	/^     restricted :: MAT{REAL}* DEFAULT_NULL$/;"	a
alpha	types.foo	/^     alpha :: MAT{REAL}* DEFAULT_NULL$/;"	a
beta	types.foo	/^     beta :: MAT{REAL}* DEFAULT_NULL$/;"	a
general	types.foo	/^     general :: MAT{REAL}* DEFAULT_NULL$/;"	a
restricted_complex	types.foo	/^     restricted_complex :: MAT{CPX}* DEFAULT_NULL$/;"	a
alpha_complex	types.foo	/^     alpha_complex :: MAT{CPX}* DEFAULT_NULL$/;"	a
beta_complex	types.foo	/^     beta_complex :: MAT{CPX}* DEFAULT_NULL$/;"	a
general_complex	types.foo	/^     general_complex :: MAT{CPX}* DEFAULT_NULL$/;"	a
triangle	types.foo	/^     triangle :: VEC{REAL}* DEFAULT_NULL$/;"	a
square	types.foo	/^     square :: VEC{REAL}* DEFAULT_NULL$/;"	a
HASH{VEC{INT},VEC{INT}}	types.foo	/^   type HASH{VEC{INT},VEC{INT}}$/;"	t
n_keys	types.foo	/^     n_keys :: INT$/;"	a
n_size	types.foo	/^     n_size :: INT$/;"	a
reverse_search	types.foo	/^     reverse_search :: BIN$/;"	a
keys	types.foo	/^     keys :: MAT{INT}* DEFAULT_NULL$/;"	a
values	types.foo	/^     values :: MAT{INT}* DEFAULT_NULL$/;"	a
TIME	types.foo	/^   type TIME$/;"	t
start_time5	types.foo	/^     start_time5 :: VEC{INT}(5)$/;"	a
stop_time5	types.foo	/^     stop_time5 :: VEC{INT}(5)$/;"	a
cpu_start_time	types.foo	/^     cpu_start_time :: REAL$/;"	a
cpu_stop_time	types.foo	/^     cpu_stop_time :: REAL$/;"	a
PARALLEL	types.foo	/^   type PARALLEL$/;"	t
is_parallel	types.foo	/^     is_parallel :: BIN  DEFAULT(FALSE)$/;"	a
do_parallel_lock	types.foo	/^     do_parallel_lock :: STR  DEFAULT(" ")$/;"	a
master_rank	types.foo	/^     master_rank :: INT  DEFAULT(0)$/;"	a
processor_rank	types.foo	/^     processor_rank :: INT  DEFAULT(0)$/;"	a
n_processors	types.foo	/^     n_processors :: INT  DEFAULT(1)$/;"	a
mpi_status	types.foo	/^     mpi_status :: INT  DEFAULT(0)$/;"	a
max_n_skip_proc	types.foo	/^     max_n_skip_proc :: INT DEFAULT(0)$/;"	a
blacs_2d_context	types.foo	/^     blacs_2d_context :: VEC{INT}(50)$/;"	a
proc_grid_nrow	types.foo	/^     proc_grid_nrow :: INT DEFAULT(0)$/;"	a
proc_grid_ncol	types.foo	/^     proc_grid_ncol :: INT DEFAULT(0)$/;"	a
proc_grid_myrow	types.foo	/^     proc_grid_myrow :: INT DEFAULT(0)$/;"	a
proc_grid_mycol	types.foo	/^     proc_grid_mycol :: INT DEFAULT(0)$/;"	a
SYSTEM	types.foo	/^   type SYSTEM$/;"	t
error_status	types.foo	/^     error_status :: INT  DEFAULT(0)$/;"	a
warnings_issued	types.foo	/^     warnings_issued :: BIN  DEFAULT(FALSE)$/;"	a
error_output_unit	types.foo	/^     error_output_unit :: INT  DEFAULT(SYSTEM_ERROR_OUTPUT_UNIT)$/;"	a
keyword_echo	types.foo	/^     keyword_echo :: BIN  DEFAULT(SYSTEM_KEYWORD_ECHO)$/;"	a
memory_used	types.foo	/^     memory_used :: INT  DEFAULT(0)$/;"	a
memory_blocks_used	types.foo	/^     memory_blocks_used :: INT  DEFAULT(0)$/;"	a
max_memory_used	types.foo	/^     max_memory_used :: INT  DEFAULT(0)$/;"	a
max_memory_blocks_used	types.foo	/^     max_memory_blocks_used :: INT  DEFAULT(0)$/;"	a
memory_limit	types.foo	/^     memory_limit :: INT  DEFAULT(SYSTEM_MEMORY_LIMIT)$/;"	a
memory_limit_exceeded	types.foo	/^     memory_limit_exceeded :: BIN  DEFAULT(FALSE)$/;"	a
memory_leak_detected	types.foo	/^     memory_leak_detected :: BIN  DEFAULT(FALSE)$/;"	a
memory_leak_level	types.foo	/^     memory_leak_level :: INT  DEFAULT(0)$/;"	a
memory_units	types.foo	/^     memory_units :: STR  DEFAULT(SYSTEM_MEMORY_UNITS)$/;"	a
n_addresses	types.foo	/^     n_addresses :: INT  DEFAULT(0)$/;"	a
max_addresses	types.foo	/^     max_addresses :: INT  DEFAULT(0)$/;"	a
memory_address_stack	types.foo	/^     memory_address_stack :: VEC{INT}* DEFAULT_NULL$/;"	a
memory_amount_stack	types.foo	/^     memory_amount_stack :: VEC{INT}* DEFAULT_NULL$/;"	a
memory_call_stack	types.foo	/^     memory_call_stack :: VEC{STR}(len=BSTR_SIZE)*  DEFAULT_NULL$/;"	a
leaky_address	types.foo	/^     leaky_address :: INT  DEFAULT(0)$/;"	a
leaky_amount	types.foo	/^     leaky_amount :: INT  DEFAULT(0)$/;"	a
leaky_routine	types.foo	/^     leaky_routine :: STR  DEFAULT(" ")$/;"	a
leaky_call_stack	types.foo	/^     leaky_call_stack :: VEC{STR}*  DEFAULT_NULL$/;"	a
stack_level	types.foo	/^     stack_level :: INT  DEFAULT(0)$/;"	a
max_stack_level	types.foo	/^     max_stack_level :: INT  DEFAULT(0)$/;"	a
stack_show_min_level	types.foo	/^     stack_show_min_level :: INT  DEFAULT(-1)$/;"	a
stack_show_max_level	types.foo	/^     stack_show_max_level :: INT  DEFAULT(-1)$/;"	a
memory_used_stack	types.foo	/^     memory_used_stack :: VEC{INT}* DEFAULT_NULL$/;"	a
call_stack	types.foo	/^     call_stack :: VEC{STR}*  DEFAULT_NULL$/;"	a
flat_stack	types.foo	/^     flat_stack :: STR(len=BSTR_SIZE)  DEFAULT(" ")$/;"	a
show_call_stack	types.foo	/^     show_call_stack :: BIN  DEFAULT(FALSE)$/;"	a
io_file	types.foo	/^     io_file :: TEXTFILE*  DEFAULT_NULL$/;"	a
known_keywords	types.foo	/^     known_keywords :: VEC{STR}*  DEFAULT_NULL$/;"	a
time_stack_level	types.foo	/^     time_stack_level :: INT  DEFAULT(0)$/;"	a
time_call_stack	types.foo	/^     time_call_stack :: VEC{INT}*  DEFAULT_NULL$/;"	a
time_strt_stack	types.foo	/^     time_strt_stack :: VEC{REAL}*  DEFAULT_NULL$/;"	a
n_timed_routines	types.foo	/^     n_timed_routines :: INT  DEFAULT(0)$/;"	a
time_for_routine	types.foo	/^     time_for_routine :: VEC{REAL}*  DEFAULT_NULL$/;"	a
name_for_routine	types.foo	/^     name_for_routine :: VEC{STR}*  DEFAULT_NULL$/;"	a
n_calls_for_routine	types.foo	/^     n_calls_for_routine :: VEC{INT}*  DEFAULT_NULL$/;"	a
time_limit	types.foo	/^     time_limit :: REAL  DEFAULT(ZERO)$/;"	a
show_cumulative_time	types.foo	/^     show_cumulative_time :: BIN DEFAULT(FALSE)$/;"	a
is_parallel	types.foo	/^     is_parallel :: BIN  DEFAULT(FALSE)$/;"	a
do_parallel_lock	types.foo	/^     do_parallel_lock :: STR  DEFAULT(" ")$/;"	a
master_rank	types.foo	/^     master_rank :: INT  DEFAULT(0)$/;"	a
processor_rank	types.foo	/^     processor_rank :: INT  DEFAULT(0)$/;"	a
n_processors	types.foo	/^     n_processors :: INT  DEFAULT(1)$/;"	a
mpi_status	types.foo	/^     mpi_status :: INT  DEFAULT(0)$/;"	a
COMMAND_LINE	types.foo	/^   type COMMAND_LINE$/;"	t
n_arg	types.foo	/^     n_arg :: INT$/;"	a
arg	types.foo	/^     arg :: VEC{STR}*$/;"	a
BUFFER	types.foo	/^   type BUFFER$/;"	t
item_start	types.foo	/^     item_start :: INT$/;"	a
item_end	types.foo	/^     item_end :: INT$/;"	a
item_index	types.foo	/^     item_index :: INT$/;"	a
n_items	types.foo	/^     n_items :: INT$/;"	a
analysed	types.foo	/^     analysed :: BIN  DEFAULT(FALSE)$/;"	a
comment_chars	types.foo	/^     comment_chars :: STR  DEFAULT(BUFFER_COMMENT_CHARS)$/;"	a
quote_chars	types.foo	/^     quote_chars :: STR  DEFAULT(BUFFER_QUOTE_CHARS)$/;"	a
ignore_unmatched_quotes	types.foo	/^     ignore_unmatched_quotes :: BIN  DEFAULT(FALSE)$/;"	a
eliminate_specials	types.foo	/^     eliminate_specials :: BIN  DEFAULT(TRUE)$/;"	a
replacement_list	types.foo	/^     replacement_list :: MAT{STR}*  DEFAULT_NULL$/;"	a
string	types.foo	/^     string :: STR(len=BSTR_SIZE)  DEFAULT(" ")$/;"	a
UNIT_NUMBER	types.foo	/^   type UNIT_NUMBER$/;"	t
unit	types.foo	/^     unit :: INT$/;"	a
FILE	types.foo	/^   type FILE$/;"	t
name	types.foo	/^     name :: STR  DEFAULT("unknown")$/;"	a
unit	types.foo	/^     unit :: INT  DEFAULT(0)$/;"	a
record	types.foo	/^     record :: INT  DEFAULT(1)$/;"	a
io_status	types.foo	/^     io_status :: INT  DEFAULT(0)$/;"	a
action	types.foo	/^     action :: STR  DEFAULT("readwrite")$/;"	a
file_status	types.foo	/^     file_status :: STR  DEFAULT("unknown")$/;"	a
buffered	types.foo	/^     buffered :: BIN  DEFAULT(FALSE)$/;"	a
buffer_type	types.foo	/^     buffer_type :: STR  DEFAULT("INT")$/;"	a
int_buffer_pos	types.foo	/^     int_buffer_pos :: INT  DEFAULT(1)$/;"	a
int_buffer	types.foo	/^     int_buffer :: VEC{INT}* DEFAULT_NULL$/;"	a
real_buffer_pos	types.foo	/^     real_buffer_pos :: INT  DEFAULT(1)$/;"	a
real_buffer	types.foo	/^     real_buffer :: VEC{REAL}* DEFAULT_NULL$/;"	a
cpx_buffer_pos	types.foo	/^     cpx_buffer_pos :: INT  DEFAULT(1)$/;"	a
cpx_buffer	types.foo	/^     cpx_buffer :: VEC{CPX}* DEFAULT_NULL$/;"	a
TEXTFILE	types.foo	/^   type TEXTFILE$/;"	t
name	types.foo	/^     name :: STR  DEFAULT("unknown")$/;"	a
action	types.foo	/^     action :: STR  DEFAULT("unknown")$/;"	a
unit	types.foo	/^     unit :: INT  DEFAULT(0)$/;"	a
record	types.foo	/^     record :: INT  DEFAULT(0)$/;"	a
io_status	types.foo	/^     io_status :: INT  DEFAULT(0)$/;"	a
ignore_end_of_file	types.foo	/^     ignore_end_of_file :: BIN  DEFAULT(FALSE)$/;"	a
no_of_lines	types.foo	/^     no_of_lines :: INT DEFAULT(-1)$/;"	a
using_fields	types.foo	/^     using_fields :: BIN  DEFAULT(TEXTFILE_USE_FIELDS)$/;"	a
n_fields_per_line	types.foo	/^     n_fields_per_line :: INT  DEFAULT(TEXTFILE_N_FIELDS_PER_LINE)$/;"	a
spacing	types.foo	/^     spacing :: INT  DEFAULT(TEXTFILE_SPACING)$/;"	a
int_width	types.foo	/^     int_width :: INT  DEFAULT(TEXTFILE_INT_WIDTH)$/;"	a
real_width	types.foo	/^     real_width :: INT  DEFAULT(TEXTFILE_REAL_WIDTH)$/;"	a
real_precision	types.foo	/^     real_precision :: INT  DEFAULT(TEXTFILE_REAL_PRECISION)$/;"	a
real_style	types.foo	/^     real_style :: STR(2)  DEFAULT(TEXTFILE_REAL_STYLE)$/;"	a
line_format	types.foo	/^     line_format :: STR  DEFAULT(" ")$/;"	a
margin_width	types.foo	/^     margin_width :: INT  DEFAULT(TEXTFILE_MARGIN_WIDTH)$/;"	a
using_array_labels	types.foo	/^     using_array_labels :: BIN  DEFAULT(TEXTFILE_USE_ARRAY_LABELS)$/;"	a
default_units	types.foo	/^     default_units :: STR  DEFAULT(" ")$/;"	a
comment_chars	types.foo	/^     comment_chars :: STR  DEFAULT(TEXTFILE_COMMENT_CHARS)$/;"	a
quote_chars	types.foo	/^     quote_chars :: STR  DEFAULT(TEXTFILE_QUOTE_CHARS)$/;"	a
ignore_unmatched_quotes	types.foo	/^     ignore_unmatched_quotes :: BIN  DEFAULT(FALSE)$/;"	a
eliminate_specials	types.foo	/^     eliminate_specials :: BIN  DEFAULT(TRUE)$/;"	a
replacement_list	types.foo	/^     replacement_list :: MAT{STR}* DEFAULT_NULL$/;"	a
buffer	types.foo	/^     buffer :: BUFFER$/;"	a
internal	types.foo	/^     internal :: VEC{STR}* DEFAULT_NULL$/;"	a
saved	types.foo	/^     saved :: TEXTFILE* DEFAULT_NULL$/;"	a
TABLE_COLUMN	types.foo	/^   type TABLE_COLUMN$/;"	t
heading	types.foo	/^     heading :: STR  DEFAULT(" ")$/;"	a
subheading	types.foo	/^     subheading :: STR  DEFAULT(" ")$/;"	a
sb3heading	types.foo	/^     sb3heading :: STR  DEFAULT(" ")$/;"	a
width	types.foo	/^     width :: INT  DEFAULT(TABLE_COLUMN_WIDTH)$/;"	a
width_set	types.foo	/^     width_set :: BIN  DEFAULT(FALSE)$/;"	a
item_width	types.foo	/^     item_width :: INT  DEFAULT(TABLE_COLUMN_WIDTH)$/;"	a
item_width_set	types.foo	/^     item_width_set :: BIN  DEFAULT(FALSE)$/;"	a
real_precision	types.foo	/^     real_precision :: INT  DEFAULT(TABLE_COLUMN_REAL_PRECISION)$/;"	a
spacing	types.foo	/^     spacing :: INT  DEFAULT(TABLE_COLUMN_SPACING)$/;"	a
item_spacing	types.foo	/^     item_spacing :: INT  DEFAULT(TABLE_COLUMN_SPACING)$/;"	a
spacer	types.foo	/^     spacer :: STR  DEFAULT(TABLE_COLUMN_SPACER)$/;"	a
center	types.foo	/^     center :: BIN  DEFAULT(TABLE_COLUMN_CENTER)$/;"	a
left_justify	types.foo	/^     left_justify :: BIN  DEFAULT(TABLE_COLUMN_LEFT_JUSTIFY)$/;"	a
b_value	types.foo	/^     b_value :: VEC{BIN}*  DEFAULT_NULL$/;"	a
i_value	types.foo	/^     i_value :: VEC{INT}*  DEFAULT_NULL$/;"	a
r_value	types.foo	/^     r_value :: VEC{REAL}*  DEFAULT_NULL$/;"	a
s_value	types.foo	/^     s_value :: VEC{STR}*  DEFAULT_NULL$/;"	a
iv_value	types.foo	/^     iv_value :: VEC{VEC_{INT}}*  DEFAULT_NULL$/;"	a
VEC{TABLE_COLUMN}	types.foo	/^   array type VEC{TABLE_COLUMN}$/;"	v
ARCHIVE	types.foo	/^   type ARCHIVE$/;"	t
root_name	types.foo	/^     root_name :: STR  DEFAULT("unknown")$/;"	a
name	types.foo	/^     name :: STR  DEFAULT("unknown")$/;"	a
genre	types.foo	/^     genre :: STR  DEFAULT(" ")$/;"	a
format	types.foo	/^     format :: STR   DEFAULT(" ")$/;"	a
file	types.foo	/^     file :: FILE*  DEFAULT_NULL$/;"	a
textfile	types.foo	/^     textfile :: TEXTFILE*  DEFAULT_NULL$/;"	a
CIF	types.foo	/^   type CIF$/;"	t
file_name	types.foo	/^     file_name :: STR  DEFAULT(" ")$/;"	a
file	types.foo	/^     file :: TEXTFILE* DEFAULT_NULL$/;"	a
data_block_name	types.foo	/^     data_block_name :: STR  DEFAULT(" ")$/;"	a
start_of_data	types.foo	/^     start_of_data :: INT  DEFAULT(1)$/;"	a
end_of_data	types.foo	/^     end_of_data :: INT  DEFAULT(0)$/;"	a
data_block_found	types.foo	/^     data_block_found :: BIN  DEFAULT(FALSE)$/;"	a
BH_bond_length	types.foo	/^     BH_bond_length :: REAL  DEFAULT(-CIF_BH_BOND_LENGTH*BOHR_PER_ANGSTROM)$/;"	a
CH_bond_length	types.foo	/^     CH_bond_length :: REAL  DEFAULT(-CIF_CH_BOND_LENGTH*BOHR_PER_ANGSTROM)$/;"	a
NH_bond_length	types.foo	/^     NH_bond_length :: REAL  DEFAULT(-CIF_NH_BOND_LENGTH*BOHR_PER_ANGSTROM)$/;"	a
OH_bond_length	types.foo	/^     OH_bond_length :: REAL  DEFAULT(-CIF_OH_BOND_LENGTH*BOHR_PER_ANGSTROM)$/;"	a
U_iso_is_B_iso	types.foo	/^     U_iso_is_B_iso :: BIN  DEFAULT(FALSE)$/;"	a
U_is_B	types.foo	/^     U_is_B :: BIN  DEFAULT(FALSE)$/;"	a
U_is_beta	types.foo	/^     U_is_beta :: BIN  DEFAULT(FALSE)$/;"	a
RYS	types.foo	/^   type RYS$/;"	t
n_roots	types.foo	/^     n_roots :: INT$/;"	a
weight	types.foo	/^     weight :: VEC{REAL}* DEFAULT_NULL$/;"	a
root	types.foo	/^     root :: VEC{REAL}* DEFAULT_NULL$/;"	a
ADAPTIVE_QUADRATURE	types.foo	/^   type ADAPTIVE_QUADRATURE$/;"	t
algorithm	types.foo	/^     algorithm :: STR  DEFAULT(" ")$/;"	a
accuracy	types.foo	/^     accuracy :: REAL  DEFAULT(QUADRATURE_ACCURACY)$/;"	a
n_points	types.foo	/^     n_points :: INT  DEFAULT(0)$/;"	a
lower_limit	types.foo	/^     lower_limit :: REAL  DEFAULT(-ONE)$/;"	a
upper_limit	types.foo	/^     upper_limit :: REAL  DEFAULT(ONE)$/;"	a
point	types.foo	/^     point :: MAT{REAL}*  DEFAULT_NULL$/;"	a
weight	types.foo	/^     weight :: VEC{REAL}*  DEFAULT_NULL$/;"	a
embedded_weight	types.foo	/^     embedded_weight :: VEC{REAL}*  DEFAULT_NULL$/;"	a
QUADRATURE	types.foo	/^   type QUADRATURE$/;"	t
kind	types.foo	/^     kind :: STR  DEFAULT(" ")$/;"	a
n_points	types.foo	/^     n_points :: INT  DEFAULT(0)$/;"	a
fold_weight_function_in	types.foo	/^     fold_weight_function_in :: BIN  DEFAULT(TRUE)$/;"	a
lower_limit	types.foo	/^     lower_limit :: REAL  DEFAULT(-ONE)$/;"	a
upper_limit	types.foo	/^     upper_limit :: REAL  DEFAULT(ONE)$/;"	a
gauss_laguerre_alpha	types.foo	/^     gauss_laguerre_alpha :: REAL  DEFAULT(ONE)$/;"	a
gauss_jacobi_alpha	types.foo	/^     gauss_jacobi_alpha :: REAL  DEFAULT(ONE)$/;"	a
gauss_jacobi_beta	types.foo	/^     gauss_jacobi_beta :: REAL  DEFAULT(ONE)$/;"	a
eps	types.foo	/^     eps :: REAL  DEFAULT(QUADRATURE_EPS)$/;"	a
maxit	types.foo	/^     maxit :: INT  DEFAULT(QUADRATURE_MAXIT)$/;"	a
point	types.foo	/^     point :: VEC{REAL}*  DEFAULT_NULL$/;"	a
weight	types.foo	/^     weight :: VEC{REAL}*  DEFAULT_NULL$/;"	a
finalised	types.foo	/^     finalised :: BIN  DEFAULT(FALSE)$/;"	a
VEC{QUADRATURE}	types.foo	/^   array type VEC{QUADRATURE}$/;"	v
QUADRATURE2	types.foo	/^   type QUADRATURE2$/;"	t
n_points	types.foo	/^     n_points :: INT  DEFAULT(0)$/;"	a
point	types.foo	/^     point :: MAT{REAL}*  DEFAULT_NULL$/;"	a
weight	types.foo	/^     weight :: VEC{REAL}*  DEFAULT_NULL$/;"	a
LEBEDEV	types.foo	/^   type LEBEDEV$/;"	t
n_points	types.foo	/^     n_points :: INT  DEFAULT(0)$/;"	a
point	types.foo	/^     point :: MAT{REAL}*  DEFAULT_NULL$/;"	a
weight	types.foo	/^     weight :: VEC{REAL}*  DEFAULT_NULL$/;"	a
n_points_per_shell	types.foo	/^     n_points_per_shell :: VEC{INT}*  DEFAULT_NULL$/;"	a
REFLECTION	types.foo	/^   type REFLECTION$/;"	t
theta	types.foo	/^     theta :: REAL  DEFAULT(ZERO)$/;"	a
equivalence_factor	types.foo	/^     equivalence_factor :: INT  DEFAULT(1)$/;"	a
F_exp	types.foo	/^     F_exp :: REAL  DEFAULT(ZERO)$/;"	a
F_sigma	types.foo	/^     F_sigma :: REAL  DEFAULT(ZERO)$/;"	a
F_calc	types.foo	/^     F_calc :: CPX  DEFAULT(ZERO)$/;"	a
F_pred	types.foo	/^     F_pred :: REAL  DEFAULT(ZERO)$/;"	a
F2_exp	types.foo	/^     F2_exp :: REAL  DEFAULT(ZERO)$/;"	a
F2_sigma	types.foo	/^     F2_sigma :: REAL  DEFAULT(ZERO)$/;"	a
F2_pred	types.foo	/^     F2_pred :: REAL  DEFAULT(ZERO)$/;"	a
F2_exp_inputted	types.foo	/^     F2_exp_inputted :: BIN  DEFAULT(FALSE)$/;"	a
I_exp	types.foo	/^     I_exp :: REAL  DEFAULT(ZERO)$/;"	a
I_sigma	types.foo	/^     I_sigma :: REAL  DEFAULT(ZERO)$/;"	a
I_pred	types.foo	/^     I_pred :: REAL  DEFAULT(ZERO)$/;"	a
group	types.foo	/^     group :: INT DEFAULT(ZERO)$/;"	a
VEC{REFLECTION}	types.foo	/^   array type VEC{REFLECTION}$/;"	v
DIIS	types.foo	/^   type DIIS$/;"	t
genre	types.foo	/^     genre :: STR  DEFAULT(DIIS_GENRE)$/;"	a
iteration	types.foo	/^     iteration :: INT  DEFAULT(0)$/;"	a
start_iteration	types.foo	/^     start_iteration :: INT  DEFAULT(DIIS_START_ITERATION)$/;"	a
save_iteration	types.foo	/^     save_iteration :: INT  DEFAULT(DIIS_SAVE_ITERATION)$/;"	a
keep	types.foo	/^     keep :: INT  DEFAULT(DIIS_KEEP)$/;"	a
kept	types.foo	/^     kept :: INT  DEFAULT(0)$/;"	a
oldest	types.foo	/^     oldest :: VEC{INT}*  DEFAULT_NULL$/;"	a
new	types.foo	/^     new :: INT  DEFAULT(0)$/;"	a
error_length	types.foo	/^     error_length :: REAL  DEFAULT(ZERO)$/;"	a
convergence_tolerance	types.foo	/^     convergence_tolerance :: REAL  DEFAULT(DIIS_CONVERGENCE_TOLERANCE)$/;"	a
start_tolerance	types.foo	/^     start_tolerance :: REAL  DEFAULT(DIIS_START_TOLERANCE)$/;"	a
encore_iterations	types.foo	/^     encore_iterations :: INT  DEFAULT(DIIS_ENCORE_ITERATIONS)$/;"	a
stage	types.foo	/^     stage :: INT   DEFAULT(0)$/;"	a
encore	types.foo	/^     encore :: INT   DEFAULT(0)$/;"	a
replacement_method	types.foo	/^     replacement_method :: STR  DEFAULT(DIIS_REPLACEMENT_METHOD)$/;"	a
archive	types.foo	/^     archive :: ARCHIVE$/;"	a
par_tag	types.foo	/^     par_tag :: STR  DEFAULT("fock_matrix")$/;"	a
err_tag	types.foo	/^     err_tag :: STR  DEFAULT("pulay_error")$/;"	a
lhs_tag	types.foo	/^     lhs_tag :: STR  DEFAULT("diis_lhs")$/;"	a
lhs_tol	types.foo	/^     lhs_tol :: REAL  DEFAULT(TOL(10))$/;"	a
F_tag	types.foo	/^     F_tag :: STR  DEFAULT("fock_matrix")$/;"	a
D_tag	types.foo	/^     D_tag :: STR  DEFAULT("density_matrix")$/;"	a
J_tag	types.foo	/^     J_tag :: STR  DEFAULT("coulomb_matrix")$/;"	a
energy	types.foo	/^     energy :: VEC{REAL}*   DEFAULT_NULL$/;"	a
e_tag	types.foo	/^     e_tag :: STR  DEFAULT("energy")$/;"	a
force_convexity	types.foo	/^     force_convexity :: BIN  DEFAULT(DIIS_FORCE_CONVEXITY)$/;"	a
micro_iteration_method	types.foo	/^     micro_iteration_method :: STR   DEFAULT(DIIS_MICRO_ITERATION_METHOD)$/;"	a
micro_starting_guess	types.foo	/^     micro_starting_guess :: STR   DEFAULT(DIIS_MICRO_STARTING_GUESS)$/;"	a
micro_convergence_tol	types.foo	/^     micro_convergence_tol :: REAL  DEFAULT(DIIS_MICRO_CONVERGENCE_TOL)$/;"	a
micro_max_iterations	types.foo	/^     micro_max_iterations :: INT  DEFAULT(DIIS_MICRO_MAX_ITERATIONS)$/;"	a
micro_damp_factor	types.foo	/^     micro_damp_factor :: REAL  DEFAULT(DIIS_MICRO_DAMP_FACTOR)$/;"	a
GAUSSIAN	types.foo	/^   type GAUSSIAN$/;"	t
ex	types.foo	/^     ex :: REAL  DEFAULT(ZERO)$/;"	a
pos	types.foo	/^     pos :: VEC{REAL}(3)  DEFAULT(ZERO)$/;"	a
n_comp	types.foo	/^     n_comp :: INT, readonly  DEFAULT(0)$/;"	a
n_sph	types.foo	/^     n_sph :: INT, readonly  DEFAULT(0)$/;"	a
first_gaussian	types.foo	/^     first_gaussian :: INT, readonly  DEFAULT(0)$/;"	a
last_gaussian	types.foo	/^     last_gaussian :: INT, readonly  DEFAULT(0)$/;"	a
GAUSSIAN2	types.foo	/^   type GAUSSIAN2$/;"	t
GAUSSIAN4	types.foo	/^   type GAUSSIAN4$/;"	t
RMS_INDICES	types.foo	/^   type RMS_INDICES$/;"	t
xyz0	types.foo	/^     xyz0 :: VEC{INT}*  DEFAULT_NULL$/;"	a
yz0	types.foo	/^     yz0 :: VEC{INT}*  DEFAULT_NULL$/;"	a
xz0	types.foo	/^     xz0 :: VEC{INT}*  DEFAULT_NULL$/;"	a
xy0	types.foo	/^     xy0 :: VEC{INT}*  DEFAULT_NULL$/;"	a
z0	types.foo	/^     z0 :: VEC{INT}*  DEFAULT_NULL$/;"	a
y0	types.foo	/^     y0 :: VEC{INT}*  DEFAULT_NULL$/;"	a
x0	types.foo	/^     x0 :: VEC{INT}*  DEFAULT_NULL$/;"	a
n0	types.foo	/^     n0 :: VEC{INT}*  DEFAULT_NULL$/;"	a
a0	types.foo	/^     a0 :: VEC{INT}*  DEFAULT_NULL$/;"	a
xy_rms_n	types.foo	/^     xy_rms_n :: VEC{VEC_{INT}}*  DEFAULT_NULL$/;"	a
xy_rms_a	types.foo	/^     xy_rms_a :: VEC{VEC_{INT}}*  DEFAULT_NULL$/;"	a
yz0px	types.foo	/^     yz0px :: VEC{INT}*  DEFAULT_NULL$/;"	a
xz0py	types.foo	/^     xz0py :: VEC{INT}*  DEFAULT_NULL$/;"	a
xy0pz	types.foo	/^     xy0pz :: VEC{INT}*  DEFAULT_NULL$/;"	a
z0px	types.foo	/^     z0px :: VEC{INT}*  DEFAULT_NULL$/;"	a
z0py	types.foo	/^     z0py :: VEC{INT}*  DEFAULT_NULL$/;"	a
y0px	types.foo	/^     y0px :: VEC{INT}*  DEFAULT_NULL$/;"	a
y0pz	types.foo	/^     y0pz :: VEC{INT}*  DEFAULT_NULL$/;"	a
x0py	types.foo	/^     x0py :: VEC{INT}*  DEFAULT_NULL$/;"	a
x0pz	types.foo	/^     x0pz :: VEC{INT}*  DEFAULT_NULL$/;"	a
n1	types.foo	/^     n1 :: VEC{INT}*  DEFAULT_NULL$/;"	a
n1px	types.foo	/^     n1px :: VEC{INT}*  DEFAULT_NULL$/;"	a
n1py	types.foo	/^     n1py :: VEC{INT}*  DEFAULT_NULL$/;"	a
n1pz	types.foo	/^     n1pz :: VEC{INT}*  DEFAULT_NULL$/;"	a
n2	types.foo	/^     n2 :: VEC{VEC_{INT}}*  DEFAULT_NULL$/;"	a
n2px	types.foo	/^     n2px :: VEC{VEC_{INT}}*  DEFAULT_NULL$/;"	a
n2py	types.foo	/^     n2py :: VEC{VEC_{INT}}*  DEFAULT_NULL$/;"	a
n2pz	types.foo	/^     n2pz :: VEC{VEC_{INT}}*  DEFAULT_NULL$/;"	a
MAT{RMS_INDICES}	types.foo	/^   array type MAT{RMS_INDICES}$/;"	v
RMS2_INDICES	types.foo	/^   type RMS2_INDICES$/;"	t
ef	types.foo	/^     ef :: VEC{INT}*  DEFAULT_NULL$/;"	a
efx	types.foo	/^     efx :: VEC{INT}*  DEFAULT_NULL$/;"	a
efy	types.foo	/^     efy :: VEC{INT}*  DEFAULT_NULL$/;"	a
efz	types.foo	/^     efz :: VEC{INT}*  DEFAULT_NULL$/;"	a
no_Ixy_is_1	types.foo	/^     no_Ixy_is_1 :: INT$/;"	a
no_Ixy_is_x	types.foo	/^     no_Ixy_is_x :: INT$/;"	a
no_Ixy_is_y	types.foo	/^     no_Ixy_is_y :: INT$/;"	a
do_Ixy_is_x	types.foo	/^     do_Ixy_is_x :: VEC{BIN}*  DEFAULT_NULL$/;"	a
do_Ixy_is_y	types.foo	/^     do_Ixy_is_y :: VEC{BIN}*  DEFAULT_NULL$/;"	a
do_Ixy	types.foo	/^     do_Ixy :: VEC{BIN}*  DEFAULT_NULL$/;"	a
MAT{RMS2_INDICES}	types.foo	/^   array type MAT{RMS2_INDICES}$/;"	v
MAT4{RMS2_INDICES}	types.foo	/^   array type MAT4{RMS2_INDICES}$/;"	v
GAUSSIAN_DATA	types.foo	/^   type GAUSSIAN_DATA$/;"	t
l_max	types.foo	/^     l_max :: INT$/;"	a
SHELL	types.foo	/^   type SHELL$/;"	t
l_chr	types.foo	/^     l_chr :: STR, readonly  DEFAULT(" ")$/;"	a
is_spherical	types.foo	/^     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)$/;"	a
n_comp	types.foo	/^     n_comp :: INT, readonly  DEFAULT(0)$/;"	a
n_sph	types.foo	/^     n_sph :: INT, readonly  DEFAULT(0)$/;"	a
n_bf	types.foo	/^     n_bf :: INT, readonly  DEFAULT(0)$/;"	a
first_gaussian	types.foo	/^     first_gaussian :: INT, readonly  DEFAULT(0)$/;"	a
last_gaussian	types.foo	/^     last_gaussian :: INT, readonly  DEFAULT(0)$/;"	a
n_cc	types.foo	/^     n_cc :: INT  DEFAULT(0)$/;"	a
ex	types.foo	/^     ex :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc	types.foo	/^     cc :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc_s	types.foo	/^     cc_s :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc_p	types.foo	/^     cc_p :: VEC{REAL}* DEFAULT_NULL$/;"	a
VEC{SHELL}	types.foo	/^   array type VEC{SHELL}$/;"	v
SHELL1	types.foo	/^   type SHELL1$/;"	t
l_chr	types.foo	/^     l_chr :: STR, readonly  DEFAULT(" ")$/;"	a
is_spherical	types.foo	/^     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)$/;"	a
n_comp	types.foo	/^     n_comp :: INT, readonly  DEFAULT(0)$/;"	a
n_sph	types.foo	/^     n_sph :: INT, readonly  DEFAULT(0)$/;"	a
n_bf	types.foo	/^     n_bf :: INT, readonly  DEFAULT(0)$/;"	a
first_gaussian	types.foo	/^     first_gaussian :: INT, readonly  DEFAULT(0)$/;"	a
last_gaussian	types.foo	/^     last_gaussian :: INT, readonly  DEFAULT(0)$/;"	a
n_cc	types.foo	/^     n_cc :: INT  DEFAULT(0)$/;"	a
pos	types.foo	/^     pos :: VEC{REAL}(3)  DEFAULT(ZERO)$/;"	a
ex	types.foo	/^     ex :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc	types.foo	/^     cc :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc_s	types.foo	/^     cc_s :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc_p	types.foo	/^     cc_p :: VEC{REAL}* DEFAULT_NULL$/;"	a
SHELL2	types.foo	/^   type SHELL2$/;"	t
is_spherical	types.foo	/^     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)$/;"	a
n_gaussian_pairs	types.foo	/^     n_gaussian_pairs :: INT, readonly$/;"	a
l_max	types.foo	/^     l_max :: INT, readonly$/;"	a
l_min	types.foo	/^     l_min :: INT, readonly$/;"	a
l_sum	types.foo	/^     l_sum :: INT, readonly$/;"	a
first_gaussian	types.foo	/^     first_gaussian :: INT, readonly$/;"	a
last_gaussian	types.foo	/^     last_gaussian :: INT, readonly$/;"	a
n_gaussian	types.foo	/^     n_gaussian :: INT, readonly$/;"	a
destroy_all	types.foo	/^     destroy_all :: BIN, readonly$/;"	a
exponent_sum	types.foo	/^     exponent_sum :: VEC{REAL}* DEFAULT_NULL$/;"	a
exponent_inv	types.foo	/^     exponent_inv :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc_prefactor	types.foo	/^     cc_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc_s_prefactor	types.foo	/^     cc_s_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc_p_prefactor	types.foo	/^     cc_p_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
same_center	types.foo	/^     same_center :: BIN$/;"	a
pair_center	types.foo	/^     pair_center :: MAT{REAL}* DEFAULT_NULL$/;"	a
center_diff	types.foo	/^     center_diff :: MAT{REAL}* DEFAULT_NULL$/;"	a
SHELL1PAIR	types.foo	/^   type SHELL1PAIR$/;"	t
n_gaussian_pairs	types.foo	/^     n_gaussian_pairs :: INT, readonly$/;"	a
n_comp_pairs	types.foo	/^     n_comp_pairs :: INT, readonly$/;"	a
n_sph_pairs	types.foo	/^     n_sph_pairs :: INT, readonly$/;"	a
n_bf_pairs	types.foo	/^     n_bf_pairs :: INT, readonly$/;"	a
l_max	types.foo	/^     l_max :: INT, readonly$/;"	a
l_min	types.foo	/^     l_min :: INT, readonly$/;"	a
l_sum	types.foo	/^     l_sum :: INT, readonly$/;"	a
first_gaussian	types.foo	/^     first_gaussian :: INT, readonly$/;"	a
last_gaussian	types.foo	/^     last_gaussian :: INT, readonly$/;"	a
n_gaussian	types.foo	/^     n_gaussian :: INT, readonly$/;"	a
exponent_sum	types.foo	/^     exponent_sum :: VEC{REAL}* DEFAULT_NULL$/;"	a
exponent_inv	types.foo	/^     exponent_inv :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc_prefactor	types.foo	/^     cc_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc_s_prefactor	types.foo	/^     cc_s_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
cc_p_prefactor	types.foo	/^     cc_p_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
pair_center	types.foo	/^     pair_center :: MAT{REAL}* DEFAULT_NULL$/;"	a
center_diff	types.foo	/^     center_diff :: MAT{REAL}* DEFAULT_NULL$/;"	a
MAT{SHELL1PAIR}	types.foo	/^   array type MAT{SHELL1PAIR}$/;"	v
SHELL4	types.foo	/^   type SHELL4$/;"	t
is_spherical	types.foo	/^     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)$/;"	a
SHELL1QUARTET	types.foo	/^   type SHELL1QUARTET$/;"	t
is_spherical	types.foo	/^     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)$/;"	a
ab_nullify	types.foo	/^     ab_nullify :: BIN$/;"	a
cd_nullify	types.foo	/^     cd_nullify :: BIN$/;"	a
ab_n_gaussian_pairs	types.foo	/^     ab_n_gaussian_pairs :: INT$/;"	a
ab_n_comp_pairs	types.foo	/^     ab_n_comp_pairs :: INT$/;"	a
ab_n_sph_pairs	types.foo	/^     ab_n_sph_pairs :: INT$/;"	a
ab_n_bf_pairs	types.foo	/^     ab_n_bf_pairs :: INT$/;"	a
ab_l_max	types.foo	/^     ab_l_max :: INT$/;"	a
ab_l_min	types.foo	/^     ab_l_min :: INT$/;"	a
ab_l_tri	types.foo	/^     ab_l_tri :: INT$/;"	a
ab_l_sum	types.foo	/^     ab_l_sum :: INT$/;"	a
ab_first_gaussian	types.foo	/^     ab_first_gaussian :: INT$/;"	a
ab_last_gaussian	types.foo	/^     ab_last_gaussian :: INT$/;"	a
n_ab	types.foo	/^     n_ab :: INT$/;"	a
ab_exponent_sum	types.foo	/^     ab_exponent_sum :: VEC{REAL}* DEFAULT_NULL$/;"	a
ab_exponent_inv	types.foo	/^     ab_exponent_inv :: VEC{REAL}* DEFAULT_NULL$/;"	a
ab_cc_prefactor	types.foo	/^     ab_cc_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
ab_cc_s_prefactor	types.foo	/^     ab_cc_s_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
ab_cc_p_prefactor	types.foo	/^     ab_cc_p_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
ab_same_center	types.foo	/^     ab_same_center :: BIN$/;"	a
ab_pair_center	types.foo	/^     ab_pair_center :: MAT{REAL}* DEFAULT_NULL$/;"	a
ab_center_diff	types.foo	/^     ab_center_diff :: MAT{REAL}* DEFAULT_NULL$/;"	a
cd_n_gaussian_pairs	types.foo	/^     cd_n_gaussian_pairs :: INT$/;"	a
cd_n_comp_pairs	types.foo	/^     cd_n_comp_pairs :: INT$/;"	a
cd_n_sph_pairs	types.foo	/^     cd_n_sph_pairs :: INT$/;"	a
cd_n_bf_pairs	types.foo	/^     cd_n_bf_pairs :: INT$/;"	a
cd_l_max	types.foo	/^     cd_l_max :: INT$/;"	a
cd_l_min	types.foo	/^     cd_l_min :: INT$/;"	a
cd_l_tri	types.foo	/^     cd_l_tri :: INT$/;"	a
cd_l_sum	types.foo	/^     cd_l_sum :: INT$/;"	a
cd_first_gaussian	types.foo	/^     cd_first_gaussian :: INT$/;"	a
cd_last_gaussian	types.foo	/^     cd_last_gaussian :: INT$/;"	a
n_cd	types.foo	/^     n_cd :: INT$/;"	a
cd_exponent_sum	types.foo	/^     cd_exponent_sum :: VEC{REAL}* DEFAULT_NULL$/;"	a
cd_exponent_inv	types.foo	/^     cd_exponent_inv :: VEC{REAL}* DEFAULT_NULL$/;"	a
cd_cc_prefactor	types.foo	/^     cd_cc_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
cd_cc_s_prefactor	types.foo	/^     cd_cc_s_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
cd_cc_p_prefactor	types.foo	/^     cd_cc_p_prefactor :: VEC{REAL}* DEFAULT_NULL$/;"	a
cd_same_center	types.foo	/^     cd_same_center :: BIN$/;"	a
cd_pair_center	types.foo	/^     cd_pair_center :: MAT{REAL}* DEFAULT_NULL$/;"	a
cd_center_diff	types.foo	/^     cd_center_diff :: MAT{REAL}* DEFAULT_NULL$/;"	a
ab_form_3dints_x_indices	types.foo	/^     ab_form_3dints_x_indices :: VEC{INT}* DEFAULT_NULL$/;"	a
ab_form_3dints_y_indices	types.foo	/^     ab_form_3dints_y_indices :: VEC{INT}* DEFAULT_NULL$/;"	a
ab_form_3dints_z_indices	types.foo	/^     ab_form_3dints_z_indices :: VEC{INT}* DEFAULT_NULL$/;"	a
ab_form_3dints_yz_rms_indices	types.foo	/^     ab_form_3dints_yz_rms_indices :: VEC{INT}* DEFAULT_NULL$/;"	a
cd_form_3dints_x_indices	types.foo	/^     cd_form_3dints_x_indices :: VEC{INT}* DEFAULT_NULL$/;"	a
cd_form_3dints_y_indices	types.foo	/^     cd_form_3dints_y_indices :: VEC{INT}* DEFAULT_NULL$/;"	a
cd_form_3dints_z_indices	types.foo	/^     cd_form_3dints_z_indices :: VEC{INT}* DEFAULT_NULL$/;"	a
cd_form_3dints_yz_rms_indices	types.foo	/^     cd_form_3dints_yz_rms_indices :: VEC{INT}* DEFAULT_NULL$/;"	a
r2ab	types.foo	/^     r2ab :: REAL$/;"	a
r2cd	types.foo	/^     r2cd :: REAL$/;"	a
BASIS	types.foo	/^   type BASIS$/;"	t
label	types.foo	/^     label :: STR$/;"	a
is_spherical	types.foo	/^     is_spherical :: BIN   DEFAULT(FALSE)$/;"	a
n_shell	types.foo	/^     n_shell :: INT$/;"	a
n_bf	types.foo	/^     n_bf :: INT$/;"	a
n_prim	types.foo	/^     n_prim :: INT$/;"	a
shell	types.foo	/^     shell :: VEC{SHELL}* DEFAULT_NULL$/;"	a
VEC{BASIS}	types.foo	/^   array type VEC{BASIS}$/;"	v
INTERPOLATOR	types.foo	/^   type INTERPOLATOR$/;"	t
interpolation_method	types.foo	/^     interpolation_method :: STR, readonly  DEFAULT(INTERPOLATOR_INTERPOLATION_METHOD)$/;"	a
interpolation_is_spline	types.foo	/^     interpolation_is_spline :: BIN, readonly  DEFAULT(FALSE)$/;"	a
range_mapping	types.foo	/^     range_mapping :: STR, readonly  DEFAULT(INTERPOLATOR_RANGE_MAPPING)$/;"	a
range_is_logarithmic	types.foo	/^     range_is_logarithmic :: BIN, readonly  DEFAULT(FALSE)$/;"	a
domain_mapping	types.foo	/^     domain_mapping :: STR, readonly  DEFAULT(INTERPOLATOR_DOMAIN_MAPPING)$/;"	a
domain_scale_factor	types.foo	/^     domain_scale_factor :: REAL, readonly  DEFAULT(ZERO)$/;"	a
domain_is_sqrt	types.foo	/^     domain_is_sqrt :: BIN, readonly  DEFAULT(FALSE)$/;"	a
domain_is_sqrt_x1x	types.foo	/^     domain_is_sqrt_x1x :: BIN, readonly  DEFAULT(FALSE)$/;"	a
table_origin	types.foo	/^     table_origin :: REAL  DEFAULT(INTERPOLATOR_TABLE_ORIGIN)$/;"	a
table_length	types.foo	/^     table_length :: REAL  DEFAULT(INTERPOLATOR_TABLE_LENGTH)$/;"	a
table_spacing	types.foo	/^     table_spacing :: REAL  DEFAULT(INTERPOLATOR_TABLE_SPACING)$/;"	a
table_eps	types.foo	/^     table_eps :: REAL  DEFAULT(INTERPOLATOR_TABLE_EPS)$/;"	a
n_data	types.foo	/^     n_data :: INT  DEFAULT(0)$/;"	a
data_point	types.foo	/^     data_point :: VEC{REAL}*  DEFAULT_NULL$/;"	a
data_value	types.foo	/^     data_value :: VEC{REAL}*  DEFAULT_NULL$/;"	a
finalised	types.foo	/^     finalised :: BIN  DEFAULT(FALSE)$/;"	a
y2	types.foo	/^     y2 :: VEC{REAL}*  DEFAULT_NULL$/;"	a
y1_initial	types.foo	/^     y1_initial :: REAL  DEFAULT(INTERPOLATOR_Y1_INITIAL)$/;"	a
y1_final	types.foo	/^     y1_final :: REAL  DEFAULT(INTERPOLATOR_Y1_FINAL)$/;"	a
VEC{INTERPOLATOR}	types.foo	/^   array type VEC{INTERPOLATOR}$/;"	v
SLATERSHELL	types.foo	/^   type SLATERSHELL$/;"	t
l_chr	types.foo	/^     l_chr :: STR, readonly  DEFAULT(" ")$/;"	a
n_comp	types.foo	/^     n_comp :: INT, readonly  DEFAULT(0)$/;"	a
n_orb	types.foo	/^     n_orb :: INT, readonly DEFAULT(0)$/;"	a
n_prim	types.foo	/^     n_prim :: INT, readonly  DEFAULT(0)$/;"	a
orb_kind	types.foo	/^     orb_kind :: VEC{STR}* DEFAULT_NULL$/;"	a
occupancy	types.foo	/^     occupancy :: VEC{INT}* DEFAULT_NULL$/;"	a
VEC{SLATERSHELL}	types.foo	/^   array type VEC{SLATERSHELL}$/;"	v
SLATERBASIS	types.foo	/^   type SLATERBASIS$/;"	t
label	types.foo	/^     label :: STR$/;"	a
configuration	types.foo	/^     configuration :: STR$/;"	a
n_shell	types.foo	/^     n_shell :: INT$/;"	a
n_bf	types.foo	/^     n_bf :: INT$/;"	a
n_prim	types.foo	/^     n_prim :: INT$/;"	a
shell	types.foo	/^     shell :: VEC{SLATERSHELL}*  DEFAULT_NULL$/;"	a
use_interpolator	types.foo	/^     use_interpolator :: BIN  DEFAULT(TRUE)$/;"	a
interpolator	types.foo	/^     interpolator :: INTERPOLATOR*  DEFAULT_NULL$/;"	a
d1_interpolator	types.foo	/^     d1_interpolator :: INTERPOLATOR*  DEFAULT_NULL$/;"	a
d2_interpolator	types.foo	/^     d2_interpolator :: INTERPOLATOR*  DEFAULT_NULL$/;"	a
VEC{SLATERBASIS}	types.foo	/^   array type VEC{SLATERBASIS}$/;"	v
COPPENSORBITAL	types.foo	/^   type COPPENSORBITAL$/;"	t
orb_kind	types.foo	/^     orb_kind :: STR, readonly$/;"	a
occupancy	types.foo	/^     occupancy :: INT, readonly$/;"	a
n_fun	types.foo	/^     n_fun :: INT, readonly$/;"	a
VEC{COPPENSORBITAL}	types.foo	/^   array type VEC{COPPENSORBITAL}$/;"	v
COPPENSBASIS	types.foo	/^   type COPPENSBASIS$/;"	t
label	types.foo	/^     label :: STR$/;"	a
n_orb	types.foo	/^     n_orb :: INT$/;"	a
n_prim	types.foo	/^     n_prim :: INT$/;"	a
orbital	types.foo	/^     orbital :: VEC{COPPENSORBITAL}*  DEFAULT_NULL$/;"	a
use_interpolator	types.foo	/^     use_interpolator :: BIN  DEFAULT(TRUE)$/;"	a
interpolator	types.foo	/^     interpolator :: INTERPOLATOR*  DEFAULT_NULL$/;"	a
VEC{COPPENSBASIS}	types.foo	/^   array type VEC{COPPENSBASIS}$/;"	v
ATOM	types.foo	/^   type ATOM$/;"	t
label	types.foo	/^     label :: STR  DEFAULT("?")$/;"	a
tag	types.foo	/^     tag :: STR  DEFAULT(" ")$/;"	a
atomic_number	types.foo	/^     atomic_number :: INT  DEFAULT(0)$/;"	a
nuclear_charge	types.foo	/^     nuclear_charge :: REAL  DEFAULT(ZERO)$/;"	a
oxidation_state	types.foo	/^     oxidation_state :: INT   DEFAULT(0)$/;"	a
pos	types.foo	/^     pos :: VEC{REAL}(3)  DEFAULT([ZERO,ZERO,ZERO])$/;"	a
axis_system	types.foo	/^     axis_system :: STR  DEFAULT("cartesian")$/;"	a
U_iso	types.foo	/^     U_iso :: REAL  DEFAULT(ZERO)$/;"	a
thermal_tensor	types.foo	/^     thermal_tensor :: MAT{REAL}(3,3)  DEFAULT(ZERO)$/;"	a
thermal_axis_system	types.foo	/^     thermal_axis_system :: STR  DEFAULT("cartesian")$/;"	a
charge	types.foo	/^     charge :: REAL  DEFAULT(ZERO)$/;"	a
dipole	types.foo	/^     dipole :: VEC{REAL}(3)  DEFAULT(ZERO)$/;"	a
quadrupole	types.foo	/^     quadrupole :: MAT{REAL}(3,3)  DEFAULT(ZERO)$/;"	a
spin	types.foo	/^     spin :: REAL  DEFAULT(ZERO)$/;"	a
spin_dipole	types.foo	/^     spin_dipole :: VEC{REAL}(3)  DEFAULT(ZERO)$/;"	a
spin_quadrupole	types.foo	/^     spin_quadrupole :: MAT{REAL}(3,3)  DEFAULT(ZERO)$/;"	a
charge_polarisability	types.foo	/^     charge_polarisability :: VEC{REAL}(3)  DEFAULT(ZERO)$/;"	a
dipole_polarisability	types.foo	/^     dipole_polarisability :: MAT{REAL}(3,3)  DEFAULT(ZERO)$/;"	a
basis_label	types.foo	/^     basis_label :: STR  DEFAULT(" ")$/;"	a
basis_kind	types.foo	/^     basis_kind :: STR  DEFAULT(" ")$/;"	a
basis	types.foo	/^     basis :: BASIS* DEFAULT_NULL$/;"	a
slaterbasis_label	types.foo	/^     slaterbasis_label :: STR  DEFAULT(" ")$/;"	a
slaterbasis	types.foo	/^     slaterbasis :: SLATERBASIS* DEFAULT_NULL$/;"	a
coppensbasis_label	types.foo	/^     coppensbasis_label :: STR  DEFAULT(" ")$/;"	a
coppensbasis	types.foo	/^     coppensbasis :: COPPENSBASIS* DEFAULT_NULL$/;"	a
atomic_orbitals	types.foo	/^     atomic_orbitals :: OPMATRIX* DEFAULT_NULL$/;"	a
density_matrix	types.foo	/^     density_matrix :: OPMATRIX* DEFAULT_NULL$/;"	a
natural_orbitals	types.foo	/^     natural_orbitals :: OPMATRIX* DEFAULT_NULL$/;"	a
occupation_numbers	types.foo	/^     occupation_numbers :: OPVECTOR* DEFAULT_NULL$/;"	a
use_interpolator	types.foo	/^     use_interpolator :: BIN  DEFAULT(TRUE)$/;"	a
interpolator	types.foo	/^     interpolator :: INTERPOLATOR*  DEFAULT_NULL$/;"	a
first_basis_fn_for_shell	types.foo	/^     first_basis_fn_for_shell :: VEC{INT}* DEFAULT_NULL$/;"	a
last_basis_fn_for_shell	types.foo	/^     last_basis_fn_for_shell :: VEC{INT}* DEFAULT_NULL$/;"	a
precomputed_basis_shellpair	types.foo	/^     precomputed_basis_shellpair :: MAT{SHELL1PAIR}* DEFAULT_NULL$/;"	a
energy	types.foo	/^     energy :: REAL$/;"	a
group	types.foo	/^     group :: INT  DEFAULT(1)$/;"	a
invariom_label	types.foo	/^     invariom_label :: STR  DEFAULT(" ")$/;"	a
protein_strand	types.foo	/^     protein_strand :: INT   DEFAULT(0)$/;"	a
residue_atom_code	types.foo	/^     residue_atom_code :: STR  DEFAULT(" ")$/;"	a
residue_code	types.foo	/^     residue_code :: STR  DEFAULT(" ")$/;"	a
residue_sequence_number	types.foo	/^     residue_sequence_number :: INT  DEFAULT(0)$/;"	a
mm_forcefield_name	types.foo	/^     mm_forcefield_name :: STR  DEFAULT(" ")$/;"	a
mm_atom_type	types.foo	/^     mm_atom_type :: STR  DEFAULT(" ")$/;"	a
mm_charge	types.foo	/^     mm_charge :: REAL  DEFAULT(ZERO)$/;"	a
restraining_position	types.foo	/^     restraining_position :: VEC{REAL}(3)  DEFAULT(ZERO)$/;"	a
restraining_force_constant	types.foo	/^     restraining_force_constant :: REAL  DEFAULT(ZERO)$/;"	a
site_occupancy	types.foo	/^     site_occupancy :: REAL  DEFAULT(ONE)$/;"	a
site_disorder_group	types.foo	/^     site_disorder_group :: INT  DEFAULT(ZERO)$/;"	a
VEC{ATOM}	types.foo	/^   array type VEC{ATOM}$/;"	v
ATOM_GROUP	types.foo	/^   type ATOM_GROUP$/;"	t
name	types.foo	/^     name :: STR  DEFAULT(" "), readonly$/;"	a
n_atoms	types.foo	/^     n_atoms :: INT   DEFAULT(0)$/;"	a
atom_index	types.foo	/^     atom_index :: VEC{INT}*, readonly  DEFAULT_NULL$/;"	a
charge	types.foo	/^     charge :: INT, readonly  DEFAULT(0)$/;"	a
n_MOs	types.foo	/^     n_MOs :: INT, readonly  DEFAULT(0)$/;"	a
atom	types.foo	/^     atom :: VEC{ATOM}*, readonly  DEFAULT_NULL$/;"	a
mol	types.foo	/^     mol :: MOLECULE*  DEFAULT_NULL$/;"	a
VEC{ATOM_GROUP}	types.foo	/^   array type VEC{ATOM_GROUP}$/;"	v
PLOT_GRID	types.foo	/^   type PLOT_GRID$/;"	t
plot_kind	types.foo	/^     plot_kind :: STR  DEFAULT(" ")$/;"	a
orbital	types.foo	/^     orbital :: INT  DEFAULT(0)$/;"	a
HOMO_orbital	types.foo	/^     HOMO_orbital :: INT  DEFAULT(0)$/;"	a
LUMO_orbital	types.foo	/^     LUMO_orbital :: INT  DEFAULT(0)$/;"	a
bond_density_atom	types.foo	/^     bond_density_atom :: VEC{INT}*   DEFAULT_NULL$/;"	a
interpolator	types.foo	/^     interpolator :: INTERPOLATOR*  DEFAULT_NULL$/;"	a
n_x	types.foo	/^     n_x :: INT  DEFAULT(PLOT_GRID_NX)$/;"	a
n_y	types.foo	/^     n_y :: INT  DEFAULT(PLOT_GRID_NY)$/;"	a
n_z	types.foo	/^     n_z :: INT  DEFAULT(PLOT_GRID_NZ)$/;"	a
n_pt	types.foo	/^     n_pt :: INT  DEFAULT(0)$/;"	a
atom	types.foo	/^     atom :: VEC{ATOM}* DEFAULT_NULL$/;"	a
destroy_atom	types.foo	/^     destroy_atom :: BIN  DEFAULT(FALSE)$/;"	a
centre_atom	types.foo	/^     centre_atom :: INT  DEFAULT(0)$/;"	a
del_x	types.foo	/^     del_x :: REAL  DEFAULT(ONE)$/;"	a
del_y	types.foo	/^     del_y :: REAL  DEFAULT(ONE)$/;"	a
del_z	types.foo	/^     del_z :: REAL  DEFAULT(ONE)$/;"	a
centre	types.foo	/^     centre :: VEC{REAL}(3)  DEFAULT(ZERO)$/;"	a
origin	types.foo	/^     origin :: VEC{REAL}(3)  DEFAULT(ZERO)$/;"	a
x_axis	types.foo	/^     x_axis :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_X_AXIS)$/;"	a
y_axis	types.foo	/^     y_axis :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_Y_AXIS)$/;"	a
z_axis	types.foo	/^     z_axis :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_Z_AXIS)$/;"	a
width	types.foo	/^     width :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_WIDTH)$/;"	a
offset	types.foo	/^     offset :: VEC{REAL}(3)  DEFAULT(ZERO)$/;"	a
x_width_set	types.foo	/^     x_width_set :: BIN  DEFAULT(TRUE)$/;"	a
y_width_set	types.foo	/^     y_width_set :: BIN  DEFAULT(TRUE)$/;"	a
z_width_set	types.foo	/^     z_width_set :: BIN  DEFAULT(TRUE)$/;"	a
x_axis_defined	types.foo	/^     x_axis_defined :: BIN  DEFAULT(FALSE)$/;"	a
y_axis_defined	types.foo	/^     y_axis_defined :: BIN  DEFAULT(FALSE)$/;"	a
z_axis_defined	types.foo	/^     z_axis_defined :: BIN  DEFAULT(FALSE)$/;"	a
box_centre	types.foo	/^     box_centre :: VEC{REAL}(3)$/;"	a
bounding_box	types.foo	/^     bounding_box :: VEC{REAL}(3)$/;"	a
box_scale_factor	types.foo	/^     box_scale_factor :: REAL$/;"	a
box_axes	types.foo	/^     box_axes :: MAT{REAL}(3,3)$/;"	a
use_unit_cell_as_bbox	types.foo	/^     use_unit_cell_as_bbox :: BIN   DEFAULT(FALSE)$/;"	a
desired_separation	types.foo	/^     desired_separation :: REAL  DEFAULT(ZERO)$/;"	a
plot_units	types.foo	/^     plot_units :: STR  DEFAULT(" ")$/;"	a
plot_format	types.foo	/^     plot_format :: STR  DEFAULT(" ")$/;"	a
use_plot_max	types.foo	/^     use_plot_max :: BIN   DEFAULT(FALSE)$/;"	a
use_plot_min	types.foo	/^     use_plot_min :: BIN   DEFAULT(FALSE)$/;"	a
plot_max	types.foo	/^     plot_max :: REAL   DEFAULT(ZERO)$/;"	a
plot_min	types.foo	/^     plot_min :: REAL   DEFAULT(ZERO)$/;"	a
DFT_FUNCTIONAL	types.foo	/^   type DFT_FUNCTIONAL$/;"	t
name	types.foo	/^     name :: STR  DEFAULT(" ")$/;"	a
Xalpha	types.foo	/^     Xalpha :: REAL  DEFAULT(DFT_FUNCTIONAL_XALPHA)$/;"	a
rho_cutoff	types.foo	/^     rho_cutoff :: REAL   DEFAULT(DFT_FUNCTIONAL_RHO_CUTOFF)$/;"	a
BECKE_GRID	types.foo	/^   type BECKE_GRID$/;"	t
kind	types.foo	/^     kind :: STR  DEFAULT(BECKE_GRID_KIND)$/;"	a
atom	types.foo	/^     atom :: VEC{ATOM}*  DEFAULT_NULL$/;"	a
atom_Z	types.foo	/^     atom_Z :: VEC{INT}*  DEFAULT_NULL$/;"	a
atom_pos	types.foo	/^     atom_pos :: MAT{REAL}*  DEFAULT_NULL$/;"	a
atom_zeta	types.foo	/^     atom_zeta :: VEC{REAL}*  DEFAULT_NULL$/;"	a
atom_lowest_exponents	types.foo	/^     atom_lowest_exponents :: VEC{REAL}* DEFAULT_NULL$/;"	a
atom_min_distance	types.foo	/^     atom_min_distance :: VEC{REAL}*, private  DEFAULT_NULL$/;"	a
n_unique_atoms	types.foo	/^     n_unique_atoms :: INT, private$/;"	a
unique_atom	types.foo	/^     unique_atom :: VEC{INT}*, private  DEFAULT_NULL$/;"	a
unique_atom_for	types.foo	/^     unique_atom_for :: VEC{INT}*, private  DEFAULT_NULL$/;"	a
basis_function_cutoff	types.foo	/^     basis_function_cutoff :: REAL  DEFAULT(BECKE_GRID_BASIS_FUNCTION_CUTOFF)$/;"	a
basis_function_pair_cutoff	types.foo	/^     basis_function_pair_cutoff :: REAL  DEFAULT(BECKE_GRID_RHO_CUTOFF)$/;"	a
partition_cutoff	types.foo	/^     partition_cutoff :: REAL  DEFAULT(BECKE_GRID_PARTITION_CUTOFF)$/;"	a
rho_cutoff	types.foo	/^     rho_cutoff :: REAL   DEFAULT(BECKE_GRID_RHO_CUTOFF)$/;"	a
n_radial_points	types.foo	/^     n_radial_points ::  INT DEFAULT(0)$/;"	a
n_extra_points_per_shell	types.foo	/^     n_extra_points_per_shell :: INT DEFAULT(BECKE_GRID_EXTRA_POINTS_PER_SHELL)$/;"	a
accuracy	types.foo	/^     accuracy :: STR  DEFAULT(BECKE_GRID_ACCURACY)$/;"	a
l_angular_grid	types.foo	/^     l_angular_grid :: INT DEFAULT(0)$/;"	a
l_H_angular_grid	types.foo	/^     l_H_angular_grid :: INT DEFAULT(0)$/;"	a
pruning_scheme	types.foo	/^     pruning_scheme :: STR  DEFAULT(BECKE_GRID_PRUNING_SCHEME)$/;"	a
reduce_H_angular_grid	types.foo	/^     reduce_H_angular_grid :: BIN  DEFAULT(BECKE_GRID_REDUCE_H_ANGULAR_GRID)$/;"	a
scale_atomic_grids	types.foo	/^     scale_atomic_grids :: BIN  DEFAULT(BECKE_GRID_SCALE_ATOMIC_GRIDS)$/;"	a
partition_power	types.foo	/^     partition_power :: INT  DEFAULT(BECKE_GRID_PARTITION_POWER)$/;"	a
stratmann_scuseria_A	types.foo	/^     stratmann_scuseria_A :: REAL  DEFAULT(BECKE_GRID_STRATMANN_SCUSERIA_A)$/;"	a
atom_n1_SS	types.foo	/^     atom_n1_SS :: VEC{INT}*, private  DEFAULT_NULL$/;"	a
partition_scheme	types.foo	/^     partition_scheme :: STR  DEFAULT(BECKE_GRID_PARTITION_SCHEME)$/;"	a
partition_scaling_scheme	types.foo	/^     partition_scaling_scheme :: STR  DEFAULT(BECKE_GRID_PARTITION_SCALING_SCHEME)$/;"	a
finalized	types.foo	/^     finalized :: BIN  DEFAULT(FALSE)$/;"	a
n_points_for_row	types.foo	/^     n_points_for_row :: VEC{INT}*, private  DEFAULT_NULL$/;"	a
radial_grid	types.foo	/^     radial_grid :: VEC{QUADRATURE}*  DEFAULT_NULL$/;"	a
lebedev_grid	types.foo	/^     lebedev_grid :: LEBEDEV*  DEFAULT_NULL$/;"	a
lebedev_H_grid	types.foo	/^     lebedev_H_grid :: LEBEDEV*  DEFAULT_NULL$/;"	a
lebedev_L3_grid	types.foo	/^     lebedev_L3_grid :: LEBEDEV*  DEFAULT_NULL$/;"	a
lebedev_L5_grid	types.foo	/^     lebedev_L5_grid :: LEBEDEV*  DEFAULT_NULL$/;"	a
lebedev_L7_grid	types.foo	/^     lebedev_L7_grid :: LEBEDEV*  DEFAULT_NULL$/;"	a
lebedev_L9_grid	types.foo	/^     lebedev_L9_grid :: LEBEDEV*  DEFAULT_NULL$/;"	a
lebedev_L11_grid	types.foo	/^     lebedev_L11_grid :: LEBEDEV*  DEFAULT_NULL$/;"	a
n_unscaled_points	types.foo	/^     n_unscaled_points :: INT DEFAULT(0)$/;"	a
unscaled_point	types.foo	/^     unscaled_point :: MAT{REAL}*, private  DEFAULT_NULL$/;"	a
unscaled_weight	types.foo	/^     unscaled_weight :: VEC{REAL}*, private  DEFAULT_NULL$/;"	a
n_points	types.foo	/^     n_points :: INT DEFAULT(0)$/;"	a
atom_points	types.foo	/^     atom_points :: VEC{MAT_{REAL}}*  DEFAULT_NULL$/;"	a
atom_weights	types.foo	/^     atom_weights :: VEC{VEC_{REAL}}*  DEFAULT_NULL$/;"	a
atom_grid0	types.foo	/^     atom_grid0 :: VEC{MAT_{REAL}}*  DEFAULT_NULL$/;"	a
atom_grid1	types.foo	/^     atom_grid1 :: VEC{MAT3_{REAL}}*  DEFAULT_NULL$/;"	a
weight_is_0	types.foo	/^     weight_is_0 :: VEC{BIN}*  DEFAULT_NULL$/;"	a
IRREP	types.foo	/^   type IRREP$/;"	t
label	types.foo	/^     label :: STR(4)$/;"	a
dimension	types.foo	/^     dimension :: INT$/;"	a
character	types.foo	/^     character :: VEC{REAL}* DEFAULT_NULL$/;"	a
mat	types.foo	/^     mat :: MAT3{REAL}* DEFAULT_NULL$/;"	a
VEC{IRREP}	types.foo	/^   array type VEC{IRREP}$/;"	v
POINTGROUP	types.foo	/^   type POINTGROUP$/;"	t
symbol	types.foo	/^     symbol :: STR(4)$/;"	a
ID_symbol	types.foo	/^     ID_symbol :: STR(4)$/;"	a
ID_number	types.foo	/^     ID_number :: INT$/;"	a
axis_order	types.foo	/^     axis_order :: INT$/;"	a
order	types.foo	/^     order :: INT$/;"	a
n_irrep	types.foo	/^     n_irrep :: INT$/;"	a
n_gen	types.foo	/^     n_gen :: INT$/;"	a
has_complex_irreps	types.foo	/^     has_complex_irreps :: BIN$/;"	a
table	types.foo	/^     table :: MAT{INT}* DEFAULT_NULL$/;"	a
mat	types.foo	/^     mat :: MAT3{REAL}* DEFAULT_NULL$/;"	a
use_spherical_basis	types.foo	/^     use_spherical_basis :: BIN   DEFAULT(FALSE)$/;"	a
ptr	types.foo	/^     ptr :: MAT3{REAL}* DEFAULT_NULL$/;"	a
dtr	types.foo	/^     dtr :: MAT3{REAL}* DEFAULT_NULL$/;"	a
ftr	types.foo	/^     ftr :: MAT3{REAL}* DEFAULT_NULL$/;"	a
gtr	types.foo	/^     gtr :: MAT3{REAL}* DEFAULT_NULL$/;"	a
inverse	types.foo	/^     inverse :: VEC{INT}* DEFAULT_NULL$/;"	a
irrep	types.foo	/^     irrep :: VEC{IRREP}* DEFAULT_NULL$/;"	a
UNIT_CELL	types.foo	/^   type UNIT_CELL$/;"	t
angle	types.foo	/^     angle :: VEC{REAL}(3)$/;"	a
length	types.foo	/^     length :: VEC{REAL}(3)$/;"	a
volume	types.foo	/^     volume :: REAL$/;"	a
direct_matrix	types.foo	/^     direct_matrix :: MAT{REAL}(3,3)$/;"	a
inverse_matrix	types.foo	/^     inverse_matrix :: MAT{REAL}(3,3)$/;"	a
reciprocal_matrix	types.foo	/^     reciprocal_matrix :: MAT{REAL}(3,3)$/;"	a
direct_U_matrix	types.foo	/^     direct_U_matrix :: MAT{REAL}(3,3)$/;"	a
reciprocal_U_matrix	types.foo	/^     reciprocal_U_matrix :: MAT{REAL}(3,3)$/;"	a
info_made	types.foo	/^     info_made :: BIN$/;"	a
VEC{UNIT_CELL}	types.foo	/^   array type VEC{UNIT_CELL}$/;"	v
MULTI_T_ADP	types.foo	/^   type MULTI_T_ADP$/;"	t
fit_method	types.foo	/^     fit_method :: STR   DEFAULT("unknown")$/;"	a
cif_file_name	types.foo	/^     cif_file_name :: VEC{STR}* DEFAULT_NULL$/;"	a
V_expansion_order	types.foo	/^     V_expansion_order :: INT  DEFAULT(2)$/;"	a
use_V_linear_term	types.foo	/^     use_V_linear_term :: BIN  DEFAULT(TRUE)$/;"	a
use_translations	types.foo	/^     use_translations :: BIN  DEFAULT(TRUE)$/;"	a
use_librations	types.foo	/^     use_librations :: BIN  DEFAULT(TRUE)$/;"	a
use_fixed_H_modes	types.foo	/^     use_fixed_H_modes :: BIN  DEFAULT(FALSE)$/;"	a
use_fixed_non_H_modes	types.foo	/^     use_fixed_non_H_modes :: BIN  DEFAULT(FALSE)$/;"	a
n_internal	types.foo	/^     n_internal :: INT  DEFAULT(0)$/;"	a
project_onto_initial_modes	types.foo	/^     project_onto_initial_modes :: BIN  DEFAULT(FALSE)$/;"	a
n_project	types.foo	/^     n_project :: INT  DEFAULT(-1)$/;"	a
equality_constraints	types.foo	/^     equality_constraints :: VEC{VEC_{INT}}*  DEFAULT_NULL$/;"	a
decoupled_parameters	types.foo	/^     decoupled_parameters :: VEC{VEC_{INT}}*  DEFAULT_NULL$/;"	a
max_iterations	types.foo	/^     max_iterations :: INT  DEFAULT(MULTI_T_ADP_MAX_ITER)$/;"	a
min_iterations	types.foo	/^     min_iterations :: INT  DEFAULT(MULTI_T_ADP_MIN_ITER)$/;"	a
tol_shift_convergence	types.foo	/^     tol_shift_convergence :: REAL DEFAULT(MULTI_T_ADP_TOL_SHIFT_CONV)$/;"	a
max_allowed_shift	types.foo	/^     max_allowed_shift :: REAL  DEFAULT(MULTI_T_ADP_MAX_SHIFT)$/;"	a
show_correlations	types.foo	/^     show_correlations :: BIN  DEFAULT(FALSE)$/;"	a
min_correlation	types.foo	/^     min_correlation :: REAL  DEFAULT(MULTI_T_ADP_MIN_CORRELATION)$/;"	a
show_near_0_eigenvectors	types.foo	/^     show_near_0_eigenvectors :: BIN  DEFAULT(FALSE)$/;"	a
tol_0	types.foo	/^     tol_0 :: REAL  DEFAULT(MULTI_T_ADP_TOL_0)$/;"	a
tol_near_0	types.foo	/^     tol_near_0 :: REAL  DEFAULT(MULTI_T_ADP_TOL_NEAR_0)$/;"	a
cif_files_read	types.foo	/^     cif_files_read :: BIN   DEFAULT(FALSE)$/;"	a
initialised	types.foo	/^     initialised :: BIN   DEFAULT(FALSE)$/;"	a
n_T	types.foo	/^     n_T :: INT  DEFAULT(0)$/;"	a
n_atom	types.foo	/^     n_atom :: INT   DEFAULT(0)$/;"	a
n3N	types.foo	/^     n3N :: INT   DEFAULT(0)$/;"	a
n6N	types.foo	/^     n6N :: INT   DEFAULT(0)$/;"	a
n9N	types.foo	/^     n9N :: INT   DEFAULT(0)$/;"	a
atom	types.foo	/^     atom :: VEC{ATOM}*$/;"	a
temperature	types.foo	/^     temperature :: VEC{REAL}*   DEFAULT_NULL$/;"	a
temperature_sigma	types.foo	/^     temperature_sigma :: VEC{REAL}*   DEFAULT_NULL$/;"	a
unit_cell	types.foo	/^     unit_cell :: VEC{UNIT_CELL}*$/;"	a
unit_cell_sigma	types.foo	/^     unit_cell_sigma :: VEC{UNIT_CELL}*$/;"	a
ADP	types.foo	/^     ADP :: VEC{MAT_{REAL}}* DEFAULT_NULL$/;"	a
ADP_cov	types.foo	/^     ADP_cov :: VEC{MAT_{REAL}}*  DEFAULT_NULL$/;"	a
ADP_wt	types.foo	/^     ADP_wt :: VEC{MAT_{REAL}}*  DEFAULT_NULL$/;"	a
V_coeff	types.foo	/^     V_coeff :: VEC{REAL}*$/;"	a
Delta_V_on_V	types.foo	/^     Delta_V_on_V :: VEC{REAL}*   DEFAULT_NULL$/;"	a
parameter_description	types.foo	/^     parameter_description :: VEC{STR}*  DEFAULT_NULL$/;"	a
n_modes	types.foo	/^     n_modes :: INT   DEFAULT(0)$/;"	a
lambda	types.foo	/^     lambda :: VEC{REAL}*$/;"	a
omega	types.foo	/^     omega :: VEC{REAL}*   DEFAULT_NULL$/;"	a
amplitude	types.foo	/^     amplitude :: MAT{REAL}*, private   DEFAULT_NULL$/;"	a
gamma_G	types.foo	/^     gamma_G :: VEC{REAL}*   DEFAULT_NULL$/;"	a
iteration	types.foo	/^     iteration :: INT$/;"	a
chi2	types.foo	/^     chi2 :: REAL$/;"	a
chi2_old	types.foo	/^     chi2_old :: REAL$/;"	a
max_shift_on_esd	types.foo	/^     max_shift_on_esd :: REAL$/;"	a
max_shift	types.foo	/^     max_shift :: REAL$/;"	a
n_ind_params	types.foo	/^     n_ind_params :: INT$/;"	a
n_0	types.foo	/^     n_0 :: INT$/;"	a
n_near_0	types.foo	/^     n_near_0 :: INT$/;"	a
near_0_eigenvalues	types.foo	/^     near_0_eigenvalues :: VEC{REAL}*  DEFAULT_NULL$/;"	a
near_0_eigenvectors	types.foo	/^     near_0_eigenvectors :: MAT{REAL}*  DEFAULT_NULL$/;"	a
delta_p	types.foo	/^     delta_p :: VEC{REAL}*  DEFAULT_NULL$/;"	a
covariance_matrix	types.foo	/^     covariance_matrix :: MAT{REAL}*  DEFAULT_NULL$/;"	a
correlation_matrix	types.foo	/^     correlation_matrix :: MAT{REAL}*  DEFAULT_NULL$/;"	a
SPACEGROUP	types.foo	/^   type SPACEGROUP$/;"	t
IT_symbol	types.foo	/^     IT_symbol :: STR   DEFAULT("?")$/;"	a
IT_group_number	types.foo	/^     IT_group_number :: INT   DEFAULT(0)$/;"	a
Hall_symbol	types.foo	/^     Hall_symbol :: STR   DEFAULT("?")$/;"	a
HM_symbol	types.foo	/^     HM_symbol :: STR   DEFAULT("?")$/;"	a
Schoenflies_symbol	types.foo	/^     Schoenflies_symbol :: STR   DEFAULT("?")$/;"	a
lattice_symbol	types.foo	/^     lattice_symbol :: STR(1)   DEFAULT("?")$/;"	a
lattice_symbol_index	types.foo	/^     lattice_symbol_index :: INT   DEFAULT(0)$/;"	a
lattice_type	types.foo	/^     lattice_type :: STR   DEFAULT("?")$/;"	a
centrosymmetric	types.foo	/^     centrosymmetric :: BIN   DEFAULT(FALSE)$/;"	a
axis_order	types.foo	/^     axis_order :: VEC{INT}(3)   DEFAULT(0)$/;"	a
axis_symbol	types.foo	/^     axis_symbol :: VEC{STR}(len=1,3)   DEFAULT(" ")$/;"	a
axis_symbol_index	types.foo	/^     axis_symbol_index :: VEC{INT}(3)   DEFAULT(0)$/;"	a
has_axis_bar	types.foo	/^     has_axis_bar :: VEC{BIN}(3)   DEFAULT(FALSE)$/;"	a
has_translation	types.foo	/^     has_translation :: VEC{BIN}(3)   DEFAULT(FALSE)$/;"	a
translation_symbol	types.foo	/^     translation_symbol :: MAT{STR}(len=1,3,3)   DEFAULT(" ")$/;"	a
origin_shift	types.foo	/^     origin_shift :: VEC{INT}(3)   DEFAULT(0)$/;"	a
nL	types.foo	/^     nL :: INT   DEFAULT(0)$/;"	a
nR	types.foo	/^     nR :: INT   DEFAULT(0)$/;"	a
nG	types.foo	/^     nG :: INT   DEFAULT(0)$/;"	a
n_seitz	types.foo	/^     n_seitz :: INT   DEFAULT(0)$/;"	a
seitz	types.foo	/^     seitz :: MAT3{REAL}* DEFAULT_NULL$/;"	a
n_inverted_symops	types.foo	/^     n_inverted_symops :: INT   DEFAULT(0)$/;"	a
inverted_symop	types.foo	/^     inverted_symop :: VEC{INT}* DEFAULT_NULL$/;"	a
translated_symop	types.foo	/^     translated_symop :: VEC{INT}* DEFAULT_NULL$/;"	a
n_unique_SF_symops	types.foo	/^     n_unique_SF_symops :: INT$/;"	a
unique_SF_symop	types.foo	/^     unique_SF_symop :: VEC{INT}* DEFAULT_NULL$/;"	a
analysed	types.foo	/^     analysed :: BIN  DEFAULT(FALSE)$/;"	a
DIFFRACTION_DATA	types.foo	/^   type DIFFRACTION_DATA$/;"	t
data_kind	types.foo	/^     data_kind :: STR  DEFAULT(DIFFRACTION_DATA_DATA_KIND)$/;"	a
reflections	types.foo	/^     reflections :: VEC{REFLECTION}* DEFAULT_NULL$/;"	a
wavelength	types.foo	/^     wavelength :: REAL  DEFAULT(DIFFRACTION_DATA_WAVELENGTH)$/;"	a
temperature	types.foo	/^     temperature :: REAL   DEFAULT(DIFFRACTION_DATA_TEMPERATURE)$/;"	a
NKA_T_sequence_no	types.foo	/^     NKA_T_sequence_no :: INT   DEFAULT(0)$/;"	a
F_sigma_cutoff	types.foo	/^     F_sigma_cutoff :: REAL  DEFAULT(DIFFRACTION_DATA_F_SIGMA_CUTOFF)$/;"	a
F2_sigma_cutoff	types.foo	/^     F2_sigma_cutoff :: REAL  DEFAULT(DIFFRACTION_DATA_F2_SIGMA_CUTOFF)$/;"	a
F_z_cutoff	types.foo	/^     F_z_cutoff :: REAL  DEFAULT(-ONE)$/;"	a
stl_cutoff	types.foo	/^     stl_cutoff :: REAL  DEFAULT(-ONE)$/;"	a
show_rejects	types.foo	/^     show_rejects :: BIN  DEFAULT(TRUE)$/;"	a
synthesize_sigma_I	types.foo	/^     synthesize_sigma_I :: BIN  DEFAULT(DIFFRACTION_DATA_SYNTHESIZE_SIGMA_I)$/;"	a
SF_mixing_parameter	types.foo	/^     SF_mixing_parameter :: REAL  DEFAULT(ZERO)$/;"	a
partition_model	types.foo	/^     partition_model :: STR  DEFAULT(DIFFRACTION_DATA_PARTITION_MODEL)$/;"	a
thermal_smearing_model	types.foo	/^     thermal_smearing_model :: STR  DEFAULT(DIFFRACTION_DATA_THERMAL_SMEARING_MODEL)$/;"	a
use_Voronoi_atoms	types.foo	/^     use_Voronoi_atoms :: BIN  DEFAULT(FALSE)$/;"	a
optimise_scale	types.foo	/^     optimise_scale :: BIN  DEFAULT(DIFFRACTION_DATA_OPTIMISE_SCALE)$/;"	a
scale_factor	types.foo	/^     scale_factor :: REAL  DEFAULT(DIFFRACTION_DATA_SCALE_FACTOR)$/;"	a
scale_factors	types.foo	/^     scale_factors :: VEC{REAL}* DEFAULT_NULL$/;"	a
exp_scale_factor	types.foo	/^     exp_scale_factor :: REAL  DEFAULT(DIFFRACTION_DATA_EXP_SCALE_FACTOR)$/;"	a
optimise_extinction	types.foo	/^     optimise_extinction :: BIN  DEFAULT(DIFFRACTION_DATA_OPTIMISE_EXTINCTION)$/;"	a
extinction_factor	types.foo	/^     extinction_factor :: REAL  DEFAULT(DIFFRACTION_DATA_EXTINCTION_FACTOR)$/;"	a
correct_dispersion	types.foo	/^     correct_dispersion :: BIN  DEFAULT(DIFFRACTION_DATA_CORRECT_DISPERSION)$/;"	a
n_param	types.foo	/^     n_param :: INT  DEFAULT(0)$/;"	a
refine_F	types.foo	/^     refine_F :: BIN, readonly  DEFAULT(TRUE)$/;"	a
refine_structure	types.foo	/^     refine_structure :: BIN, readonly  DEFAULT(FALSE)$/;"	a
refine_positions_only	types.foo	/^     refine_positions_only :: BIN  DEFAULT(FALSE)$/;"	a
refine_ADPs_only	types.foo	/^     refine_ADPs_only :: BIN  DEFAULT(FALSE)$/;"	a
refine_H_ADPs	types.foo	/^     refine_H_ADPs :: BIN  DEFAULT(TRUE)$/;"	a
refine_H_U_iso	types.foo	/^     refine_H_U_iso :: BIN  DEFAULT(FALSE)$/;"	a
refine_atom_parameters	types.foo	/^     refine_atom_parameters :: MAT{INT}*  DEFAULT_NULL$/;"	a
iteration	types.foo	/^     iteration :: INT  DEFAULT(0)$/;"	a
chi2	types.foo	/^     chi2 :: REAL  DEFAULT(0)$/;"	a
chi2_old	types.foo	/^     chi2_old :: REAL  DEFAULT(0)$/;"	a
max_iterations	types.foo	/^     max_iterations :: INT  DEFAULT(DIFFRACTION_DATA_MAX_ITER)$/;"	a
min_iterations	types.foo	/^     min_iterations :: INT  DEFAULT(DIFFRACTION_DATA_MIN_ITER)$/;"	a
tol_shift_convergence	types.foo	/^     tol_shift_convergence :: REAL DEFAULT(DIFFRACTION_DATA_TOL_SHIFT_CONV)$/;"	a
max_shift	types.foo	/^     max_shift :: REAL  DEFAULT(ZERO)$/;"	a
max_shift_on_esd	types.foo	/^     max_shift_on_esd :: REAL DEFAULT(DIFFRACTION_DATA_MAX_SHIFT_ON_ESD)$/;"	a
max_allowed_shift	types.foo	/^     max_allowed_shift :: REAL  DEFAULT(DIFFRACTION_DATA_MAX_ALLOWED_SHIFT)$/;"	a
tol_0	types.foo	/^     tol_0 :: REAL  DEFAULT(DIFFRACTION_DATA_TOL_0)$/;"	a
n_0	types.foo	/^     n_0 :: INT  DEFAULT(0)$/;"	a
tol_near_0	types.foo	/^     tol_near_0 :: REAL  DEFAULT(DIFFRACTION_DATA_TOL_NEAR_0)$/;"	a
n_near_0	types.foo	/^     n_near_0 :: INT  DEFAULT(0)$/;"	a
near_0_eigenvalues	types.foo	/^     near_0_eigenvalues :: VEC{REAL}*  DEFAULT_NULL$/;"	a
near_0_eigenvectors	types.foo	/^     near_0_eigenvectors :: MAT{REAL}*  DEFAULT_NULL$/;"	a
display_correlation_matrix	types.foo	/^     display_correlation_matrix :: BIN  DEFAULT(FALSE)$/;"	a
display_near_0_eigenvectors	types.foo	/^     display_near_0_eigenvectors :: BIN  DEFAULT(FALSE)$/;"	a
delta_p	types.foo	/^     delta_p :: VEC{REAL}*  DEFAULT_NULL$/;"	a
min_correlation	types.foo	/^     min_correlation :: REAL  DEFAULT(DIFFRACTION_DATA_MIN_CORRELATION)$/;"	a
covariance_matrix	types.foo	/^     covariance_matrix :: MAT{REAL}*  DEFAULT_NULL$/;"	a
correlation_matrix	types.foo	/^     correlation_matrix :: MAT{REAL}*  DEFAULT_NULL$/;"	a
fragment_covariance_matrix	types.foo	/^     fragment_covariance_matrix :: MAT{REAL}*  DEFAULT_NULL$/;"	a
CRYSTAL	types.foo	/^   type CRYSTAL$/;"	t
CIF_chemical_formula	types.foo	/^     CIF_chemical_formula :: STR  DEFAULT("?")$/;"	a
spacegroup	types.foo	/^     spacegroup :: SPACEGROUP$/;"	a
unit_cell	types.foo	/^     unit_cell :: UNIT_CELL$/;"	a
n_fragment_atoms	types.foo	/^     n_fragment_atoms :: INT$/;"	a
fragment_geometry	types.foo	/^     fragment_geometry :: MAT{REAL}* DEFAULT_NULL$/;"	a
asymmetric_unit_source	types.foo	/^     asymmetric_unit_source :: STR  DEFAULT("?")$/;"	a
n_asymmetric_unit_atoms	types.foo	/^     n_asymmetric_unit_atoms :: INT$/;"	a
asymmetric_unit_geometry	types.foo	/^     asymmetric_unit_geometry :: MAT{REAL}* DEFAULT_NULL$/;"	a
prune_asymmetric_unit	types.foo	/^     prune_asymmetric_unit :: BIN  DEFAULT(TRUE)$/;"	a
asymmetric_unit_atom	types.foo	/^     asymmetric_unit_atom :: VEC{ATOM}*  DEFAULT_NULL$/;"	a
n_unit_cell_atoms	types.foo	/^     n_unit_cell_atoms :: INT$/;"	a
unit_cell_geometry	types.foo	/^     unit_cell_geometry :: MAT{REAL}*  DEFAULT_NULL$/;"	a
unique_unit_cell_atom	types.foo	/^     unique_unit_cell_atom :: VEC{INT}*  DEFAULT_NULL$/;"	a
unique_uc_atom_offset	types.foo	/^     unique_uc_atom_offset :: VEC{VEC_{INT}}*  DEFAULT_NULL$/;"	a
is_asym_unit_cell_atom	types.foo	/^     is_asym_unit_cell_atom :: VEC{BIN}*  DEFAULT_NULL$/;"	a
fragment_info_made	types.foo	/^     fragment_info_made :: BIN  DEFAULT(FALSE)$/;"	a
asym_atom_for_unit_cell_atom	types.foo	/^     asym_atom_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
symop_for_unit_cell_atom	types.foo	/^     symop_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
frag_atom_for_unit_cell_atom	types.foo	/^     frag_atom_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
unit_cell_atom_for_frag_atom	types.foo	/^     unit_cell_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
frag_atom_for_asym_unit_atom	types.foo	/^     frag_atom_for_asym_unit_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
asym_unit_atom_for_frag_atom	types.foo	/^     asym_unit_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
frag_parent_for_cell_atom	types.foo	/^     frag_parent_for_cell_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
n_unique_frag_atoms	types.foo	/^     n_unique_frag_atoms :: INT$/;"	a
unique_frag_atom	types.foo	/^     unique_frag_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
unique_atom_for_frag_atom	types.foo	/^     unique_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
asym_symop_for_frag_atom	types.foo	/^     asym_symop_for_frag_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
asym_shift_for_frag_atom	types.foo	/^     asym_shift_for_frag_atom :: MAT{REAL}* DEFAULT_NULL$/;"	a
use_manual_repetition_factors	types.foo	/^     use_manual_repetition_factors :: BIN  DEFAULT(FALSE)$/;"	a
repetition_factor	types.foo	/^     repetition_factor :: VEC{REAL}* DEFAULT_NULL$/;"	a
asym_atom_rep_factor	types.foo	/^     asym_atom_rep_factor :: VEC{REAL}* DEFAULT_NULL$/;"	a
asym_atom_stabilizer	types.foo	/^     asym_atom_stabilizer :: VEC{VEC_{INT}}* DEFAULT_NULL$/;"	a
unit_cell_connection	types.foo	/^     unit_cell_connection :: VEC{VEC_{VEC_{INT}}}*  DEFAULT_NULL$/;"	a
uc_vdw_connection	types.foo	/^     uc_vdw_connection :: VEC{VEC_{VEC_{INT}}}*  DEFAULT_NULL$/;"	a
unit_cell_mol_for_atom	types.foo	/^     unit_cell_mol_for_atom :: VEC{INT}*  DEFAULT_NULL$/;"	a
n_unit_cell_mols	types.foo	/^     n_unit_cell_mols :: INT   DEFAULT(0)$/;"	a
n_stabilizer_symops	types.foo	/^     n_stabilizer_symops :: INT$/;"	a
stabilizer_symop	types.foo	/^     stabilizer_symop :: VEC{INT}* DEFAULT_NULL$/;"	a
str	types.foo	/^     str :: MAT3{REAL}* DEFAULT_NULL$/;"	a
ptr	types.foo	/^     ptr :: MAT3{REAL}* DEFAULT_NULL$/;"	a
dtr	types.foo	/^     dtr :: MAT3{REAL}* DEFAULT_NULL$/;"	a
ftr	types.foo	/^     ftr :: MAT3{REAL}* DEFAULT_NULL$/;"	a
gtr	types.foo	/^     gtr :: MAT3{REAL}* DEFAULT_NULL$/;"	a
data_kind	types.foo	/^     data_kind :: STR$/;"	a
data	types.foo	/^     data :: DIFFRACTION_DATA* DEFAULT_NULL$/;"	a
xray_data	types.foo	/^     xray_data :: DIFFRACTION_DATA* DEFAULT_NULL$/;"	a
pnd_data	types.foo	/^     pnd_data :: DIFFRACTION_DATA* DEFAULT_NULL$/;"	a
r_free_percentage	types.foo	/^     r_free_percentage :: INT  DEFAULT(0)$/;"	a
xray_r_free_data	types.foo	/^     xray_r_free_data :: DIFFRACTION_DATA*  DEFAULT_NULL$/;"	a
pnd_r_free_data	types.foo	/^     pnd_r_free_data :: DIFFRACTION_DATA*  DEFAULT_NULL$/;"	a
core_reflection	types.foo	/^     core_reflection :: VEC{REFLECTION}* DEFAULT_NULL$/;"	a
finalize	types.foo	/^     finalize :: BIN  DEFAULT(TRUE)$/;"	a
CLUSTER	types.foo	/^   type CLUSTER$/;"	t
radius	types.foo	/^     radius :: REAL  DEFAULT(CLUSTER_RADIUS)$/;"	a
atom_density_cutoff	types.foo	/^     atom_density_cutoff :: REAL  DEFAULT(CLUSTER_ATOM_DENSITY_CUTOFF)$/;"	a
generation_method	types.foo	/^     generation_method :: STR  DEFAULT(CLUSTER_GENERATION_METHOD)$/;"	a
defragment	types.foo	/^     defragment :: BIN  DEFAULT(CLUSTER_DEFRAGMENT)$/;"	a
n_atoms	types.foo	/^     n_atoms :: INT$/;"	a
geometry	types.foo	/^     geometry :: MAT{REAL}* DEFAULT_NULL$/;"	a
crystal	types.foo	/^     crystal :: CRYSTAL* DEFAULT_NULL$/;"	a
asymmetric_unit_atom	types.foo	/^     asymmetric_unit_atom :: VEC{ATOM}* DEFAULT_NULL$/;"	a
n_fragment_atoms	types.foo	/^     n_fragment_atoms :: INT$/;"	a
fragment_geometry	types.foo	/^     fragment_geometry :: MAT{REAL}* DEFAULT_NULL$/;"	a
fragment_width	types.foo	/^     fragment_width :: VEC{REAL}(3)$/;"	a
fragment_offset	types.foo	/^     fragment_offset :: VEC{INT}(3)$/;"	a
unit_cell_offset	types.foo	/^     unit_cell_offset :: VEC{REAL}(3)  DEFAULT(ZERO)$/;"	a
h_min	types.foo	/^     h_min :: VEC{INT}(3), private$/;"	a
h_max	types.foo	/^     h_max :: VEC{INT}(3), private$/;"	a
n_shift	types.foo	/^     n_shift :: INT  DEFAULT(0)$/;"	a
shift	types.foo	/^     shift :: MAT{INT}* DEFAULT_NULL$/;"	a
shift_for_atom	types.foo	/^     shift_for_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
is_fragment_atom	types.foo	/^     is_fragment_atom :: VEC{BIN}* DEFAULT_NULL$/;"	a
occupation_list	types.foo	/^     occupation_list :: VEC{INT}*  DEFAULT_NULL$/;"	a
molecule_for_atom	types.foo	/^     molecule_for_atom :: VEC{INT}*  DEFAULT_NULL$/;"	a
atom_connection	types.foo	/^     atom_connection :: VEC{VEC_{INT}}*  DEFAULT_NULL$/;"	a
n_molecules	types.foo	/^     n_molecules :: INT   DEFAULT(0)$/;"	a
info_made	types.foo	/^     info_made :: BIN  DEFAULT(FALSE)$/;"	a
SCFDATA	types.foo	/^   type SCFDATA$/;"	t
scf_kind	types.foo	/^     scf_kind :: STR  DEFAULT(" ")$/;"	a
dft_exchange_functional	types.foo	/^     dft_exchange_functional :: STR, readonly  DEFAULT(SCFDATA_DFT_EXCHANGE_FUNCTIONAL)$/;"	a
dft_correlation_functional	types.foo	/^     dft_correlation_functional :: STR, readonly  DEFAULT(SCFDATA_DFT_CORRELATION_FUNCTIONAL)$/;"	a
using_GGA_exchange	types.foo	/^     using_GGA_exchange :: BIN, readonly  DEFAULT(SCFDATA_USING_GGA_EXCHANGE)$/;"	a
using_GGA_correlation	types.foo	/^     using_GGA_correlation :: BIN, readonly  DEFAULT(SCFDATA_USING_GGA_CORRELATION)$/;"	a
iteration	types.foo	/^     iteration :: INT  DEFAULT(0)$/;"	a
total_iterations	types.foo	/^     total_iterations :: INT  DEFAULT(0)$/;"	a
lambda_iteration	types.foo	/^     lambda_iteration :: INT, readonly  DEFAULT(0)$/;"	a
min_iterations	types.foo	/^     min_iterations :: INT, readonly  DEFAULT(SCFDATA_MIN_ITERATIONS)$/;"	a
max_iterations	types.foo	/^     max_iterations :: INT, readonly  DEFAULT(SCFDATA_MAX_ITERATIONS)$/;"	a
nuclear_repulsion_energy	types.foo	/^     nuclear_repulsion_energy :: REAL  DEFAULT(ZERO)$/;"	a
nuclear_attraction_energy	types.foo	/^     nuclear_attraction_energy :: REAL  DEFAULT(ZERO)$/;"	a
kinetic_energy	types.foo	/^     kinetic_energy :: REAL  DEFAULT(ZERO)$/;"	a
dft_energy_correction	types.foo	/^     dft_energy_correction :: REAL  DEFAULT(ZERO)$/;"	a
dft_alpha_energy_correction	types.foo	/^     dft_alpha_energy_correction :: REAL  DEFAULT(ZERO)$/;"	a
dft_beta_energy_correction	types.foo	/^     dft_beta_energy_correction :: REAL  DEFAULT(ZERO)$/;"	a
energy	types.foo	/^     energy :: REAL  DEFAULT(ZERO)$/;"	a
old_energy	types.foo	/^     old_energy :: REAL  DEFAULT(ZERO)$/;"	a
energy_difference	types.foo	/^     energy_difference :: REAL  DEFAULT(ZERO)$/;"	a
lambda	types.foo	/^     lambda :: REAL, readonly  DEFAULT(ZERO)$/;"	a
initial_lambda	types.foo	/^     initial_lambda :: REAL, readonly  DEFAULT(ZERO)$/;"	a
lambda_max	types.foo	/^     lambda_max :: REAL, readonly  DEFAULT(ZERO)$/;"	a
lambda_step	types.foo	/^     lambda_step :: REAL, readonly  DEFAULT(ONE)$/;"	a
fit_value	types.foo	/^     fit_value :: REAL, readonly  DEFAULT(ZERO)$/;"	a
old_fit_value	types.foo	/^     old_fit_value :: REAL, readonly  DEFAULT(ZERO)$/;"	a
penalty	types.foo	/^     penalty :: REAL  DEFAULT(ZERO)$/;"	a
old_penalty	types.foo	/^     old_penalty :: REAL  DEFAULT(ZERO)$/;"	a
zero_oo_constraint_block	types.foo	/^     zero_oo_constraint_block :: BIN, readonly   DEFAULT(FALSE)$/;"	a
crystal	types.foo	/^     crystal :: CRYSTAL*  DEFAULT_NULL$/;"	a
initial_density	types.foo	/^     initial_density :: STR, readonly  DEFAULT("core")$/;"	a
initial_mos	types.foo	/^     initial_mos :: STR, readonly  DEFAULT(" ")$/;"	a
initial_Us	types.foo	/^     initial_Us :: STR, readonly  DEFAULT(" ")$/;"	a
use_default_guess_options	types.foo	/^     use_default_guess_options :: BIN, readonly  DEFAULT(TRUE)$/;"	a
convergence	types.foo	/^     convergence :: REAL, readonly  DEFAULT(SCFDATA_CONVERGENCE)$/;"	a
damp_finish	types.foo	/^     damp_finish :: INT, readonly  DEFAULT(DIIS_START_ITERATION)$/;"	a
damp_factor	types.foo	/^     damp_factor :: REAL, readonly  DEFAULT(SCFDATA_DAMP_FACTOR)$/;"	a
level_shift_finish	types.foo	/^     level_shift_finish :: INT, readonly  DEFAULT(DIIS_START_ITERATION)$/;"	a
level_shift	types.foo	/^     level_shift :: REAL, readonly  DEFAULT(SCFDATA_LEVEL_SHIFT)$/;"	a
linear_dependence_tol	types.foo	/^     linear_dependence_tol :: REAL, readonly   DEFAULT(SCFDATA_LINEAR_DEPENDENCE_TOL)$/;"	a
linear_dependence_shift	types.foo	/^     linear_dependence_shift :: REAL, readonly   DEFAULT(SCFDATA_LINEAR_DEPENDENCE_SHIFT)$/;"	a
MO_gradient_stepsize	types.foo	/^     MO_gradient_stepsize :: REAL, readonly  DEFAULT(0.01d0)$/;"	a
max_update_stepsize	types.foo	/^     max_update_stepsize :: REAL, readonly  DEFAULT(0.01d0)$/;"	a
eri_disk_cutoff	types.foo	/^     eri_disk_cutoff :: REAL, readonly  DEFAULT(SCFDATA_ERI_DISK_CUTOFF)$/;"	a
eri_schwarz_cutoff	types.foo	/^     eri_schwarz_cutoff :: REAL, readonly  DEFAULT(SCFDATA_ERI_SCHWARZ_CUTOFF)$/;"	a
eri_J_density_cutoff	types.foo	/^     eri_J_density_cutoff :: REAL, readonly  DEFAULT(SCFDATA_ERI_J_DENSITY_CUTOFF)$/;"	a
eri_K_density_cutoff	types.foo	/^     eri_K_density_cutoff :: REAL, readonly  DEFAULT(SCFDATA_ERI_K_DENSITY_CUTOFF)$/;"	a
eri_bf_overlap_cutoff	types.foo	/^     eri_bf_overlap_cutoff :: REAL, readonly DEFAULT(SCFDATA_ERI_BF_OVERLAP_CUTOFF)$/;"	a
eri_primitive_pair_cutoff	types.foo	/^     eri_primitive_pair_cutoff :: REAL, readonly DEFAULT(SCFDATA_ERI_PAIR_CUTOFF)$/;"	a
atom_overlap_cutoff	types.foo	/^     atom_overlap_cutoff :: REAL, readonly  DEFAULT(SCFDATA_ATOM_OVERLAP_CUTOFF)$/;"	a
XC_atom_separation_cutoff	types.foo	/^     XC_atom_separation_cutoff :: REAL, readonly  DEFAULT(SCFDATA_XC_ATOM_SEPARATION_CUTOFF)$/;"	a
diis	types.foo	/^     diis :: DIIS$/;"	a
diis_error	types.foo	/^     diis_error :: REAL, readonly  DEFAULT(ZERO)$/;"	a
old_diis_error	types.foo	/^     old_diis_error :: REAL, readonly  DEFAULT(ZERO)$/;"	a
diis_start_iteration	types.foo	/^     diis_start_iteration :: INT, private  DEFAULT(DIIS_START_ITERATION)$/;"	a
diis_save_iteration	types.foo	/^     diis_save_iteration :: INT, private  DEFAULT(DIIS_SAVE_ITERATION)$/;"	a
using_previous_diis_info	types.foo	/^     using_previous_diis_info :: BIN, readonly   DEFAULT(TRUE)$/;"	a
diis_error_temp_cutoff	types.foo	/^     diis_error_temp_cutoff :: REAL, readonly  DEFAULT(DIIS_ERROR_TEMP_CUTOFF)$/;"	a
sl_1e_factor	types.foo	/^     sl_1e_factor :: REAL, readonly  DEFAULT(ONE)$/;"	a
sl_2e_factor	types.foo	/^     sl_2e_factor :: REAL, readonly  DEFAULT(ONE)$/;"	a
quantization_axis	types.foo	/^     quantization_axis :: VEC{REAL}(3), readonly  DEFAULT([ZERO,ZERO,ONE])$/;"	a
output	types.foo	/^     output :: BIN, readonly  DEFAULT(TRUE)$/;"	a
guess_output	types.foo	/^     guess_output :: BIN, readonly  DEFAULT(FALSE)$/;"	a
is_guess	types.foo	/^     is_guess :: BIN, readonly  DEFAULT(FALSE)$/;"	a
test	types.foo	/^     test :: BIN, readonly  DEFAULT(FALSE)$/;"	a
stabilize_density	types.foo	/^     stabilize_density :: BIN, readonly  DEFAULT(FALSE)$/;"	a
relativity_kind	types.foo	/^     relativity_kind :: STR, readonly  DEFAULT("none")$/;"	a
using_iotc	types.foo	/^     using_iotc :: BIN, readonly  DEFAULT(FALSE)$/;"	a
DK1_PCE	types.foo	/^     DK1_PCE :: BIN, readonly  DEFAULT(FALSE)$/;"	a
DK2_PCE	types.foo	/^     DK2_PCE :: BIN, readonly  DEFAULT(FALSE)$/;"	a
DK1	types.foo	/^     DK1 :: BIN, readonly  DEFAULT(TRUE)$/;"	a
DK2	types.foo	/^     DK2 :: BIN, readonly  DEFAULT(TRUE)$/;"	a
DK3	types.foo	/^     DK3 :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_ppzpp	types.foo	/^     using_ppzpp :: BIN, readonly DEFAULT(FALSE)$/;"	a
PCE_CORR	types.foo	/^     PCE_CORR :: BIN, readonly DEFAULT(FALSE)$/;"	a
using_SO_FDFF	types.foo	/^     using_SO_FDFF :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_1e_zora_term	types.foo	/^     using_1e_zora_term :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_pauli_terms	types.foo	/^     using_pauli_terms :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_1e_sl_term	types.foo	/^     using_1e_sl_term :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_1e_srxa_term	types.foo	/^     using_1e_srxa_term :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_2e_sl_term	types.foo	/^     using_2e_sl_term :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_aa_term	types.foo	/^     using_aa_term :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_bl_term	types.foo	/^     using_bl_term :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_bs_term	types.foo	/^     using_bs_term :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_bs_t_term	types.foo	/^     using_bs_t_term :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_damping	types.foo	/^     using_damping :: BIN, readonly  DEFAULT(SCFDATA_USING_DAMPING)$/;"	a
using_pFON	types.foo	/^     using_pFON :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_delta_build	types.foo	/^     using_delta_build :: BIN, readonly  DEFAULT(TRUE)$/;"	a
using_direct_scf	types.foo	/^     using_direct_scf :: BIN, readonly  DEFAULT(TRUE)$/;"	a
using_fock_diis	types.foo	/^     using_fock_diis :: BIN, readonly  DEFAULT(TRUE)$/;"	a
using_level_shift	types.foo	/^     using_level_shift :: BIN, readonly  DEFAULT(SCFDATA_USING_LEVEL_SHIFT)$/;"	a
using_orbital_locking	types.foo	/^     using_orbital_locking :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_MO_diis	types.foo	/^     using_MO_diis :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_exponential_update	types.foo	/^     using_exponential_update :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_MO_gradient_update	types.foo	/^     using_MO_gradient_update :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_CPHF_diis	types.foo	/^     using_CPHF_diis :: BIN, readonly  DEFAULT(TRUE)$/;"	a
using_NDDO	types.foo	/^     using_NDDO :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_NUDO	types.foo	/^     using_NUDO :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_PIE	types.foo	/^     using_PIE :: BIN, readonly  DEFAULT(FALSE)$/;"	a
kappa	types.foo	/^     kappa :: REAL DEFAULT(ZERO)$/;"	a
using_cluster_charges	types.foo	/^     using_cluster_charges :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_SC_cluster_charges	types.foo	/^     using_SC_cluster_charges :: BIN, readonly  DEFAULT(FALSE)$/;"	a
using_qq_cluster_charges	types.foo	/^     using_qq_cluster_charges :: BIN, readonly  DEFAULT(FALSE)$/;"	a
cluster_radius	types.foo	/^     cluster_radius :: REAL, readonly  DEFAULT(SCFDATA_CLUSTER_RADIUS)$/;"	a
cluster	types.foo	/^     cluster :: CLUSTER*  DEFAULT_NULL$/;"	a
save_cluster_charges	types.foo	/^     save_cluster_charges :: BIN, readonly  DEFAULT(FALSE)$/;"	a
cluster_charge	types.foo	/^     cluster_charge :: VEC{REAL}*   DEFAULT_NULL$/;"	a
cluster_pos	types.foo	/^     cluster_pos :: MAT{REAL}*   DEFAULT_NULL$/;"	a
using_SC_Lorentz_fields	types.foo	/^     using_SC_Lorentz_fields :: BIN, readonly  DEFAULT(FALSE)$/;"	a
delete_scf_archives	types.foo	/^     delete_scf_archives :: BIN  DEFAULT(TRUE)$/;"	a
COLOUR	types.foo	/^   type COLOUR$/;"	t
name	types.foo	/^     name :: STR$/;"	a
RGB255	types.foo	/^     RGB255 :: VEC{INT}(3)$/;"	a
COLOUR_FUNCTION	types.foo	/^   type COLOUR_FUNCTION$/;"	t
n_data	types.foo	/^     n_data :: INT$/;"	a
data	types.foo	/^     data :: VEC{REAL}* DEFAULT_NULL$/;"	a
RGB	types.foo	/^     RGB :: MAT{REAL}* DEFAULT_NULL$/;"	a
finalised	types.foo	/^     finalised :: BIN$/;"	a
CAPPING_SQUARE	types.foo	/^   type CAPPING_SQUARE$/;"	t
case	types.foo	/^     case :: INT$/;"	a
face_number	types.foo	/^     face_number :: INT$/;"	a
iso_value	types.foo	/^     iso_value :: REAL$/;"	a
vertex_pos	types.foo	/^     vertex_pos :: MAT{REAL}(3,0:3)$/;"	a
edge_pos	types.foo	/^     edge_pos :: MAT{REAL}(3,0:3)$/;"	a
value_at_vertex	types.foo	/^     value_at_vertex :: VEC{REAL}(0:3)$/;"	a
edge_vertex_index	types.foo	/^     edge_vertex_index :: VEC{INT}(0:7)$/;"	a
edge_vertex_pos	types.foo	/^     edge_vertex_pos :: MAT{REAL}(3,0:7)$/;"	a
cap_vertex_flag	types.foo	/^     cap_vertex_flag :: VEC{BIN}(0:3)$/;"	a
n_triangle	types.foo	/^     n_triangle :: INT$/;"	a
n_pt	types.foo	/^     n_pt :: INT$/;"	a
no_new_vertex	types.foo	/^     no_new_vertex :: INT$/;"	a
triangle_edge_index	types.foo	/^     triangle_edge_index :: MAT{INT}(3,4)$/;"	a
triangle_vertex_index	types.foo	/^     triangle_vertex_index :: MAT{INT}(3,4)$/;"	a
new_vertex_index	types.foo	/^     new_vertex_index :: VEC{INT}(6)$/;"	a
edge_vertex_gradient	types.foo	/^     edge_vertex_gradient :: MAT{REAL}(3,0:7)$/;"	a
edge_mean_curvature	types.foo	/^     edge_mean_curvature :: VEC{REAL}(0:7)$/;"	a
edge_gaussian_curvature	types.foo	/^     edge_gaussian_curvature :: VEC{REAL}(0:7)$/;"	a
MARCHINGCUBE	types.foo	/^   type MARCHINGCUBE$/;"	t
vertex_pos	types.foo	/^     vertex_pos :: MAT{REAL}(3,0:7)$/;"	a
value_at_vertex	types.foo	/^     value_at_vertex :: VEC{REAL}(0:7)$/;"	a
vertex_gradient	types.foo	/^     vertex_gradient :: MAT{REAL}(3,0:7)$/;"	a
vertex_hessian	types.foo	/^     vertex_hessian :: MAT3{REAL}(3,3,0:7)$/;"	a
x_side_length	types.foo	/^     x_side_length :: REAL$/;"	a
y_side_length	types.foo	/^     y_side_length :: REAL$/;"	a
z_side_length	types.foo	/^     z_side_length :: REAL$/;"	a
axes	types.foo	/^     axes :: MAT{REAL}(3,3)$/;"	a
inverse_axes	types.foo	/^     inverse_axes :: MAT{REAL}(3,3)$/;"	a
iso_value	types.foo	/^     iso_value :: REAL$/;"	a
accuracy	types.foo	/^     accuracy :: REAL$/;"	a
case	types.foo	/^     case :: INT$/;"	a
interior_case	types.foo	/^     interior_case :: INT$/;"	a
exterior_case	types.foo	/^     exterior_case :: INT$/;"	a
edge_bit_string	types.foo	/^     edge_bit_string :: INT$/;"	a
skip_bit_string	types.foo	/^     skip_bit_string :: INT$/;"	a
cube_bit_string	types.foo	/^     cube_bit_string :: INT$/;"	a
n_edge	types.foo	/^     n_edge :: INT$/;"	a
n_active_edge	types.foo	/^     n_active_edge :: INT$/;"	a
n_triangle	types.foo	/^     n_triangle :: INT$/;"	a
n_pt	types.foo	/^     n_pt :: INT$/;"	a
triangle_edge_index	types.foo	/^     triangle_edge_index :: MAT{INT}(3,5)$/;"	a
triangle_vertex_index	types.foo	/^     triangle_vertex_index :: MAT{INT}(3,5)$/;"	a
edge_vertex_pos	types.foo	/^     edge_vertex_pos :: MAT{REAL}(3,0:11)$/;"	a
edge_vertex_value	types.foo	/^     edge_vertex_value :: VEC{REAL}(0:11)$/;"	a
edge_vertex_gradient	types.foo	/^     edge_vertex_gradient :: MAT{REAL}(3,0:11)$/;"	a
edge_vertex_hessian	types.foo	/^     edge_vertex_hessian :: MAT3{REAL}(3,3,0:11)$/;"	a
edge_mean_curvature	types.foo	/^     edge_mean_curvature :: VEC{REAL}(0:11)$/;"	a
edge_gaussian_curvature	types.foo	/^     edge_gaussian_curvature :: VEC{REAL}(0:11)$/;"	a
edge_vertex_index	types.foo	/^     edge_vertex_index :: VEC{INT}(0:12)$/;"	a
vertex_edge_index	types.foo	/^     vertex_edge_index :: VEC{INT}(12)$/;"	a
VEC{MARCHINGCUBE}	types.foo	/^   array type VEC{MARCHINGCUBE}$/;"	v
ISOSURFACE	types.foo	/^   type ISOSURFACE$/;"	t
iso_kind	types.foo	/^     iso_kind :: STR$/;"	a
triangulation_method	types.foo	/^     triangulation_method :: STR$/;"	a
iso_value	types.foo	/^     iso_value :: REAL$/;"	a
iso_values	types.foo	/^     iso_values :: VEC{REAL}*$/;"	a
plot_grid	types.foo	/^     plot_grid :: PLOT_GRID$/;"	a
n_pt	types.foo	/^     n_pt :: INT$/;"	a
point	types.foo	/^     point :: MAT{REAL}*  DEFAULT_NULL$/;"	a
n_face	types.foo	/^     n_face :: INT$/;"	a
face	types.foo	/^     face :: MAT{INT}*  DEFAULT_NULL$/;"	a
n_cap	types.foo	/^     n_cap :: INT$/;"	a
cap	types.foo	/^     cap :: MAT{INT}*  DEFAULT_NULL$/;"	a
point_gradient	types.foo	/^     point_gradient :: MAT{REAL}*  DEFAULT_NULL$/;"	a
point_mean_curvature	types.foo	/^     point_mean_curvature :: VEC{REAL}*  DEFAULT_NULL$/;"	a
point_gaussian_curvature	types.foo	/^     point_gaussian_curvature :: VEC{REAL}*  DEFAULT_NULL$/;"	a
area	types.foo	/^     area :: REAL$/;"	a
volume	types.foo	/^     volume :: REAL$/;"	a
an_volume	types.foo	/^     an_volume :: REAL$/;"	a
volume_min	types.foo	/^     volume_min :: REAL$/;"	a
volume_max	types.foo	/^     volume_max :: REAL$/;"	a
n_skip	types.foo	/^     n_skip :: INT$/;"	a
level	types.foo	/^     level :: INT$/;"	a
final_level	types.foo	/^     final_level :: INT$/;"	a
scan_level	types.foo	/^     scan_level :: INT$/;"	a
minimum_scan_level	types.foo	/^     minimum_scan_level :: INT  DEFAULT(ISOSURFACE_MINIMUM_SCAN_LEVEL)$/;"	a
minimum_scan_division	types.foo	/^     minimum_scan_division :: REAL  DEFAULT(ZERO)$/;"	a
voxel_proximity_factor	types.foo	/^     voxel_proximity_factor :: REAL  DEFAULT(ISOSURFACE_VOXEL_PROXIMITY_FACTOR)$/;"	a
cube	types.foo	/^     cube :: MARCHINGCUBE$/;"	a
cap_square	types.foo	/^     cap_square :: CAPPING_SQUARE$/;"	a
del_x	types.foo	/^     del_x :: REAL   DEFAULT(ONE)$/;"	a
del_y	types.foo	/^     del_y :: REAL   DEFAULT(ONE)$/;"	a
del_z	types.foo	/^     del_z :: REAL   DEFAULT(ONE)$/;"	a
hash	types.foo	/^     hash :: HASH{VEC{INT},VEC{INT}}* DEFAULT_NULL$/;"	a
small_hash	types.foo	/^     small_hash :: BIN  DEFAULT(FALSE)$/;"	a
big_interior	types.foo	/^     big_interior :: BIN  DEFAULT(FALSE)$/;"	a
cap_ends	types.foo	/^     cap_ends :: INT  DEFAULT(0)$/;"	a
suppress_caps	types.foo	/^     suppress_caps :: BIN DEFAULT(FALSE)$/;"	a
surface_property	types.foo	/^     surface_property :: STR  DEFAULT(" ")$/;"	a
surface_property_values	types.foo	/^     surface_property_values :: VEC{REAL}* DEFAULT_NULL$/;"	a
surface_iso_values	types.foo	/^     surface_iso_values :: VEC{REAL}*  DEFAULT_NULL$/;"	a
surface_point	types.foo	/^     surface_point :: VEC{REAL}(3)$/;"	a
chop_surface_property_range	types.foo	/^     chop_surface_property_range :: BIN$/;"	a
surface_property_lower_bound	types.foo	/^     surface_property_lower_bound :: REAL  DEFAULT(ISOSURFACE_PROPERTY_LB)$/;"	a
surface_property_upper_bound	types.foo	/^     surface_property_upper_bound :: REAL  DEFAULT(ISOSURFACE_PROPERTY_UB)$/;"	a
surface_prop_lower_bound_abs	types.foo	/^     surface_prop_lower_bound_abs :: REAL  DEFAULT(ISOSURFACE_PROPERTY_LB_ABS)$/;"	a
surface_prop_upper_bound_abs	types.foo	/^     surface_prop_upper_bound_abs :: REAL  DEFAULT(ISOSURFACE_PROPERTY_UB_ABS)$/;"	a
colour	types.foo	/^     colour :: COLOUR_FUNCTION*  DEFAULT_NULL$/;"	a
atom	types.foo	/^     atom :: VEC{ATOM}*  DEFAULT_NULL$/;"	a
destroy_atom	types.foo	/^     destroy_atom :: BIN  DEFAULT(FALSE)$/;"	a
interpolator	types.foo	/^     interpolator :: INTERPOLATOR*  DEFAULT_NULL$/;"	a
CX_output_fingerprint	types.foo	/^     CX_output_fingerprint :: BIN DEFAULT(FALSE)$/;"	a
CX_fingerprint_grid	types.foo	/^     CX_fingerprint_grid :: INT DEFAULT(2)$/;"	a
ROBY	types.foo	/^   type ROBY$/;"	t
roby_kind	types.foo	/^     roby_kind :: STR$/;"	a
n1	types.foo	/^     n1 :: VEC{REAL}* DEFAULT_NULL$/;"	a
n2	types.foo	/^     n2 :: MAT{REAL}* DEFAULT_NULL$/;"	a
n_shared	types.foo	/^     n_shared :: REAL$/;"	a
bond_index	types.foo	/^     bond_index :: MAT{REAL}* DEFAULT_NULL$/;"	a
percent_covalency	types.foo	/^     percent_covalency :: MAT{REAL}* DEFAULT_NULL$/;"	a
gould_charge	types.foo	/^     gould_charge :: VEC{REAL}* DEFAULT_NULL$/;"	a
cruickshank_charge	types.foo	/^     cruickshank_charge :: VEC{REAL}* DEFAULT_NULL$/;"	a
summed_n2	types.foo	/^     summed_n2 :: VEC{REAL}* DEFAULT_NULL$/;"	a
summed_n3	types.foo	/^     summed_n3 :: VEC{REAL}* DEFAULT_NULL$/;"	a
subgroup_pop	types.foo	/^     subgroup_pop :: VEC{REAL}* DEFAULT_NULL$/;"	a
atom_list	types.foo	/^     atom_list :: VEC{INT}* DEFAULT_NULL$/;"	a
atom_group	types.foo	/^     atom_group :: VEC{VEC_{INT}}* DEFAULT_NULL$/;"	a
analyse_all_atom_pairs	types.foo	/^     analyse_all_atom_pairs :: BIN$/;"	a
bond_scale_factor	types.foo	/^     bond_scale_factor :: REAL$/;"	a
covalent_cutoff	types.foo	/^     covalent_cutoff :: REAL$/;"	a
ionic_cutoff	types.foo	/^     ionic_cutoff :: REAL$/;"	a
pi_on_2_cutoff	types.foo	/^     pi_on_2_cutoff :: REAL$/;"	a
zero_cutoff	types.foo	/^     zero_cutoff :: REAL$/;"	a
occupied_ANO_cutoff	types.foo	/^     occupied_ANO_cutoff :: REAL$/;"	a
output_theta_info	types.foo	/^     output_theta_info :: BIN$/;"	a
atom_a	types.foo	/^     atom_a :: VEC{INT}* DEFAULT_NULL$/;"	a
atom_b	types.foo	/^     atom_b :: VEC{INT}* DEFAULT_NULL$/;"	a
atom_ab	types.foo	/^     atom_ab :: VEC{INT}* DEFAULT_NULL$/;"	a
theta_C	types.foo	/^     theta_C :: MAT{REAL}* DEFAULT_NULL$/;"	a
eval_C	types.foo	/^     eval_C :: VEC{REAL}* DEFAULT_NULL$/;"	a
theta_angle	types.foo	/^     theta_angle :: VEC{REAL}* DEFAULT_NULL$/;"	a
pair	types.foo	/^     pair :: VEC{INT}* DEFAULT_NULL$/;"	a
theta_I	types.foo	/^     theta_I :: MAT{REAL}* DEFAULT_NULL$/;"	a
eval_I	types.foo	/^     eval_I :: VEC{REAL}* DEFAULT_NULL$/;"	a
pop_C	types.foo	/^     pop_C :: VEC{REAL}* DEFAULT_NULL$/;"	a
pop_I	types.foo	/^     pop_I :: VEC{REAL}* DEFAULT_NULL$/;"	a
pop_A	types.foo	/^     pop_A :: VEC{REAL}* DEFAULT_NULL$/;"	a
pop_B	types.foo	/^     pop_B :: VEC{REAL}* DEFAULT_NULL$/;"	a
covalent_index	types.foo	/^     covalent_index :: VEC{REAL}* DEFAULT_NULL$/;"	a
ionic_index	types.foo	/^     ionic_index :: VEC{REAL}* DEFAULT_NULL$/;"	a
proportion_a	types.foo	/^     proportion_a :: MAT{REAL}* DEFAULT_NULL$/;"	a
charge	types.foo	/^     charge :: INT$/;"	a
spin_multiplicity	types.foo	/^     spin_multiplicity :: INT$/;"	a
rho	types.foo	/^     rho :: OPMATRIX* DEFAULT_NULL$/;"	a
overlap_matrix	types.foo	/^     overlap_matrix :: MAT{REAL}* DEFAULT_NULL$/;"	a
atom	types.foo	/^     atom :: VEC{ATOM}* DEFAULT_NULL$/;"	a
MO_LOCALISER	types.foo	/^   type MO_LOCALISER$/;"	t
algorithm	types.foo	/^     algorithm :: STR  DEFAULT(MO_LOCALISER_ALGORITHM)$/;"	a
n_orb	types.foo	/^     n_orb :: INT  DEFAULT (0)$/;"	a
accuracy	types.foo	/^     accuracy :: REAL  DEFAULT(MO_LOCALISER_ACCURACY)$/;"	a
iteration	types.foo	/^     iteration :: INT  DEFAULT(0)$/;"	a
max_iterations	types.foo	/^     max_iterations :: INT  DEFAULT(MO_LOCALISER_MAXIT)$/;"	a
MO	types.foo	/^     MO :: MAT{REAL}*  DEFAULT_NULL$/;"	a
TM	types.foo	/^     TM :: MAT{REAL}*  DEFAULT_NULL$/;"	a
dipole	types.foo	/^     dipole :: MAT3{REAL}*  DEFAULT_NULL$/;"	a
quadrupole	types.foo	/^     quadrupole :: MAT3{REAL}*  DEFAULT_NULL$/;"	a
GEMINAL_MF_SPECTRUM	types.foo	/^   type GEMINAL_MF_SPECTRUM$/;"	t
name	types.foo	/^     name :: STR$/;"	a
nuclear_electric_dipole	types.foo	/^     nuclear_electric_dipole :: VEC{REAL}(3)$/;"	a
nuclear_repulsion_energy	types.foo	/^     nuclear_repulsion_energy :: REAL$/;"	a
n_geminals	types.foo	/^     n_geminals :: INT$/;"	a
i_geminals	types.foo	/^     i_geminals :: INT$/;"	a
n_bf	types.foo	/^     n_bf :: INT$/;"	a
n_bas	types.foo	/^     n_bas :: INT$/;"	a
n_dependent	types.foo	/^     n_dependent :: INT$/;"	a
bra	types.foo	/^     bra :: VEC{MAT_{REAL}}*$/;"	a
ket	types.foo	/^     ket :: VEC{MAT_{REAL}}*$/;"	a
special_ket	types.foo	/^     special_ket :: VEC{VEC_{INT}}*$/;"	a
contraction_wfs	types.foo	/^     contraction_wfs :: VEC{MAT_{REAL}}*$/;"	a
contraction_energies	types.foo	/^     contraction_energies :: VEC{REAL}*$/;"	a
tol	types.foo	/^     tol :: REAL$/;"	a
ld_tol	types.foo	/^     ld_tol :: REAL$/;"	a
ig_tol	types.foo	/^     ig_tol :: REAL$/;"	a
GEMINAL_MF_SCHEME	types.foo	/^   type GEMINAL_MF_SCHEME$/;"	t
spectrum	types.foo	/^   spectrum :: GEMINAL_MF_SPECTRUM*$/;"	g
max_iterations	types.foo	/^   max_iterations :: INT$/;"	g
n_iterations	types.foo	/^   n_iterations :: INT$/;"	g
n_orbitals	types.foo	/^   n_orbitals :: INT$/;"	g
tolerance_scheme	types.foo	/^   tolerance_scheme :: VEC{INT}*$/;"	g
ld_tol_scheme	types.foo	/^   ld_tol_scheme :: VEC{REAL}*$/;"	g
ig_tol_scheme	types.foo	/^   ig_tol_scheme :: VEC{REAL}*$/;"	g
truncation_scheme	types.foo	/^   truncation_scheme :: VEC{REAL}*$/;"	g
do_triplet_energies	types.foo	/^   do_triplet_energies :: VEC{BIN}*$/;"	g
do_electric_dipole	types.foo	/^   do_electric_dipole :: VEC{BIN}*$/;"	g
convergence_threshold	types.foo	/^   convergence_threshold :: REAL$/;"	g
add_core	types.foo	/^   add_core :: BIN$/;"	g
use_brillouin	types.foo	/^   use_brillouin :: BIN$/;"	g
make_integrals	types.foo	/^   make_integrals :: BIN$/;"	g
make_singlet_extremals	types.foo	/^   make_singlet_extremals :: BIN$/;"	g
readin_mos	types.foo	/^   readin_mos :: BIN$/;"	g
readin_scheme	types.foo	/^   readin_scheme :: BIN$/;"	g
guess_type	types.foo	/^   guess_type :: STR$/;"	g
starting_group	types.foo	/^   starting_group :: INT$/;"	g
orthogonality_type	types.foo	/^   orthogonality_type :: STR$/;"	g
print_hamiltonian	types.foo	/^   print_hamiltonian :: BIN$/;"	g
MOLECULE	types.foo	/^   type MOLECULE$/;"	t
name	types.foo	/^     name :: STR$/;"	a
charge	types.foo	/^     charge :: INT$/;"	a
spin_multiplicity	types.foo	/^     spin_multiplicity :: INT$/;"	a
E_field	types.foo	/^     E_field :: VEC{REAL}(3)$/;"	a
B_field	types.foo	/^     B_field :: VEC{REAL}(3)$/;"	a
gauge_origin	types.foo	/^     gauge_origin :: VEC{REAL}(3)$/;"	a
atom	types.foo	/^     atom :: VEC{ATOM}* DEFAULT_NULL$/;"	a
atom_info_made	types.foo	/^     atom_info_made :: BIN  DEFAULT(FALSE)$/;"	a
basis_name	types.foo	/^     basis_name :: STR  DEFAULT(" ")$/;"	a
basis_l_max	types.foo	/^     basis_l_max :: INT$/;"	a
basis	types.foo	/^     basis :: VEC{BASIS}* DEFAULT_NULL$/;"	a
use_spherical_basis	types.foo	/^     use_spherical_basis :: BIN   DEFAULT(FALSE)$/;"	a
slaterbasis_name	types.foo	/^     slaterbasis_name :: STR  DEFAULT(" ")$/;"	a
slaterbasis	types.foo	/^     slaterbasis :: VEC{SLATERBASIS}* DEFAULT_NULL$/;"	a
coppensbasis_name	types.foo	/^     coppensbasis_name :: STR  DEFAULT(" ")$/;"	a
coppensbasis	types.foo	/^     coppensbasis :: VEC{COPPENSBASIS}* DEFAULT_NULL$/;"	a
basis_info_made	types.foo	/^     basis_info_made :: BIN$/;"	a
plot_grid	types.foo	/^     plot_grid :: PLOT_GRID* DEFAULT_NULL$/;"	a
use_interpolators	types.foo	/^     use_interpolators :: BIN  DEFAULT(TRUE)$/;"	a
interpolator	types.foo	/^     interpolator :: INTERPOLATOR*  DEFAULT_NULL$/;"	a
isosurface	types.foo	/^     isosurface :: ISOSURFACE* DEFAULT_NULL$/;"	a
becke_grid	types.foo	/^     becke_grid :: BECKE_GRID* DEFAULT_NULL$/;"	a
crystal	types.foo	/^     crystal :: CRYSTAL* DEFAULT_NULL$/;"	a
cluster	types.foo	/^     cluster :: CLUSTER* DEFAULT_NULL$/;"	a
cif	types.foo	/^     cif :: CIF* DEFAULT_NULL$/;"	a
pointgroup	types.foo	/^     pointgroup :: POINTGROUP* DEFAULT_NULL$/;"	a
saved	types.foo	/^     saved :: MOLECULE* DEFAULT_NULL$/;"	a
n_e	types.foo	/^     n_e :: INT$/;"	a
n_a	types.foo	/^     n_a :: INT$/;"	a
n_b	types.foo	/^     n_b :: INT$/;"	a
n_atom	types.foo	/^     n_atom :: INT$/;"	a
n_atom_kind	types.foo	/^     n_atom_kind :: INT$/;"	a
n_basis	types.foo	/^     n_basis :: INT$/;"	a
n_shell	types.foo	/^     n_shell :: INT$/;"	a
n_shell_pairs	types.foo	/^     n_shell_pairs :: INT$/;"	a
n_bf	types.foo	/^     n_bf :: INT$/;"	a
n_prim	types.foo	/^     n_prim :: INT$/;"	a
n_unique_shells	types.foo	/^     n_unique_shells :: INT$/;"	a
atom_for_shell	types.foo	/^     atom_for_shell :: VEC{INT}* DEFAULT_NULL$/;"	a
atom_shell_for_shell	types.foo	/^     atom_shell_for_shell :: VEC{INT}* DEFAULT_NULL$/;"	a
first_shell_for_atom	types.foo	/^     first_shell_for_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
last_shell_for_atom	types.foo	/^     last_shell_for_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
basis_shell_for_shell	types.foo	/^     basis_shell_for_shell :: VEC{INT}* DEFAULT_NULL$/;"	a
first_basis_fn_for_shell	types.foo	/^     first_basis_fn_for_shell :: VEC{INT}* DEFAULT_NULL$/;"	a
last_basis_fn_for_shell	types.foo	/^     last_basis_fn_for_shell :: VEC{INT}* DEFAULT_NULL$/;"	a
angular_moment_for_shell	types.foo	/^     angular_moment_for_shell :: VEC{INT}* DEFAULT_NULL$/;"	a
first_basis_fn_for_atom	types.foo	/^     first_basis_fn_for_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
last_basis_fn_for_atom	types.foo	/^     last_basis_fn_for_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
precomputed_basis_shellpair	types.foo	/^     precomputed_basis_shellpair :: MAT{SHELL1PAIR}* DEFAULT_NULL$/;"	a
max_I	types.foo	/^     max_I :: VEC{REAL}*, private  DEFAULT_NULL $/;"	a
atom_kind	types.foo	/^     atom_kind :: VEC{INT}* DEFAULT_NULL$/;"	a
unique_atom	types.foo	/^     unique_atom :: VEC{INT}* DEFAULT_NULL$/;"	a
ANO_data_made	types.foo	/^     ANO_data_made :: BIN  DEFAULT(FALSE)$/;"	a
ANO_interpolators_made	types.foo	/^     ANO_interpolators_made :: BIN  DEFAULT(FALSE)$/;"	a
interpolators_made	types.foo	/^     interpolators_made :: BIN  DEFAULT(FALSE)$/;"	a
atom_shell_info_made	types.foo	/^     atom_shell_info_made :: BIN  DEFAULT(FALSE)$/;"	a
spherical_atom_data_made	types.foo	/^     spherical_atom_data_made :: BIN  DEFAULT(FALSE)$/;"	a
overlapping_atoms	types.foo	/^     overlapping_atoms :: VEC{BIN}* DEFAULT_NULL$/;"	a
overlapping_atoms_for_atom	types.foo	/^     overlapping_atoms_for_atom :: VEC{VEC_{INT}}* DEFAULT_NULL$/;"	a
scfdata	types.foo	/^     scfdata :: SCFDATA* DEFAULT_NULL$/;"	a
orbital_energies	types.foo	/^     orbital_energies :: OPVECTOR* DEFAULT_NULL$/;"	a
molecular_orbitals	types.foo	/^     molecular_orbitals :: OPMATRIX* DEFAULT_NULL$/;"	a
density_matrix	types.foo	/^     density_matrix :: OPMATRIX* DEFAULT_NULL$/;"	a
natural_orbitals	types.foo	/^     natural_orbitals :: OPMATRIX* DEFAULT_NULL$/;"	a
occupation_numbers	types.foo	/^     occupation_numbers :: OPVECTOR* DEFAULT_NULL$/;"	a
geminal_mf_spectrum	types.foo	/^     geminal_mf_spectrum :: GEMINAL_MF_SPECTRUM*$/;"	a
geminal_mf_scheme	types.foo	/^     geminal_mf_scheme :: GEMINAL_MF_SCHEME*$/;"	a
overlap_matrix	types.foo	/^     overlap_matrix :: MAT{REAL}* DEFAULT_NULL$/;"	a
overlap_eigenvectors	types.foo	/^     overlap_eigenvectors :: MAT{REAL}* DEFAULT_NULL$/;"	a
overlap_eigenvalues	types.foo	/^     overlap_eigenvalues :: VEC{REAL}* DEFAULT_NULL$/;"	a
max_S	types.foo	/^     max_S :: VEC{REAL}* DEFAULT_NULL$/;"	a
core_matrix	types.foo	/^     core_matrix :: OPMATRIX* DEFAULT_NULL$/;"	a
fock_matrix	types.foo	/^     fock_matrix :: OPMATRIX* DEFAULT_NULL$/;"	a
constraint_matrix	types.foo	/^     constraint_matrix :: OPMATRIX* DEFAULT_NULL$/;"	a
old_molecular_orbitals	types.foo	/^     old_molecular_orbitals :: OPMATRIX* DEFAULT_NULL$/;"	a
old_density_matrix	types.foo	/^     old_density_matrix :: OPMATRIX* DEFAULT_NULL$/;"	a
old_fock_matrix	types.foo	/^     old_fock_matrix :: OPMATRIX* DEFAULT_NULL$/;"	a
old_constraint_matrix	types.foo	/^     old_constraint_matrix :: OPMATRIX* DEFAULT_NULL$/;"	a
atom_group	types.foo	/^     atom_group :: VEC{ATOM_GROUP}* DEFAULT_NULL$/;"	a
optimise_thermals	types.foo	/^     optimise_thermals :: BIN$/;"	a
roby	types.foo	/^     roby :: ROBY* DEFAULT_NULL$/;"	a
CX_file_name	types.foo	/^     CX_file_name :: STR  DEFAULT(" ")$/;"	a
CX_uses_angstrom	types.foo	/^     CX_uses_angstrom :: BIN  DEFAULT(FALSE)$/;"	a
localiser	types.foo	/^     localiser :: MO_LOCALISER*$/;"	a
U_electric_dipole	types.foo	/^     U_electric_dipole :: MAT3{REAL}*$/;"	a
dipole_polarisability	types.foo	/^     dipole_polarisability :: MAT{REAL}*  DEFAULT_NULL$/;"	a
dipole_hyperpolarisability	types.foo	/^     dipole_hyperpolarisability :: MAT3{REAL}*  DEFAULT_NULL$/;"	a
Hirshfeld_atom_info_made	types.foo	/^     Hirshfeld_atom_info_made :: BIN  DEFAULT(FALSE)$/;"	a
atomic_polarisabilities_made	types.foo	/^     atomic_polarisabilities_made :: BIN  DEFAULT(FALSE)$/;"	a
invariom_database_directory	types.foo	/^     invariom_database_directory :: STR  DEFAULT(" ")$/;"	a
invariom_refinement	types.foo	/^     invariom_refinement :: BIN DEFAULT(FALSE)$/;"	a
debug_list	unit_cell.foo	/^   debug_list :: VEC{STR}*, private  DEFAULT_NULL$/;"	g
create	unit_cell.foo	/^   create ::: get_from(OBJECT), leaky$/;"	r
destroy	unit_cell.foo	/^   destroy ::: get_from(OBJECT), leaky$/;"	r
created	unit_cell.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	unit_cell.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	unit_cell.foo	/^   set_defaults$/;"	r
create_copy	unit_cell.foo	/^   create_copy(unit_cell) ::: leaky$/;"	r
copy	unit_cell.foo	/^   copy(unit_cell)$/;"	r
alpha	unit_cell.foo	/^   alpha result (res)$/;"	r
beta	unit_cell.foo	/^   beta result (res)$/;"	r
gamma	unit_cell.foo	/^   gamma result (res)$/;"	r
alpha_star	unit_cell.foo	/^   alpha_star result (res)$/;"	r
beta_star	unit_cell.foo	/^   beta_star result (res)$/;"	r
gamma_star	unit_cell.foo	/^   gamma_star result (res)$/;"	r
a_star	unit_cell.foo	/^   a_star result (res)$/;"	r
b_star	unit_cell.foo	/^   b_star result (res)$/;"	r
c_star	unit_cell.foo	/^   c_star result (res)$/;"	r
make_info	unit_cell.foo	/^   make_info $/;"	r
make_volume	unit_cell.foo	/^   make_volume ::: private$/;"	r
make_direct_matrix	unit_cell.foo	/^   make_direct_matrix ::: private$/;"	r
make_reciprocal_matrix	unit_cell.foo	/^   make_reciprocal_matrix ::: private$/;"	r
make_direct_U_matrix	unit_cell.foo	/^   make_direct_U_matrix ::: private$/;"	r
make_reciprocal_U_matrix	unit_cell.foo	/^   make_reciprocal_U_matrix ::: private$/;"	r
change_from_fractional	unit_cell.foo	/^   change_from_fractional(g)$/;"	r
change_into_fractional	unit_cell.foo	/^   change_into_fractional(g)$/;"	r
change_from_fractional	unit_cell.foo	/^   change_from_fractional(p)$/;"	r
change_into_fractional	unit_cell.foo	/^   change_into_fractional(p)$/;"	r
change_adp_from_fractional	unit_cell.foo	/^   change_adp_from_fractional(adp_vector)$/;"	r
change_adp_into_fractional	unit_cell.foo	/^   change_adp_into_fractional(adp_vector)$/;"	r
change_U_iso_to_ADP	unit_cell.foo	/^   change_U_iso_to_ADP(U_iso,ADP)$/;"	r
read_keywords	unit_cell.foo	/^   read_keywords ::: get_from(OBJECT), recursive$/;"	r
process_keyword	unit_cell.foo	/^   process_keyword(keyword)$/;"	r
read_units	unit_cell.foo	/^   read_units ::: get_from(OBJECT)$/;"	r
read_junk	unit_cell.foo	/^   read_junk ::: get_from(OBJECT)$/;"	r
update	unit_cell.foo	/^   update$/;"	r
read_lengths	unit_cell.foo	/^   read_lengths ::: private$/;"	r
read_a	unit_cell.foo	/^   read_a ::: private$/;"	r
read_b	unit_cell.foo	/^   read_b ::: private$/;"	r
read_c	unit_cell.foo	/^   read_c ::: private$/;"	r
read_angles	unit_cell.foo	/^   read_angles ::: private$/;"	r
read_alpha	unit_cell.foo	/^   read_alpha ::: private$/;"	r
read_beta	unit_cell.foo	/^   read_beta ::: private$/;"	r
read_gamma	unit_cell.foo	/^   read_gamma ::: private$/;"	r
read_CIF	unit_cell.foo	/^   read_CIF(cif) $/;"	r
read_CIF	unit_cell.foo	/^   read_CIF(cif,sigma) $/;"	r
make_LFF_tensors	unit_cell.foo	/^   make_LFF_tensors(L2,pos)$/;"	r
make_LFF_h_tensor	unit_cell.foo	/^   make_LFF_h_tensor(r,h2) ::: private$/;"	r
make_LFF_g_tensor	unit_cell.foo	/^   make_LFF_g_tensor(q,g2) ::: private$/;"	r
make_LFF_tensors	unit_cell.foo	/^   make_LFF_tensors(L0,L1,pos,mol_for,sphere_sum)$/;"	r
make_LFF_h_tensors	unit_cell.foo	/^   make_LFF_h_tensors(H0,H1,x,n)$/;"	r
make_LFF_g_tensors	unit_cell.foo	/^   make_LFF_g_tensors(G0,G1,x)$/;"	r
read_debug_on	unit_cell.foo	/^   read_debug_on ::: get_from(DEBUG), leaky$/;"	r
read_debug_off	unit_cell.foo	/^   read_debug_off ::: get_from(DEBUG), leaky$/;"	r
debugging	unit_cell.foo	/^   debugging(name) result (res) ::: get_from(DEBUG)$/;"	r
put_debug_list	unit_cell.foo	/^   put_debug_list ::: get_from(DEBUG)$/;"	r
put_debug	unit_cell.foo	/^   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})$/;"	r
put	unit_cell.foo	/^   put$/;"	r
put_CX	unit_cell.foo	/^   put_CX(label,formula,spacegroup)$/;"	r
put_cif	unit_cell.foo	/^   put_cif$/;"	r
used_unit_list	unit_number.foo	/^   used_unit_list :: VEC{INT}*, private DEFAULT_NULL$/;"	g
get	unit_number.foo	/^   get(unit) ::: leaky$/;"	r
free	unit_number.foo	/^   free(unit) ::: leaky$/;"	r
flush_buffer	unit_number.foo	/^   flush_buffer$/;"	r
saved_self	vec{atom}.foo	/^   saved_self :: VEC{ATOM}*, private  DEFAULT_NULL$/;"	g
connections_for	vec{atom}.foo	/^   connections_for :: VEC{VEC_{INT}}*, private DEFAULT_NULL$/;"	g
create	vec{atom}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{atom}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
create_copy	vec{atom}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{atom}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
nullify_ptr_part	vec{atom}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
nullify_bases	vec{atom}.foo	/^   nullify_bases$/;"	r
nullify_basis_part	vec{atom}.foo	/^   nullify_basis_part$/;"	r
nullify_slaterbasis_part	vec{atom}.foo	/^   nullify_slaterbasis_part$/;"	r
nullify_coppensbasis_part	vec{atom}.foo	/^   nullify_coppensbasis_part$/;"	r
destroy_ptr_part	vec{atom}.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	vec{atom}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{atom}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	vec{atom}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
set_labels_and_atomic_numbers	vec{atom}.foo	/^   set_labels_and_atomic_numbers(labels)$/;"	r
set_labels	vec{atom}.foo	/^   set_labels(labels)$/;"	r
set_recognised_labels	vec{atom}.foo	/^   set_recognised_labels(list) ::: leaky$/;"	r
set_use_interpolators	vec{atom}.foo	/^   set_use_interpolators(use_interp)$/;"	r
set_unique_tags	vec{atom}.foo	/^   set_unique_tags$/;"	r
shrink	vec{atom}.foo	/^   shrink(dim)$/;"	r
expand	vec{atom}.foo	/^   expand(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{atom}.foo	/^   append(v) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{atom}.foo	/^   append(value) ::: get_from(VEC{OBJECT}), leaky$/;"	r
prune_element	vec{atom}.foo	/^   prune_element(k) ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_list_keywords	vec{atom}.foo	/^   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky$/;"	r
process_list_keyword	vec{atom}.foo	/^   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_data	vec{atom}.foo	/^   read_data(ignore_braces) ::: get_from(VEC{OBJECT}), leaky$/;"	r
data_length	vec{atom}.foo	/^   data_length result (length) ::: get_from(VEC{OBJECT})$/;"	r
read_altered_data	vec{atom}.foo	/^   read_altered_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_append_data	vec{atom}.foo	/^   read_append_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys	vec{atom}.foo	/^   process_keys ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys_once	vec{atom}.foo	/^   process_keys_once ::: get_from(VEC{OBJECT})$/;"	r
keys_created	vec{atom}.foo	/^   keys_created result (res) ::: get_from(VEC{OBJECT})$/;"	r
set_keys	vec{atom}.foo	/^   set_keys(the_keys) ::: get_from(VEC{OBJECT})$/;"	r
clear_keys	vec{atom}.foo	/^   clear_keys ::: get_from(VEC{OBJECT})$/;"	r
read_keys	vec{atom}.foo	/^   read_keys ::: get_from(VEC{OBJECT})$/;"	r
put_keys_table	vec{atom}.foo	/^   put_keys_table ::: get_from(VEC{OBJECT})$/;"	r
put_table_header	vec{atom}.foo	/^   put_table_header ::: get_from(VEC{OBJECT})$/;"	r
put_table_footer	vec{atom}.foo	/^   put_table_footer ::: get_from(VEC{OBJECT})$/;"	r
redirect	vec{atom}.foo	/^   redirect ::: leaky$/;"	r
revert	vec{atom}.foo	/^   revert ::: leaky$/;"	r
read_keywords	vec{atom}.foo	/^   read_keywords ::: get_from(VEC{OBJECT}), recursive, leaky$/;"	r
process_keyword	vec{atom}.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
read_CIF	vec{atom}.foo	/^   read_CIF ::: leaky$/;"	r
read_CIF	vec{atom}.foo	/^   read_CIF(name) ::: leaky$/;"	r
read_CIF	vec{atom}.foo	/^   read_CIF(cif) ::: leaky$/;"	r
read_CIF_ADPs	vec{atom}.foo	/^   read_CIF_ADPs(name) ::: leaky$/;"	r
read_CIF_ADPs	vec{atom}.foo	/^   read_CIF_ADPs(cif) ::: leaky$/;"	r
read_use_interpolators	vec{atom}.foo	/^   read_use_interpolators $/;"	r
resolve_bases	vec{atom}.foo	/^   resolve_bases(basis,suffix) $/;"	r
resolve_bases	vec{atom}.foo	/^   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, BASIS=>SLATERBASIS)$/;"	r
resolve_bases	vec{atom}.foo	/^   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, BASIS=>COPPENSBASIS)$/;"	r
put	vec{atom}.foo	/^   put$/;"	r
put_coordinate_info	vec{atom}.foo	/^   put_coordinate_info$/;"	r
put_coordinates	vec{atom}.foo	/^   put_coordinates$/;"	r
put_pdb	vec{atom}.foo	/^   put_pdb(pdbfile)$/;"	r
put_coordinates_and_charges	vec{atom}.foo	/^   put_coordinates_and_charges$/;"	r
put_coords_and_charges	vec{atom}.foo	/^   put_coords_and_charges(angstrom) ::: private$/;"	r
put_bond_length_table	vec{atom}.foo	/^   put_bond_length_table ::: private$/;"	r
get_bonded_atoms	vec{atom}.foo	/^   get_bonded_atoms(pair,dist,atom_kind,k1,k2) ::: leaky, private$/;"	r
put_bond_angle_table	vec{atom}.foo	/^   put_bond_angle_table ::: private$/;"	r
get_bonded_angles	vec{atom}.foo	/^   get_bonded_angles(triple,angle,atom_kind,k1,k2,k3) ::: leaky, private$/;"	r
put_torsion_angle_table	vec{atom}.foo	/^   put_torsion_angle_table(all) ::: private$/;"	r
list_symbol	vec{atom}.foo	/^   list_symbol(a) result (res) ::: private$/;"	r
put_ADPs	vec{atom}.foo	/^   put_ADPs(cell)$/;"	r
put_ADP_helper	vec{atom}.foo	/^   put_ADP_helper(units) ::: private$/;"	r
put_mm_info	vec{atom}.foo	/^   put_mm_info ::: private$/;"	r
put_restraint_atoms	vec{atom}.foo	/^   put_restraint_atoms ::: private$/;"	r
put_principal_axes	vec{atom}.foo	/^   put_principal_axes$/;"	r
put_vrml	vec{atom}.foo	/^   put_vrml(out)$/;"	r
put_vrml_header	vec{atom}.foo	/^   put_vrml_header(out) ::: private$/;"	r
put_vrml_atoms	vec{atom}.foo	/^   put_vrml_atoms(out) ::: private$/;"	r
put_vrml_bonds	vec{atom}.foo	/^   put_vrml_bonds(out) ::: private$/;"	r
put_atom_groups	vec{atom}.foo	/^   put_atom_groups$/;"	r
put_CX	vec{atom}.foo	/^   put_CX(label,angstrom)$/;"	r
put_cif	vec{atom}.foo	/^   put_cif$/;"	r
put_cif_with_errors	vec{atom}.foo	/^   put_cif_with_errors(delta_p)$/;"	r
put_accurate_cif	vec{atom}.foo	/^   put_accurate_cif(covariance_matrix)$/;"	r
put_NKA_with_errors	vec{atom}.foo	/^   put_NKA_with_errors(delta_p,T_sequence_no,fractional_coords)$/;"	r
put_excel_with_errors	vec{atom}.foo	/^   put_excel_with_errors(delta_p,temperature)$/;"	r
put_bond_length_table	vec{atom}.foo	/^   put_bond_length_table(covariance_matrix,all) $/;"	r
put_bond_angle_table	vec{atom}.foo	/^   put_bond_angle_table(covariance_matrix,all)$/;"	r
put_torsion_angle_table	vec{atom}.foo	/^   put_torsion_angle_table(covariance_matrix,all)$/;"	r
initialise_local_H_modes	vec{atom}.foo	/^   initialise_local_H_modes(L)$/;"	r
resolve_axis_system	vec{atom}.foo	/^   resolve_axis_system(cell)$/;"	r
change_axis_system_to	vec{atom}.foo	/^   change_axis_system_to(axiskind,cell)$/;"	r
change_coord_axis_system_to	vec{atom}.foo	/^   change_coord_axis_system_to(axiskind,cell)$/;"	r
change_thermal_axis_system_to	vec{atom}.foo	/^   change_thermal_axis_system_to(axiskind,cell)$/;"	r
convert_from_angstrom	vec{atom}.foo	/^   convert_from_angstrom$/;"	r
convert_to_angstrom	vec{atom}.foo	/^   convert_to_angstrom$/;"	r
extend_bond_lengths	vec{atom}.foo	/^   extend_bond_lengths(z1,z2,factor) $/;"	r
set_bond_lengths	vec{atom}.foo	/^   set_bond_lengths(z1,z2,length) $/;"	r
no_of_dummy_atoms	vec{atom}.foo	/^   no_of_dummy_atoms result (res) ::: pure$/;"	r
dummy_atoms	vec{atom}.foo	/^   dummy_atoms result (ind) ::: pure$/;"	r
no_of_nondummy_atoms	vec{atom}.foo	/^   no_of_nondummy_atoms result (res) ::: pure$/;"	r
nondummy_atoms	vec{atom}.foo	/^   nondummy_atoms result (ind) ::: pure$/;"	r
no_of_atoms_with_bases	vec{atom}.foo	/^   no_of_atoms_with_bases result (res) ::: pure$/;"	r
atoms_with_bases	vec{atom}.foo	/^   atoms_with_bases result (ind) ::: pure$/;"	r
chemical_formula	vec{atom}.foo	/^   chemical_formula(with_spaces) result (res)$/;"	r
molecular_weight	vec{atom}.foo	/^   molecular_weight result (res)$/;"	r
get_mean_neutron_numbers	vec{atom}.foo	/^   get_mean_neutron_numbers(NN)$/;"	r
unique_tags	vec{atom}.foo	/^   unique_tags result (res) ::: leaky$/;"	r
chemical_symbols	vec{atom}.foo	/^   chemical_symbols result (res)$/;"	r
has_dummy_labels	vec{atom}.foo	/^   has_dummy_labels result (res) $/;"	r
sum_of_nuclear_charges	vec{atom}.foo	/^   sum_of_nuclear_charges result (res)$/;"	r
nuclear_repulsion_energy	vec{atom}.foo	/^   nuclear_repulsion_energy result (res)$/;"	r
nuclear_repulsion_energy	vec{atom}.foo	/^   nuclear_repulsion_energy(atoms) result (res)$/;"	r
nuclear_repulsion_energy	vec{atom}.foo	/^   nuclear_repulsion_energy(atoms,nuclei) result (res)$/;"	r
centre_of_mass	vec{atom}.foo	/^   centre_of_mass result(centre)$/;"	r
move_origin_to_centre_of_mass	vec{atom}.foo	/^   move_origin_to_centre_of_mass$/;"	r
change_to_principal_axes	vec{atom}.foo	/^   change_to_principal_axes$/;"	r
change_to_principal_top_axes	vec{atom}.foo	/^   change_to_principal_top_axes$/;"	r
change_coordinate_axes	vec{atom}.foo	/^   change_coordinate_axes(axes)$/;"	r
mass	vec{atom}.foo	/^   mass result (res)$/;"	r
reduced_mass	vec{atom}.foo	/^   reduced_mass result(mu)$/;"	r
make_inertia_tensor	vec{atom}.foo	/^   make_inertia_tensor(it)$/;"	r
make_principal_moments	vec{atom}.foo	/^   make_principal_moments(pm,pa,reorder)$/;"	r
make_shape_tensor	vec{atom}.foo	/^   make_shape_tensor(st)$/;"	r
make_shape_moments	vec{atom}.foo	/^   make_shape_moments(sm,sa)$/;"	r
is_linear	vec{atom}.foo	/^   is_linear(pm) result (res) ::: private$/;"	r
is_spherical_top	vec{atom}.foo	/^   is_spherical_top(pm) result (res) ::: private$/;"	r
is_symmetric_top	vec{atom}.foo	/^   is_symmetric_top(pm) result (res) ::: private$/;"	r
is_prolate_top	vec{atom}.foo	/^   is_prolate_top(pm) result (res) ::: private$/;"	r
is_oblate_top	vec{atom}.foo	/^   is_oblate_top(pm) result (res) ::: private$/;"	r
is_asymmetric_top	vec{atom}.foo	/^   is_asymmetric_top(pm) result (res) ::: private$/;"	r
no_of_same_principal_moments	vec{atom}.foo	/^   no_of_same_principal_moments(pm) result(same)$/;"	r
centre_of_atoms	vec{atom}.foo	/^   centre_of_atoms(axes) result(centre)$/;"	r
move_origin_to_centre_of_atoms	vec{atom}.foo	/^   move_origin_to_centre_of_atoms$/;"	r
bounding_cube_width	vec{atom}.foo	/^   bounding_cube_width result(width)$/;"	r
bounding_box	vec{atom}.foo	/^   bounding_box(axes) result(box)$/;"	r
has_sequence_numbers	vec{atom}.foo	/^   has_sequence_numbers result (res)$/;"	r
has_thermal_tensors	vec{atom}.foo	/^   has_thermal_tensors result (res)$/;"	r
has_U_iso	vec{atom}.foo	/^   has_U_iso result (res)$/;"	r
has_thermal_factors	vec{atom}.foo	/^   has_thermal_factors result (res)$/;"	r
has_residue_codes	vec{atom}.foo	/^   has_residue_codes result (res)$/;"	r
has_restraints	vec{atom}.foo	/^   has_restraints result (res)$/;"	r
has_dipoles	vec{atom}.foo	/^   has_dipoles result (has)$/;"	r
has_polarisabilities	vec{atom}.foo	/^   has_polarisabilities result (has)$/;"	r
get_coordinates	vec{atom}.foo	/^   get_coordinates(coord)$/;"	r
coordinates	vec{atom}.foo	/^   coordinates result (coord)$/;"	r
geometry	vec{atom}.foo	/^   geometry(skip_dummies) result (g) ::: leaky$/;"	r
get_geometry	vec{atom}.foo	/^   get_geometry(g,skip_dummies)$/;"	r
get_geometry_vector	vec{atom}.foo	/^   get_geometry_vector(g)$/;"	r
geometry_vector	vec{atom}.foo	/^   geometry_vector result (g)$/;"	r
set_geometry_from_vector	vec{atom}.foo	/^   set_geometry_from_vector(g)$/;"	r
has_unique_labels	vec{atom}.foo	/^   has_unique_labels result (has)$/;"	r
has_all_ANO_data	vec{atom}.foo	/^   has_all_ANO_data result(has)$/;"	r
has_all_bases	vec{atom}.foo	/^   has_all_bases result(has)$/;"	r
has_all_gaussian_bases	vec{atom}.foo	/^   has_all_gaussian_bases result(has)$/;"	r
has_all_slater_bases	vec{atom}.foo	/^   has_all_slater_bases result(has)$/;"	r
has_all_coppens_bases	vec{atom}.foo	/^   has_all_coppens_bases result(has)$/;"	r
has_all_density_data	vec{atom}.foo	/^   has_all_density_data result(has)$/;"	r
has_all_interpolators	vec{atom}.foo	/^   has_all_interpolators result(has)$/;"	r
has_all_atom_interpolators	vec{atom}.foo	/^   has_all_atom_interpolators result(has)$/;"	r
has_all_slater_interpolators	vec{atom}.foo	/^   has_all_slater_interpolators result(has)$/;"	r
has_all_coppens_interpolators	vec{atom}.foo	/^   has_all_coppens_interpolators result(has)$/;"	r
basis_labels	vec{atom}.foo	/^   basis_labels result (labels) ::: leaky$/;"	r
library_basis_labels	vec{atom}.foo	/^   library_basis_labels(suffix) result (labels) ::: leaky$/;"	r
library_basis_labels	vec{atom}.foo	/^   library_basis_labels(Z_max,suffix) result (labels) ::: selfless, leaky$/;"	r
minimum_basis_exponents	vec{atom}.foo	/^   minimum_basis_exponents result (res)$/;"	r
has_cartesian_thermal_axes	vec{atom}.foo	/^   has_cartesian_thermal_axes result(has)$/;"	r
has_crystal_thermal_axes	vec{atom}.foo	/^   has_crystal_thermal_axes result(has)$/;"	r
has_disorder	vec{atom}.foo	/^   has_disorder result (has)$/;"	r
atom_index_from_pos	vec{atom}.foo	/^   atom_index_from_pos(pos) result (res)$/;"	r
covalent_radii_ccdc	vec{atom}.foo	/^   covalent_radii_ccdc result (res) $/;"	r
vdw_radii_ccdc	vec{atom}.foo	/^   vdw_radii_ccdc result (res) $/;"	r
get_covalent_radii_ccdc	vec{atom}.foo	/^   get_covalent_radii_ccdc(radii) $/;"	r
get_vdw_radii_ccdc	vec{atom}.foo	/^   get_vdw_radii_ccdc(radii) $/;"	r
nuclear_dipole_moment	vec{atom}.foo	/^   nuclear_dipole_moment result (res)$/;"	r
nuclear_quadrupole_moment	vec{atom}.foo	/^   nuclear_quadrupole_moment result (res)$/;"	r
nuclear_octupole_moment	vec{atom}.foo	/^   nuclear_octupole_moment result (res)$/;"	r
nuclear_E_field_at_nuclei	vec{atom}.foo	/^   nuclear_E_field_at_nuclei result (res)$/;"	r
nuclear_EFG_at_nuclei	vec{atom}.foo	/^   nuclear_EFG_at_nuclei result (res)$/;"	r
same_kind_of_atoms	vec{atom}.foo	/^   same_kind_of_atoms(a,b) result (res)$/;"	r
make_atom_kind_count	vec{atom}.foo	/^   make_atom_kind_count(cnt,n_kind) ::: leaky$/;"	r
make_atom_kind_list	vec{atom}.foo	/^   make_atom_kind_list(atom_kind) ::: leaky$/;"	r
make_atom_kind_list	vec{atom}.foo	/^   make_atom_kind_list(atom_kind,n_kind)$/;"	r
make_unique_atom_list	vec{atom}.foo	/^   make_unique_atom_list(unique_atom)$/;"	r
make_atom_kind_map	vec{atom}.foo	/^   make_atom_kind_map(map)$/;"	r
are_distinct	vec{atom}.foo	/^   are_distinct(a,b) result (res)$/;"	r
groups_defined	vec{atom}.foo	/^   groups_defined result (res)$/;"	r
find_connected_groups	vec{atom}.foo	/^   find_connected_groups$/;"	r
make_atom_group_list	vec{atom}.foo	/^   make_atom_group_list(atom_group) ::: leaky$/;"	r
make_shell_limits	vec{atom}.foo	/^   make_shell_limits(first,last,momentum) ::: leaky$/;"	r
make_atom_basis_fn_limits	vec{atom}.foo	/^   make_atom_basis_fn_limits(first,last) ::: leaky$/;"	r
make_primitive_limits	vec{atom}.foo	/^   make_primitive_limits(frst,last,atom,lmom,expo) ::: leaky$/;"	r
atom_for_shell	vec{atom}.foo	/^   atom_for_shell(s) result(a)$/;"	r
atom_for_shell	vec{atom}.foo	/^   atom_for_shell result (res) ::: leaky$/;"	r
atom_shell_for_shell	vec{atom}.foo	/^   atom_shell_for_shell(s) result(as)$/;"	r
atom_shell_for_shell	vec{atom}.foo	/^   atom_shell_for_shell result (res) ::: leaky$/;"	r
first_shell_for_atom	vec{atom}.foo	/^   first_shell_for_atom(a) result (res)$/;"	r
make_shell_for_atom_limits	vec{atom}.foo	/^   make_shell_for_atom_limits(first,last)$/;"	r
first_shell_for_atom	vec{atom}.foo	/^   first_shell_for_atom result (res) ::: leaky$/;"	r
neighbours_of	vec{atom}.foo	/^   neighbours_of(a,range_factor) result (res) ::: leaky$/;"	r
is_next_neighbour_chiral	vec{atom}.foo	/^   is_next_neighbour_chiral(a) result (res) ::: leaky$/;"	r
next_neighbour_handedness_of	vec{atom}.foo	/^   next_neighbour_handedness_of(a) result (res) ::: leaky$/;"	r
invariom_labels	vec{atom}.foo	/^   invariom_labels result (res) ::: leaky$/;"	r
invariom_label_of	vec{atom}.foo	/^   invariom_label_of(a) result (res)$/;"	r
put_invariom_labels	vec{atom}.foo	/^   put_invariom_labels$/;"	r
allred_rochow_bond_orders	vec{atom}.foo	/^   allred_rochow_bond_orders(a,neighbours,bond,bonds)$/;"	r
bond_distinguisher	vec{atom}.foo	/^   bond_distinguisher(a,b) result (res)$/;"	r
smiles_invariom_labels	vec{atom}.foo	/^   smiles_invariom_labels result (res) ::: leaky$/;"	r
smiles_invariom_label_of	vec{atom}.foo	/^   smiles_invariom_label_of(a) result (res)$/;"	r
put_smiles_invariom_labels	vec{atom}.foo	/^   put_smiles_invariom_labels$/;"	r
smiles_bond_orders	vec{atom}.foo	/^   smiles_bond_orders(a,neighbours,bond,bonds)$/;"	r
find_N_terminal_atoms	vec{atom}.foo	/^   find_N_terminal_atoms$/;"	r
find_N_terminal_atoms	vec{atom}.foo	/^   find_N_terminal_atoms(list) ::: leaky$/;"	r
find_protein_backbone	vec{atom}.foo	/^   find_protein_backbone$/;"	r
find_protein_backbone	vec{atom}.foo	/^   find_protein_backbone(backbone) ::: leaky$/;"	r
is_protein_backbone_N	vec{atom}.foo	/^   is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try) result (res)$/;"	r
is_protein_C_alpha	vec{atom}.foo	/^   is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct) result (res)$/;"	r
is_protein_C_prime_carbon	vec{atom}.foo	/^   is_protein_C_prime_carbon(Cp,N,O,Ca,N1) result (res)$/;"	r
is_NCOC_carbon	vec{atom}.foo	/^   is_NCOC_carbon(Cp,N,O,Ca,N1) result (res)$/;"	r
is_CCOO_carbon	vec{atom}.foo	/^   is_CCOO_carbon(Cp,Ca,O1,O2) result (res)$/;"	r
is_CCOC_carbon	vec{atom}.foo	/^   is_CCOC_carbon(Cp,Ca,O1,C) result (res)$/;"	r
is_CCON_carbon	vec{atom}.foo	/^   is_CCON_carbon(Cp,Ca,O1,N1) result (res)$/;"	r
make_connection_table	vec{atom}.foo	/^   make_connection_table(skip_hydrogen) ::: leaky$/;"	r
make_connection_table	vec{atom}.foo	/^   make_connection_table(connections_for,skip_hydrogen) ::: leaky$/;"	r
has_a_connection	vec{atom}.foo	/^   has_a_connection(X,W) result (res)$/;"	r
has_Z_connection	vec{atom}.foo	/^   has_Z_connection(X,Z) result (res)$/;"	r
has_Z_connections	vec{atom}.foo	/^   has_Z_connections(X,Z,list) result (res) ::: leaky$/;"	r
has_0_connections	vec{atom}.foo	/^   has_0_connections(X) result (res)$/;"	r
has_1_connection	vec{atom}.foo	/^   has_1_connection(X) result (res)$/;"	r
has_1_connection	vec{atom}.foo	/^   has_1_connection(X,Y) result (res)$/;"	r
has_1_connection	vec{atom}.foo	/^   has_1_connection(X,Z,Y) result (res)$/;"	r
has_2_connections	vec{atom}.foo	/^   has_2_connections(X) result (res)$/;"	r
has_2_connections	vec{atom}.foo	/^   has_2_connections(X,Y1,Y2) result (res)$/;"	r
has_2_connections	vec{atom}.foo	/^   has_2_connections(X,Z1,Z2,Y1,Y2) result (res)$/;"	r
has_2_connections	vec{atom}.foo	/^   has_2_connections(X,W,Z,Y) result (res)$/;"	r
has_3_connections	vec{atom}.foo	/^   has_3_connections(X) result (res)$/;"	r
has_3_connections	vec{atom}.foo	/^   has_3_connections(X,Z1,Z2,Z3,Y1,Y2,Y3) result (res)$/;"	r
has_3_connections	vec{atom}.foo	/^   has_3_connections(X,W,Z1,Z2,Y1,Y2) result (res)$/;"	r
has_3_connections	vec{atom}.foo	/^   has_3_connections(X,V,W,Z,Y) result (res)$/;"	r
has_4_connections	vec{atom}.foo	/^   has_4_connections(X) result (res)$/;"	r
has_4_connections	vec{atom}.foo	/^   has_4_connections(X,W,Z1,Z2,Z3,Y1,Y2,Y3) result (res)$/;"	r
has_4_connections	vec{atom}.foo	/^   has_4_connections(X,W,Z,Y1,Y2,Y3) result (res)$/;"	r
has_ring	vec{atom}.foo	/^   has_ring(A,B,Z,R) result (res)$/;"	r
has_chain	vec{atom}.foo	/^   has_chain(A,B,Z,C) result (res)$/;"	r
put_protein_sequence	vec{atom}.foo	/^   put_protein_sequence ::: leaky$/;"	r
protein_side_chain_3_code	vec{atom}.foo	/^   protein_side_chain_3_code(Ca,Cb) result (res)$/;"	r
has_ALA	vec{atom}.foo	/^   has_ALA(Ca,Cb) result (res)$/;"	r
has_ARG	vec{atom}.foo	/^   has_ARG(Ca,Cb) result (res)$/;"	r
has_ASN	vec{atom}.foo	/^   has_ASN(Ca,Cb) result (res)$/;"	r
has_ASP	vec{atom}.foo	/^   has_ASP(Ca,Cb) result (res)$/;"	r
has_CYS	vec{atom}.foo	/^   has_CYS(Ca,Cb) result (res)$/;"	r
has_GLN	vec{atom}.foo	/^   has_GLN(Ca,Cb) result (res)$/;"	r
has_GLU	vec{atom}.foo	/^   has_GLU(Ca,Cb) result (res)$/;"	r
has_HIS	vec{atom}.foo	/^   has_HIS(Ca,Cb) result (res)$/;"	r
has_ILE	vec{atom}.foo	/^   has_ILE(Ca,Cb) result (res)$/;"	r
has_LEU	vec{atom}.foo	/^   has_LEU(Ca,Cb) result (res)$/;"	r
has_LYS	vec{atom}.foo	/^   has_LYS(Ca,Cb) result (res)$/;"	r
has_MET	vec{atom}.foo	/^   has_MET(Ca,Cb) result (res)$/;"	r
has_PHE	vec{atom}.foo	/^   has_PHE(Ca,Cb) result (res)$/;"	r
has_SER	vec{atom}.foo	/^   has_SER(Ca,Cb) result (res)$/;"	r
has_THR	vec{atom}.foo	/^   has_THR(Ca,Cb) result (res)$/;"	r
has_TRP	vec{atom}.foo	/^   has_TRP(Ca,Cb) result (res)$/;"	r
has_TYR	vec{atom}.foo	/^   has_TYR(Ca,Cb) result (res)$/;"	r
has_VAL	vec{atom}.foo	/^   has_VAL(Ca,Cb) result (res)$/;"	r
bonded	vec{atom}.foo	/^   bonded(a,b,range_factor) result (res) ::: pure$/;"	r
vdw_bonded	vec{atom}.foo	/^   vdw_bonded(a,b,range_factor,vdw_range_pc) result (res)$/;"	r
are_nearby	vec{atom}.foo	/^   are_nearby(a,b,dist) result (res)$/;"	r
connected	vec{atom}.foo	/^   connected(a,b,c,d) result (res)$/;"	r
no_of_bonds	vec{atom}.foo	/^   no_of_bonds result (res)$/;"	r
bond_distance	vec{atom}.foo	/^   bond_distance(a,b,angstrom) result (res)$/;"	r
no_of_angles	vec{atom}.foo	/^   no_of_angles result (res)$/;"	r
no_of_angle_center_atoms	vec{atom}.foo	/^   no_of_angle_center_atoms result (res) ::: pure$/;"	r
angle_center_atoms	vec{atom}.foo	/^   angle_center_atoms result (res) ::: pure$/;"	r
no_of_angle_outer_atoms	vec{atom}.foo	/^   no_of_angle_outer_atoms result (res) ::: pure$/;"	r
angle_outer_atoms	vec{atom}.foo	/^   angle_outer_atoms result (res) ::: pure$/;"	r
bond_angle	vec{atom}.foo	/^   bond_angle(a,b,c,degrees) result (res)$/;"	r
no_of_torsion_angles	vec{atom}.foo	/^   no_of_torsion_angles result (res)$/;"	r
torsion_angle	vec{atom}.foo	/^   torsion_angle(a,b,c,d,abc_colinear,bcd_colinear,degrees) result (res)$/;"	r
has_all_Hs_single_bonded	vec{atom}.foo	/^   has_all_Hs_single_bonded(has_Hs) result (res)$/;"	r
bond_distance_deriv	vec{atom}.foo	/^   bond_distance_deriv(a,b,deriv,angstrom)$/;"	r
bond_angle_deriv	vec{atom}.foo	/^   bond_angle_deriv(a,b,c,deriv,abc_colinear,degrees)$/;"	r
torsion_angle_deriv	vec{atom}.foo	/^   torsion_angle_deriv(a,b,c,d,deriv,abc_colinear,bcd_colinear,degrees) $/;"	r
no_of_electrons	vec{atom}.foo	/^   no_of_electrons result (res) ::: pure$/;"	r
no_of_occupied_ANOs	vec{atom}.foo	/^   no_of_occupied_ANOs(ANOkind,tol) result (res)$/;"	r
no_of_shells	vec{atom}.foo	/^   no_of_shells result (res) ::: pure$/;"	r
n_shell	vec{atom}.foo	/^   n_shell result (res) ::: pure$/;"	r
n_shell_pairs	vec{atom}.foo	/^   n_shell_pairs result (res) ::: pure$/;"	r
no_of_primitive_shells	vec{atom}.foo	/^   no_of_primitive_shells result (res) ::: pure$/;"	r
no_of_basis_functions	vec{atom}.foo	/^   no_of_basis_functions result (res) ::: pure$/;"	r
no_of_sph_basis_functions	vec{atom}.foo	/^   no_of_sph_basis_functions result (res) ::: pure$/;"	r
n_bf	vec{atom}.foo	/^   n_bf result (res) ::: pure$/;"	r
no_of_primitives	vec{atom}.foo	/^   no_of_primitives result (res) ::: pure$/;"	r
no_of_sph_primitives	vec{atom}.foo	/^   no_of_sph_primitives result (res) ::: pure$/;"	r
n_prim	vec{atom}.foo	/^   n_prim result (res) ::: pure$/;"	r
bases_are_resolved	vec{atom}.foo	/^   bases_are_resolved result (res)$/;"	r
slaterbases_are_resolved	vec{atom}.foo	/^   slaterbases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, basis=>slaterbasis)$/;"	r
coppensbases_are_resolved	vec{atom}.foo	/^   coppensbases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, basis=>coppensbasis)$/;"	r
bases_are_all_labeled	vec{atom}.foo	/^   bases_are_all_labeled result (res)$/;"	r
slaterbases_are_all_labeled	vec{atom}.foo	/^   slaterbases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, basis=>slaterbasis)$/;"	r
coppensbases_are_all_labeled	vec{atom}.foo	/^   coppensbases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, basis=>coppensbasis)$/;"	r
get_distance_from	vec{atom}.foo	/^   get_distance_from(atomvec,distance,t1,t2)$/;"	r
get_distance_from	vec{atom}.foo	/^   get_distance_from(pos,distance,t1)$/;"	r
same_as	vec{atom}.foo	/^   same_as(atomvec) result (res)$/;"	r
translate_by	vec{atom}.foo	/^   translate_by(vector)$/;"	r
rotate_by	vec{atom}.foo	/^   rotate_by(matrix)$/;"	r
rotate_positions_by	vec{atom}.foo	/^   rotate_positions_by(matrix)$/;"	r
rotate_thermal_tensors_by	vec{atom}.foo	/^   rotate_thermal_tensors_by(matrix)$/;"	r
thermal_tensor_to	vec{atom}.foo	/^   thermal_tensor_to(cell)$/;"	r
thermal_tensor_from	vec{atom}.foo	/^   thermal_tensor_from(cell)$/;"	r
default_multiplicity	vec{atom}.foo	/^   default_multiplicity result (res)$/;"	r
max_interpolator_table_length	vec{atom}.foo	/^   max_interpolator_table_length(tol) result (res)$/;"	r
saved_self	vec{atom_group}.foo	/^   saved_self :: VEC{ATOM_GROUP}*, private$/;"	g
create	vec{atom_group}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{atom_group}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
create_copy	vec{atom_group}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{atom_group}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT})$/;"	r
set_defaults	vec{atom_group}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
created	vec{atom_group}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{atom_group}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
nullify_ptr_part	vec{atom_group}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
destroy_ptr_part	vec{atom_group}.foo	/^   destroy_ptr_part ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_list_keywords	vec{atom_group}.foo	/^   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky$/;"	r
process_list_keyword	vec{atom_group}.foo	/^   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_data	vec{atom_group}.foo	/^   read_data(ignore_braces) ::: get_from(VEC{OBJECT}), leaky$/;"	r
data_length	vec{atom_group}.foo	/^   data_length result (length) ::: get_from(VEC{OBJECT})$/;"	r
read_altered_data	vec{atom_group}.foo	/^   read_altered_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_append_data	vec{atom_group}.foo	/^   read_append_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys	vec{atom_group}.foo	/^   process_keys ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys_once	vec{atom_group}.foo	/^   process_keys_once ::: get_from(VEC{OBJECT})$/;"	r
keys_created	vec{atom_group}.foo	/^   keys_created result (res) ::: get_from(VEC{OBJECT})$/;"	r
set_keys	vec{atom_group}.foo	/^   set_keys(the_keys) ::: get_from(VEC{OBJECT})$/;"	r
clear_keys	vec{atom_group}.foo	/^   clear_keys ::: get_from(VEC{OBJECT})$/;"	r
read_keys	vec{atom_group}.foo	/^   read_keys ::: get_from(VEC{OBJECT})$/;"	r
put_keys_table	vec{atom_group}.foo	/^   put_keys_table ::: get_from(VEC{OBJECT})$/;"	r
put_table_header	vec{atom_group}.foo	/^   put_table_header ::: get_from(VEC{OBJECT})$/;"	r
put_table_footer	vec{atom_group}.foo	/^   put_table_footer ::: get_from(VEC{OBJECT})$/;"	r
redirect	vec{atom_group}.foo	/^   redirect ::: get_from(OBJECT), leaky$/;"	r
revert	vec{atom_group}.foo	/^   revert ::: get_from(OBJECT), leaky$/;"	r
finalise	vec{atom_group}.foo	/^   finalise(atom) ::: leaky$/;"	r
read_keywords	vec{atom_group}.foo	/^   read_keywords ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keyword	vec{atom_group}.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
shrink	vec{atom_group}.foo	/^   shrink(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
expand	vec{atom_group}.foo	/^   expand(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{atom_group}.foo	/^   append(v) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{atom_group}.foo	/^   append(value) ::: get_from(VEC{OBJECT}), leaky$/;"	r
put	vec{atom_group}.foo	/^   put$/;"	r
saved_self	vec{basis}.foo	/^   saved_self :: VEC{BASIS}*, private  DEFAULT_NULL$/;"	g
basis_library_directory	vec{basis}.foo	/^   basis_library_directory :: STR, private = ".\/basis_sets"$/;"	g
create	vec{basis}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{basis}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
nullify_ptr_part	vec{basis}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
destroy_ptr_part	vec{basis}.foo	/^   destroy_ptr_part ::: get_from(VEC{OBJECT}), leaky$/;"	r
created	vec{basis}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{basis}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{basis}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{basis}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
set_defaults	vec{basis}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
set_library_directory	vec{basis}.foo	/^   set_library_directory(directory)$/;"	r
library_file	vec{basis}.foo	/^   library_file(basis_kind) result (res)$/;"	r
set_spherical	vec{basis}.foo	/^   set_spherical(val)$/;"	r
shrink	vec{basis}.foo	/^   shrink(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
expand	vec{basis}.foo	/^   expand(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{basis}.foo	/^   append(v) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{basis}.foo	/^   append(value) ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_list_keywords	vec{basis}.foo	/^   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky$/;"	r
process_list_keyword	vec{basis}.foo	/^   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_data	vec{basis}.foo	/^   read_data(ignore_braces) ::: get_from(VEC{OBJECT}), leaky$/;"	r
data_length	vec{basis}.foo	/^   data_length result (length) ::: get_from(VEC{OBJECT})$/;"	r
read_altered_data	vec{basis}.foo	/^   read_altered_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_append_data	vec{basis}.foo	/^   read_append_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys	vec{basis}.foo	/^   process_keys ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys_once	vec{basis}.foo	/^   process_keys_once ::: get_from(VEC{OBJECT})$/;"	r
keys_created	vec{basis}.foo	/^   keys_created result (res) ::: get_from(VEC{OBJECT})$/;"	r
set_keys	vec{basis}.foo	/^   set_keys(the_keys) ::: get_from(VEC{OBJECT})$/;"	r
clear_keys	vec{basis}.foo	/^   clear_keys ::: get_from(VEC{OBJECT})$/;"	r
read_keys	vec{basis}.foo	/^   read_keys ::: get_from(VEC{OBJECT})$/;"	r
put_keys_table	vec{basis}.foo	/^   put_keys_table ::: get_from(VEC{OBJECT})$/;"	r
put_table_header	vec{basis}.foo	/^   put_table_header ::: get_from(VEC{OBJECT})$/;"	r
put_table_footer	vec{basis}.foo	/^   put_table_footer ::: get_from(VEC{OBJECT})$/;"	r
redirect	vec{basis}.foo	/^   redirect ::: get_from(OBJECT), leaky$/;"	r
revert	vec{basis}.foo	/^   revert ::: get_from(OBJECT), leaky$/;"	r
read_keywords	vec{basis}.foo	/^   read_keywords ::: get_from(VEC{OBJECT}), recursive, leaky$/;"	r
process_keyword	vec{basis}.foo	/^   process_keyword(keyword)$/;"	r
read_library_directory	vec{basis}.foo	/^   read_library_directory$/;"	r
read_library_data	vec{basis}.foo	/^   read_library_data(library,labels,n_unique_labels) ::: leaky$/;"	r
unnormalise	vec{basis}.foo	/^   unnormalise$/;"	r
renormalise	vec{basis}.foo	/^   renormalise$/;"	r
no_of_shells	vec{basis}.foo	/^   no_of_shells result (res)$/;"	r
maximum_basis_set_l_value	vec{basis}.foo	/^   maximum_basis_set_l_value result (res)$/;"	r
put	vec{basis}.foo	/^   put ::: get_from(VEC{OBJECT})$/;"	r
create	vec{bin}.foo	/^   create(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create	vec{bin}.foo	/^   create(lb,ub) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create	vec{bin}.foo	/^   create(bounds) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
destroy	vec{bin}.foo	/^   destroy ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create_copy	vec{bin}.foo	/^   create_copy(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
copy	vec{bin}.foo	/^   copy(v) ::: get_from(VEC{INTRINSIC})$/;"	r
created	vec{bin}.foo	/^   created result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	vec{bin}.foo	/^   destroyed result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
size	vec{bin}.foo	/^   size result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
dim	vec{bin}.foo	/^   dim result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
shrink	vec{bin}.foo	/^   shrink(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
expand	vec{bin}.foo	/^   expand(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append	vec{bin}.foo	/^   append(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append	vec{bin}.foo	/^   append(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prepend	vec{bin}.foo	/^   prepend(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prepend	vec{bin}.foo	/^   prepend(value) ::: get_from(VEC{INTRINSIC}), leaky ! Prepend an single "value" to "self". "self" is expanded.$/;"	r
join	vec{bin}.foo	/^   join(v) result (res) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
join	vec{bin}.foo	/^   join(v1,v2) result (res) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
equals	vec{bin}.foo	/^   equals(v) result (res)$/;"	r
same_as	vec{bin}.foo	/^   same_as(v) result (res)$/;"	r
reverse_order	vec{bin}.foo	/^   reverse_order ::: get_from(VEC{INTRINSIC}), pure$/;"	r
swap_elements	vec{bin}.foo	/^   swap_elements(e1,e2) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
set_to	vec{bin}.foo	/^   set_to(v) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{BIN}), pure$/;"	r
n_true	vec{bin}.foo	/^   n_true result (res)$/;"	r
n_false	vec{bin}.foo	/^   n_false result (res)$/;"	r
index_of_first_true_element	vec{bin}.foo	/^   index_of_first_true_element result (res)$/;"	r
str_lengths	vec{bin}.foo	/^   str_lengths(spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
str_length	vec{bin}.foo	/^   str_length(spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
to_str	vec{bin}.foo	/^   to_str result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
to_str	vec{bin}.foo	/^   to_str(format,left_justify) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
to_str	vec{bin}.foo	/^   to_str(width,left_justify) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
saved_self	vec{coppensbasis}.foo	/^   saved_self :: VEC{COPPENSBASIS}*, private  DEFAULT_NULL$/;"	g
basis_library_directory	vec{coppensbasis}.foo	/^   basis_library_directory :: STR, private = ".\/basis_sets"$/;"	g
create	vec{coppensbasis}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{coppensbasis}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
create_copy	vec{coppensbasis}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{coppensbasis}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
nullify_ptr_part	vec{coppensbasis}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
destroy_ptr_part	vec{coppensbasis}.foo	/^   destroy_ptr_part ::: get_from(VEC{OBJECT}), leaky$/;"	r
created	vec{coppensbasis}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{coppensbasis}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	vec{coppensbasis}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
set_library_directory	vec{coppensbasis}.foo	/^   set_library_directory(directory) ::: get_from(VEC{BASIS})$/;"	r
library_file	vec{coppensbasis}.foo	/^   library_file(basis_kind) result (res) ::: get_from(VEC{BASIS})$/;"	r
read_list_keywords	vec{coppensbasis}.foo	/^   read_list_keywords ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_list_keyword	vec{coppensbasis}.foo	/^   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_data	vec{coppensbasis}.foo	/^   read_data(ignore_braces) ::: get_from(VEC{OBJECT}), leaky$/;"	r
data_length	vec{coppensbasis}.foo	/^   data_length result (length) ::: get_from(VEC{OBJECT})$/;"	r
read_altered_data	vec{coppensbasis}.foo	/^   read_altered_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_append_data	vec{coppensbasis}.foo	/^   read_append_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys	vec{coppensbasis}.foo	/^   process_keys ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys_once	vec{coppensbasis}.foo	/^   process_keys_once ::: get_from(VEC{OBJECT})$/;"	r
keys_created	vec{coppensbasis}.foo	/^   keys_created result (res) ::: get_from(VEC{OBJECT})$/;"	r
set_keys	vec{coppensbasis}.foo	/^   set_keys(the_keys) ::: get_from(VEC{OBJECT})$/;"	r
clear_keys	vec{coppensbasis}.foo	/^   clear_keys ::: get_from(VEC{OBJECT})$/;"	r
read_keys	vec{coppensbasis}.foo	/^   read_keys ::: get_from(VEC{OBJECT})$/;"	r
put_keys_table	vec{coppensbasis}.foo	/^   put_keys_table ::: get_from(VEC{OBJECT})$/;"	r
put_table_header	vec{coppensbasis}.foo	/^   put_table_header ::: get_from(VEC{OBJECT})$/;"	r
put_table_footer	vec{coppensbasis}.foo	/^   put_table_footer ::: get_from(VEC{OBJECT})$/;"	r
redirect	vec{coppensbasis}.foo	/^   redirect ::: get_from(OBJECT), leaky$/;"	r
revert	vec{coppensbasis}.foo	/^   revert ::: get_from(OBJECT), leaky$/;"	r
read_keywords	vec{coppensbasis}.foo	/^   read_keywords ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keyword	vec{coppensbasis}.foo	/^   process_keyword(keyword)$/;"	r
read_library_directory	vec{coppensbasis}.foo	/^   read_library_directory ::: get_from(VEC{BASIS})$/;"	r
read_library_data	vec{coppensbasis}.foo	/^   read_library_data(library,labels,n_unique_labels) ::: get_from(VEC{BASIS}), leaky$/;"	r
shrink	vec{coppensbasis}.foo	/^   shrink(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
expand	vec{coppensbasis}.foo	/^   expand(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{coppensbasis}.foo	/^   append(v) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{coppensbasis}.foo	/^   append(value) ::: get_from(VEC{OBJECT}), leaky$/;"	r
no_of_orbitals	vec{coppensbasis}.foo	/^   no_of_orbitals result (res) ::: pure$/;"	r
no_of_primitives	vec{coppensbasis}.foo	/^   no_of_primitives result (res) ::: pure$/;"	r
maximum_basis_n_value	vec{coppensbasis}.foo	/^   maximum_basis_n_value result (res)$/;"	r
same_as	vec{coppensbasis}.foo	/^   same_as(vec) result(same)$/;"	r
unnormalise	vec{coppensbasis}.foo	/^   unnormalise $/;"	r
renormalise	vec{coppensbasis}.foo	/^   renormalise $/;"	r
put	vec{coppensbasis}.foo	/^   put ::: get_from(VEC{OBJECT})$/;"	r
put_table	vec{coppensbasis}.foo	/^   put_table ::: get_from(VEC{OBJECT})$/;"	r
saved_self	vec{coppensorbital}.foo	/^   saved_self :: VEC{COPPENSORBITAL}*, private  DEFAULT_NULL$/;"	g
create	vec{coppensorbital}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{coppensorbital}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
create_copy	vec{coppensorbital}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{coppensorbital}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
nullify_ptr_part	vec{coppensorbital}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
destroy_ptr_part	vec{coppensorbital}.foo	/^   destroy_ptr_part ::: get_from(VEC{OBJECT}), leaky$/;"	r
created	vec{coppensorbital}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{coppensorbital}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	vec{coppensorbital}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
set_saved_self	vec{coppensorbital}.foo	/^   set_saved_self $/;"	r
read_list_keywords	vec{coppensorbital}.foo	/^   read_list_keywords ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_list_keyword	vec{coppensorbital}.foo	/^   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_data	vec{coppensorbital}.foo	/^   read_data(ignore_braces) ::: get_from(VEC{OBJECT}), leaky$/;"	r
data_length	vec{coppensorbital}.foo	/^   data_length result (length) ::: get_from(VEC{OBJECT})$/;"	r
read_altered_data	vec{coppensorbital}.foo	/^   read_altered_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_append_data	vec{coppensorbital}.foo	/^   read_append_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys	vec{coppensorbital}.foo	/^   process_keys ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys_once	vec{coppensorbital}.foo	/^   process_keys_once ::: get_from(VEC{OBJECT})$/;"	r
keys_created	vec{coppensorbital}.foo	/^   keys_created result (res) ::: get_from(VEC{OBJECT})$/;"	r
set_keys	vec{coppensorbital}.foo	/^   set_keys(the_keys) ::: get_from(VEC{OBJECT})$/;"	r
clear_keys	vec{coppensorbital}.foo	/^   clear_keys ::: get_from(VEC{OBJECT})$/;"	r
read_keys	vec{coppensorbital}.foo	/^   read_keys ::: get_from(VEC{OBJECT})$/;"	r
put_keys_table	vec{coppensorbital}.foo	/^   put_keys_table ::: get_from(VEC{OBJECT})$/;"	r
put_table_header	vec{coppensorbital}.foo	/^   put_table_header ::: get_from(VEC{OBJECT})$/;"	r
put_table_footer	vec{coppensorbital}.foo	/^   put_table_footer ::: get_from(VEC{OBJECT})$/;"	r
redirect	vec{coppensorbital}.foo	/^   redirect ::: get_from(OBJECT), leaky$/;"	r
revert	vec{coppensorbital}.foo	/^   revert ::: get_from(OBJECT), leaky$/;"	r
read_keywords	vec{coppensorbital}.foo	/^   read_keywords ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keyword	vec{coppensorbital}.foo	/^   process_keyword(keyword)$/;"	r
n_orbitals	vec{coppensorbital}.foo	/^   n_orbitals result (res)$/;"	r
maximum_orbital_n_value	vec{coppensorbital}.foo	/^   maximum_orbital_n_value result (res)$/;"	r
same_as	vec{coppensorbital}.foo	/^   same_as(vec) result(same)$/;"	r
shrink	vec{coppensorbital}.foo	/^   shrink(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
expand	vec{coppensorbital}.foo	/^   expand(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{coppensorbital}.foo	/^   append(v) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{coppensorbital}.foo	/^   append(value) ::: get_from(VEC{OBJECT}), leaky$/;"	r
density_at_radius	vec{coppensorbital}.foo	/^   density_at_radius(R) result (res)$/;"	r
densities_at_radii	vec{coppensorbital}.foo	/^   densities_at_radii(R) result (res)$/;"	r
density_value_at_radius	vec{coppensorbital}.foo	/^   density_value_at_radius(R) result (res) ::: selfless, public$/;"	r
density_at_sqrt_radius2	vec{coppensorbital}.foo	/^   density_at_sqrt_radius2(R2) result (res) ::: selfless, public$/;"	r
radial_density_value_at_radius	vec{coppensorbital}.foo	/^   radial_density_value_at_radius(R) result (res) ::: selfless, public$/;"	r
res	vec{coppensorbital}.foo	/^     res :: REAL$/;"	a
self	vec{coppensorbital}.foo	/^     self :: VEC{COPPENSORBITAL}*$/;"	a
unnormalise	vec{coppensorbital}.foo	/^   unnormalise$/;"	r
renormalise	vec{coppensorbital}.foo	/^   renormalise$/;"	r
put	vec{coppensorbital}.foo	/^   put ::: get_from(VEC{OBJECT})$/;"	r
put_table	vec{coppensorbital}.foo	/^   put_table ::: get_from(VEC{OBJECT})$/;"	r
create	vec{cpx}.foo	/^   create(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create	vec{cpx}.foo	/^   create(lb,ub) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create	vec{cpx}.foo	/^   create(bounds) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
destroy	vec{cpx}.foo	/^   destroy ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create_copy	vec{cpx}.foo	/^   create_copy(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
copy	vec{cpx}.foo	/^   copy(v) ::: get_from(VEC{INTRINSIC})$/;"	r
created	vec{cpx}.foo	/^   created result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	vec{cpx}.foo	/^   destroyed result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
size	vec{cpx}.foo	/^   size result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
dim	vec{cpx}.foo	/^   dim result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
shrink	vec{cpx}.foo	/^   shrink(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
expand	vec{cpx}.foo	/^   expand(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append	vec{cpx}.foo	/^   append(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append	vec{cpx}.foo	/^   append(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prepend	vec{cpx}.foo	/^   prepend(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prepend	vec{cpx}.foo	/^   prepend(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
join	vec{cpx}.foo	/^   join(v) result (res) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
join	vec{cpx}.foo	/^   join(v1,v2) result (res) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
equals	vec{cpx}.foo	/^   equals(v,eps) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
same_as	vec{cpx}.foo	/^   same_as(v,eps) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
are_all_equal	vec{cpx}.foo	/^   are_all_equal(eps) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
is_zero	vec{cpx}.foo	/^   is_zero(eps) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
remove_repetitions	vec{cpx}.foo	/^   remove_repetitions ::: get_from(VEC{OBJECT}), leaky$/;"	r
has_repetitions	vec{cpx}.foo	/^   has_repetitions result (res) ::: get_from(VEC{OBJECT})$/;"	r
no_of_unique_elements	vec{cpx}.foo	/^   no_of_unique_elements result (res) ::: get_from(VEC{OBJECT}), pure$/;"	r
reverse_order	vec{cpx}.foo	/^   reverse_order ::: get_from(VEC{INTRINSIC}), pure$/;"	r
swap_elements	vec{cpx}.foo	/^   swap_elements(e1,e2) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
set_to	vec{cpx}.foo	/^   set_to(v) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}), pure$/;"	r
set_to	vec{cpx}.foo	/^   set_to(v) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}), pure$/;"	r
plus	vec{cpx}.foo	/^   plus(v,mask) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}), pure$/;"	r
plus	vec{cpx}.foo	/^   plus(v,mask) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}), pure$/;"	r
minus	vec{cpx}.foo	/^   minus(v,mask) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}), pure$/;"	r
minus	vec{cpx}.foo	/^   minus(v,mask) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}), pure$/;"	r
to_scaled	vec{cpx}.foo	/^   to_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}, FAC_TYPE=>CPX), pure$/;"	r
to_scaled	vec{cpx}.foo	/^   to_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}, FAC_TYPE=>REAL), pure$/;"	r
to_scaled	vec{cpx}.foo	/^   to_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>CPX), pure$/;"	r
to_scaled	vec{cpx}.foo	/^   to_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL), pure$/;"	r
plus_scaled	vec{cpx}.foo	/^   plus_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}, FAC_TYPE=>CPX), pure$/;"	r
plus_scaled	vec{cpx}.foo	/^   plus_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}, FAC_TYPE=>REAL), pure$/;"	r
plus_scaled	vec{cpx}.foo	/^   plus_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>CPX), pure$/;"	r
plus_scaled	vec{cpx}.foo	/^   plus_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL), pure$/;"	r
dot	vec{cpx}.foo	/^   dot(v) result (res) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}, RES_TYPE=>CPX), pure$/;"	r
dot	vec{cpx}.foo	/^   dot(v) result (res) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, RES_TYPE=>CPX), pure$/;"	r
cross	vec{cpx}.foo	/^   cross(v) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
to_cross_product_of	vec{cpx}.foo	/^   to_cross_product_of(u,v) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
to_product_of	vec{cpx}.foo	/^   to_product_of(a,v,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX})$/;"	r
to_product_of	vec{cpx}.foo	/^   to_product_of(a,v,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL})$/;"	r
to_product_of	vec{cpx}.foo	/^   to_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{CPX})$/;"	r
to_product_of	vec{cpx}.foo	/^   to_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL})$/;"	r
plus_product_of	vec{cpx}.foo	/^   plus_product_of(a,v,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX})$/;"	r
plus_product_of	vec{cpx}.foo	/^   plus_product_of(a,v,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL})$/;"	r
plus_product_of	vec{cpx}.foo	/^   plus_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{CPX})$/;"	r
plus_product_of	vec{cpx}.foo	/^   plus_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL})$/;"	r
minus_product_of	vec{cpx}.foo	/^   minus_product_of(a,v,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX})$/;"	r
minus_product_of	vec{cpx}.foo	/^   minus_product_of(a,v,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL})$/;"	r
minus_product_of	vec{cpx}.foo	/^   minus_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{CPX})$/;"	r
minus_product_of	vec{cpx}.foo	/^   minus_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL})$/;"	r
to_scaled_product_of	vec{cpx}.foo	/^   to_scaled_product_of(a,v,fac,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}, FAC_TYPE=>CPX)$/;"	r
to_scaled_product_of	vec{cpx}.foo	/^   to_scaled_product_of(a,v,fac,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}, FAC_TYPE=>REAL)$/;"	r
to_scaled_product_of	vec{cpx}.foo	/^   to_scaled_product_of(a,v,fac,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>CPX)$/;"	r
to_scaled_product_of	vec{cpx}.foo	/^   to_scaled_product_of(a,v,fac,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL)$/;"	r
to_scaled_product_of	vec{cpx}.foo	/^   to_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{CPX}, FAC_TYPE=>CPX)$/;"	r
to_scaled_product_of	vec{cpx}.foo	/^   to_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{CPX}, FAC_TYPE=>REAL)$/;"	r
to_scaled_product_of	vec{cpx}.foo	/^   to_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL}, FAC_TYPE=>CPX)$/;"	r
to_scaled_product_of	vec{cpx}.foo	/^   to_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL)$/;"	r
plus_scaled_product_of	vec{cpx}.foo	/^   plus_scaled_product_of(a,v,fac,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}, FAC_TYPE=>CPX)$/;"	r
plus_scaled_product_of	vec{cpx}.foo	/^   plus_scaled_product_of(a,v,fac,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{CPX}, FAC_TYPE=>REAL)$/;"	r
plus_scaled_product_of	vec{cpx}.foo	/^   plus_scaled_product_of(a,v,fac,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>CPX)$/;"	r
plus_scaled_product_of	vec{cpx}.foo	/^   plus_scaled_product_of(a,v,fac,dagger_a,transpose_a) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL)$/;"	r
plus_scaled_product_of	vec{cpx}.foo	/^   plus_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{CPX}, FAC_TYPE=>CPX)$/;"	r
plus_scaled_product_of	vec{cpx}.foo	/^   plus_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{CPX}, FAC_TYPE=>REAL)$/;"	r
plus_scaled_product_of	vec{cpx}.foo	/^   plus_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL}, FAC_TYPE=>CPX)$/;"	r
plus_scaled_product_of	vec{cpx}.foo	/^   plus_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL)$/;"	r
rotate_by	vec{cpx}.foo	/^   rotate_by(a) ::: get_from(VEC{INTRINSIC})$/;"	r
translate_by	vec{cpx}.foo	/^   translate_by(v) ::: get_from(VEC{INTRINSIC})$/;"	r
outer_product_with	vec{cpx}.foo	/^   outer_product_with(v) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
norm	vec{cpx}.foo	/^   norm result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
normalise	vec{cpx}.foo	/^   normalise ::: get_from(VEC{INTRINSIC})$/;"	r
distance_to	vec{cpx}.foo	/^   distance_to(a) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
mean	vec{cpx}.foo	/^   mean result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
chop_large_values	vec{cpx}.foo	/^   chop_large_values(val) ::: pure$/;"	r
zero_small_values	vec{cpx}.foo	/^   zero_small_values(eps) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
largest_value	vec{cpx}.foo	/^   largest_value result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
smallest_value	vec{cpx}.foo	/^   smallest_value result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_largest_value	vec{cpx}.foo	/^   index_of_largest_value result (ind) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_smallest_value	vec{cpx}.foo	/^   index_of_smallest_value result (ind) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
str_lengths	vec{cpx}.foo	/^   str_lengths(spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
str_length	vec{cpx}.foo	/^   str_length(spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
str_lengths_with_precision	vec{cpx}.foo	/^   str_lengths_with_precision(dp,spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
str_length_with_precision	vec{cpx}.foo	/^   str_length_with_precision(dp,spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure $/;"	r
to_str	vec{cpx}.foo	/^   to_str result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
to_str	vec{cpx}.foo	/^   to_str(format,left_justify) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
to_str	vec{cpx}.foo	/^   to_str(style,width,precision,left_justify) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
alpha	vec{cpx}.foo	/^   alpha result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
beta	vec{cpx}.foo	/^   beta result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
alpha_set_to	vec{cpx}.foo	/^   alpha_set_to(X) ::: get_from(VEC{INTRINSIC})$/;"	r
beta_set_to	vec{cpx}.foo	/^   beta_set_to(X) ::: get_from(VEC{INTRINSIC})$/;"	r
alpha_set_to	vec{cpx}.foo	/^   alpha_set_to(X)$/;"	r
beta_set_to	vec{cpx}.foo	/^   beta_set_to(X)$/;"	r
create	vec{interpolator}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{interpolator}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
create_copy	vec{interpolator}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{interpolator}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
created	vec{interpolator}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{interpolator}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
nullify_ptr_part	vec{interpolator}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
destroy_ptr_part	vec{interpolator}.foo	/^   destroy_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
set_defaults	vec{interpolator}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
read_keywords	vec{interpolator}.foo	/^   read_keywords ::: get_from(VEC{OBJECT})$/;"	r
process_keyword	vec{interpolator}.foo	/^   process_keyword(keyword) $/;"	r
redirect	vec{interpolator}.foo	/^   redirect ::: get_from(OBJECT), leaky$/;"	r
revert	vec{interpolator}.foo	/^   revert ::: get_from(OBJECT), leaky$/;"	r
create	vec{int}.foo	/^   create(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create	vec{int}.foo	/^   create(lb,ub) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create	vec{int}.foo	/^   create(bounds) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
destroy	vec{int}.foo	/^   destroy ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create_copy	vec{int}.foo	/^   create_copy(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
copy	vec{int}.foo	/^   copy(v) ::: get_from(VEC{INTRINSIC})$/;"	r
created	vec{int}.foo	/^   created result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	vec{int}.foo	/^   destroyed result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
size	vec{int}.foo	/^   size result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
dim	vec{int}.foo	/^   dim result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
shrink	vec{int}.foo	/^   shrink(dim,chop_start) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
expand	vec{int}.foo	/^   expand(dim,grow_start) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append	vec{int}.foo	/^   append(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append	vec{int}.foo	/^   append(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append_only_if_unique	vec{int}.foo	/^   append_only_if_unique(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prepend	vec{int}.foo	/^   prepend(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prepend	vec{int}.foo	/^   prepend(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
join	vec{int}.foo	/^   join(v) result (res) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
join	vec{int}.foo	/^   join(v1,v2) result (res) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prune	vec{int}.foo	/^   prune(values) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prune	vec{int}.foo	/^   prune(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prune_element	vec{int}.foo	/^   prune_element(k) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
equals	vec{int}.foo	/^   equals(v) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
same_as	vec{int}.foo	/^   same_as(v) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
has_elements_common_with	vec{int}.foo	/^   has_elements_common_with(v) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
has_no_elements_common_with	vec{int}.foo	/^   has_no_elements_common_with(v) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
has_all_elements_common_with	vec{int}.foo	/^   has_all_elements_common_with(v) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
n_elements_common_with	vec{int}.foo	/^   n_elements_common_with(v) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
n_elements_uncommon_with	vec{int}.foo	/^   n_elements_uncommon_with(v) result (res) ::: get_from(VEC{INTRINSIC}), always_pure$/;"	r
elements_common_with	vec{int}.foo	/^   elements_common_with(v) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
elements_uncommon_with	vec{int}.foo	/^   elements_uncommon_with(v) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
indices_of_elements_matching	vec{int}.foo	/^   indices_of_elements_matching(item) result (res) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
is_zero	vec{int}.foo	/^   is_zero result (res) ::: pure$/;"	r
is_z_axis	vec{int}.foo	/^   is_z_axis result (res)$/;"	r
remove_repetitions	vec{int}.foo	/^   remove_repetitions ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
has_repetitions	vec{int}.foo	/^   has_repetitions result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
no_of_unique_elements	vec{int}.foo	/^   no_of_unique_elements result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
unique_elements	vec{int}.foo	/^   unique_elements result(unique) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
make_repetition_count	vec{int}.foo	/^   make_repetition_count(cnt,n_kind) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
indices_of_unique_elements	vec{int}.foo	/^   indices_of_unique_elements result(unique) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
make_unique_element_maps	vec{int}.foo	/^   make_unique_element_maps(unique_element,unique_element_for) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
sort	vec{int}.foo	/^   sort(decreasing_order) ::: get_from(VEC{OBJECT})$/;"	r
quick_sort	vec{int}.foo	/^   quick_sort(decreasing_order) ::: get_from(VEC{OBJECT})$/;"	r
quick_sort_increasing	vec{int}.foo	/^   quick_sort_increasing ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
quick_sort_decreasing	vec{int}.foo	/^   quick_sort_decreasing ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
quick_sort	vec{int}.foo	/^   quick_sort(indices,decreasing_order) ::: get_from(VEC{OBJECT})$/;"	r
quick_sort_increasing	vec{int}.foo	/^   quick_sort_increasing(indices) ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
quick_sort_decreasing	vec{int}.foo	/^   quick_sort_decreasing(indices) ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
reverse_order	vec{int}.foo	/^   reverse_order ::: get_from(VEC{INTRINSIC})$/;"	r
swap_elements	vec{int}.foo	/^   swap_elements(e1,e2) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
set_to	vec{int}.foo	/^   set_to(v) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{INT}), pure$/;"	r
plus	vec{int}.foo	/^   plus(v,mask) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{INT}), pure$/;"	r
minus	vec{int}.foo	/^   minus(v,mask) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{INT}), pure$/;"	r
to_scaled	vec{int}.foo	/^   to_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{INT}, FAC_TYPE=>INT), pure$/;"	r
plus_scaled	vec{int}.foo	/^   plus_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{INT}, FAC_TYPE=>INT), pure$/;"	r
dot	vec{int}.foo	/^   dot(v) result (res) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{INT}, RES_TYPE=>INT), pure$/;"	r
cross	vec{int}.foo	/^   cross(v) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
to_cross_product_of	vec{int}.foo	/^   to_cross_product_of(u,v) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
to_product_of	vec{int}.foo	/^   to_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{INT}, V_TYPE=>VEC{INT})$/;"	r
plus_product_of	vec{int}.foo	/^   plus_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{INT}, V_TYPE=>VEC{INT})$/;"	r
to_scaled_product_of	vec{int}.foo	/^   to_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{INT}, V_TYPE=>VEC{INT}, FAC_TYPE=>INT)$/;"	r
plus_scaled_product_of	vec{int}.foo	/^   plus_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{INT}, V_TYPE=>VEC{INT}, FAC_TYPE=>INT)$/;"	r
rotate_by	vec{int}.foo	/^   rotate_by(a) ::: get_from(VEC{INTRINSIC})$/;"	r
translate_by	vec{int}.foo	/^   translate_by(v) ::: get_from(VEC{INTRINSIC})$/;"	r
outer_product_with	vec{int}.foo	/^   outer_product_with(v) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
norm	vec{int}.foo	/^   norm result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
distance_to	vec{int}.foo	/^   distance_to(a) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
chop_large_absolute_values	vec{int}.foo	/^   chop_large_absolute_values(val) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
largest_value	vec{int}.foo	/^   largest_value result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
smallest_value	vec{int}.foo	/^   smallest_value result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
no_of_elements_larger_than	vec{int}.foo	/^   no_of_elements_larger_than(tol) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
all_in_range	vec{int}.foo	/^   all_in_range(range) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
in_range	vec{int}.foo	/^   in_range(range) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
range	vec{int}.foo	/^   range result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
index_of_maximum	vec{int}.foo	/^   index_of_maximum result (ind) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_minimum	vec{int}.foo	/^   index_of_minimum result (ind) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_largest_value	vec{int}.foo	/^   index_of_largest_value result (ind) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_smallest_value	vec{int}.foo	/^   index_of_smallest_value result (ind) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_first_nonzero_value	vec{int}.foo	/^   index_of_first_nonzero_value result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_first_zero_value	vec{int}.foo	/^   index_of_first_zero_value result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_value	vec{int}.foo	/^   index_of_value(val) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_value_ne_to	vec{int}.foo	/^   index_of_value_ne_to(val) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
str_lengths	vec{int}.foo	/^   str_lengths(spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
str_length	vec{int}.foo	/^   str_length(spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
to_str	vec{int}.foo	/^   to_str result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
to_str	vec{int}.foo	/^   to_str(format,left_justify) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
to_str	vec{int}.foo	/^   to_str(width,left_justify) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
to_concatenated_str	vec{int}.foo	/^   to_concatenated_str(format,separator) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
convert_to	vec{int}.foo	/^   convert_to(units) ::: get_from(VEC{INTRINSIC})$/;"	r
convert_from	vec{int}.foo	/^   convert_from(units) ::: get_from(VEC{INTRINSIC})$/;"	r
alpha	vec{int}.foo	/^   alpha result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
beta	vec{int}.foo	/^   beta result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
make_combinations_of_length	vec{int}.foo	/^   make_combinations_of_length(k,C) ::: recursive$/;"	r
combinations_of_length	vec{int}.foo	/^   combinations_of_length(k) result(C) ::: recursive, leaky$/;"	r
to_pair_vec_from	vec{int}.foo	/^   to_pair_vec_from(v1,v2)$/;"	r
bin_XY_data	vec{int}.foo	/^   bin_XY_data(X,Y,bin_side_length)$/;"	r
create	vec{intrinsic}.foo	/^   create(dim) ::: leaky$/;"	r
create	vec{intrinsic}.foo	/^   create(lb,ub) ::: leaky$/;"	r
create	vec{intrinsic}.foo	/^   create(bounds) ::: leaky$/;"	r
destroy	vec{intrinsic}.foo	/^   destroy ::: leaky$/;"	r
create_copy	vec{intrinsic}.foo	/^   create_copy(v) ::: leaky$/;"	r
copy	vec{intrinsic}.foo	/^   copy(v)$/;"	r
created	vec{intrinsic}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	vec{intrinsic}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
size	vec{intrinsic}.foo	/^   size result (res) ::: inlined_by_foo$/;"	r
dim	vec{intrinsic}.foo	/^   dim result (res) ::: inlined_by_foo$/;"	r
shape	vec{intrinsic}.foo	/^   shape result (res)$/;"	r
shrink	vec{intrinsic}.foo	/^   shrink(dim) ::: leaky$/;"	r
expand	vec{intrinsic}.foo	/^   expand(dim) ::: leaky$/;"	r
resize	vec{intrinsic}.foo	/^   resize(dim) ::: leaky$/;"	r
shrink	vec{intrinsic}.foo	/^   shrink(dim,chop_start) ::: leaky$/;"	r
expand	vec{intrinsic}.foo	/^   expand(dim,grow_start) ::: leaky$/;"	r
append	vec{intrinsic}.foo	/^   append(v) ::: leaky$/;"	r
append	vec{intrinsic}.foo	/^   append(value) ::: leaky$/;"	r
append_only_if_unique	vec{intrinsic}.foo	/^   append_only_if_unique(value) ::: leaky$/;"	r
prepend	vec{intrinsic}.foo	/^   prepend(v) ::: leaky$/;"	r
prepend	vec{intrinsic}.foo	/^   prepend(value) ::: leaky$/;"	r
join	vec{intrinsic}.foo	/^   join(v) result (res) ::: leaky$/;"	r
join	vec{intrinsic}.foo	/^   join(v1,v2) result (res) ::: leaky$/;"	r
prune	vec{intrinsic}.foo	/^   prune(values) ::: leaky$/;"	r
prune	vec{intrinsic}.foo	/^   prune(value) ::: leaky$/;"	r
prune_element	vec{intrinsic}.foo	/^   prune_element(k) ::: leaky$/;"	r
reverse_order	vec{intrinsic}.foo	/^   reverse_order ::: pure$/;"	r
swap_elements	vec{intrinsic}.foo	/^   swap_elements(e1,e2) ::: pure$/;"	r
set_to_flattened_reverse_of	vec{intrinsic}.foo	/^   set_to_flattened_reverse_of(b)$/;"	r
equals	vec{intrinsic}.foo	/^   equals(v) result (res)$/;"	r
equals	vec{intrinsic}.foo	/^   equals(v,eps) result (res)$/;"	r
same_as	vec{intrinsic}.foo	/^   same_as(v) result (res)$/;"	r
same_as	vec{intrinsic}.foo	/^   same_as(v,eps) result (res)$/;"	r
are_all_equal	vec{intrinsic}.foo	/^   are_all_equal(eps) result (res)$/;"	r
are_all_equal_to	vec{intrinsic}.foo	/^   are_all_equal_to(val,eps) result (res)$/;"	r
is_zero	vec{intrinsic}.foo	/^   is_zero(eps) result (res) ::: pure$/;"	r
is_monotone	vec{intrinsic}.foo	/^   is_monotone result (res) ::: pure$/;"	r
is_monotonically_increasing	vec{intrinsic}.foo	/^   is_monotonically_increasing result (res) ::: pure$/;"	r
is_monotonically_decreasing	vec{intrinsic}.foo	/^   is_monotonically_decreasing result (res) ::: pure$/;"	r
has_elements_common_with	vec{intrinsic}.foo	/^   has_elements_common_with(v) result (res) ::: pure$/;"	r
has_no_elements_common_with	vec{intrinsic}.foo	/^   has_no_elements_common_with(v) result (res) ::: pure$/;"	r
has_all_elements_common_with	vec{intrinsic}.foo	/^   has_all_elements_common_with(v) result (res) ::: pure$/;"	r
n_elements_common_with	vec{intrinsic}.foo	/^   n_elements_common_with(v) result (res) ::: pure$/;"	r
n_elements_uncommon_with	vec{intrinsic}.foo	/^   n_elements_uncommon_with(v) result (res) ::: pure$/;"	r
elements_common_with	vec{intrinsic}.foo	/^   elements_common_with(v) result (res) ::: pure$/;"	r
elements_uncommon_with	vec{intrinsic}.foo	/^   elements_uncommon_with(v) result (res) ::: pure$/;"	r
indices_of_elements_matching	vec{intrinsic}.foo	/^   indices_of_elements_matching(item) result (res) ::: leaky$/;"	r
remove_repetitions	vec{intrinsic}.foo	/^   remove_repetitions ::: leaky$/;"	r
has_repetitions	vec{intrinsic}.foo	/^   has_repetitions result (res)$/;"	r
no_of_unique_elements	vec{intrinsic}.foo	/^   no_of_unique_elements result (res) ::: pure$/;"	r
unique_elements	vec{intrinsic}.foo	/^   unique_elements result(unique) ::: leaky$/;"	r
make_repetition_count	vec{intrinsic}.foo	/^   make_repetition_count(cnt,n_kind) ::: leaky$/;"	r
indices_of_unique_elements	vec{intrinsic}.foo	/^   indices_of_unique_elements result(unique) ::: leaky$/;"	r
make_unique_element_maps	vec{intrinsic}.foo	/^   make_unique_element_maps(unique_element,unique_element_for) ::: leaky$/;"	r
str_lengths	vec{intrinsic}.foo	/^   str_lengths(spaces) result (res) ::: pure$/;"	r
str_length	vec{intrinsic}.foo	/^   str_length(spaces) result (res) ::: pure$/;"	r
str_lengths_with_precision	vec{intrinsic}.foo	/^   str_lengths_with_precision(dp,spaces) result (res) ::: pure$/;"	r
str_length_with_precision	vec{intrinsic}.foo	/^   str_length_with_precision(dp,spaces) result (res) ::: pure$/;"	r
to_str	vec{intrinsic}.foo	/^   to_str result (res)$/;"	r
to_str	vec{intrinsic}.foo	/^   to_str(format,left_justify) result (res)$/;"	r
to_str	vec{intrinsic}.foo	/^   to_str(width,left_justify) result (res)$/;"	r
to_str	vec{intrinsic}.foo	/^   to_str(style,width,precision,left_justify) result (res)$/;"	r
to_concatenated_str	vec{intrinsic}.foo	/^   to_concatenated_str(format,separator) result (res)$/;"	r
convert_to	vec{intrinsic}.foo	/^   convert_to(units)$/;"	r
convert_from	vec{intrinsic}.foo	/^   convert_from(units)$/;"	r
set_to	vec{intrinsic}.foo	/^   set_to(v) ::: pure$/;"	r
plus	vec{intrinsic}.foo	/^   plus(v,mask) ::: pure$/;"	r
minus	vec{intrinsic}.foo	/^   minus(v,mask) ::: pure$/;"	r
to_scaled	vec{intrinsic}.foo	/^   to_scaled(v,fac) ::: pure$/;"	r
plus_scaled	vec{intrinsic}.foo	/^   plus_scaled(v,fac) ::: pure$/;"	r
dot	vec{intrinsic}.foo	/^   dot(v) result (res) ::: pure$/;"	r
cross	vec{intrinsic}.foo	/^   cross(v) result (res) ::: pure$/;"	r
to_cross_product_of	vec{intrinsic}.foo	/^   to_cross_product_of(u,v) ::: pure$/;"	r
to_product_of	vec{intrinsic}.foo	/^   to_product_of(a,v,transpose_a)$/;"	r
to_product_of	vec{intrinsic}.foo	/^   to_product_of(a,v,dagger_a,transpose_a)$/;"	r
plus_product_of	vec{intrinsic}.foo	/^   plus_product_of(a,v,transpose_a)$/;"	r
plus_product_of	vec{intrinsic}.foo	/^   plus_product_of(a,v,dagger_a,transpose_a)$/;"	r
minus_product_of	vec{intrinsic}.foo	/^   minus_product_of(a,v,transpose_a)$/;"	r
minus_product_of	vec{intrinsic}.foo	/^   minus_product_of(a,v,dagger_a,transpose_a)$/;"	r
to_scaled_product_of	vec{intrinsic}.foo	/^   to_scaled_product_of(a,v,fac,transpose_a)$/;"	r
to_scaled_product_of	vec{intrinsic}.foo	/^   to_scaled_product_of(a,v,fac,dagger_a,transpose_a)$/;"	r
plus_scaled_product_of	vec{intrinsic}.foo	/^   plus_scaled_product_of(a,v,fac,transpose_a)$/;"	r
plus_scaled_product_of	vec{intrinsic}.foo	/^   plus_scaled_product_of(a,v,fac,dagger_a,transpose_a)$/;"	r
rotate_by	vec{intrinsic}.foo	/^   rotate_by(a)$/;"	r
translate_by	vec{intrinsic}.foo	/^   translate_by(v)$/;"	r
outer_product_with	vec{intrinsic}.foo	/^   outer_product_with(v) result (res)$/;"	r
norm	vec{intrinsic}.foo	/^   norm result (res) ::: pure$/;"	r
normalise	vec{intrinsic}.foo	/^   normalise$/;"	r
distance_to	vec{intrinsic}.foo	/^   distance_to(a) result (res)$/;"	r
mean	vec{intrinsic}.foo	/^   mean result (res) ::: pure$/;"	r
chop_small_values	vec{intrinsic}.foo	/^   chop_small_values(val) ::: pure$/;"	r
chop_large_values	vec{intrinsic}.foo	/^   chop_large_values(val) ::: pure$/;"	r
chop_small_absolute_values	vec{intrinsic}.foo	/^   chop_small_absolute_values(val) ::: pure$/;"	r
chop_large_absolute_values	vec{intrinsic}.foo	/^   chop_large_absolute_values(val) ::: pure$/;"	r
zero_small_values	vec{intrinsic}.foo	/^   zero_small_values(eps) ::: pure$/;"	r
largest_value	vec{intrinsic}.foo	/^   largest_value result (res) ::: pure$/;"	r
smallest_value	vec{intrinsic}.foo	/^   smallest_value result (res) ::: pure$/;"	r
no_of_elements_larger_than	vec{intrinsic}.foo	/^   no_of_elements_larger_than(tol) result (res) ::: pure$/;"	r
all_in_range	vec{intrinsic}.foo	/^   all_in_range(range) result (res) ::: pure$/;"	r
in_range	vec{intrinsic}.foo	/^   in_range(range) result (res) ::: pure$/;"	r
is_in_range	vec{intrinsic}.foo	/^   is_in_range(low,high) result (res) ::: pure$/;"	r
range	vec{intrinsic}.foo	/^   range result (res) ::: pure$/;"	r
index_of_maximum	vec{intrinsic}.foo	/^   index_of_maximum result (ind) ::: pure$/;"	r
index_of_minimum	vec{intrinsic}.foo	/^   index_of_minimum result (ind) ::: pure$/;"	r
index_of_largest_value	vec{intrinsic}.foo	/^   index_of_largest_value result (ind) ::: pure$/;"	r
index_of_smallest_value	vec{intrinsic}.foo	/^   index_of_smallest_value result (ind) ::: pure$/;"	r
index_of_first_nonzero_value	vec{intrinsic}.foo	/^   index_of_first_nonzero_value result (res) ::: pure$/;"	r
index_of_first_nonzero_value	vec{intrinsic}.foo	/^   index_of_first_nonzero_value result (res) ::: pure$/;"	r
index_of_first_zero_value	vec{intrinsic}.foo	/^   index_of_first_zero_value result (res) ::: pure$/;"	r
index_of_first_zero_value	vec{intrinsic}.foo	/^   index_of_first_zero_value result (res) ::: pure$/;"	r
index_of_first_greater_than	vec{intrinsic}.foo	/^   index_of_first_greater_than(val) result (res) ::: pure$/;"	r
index_of_value	vec{intrinsic}.foo	/^   index_of_value(val) result (res) ::: pure$/;"	r
index_of_value	vec{intrinsic}.foo	/^   index_of_value(val) result (res) ::: pure$/;"	r
index_of_value_ne_to	vec{intrinsic}.foo	/^   index_of_value_ne_to(val) result (res) ::: pure$/;"	r
alpha	vec{intrinsic}.foo	/^   alpha result (res)$/;"	r
beta	vec{intrinsic}.foo	/^   beta result (res)$/;"	r
alpha_set_to	vec{intrinsic}.foo	/^   alpha_set_to(X)$/;"	r
beta_set_to	vec{intrinsic}.foo	/^   beta_set_to(X)$/;"	r
create	vec{irrep}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{irrep}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
nullify_ptr_part	vec{irrep}.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	vec{irrep}.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	vec{irrep}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{irrep}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{irrep}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{irrep}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
create	vec{marchingcube}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{marchingcube}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
create_copy	vec{marchingcube}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{marchingcube}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
nullify_ptr_part	vec{marchingcube}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
destroy_ptr_part	vec{marchingcube}.foo	/^   destroy_ptr_part ::: get_from(VEC{OBJECT}), leaky$/;"	r
created	vec{marchingcube}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{marchingcube}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	vec{marchingcube}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
read_keywords	vec{marchingcube}.foo	/^   read_keywords ::: get_from(VEC{OBJECT})$/;"	r
process_keyword	vec{marchingcube}.foo	/^   process_keyword(keyword) $/;"	r
redirect	vec{marchingcube}.foo	/^   redirect ::: get_from(OBJECT), leaky$/;"	r
revert	vec{marchingcube}.foo	/^   revert ::: get_from(OBJECT), leaky$/;"	r
create	vec{mat3_{intrinsic}}.foo	/^   create(dim) ::: leaky$/;"	r
create	vec{mat3_{intrinsic}}.foo	/^   create(lb,ub) ::: leaky$/;"	r
destroy	vec{mat3_{intrinsic}}.foo	/^   destroy ::: leaky$/;"	r
nullify_ptr_part	vec{mat3_{intrinsic}}.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	vec{mat3_{intrinsic}}.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	vec{mat3_{intrinsic}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{mat3_{intrinsic}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{mat3_{intrinsic}}.foo	/^   create_copy(m) ::: leaky$/;"	r
copy	vec{mat3_{intrinsic}}.foo	/^   copy(m) ::: leaky$/;"	r
lb	vec{mat3_{intrinsic}}.foo	/^   lb result (res) ::: pure$/;"	r
ub	vec{mat3_{intrinsic}}.foo	/^   ub result (res) ::: pure$/;"	r
create	vec{mat3_{real}}.foo	/^   create(dim) ::: get_from(VEC{MAT3_{INTRINSIC}}), leaky$/;"	r
create	vec{mat3_{real}}.foo	/^   create(lb,ub) ::: get_from(VEC{MAT3_{INTRINSIC}}), leaky$/;"	r
destroy	vec{mat3_{real}}.foo	/^   destroy ::: get_from(VEC{MAT3_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	vec{mat3_{real}}.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	vec{mat3_{real}}.foo	/^   destroy_ptr_part ::: get_from(VEC{MAT3_{INTRINSIC}}), leaky$/;"	r
created	vec{mat3_{real}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{mat3_{real}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{mat3_{real}}.foo	/^   create_copy(m) ::: get_from(VEC{MAT3_{INTRINSIC}}), leaky$/;"	r
copy	vec{mat3_{real}}.foo	/^   copy(m) ::: get_from(VEC{MAT3_{INTRINSIC}}), leaky$/;"	r
lb	vec{mat3_{real}}.foo	/^   lb result (res) ::: get_from(VEC{MAT3_{INTRINSIC}}), pure$/;"	r
ub	vec{mat3_{real}}.foo	/^   ub result (res) ::: get_from(VEC{MAT3_{INTRINSIC}}), pure$/;"	r
make_gaussian_xyz_matrices	vec{mat3_{real}}.foo	/^   make_gaussian_xyz_matrices(ptr) ::: leaky$/;"	r
create	vec{mat4_{intrinsic}}.foo	/^   create(dim) ::: leaky$/;"	r
destroy	vec{mat4_{intrinsic}}.foo	/^   destroy ::: leaky$/;"	r
nullify_ptr_part	vec{mat4_{intrinsic}}.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	vec{mat4_{intrinsic}}.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	vec{mat4_{intrinsic}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{mat4_{intrinsic}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create	vec{mat4_{real}}.foo	/^   create(dim) ::: get_from(VEC{MAT4_{INTRINSIC}}), leaky$/;"	r
destroy	vec{mat4_{real}}.foo	/^   destroy ::: get_from(VEC{MAT4_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	vec{mat4_{real}}.foo	/^   nullify_ptr_part ::: get_from(VEC{MAT4_{INTRINSIC}})$/;"	r
destroy_ptr_part	vec{mat4_{real}}.foo	/^   destroy_ptr_part ::: get_from(VEC{MAT4_{INTRINSIC}}), leaky$/;"	r
created	vec{mat4_{real}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{mat4_{real}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create	vec{mat_{int}}.foo	/^   create(dim) ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
create	vec{mat_{int}}.foo	/^   create(lb,ub) ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
destroy	vec{mat_{int}}.foo	/^   destroy ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	vec{mat_{int}}.foo	/^   nullify_ptr_part ::: get_from(VEC{MAT_{INT}})$/;"	r
destroy_ptr_part	vec{mat_{int}}.foo	/^   destroy_ptr_part ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
created	vec{mat_{int}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{mat_{int}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{mat_{int}}.foo	/^   create_copy(m) ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
copy	vec{mat_{int}}.foo	/^   copy(m) ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
create	vec{mat_{intrinsic}}.foo	/^   create(dim) ::: leaky$/;"	r
create	vec{mat_{intrinsic}}.foo	/^   create(lb,ub) ::: leaky$/;"	r
create	vec{mat_{intrinsic}}.foo	/^   create(dim,dim1,dim2) ::: leaky$/;"	r
create_mat	vec{mat_{intrinsic}}.foo	/^   create_mat(dim1,dim2) ::: leaky$/;"	r
destroy	vec{mat_{intrinsic}}.foo	/^   destroy ::: leaky$/;"	r
nullify_ptr_part	vec{mat_{intrinsic}}.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	vec{mat_{intrinsic}}.foo	/^   destroy_ptr_part ::: leaky$/;"	r
created	vec{mat_{intrinsic}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{mat_{intrinsic}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{mat_{intrinsic}}.foo	/^   create_copy(m) ::: leaky$/;"	r
copy	vec{mat_{intrinsic}}.foo	/^   copy(m) ::: leaky$/;"	r
create	vec{mat_{real}}.foo	/^   create(dim) ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
create	vec{mat_{real}}.foo	/^   create(lb,ub) ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
create	vec{mat_{real}}.foo	/^   create(dim,dim1,dim2) ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
create_mat	vec{mat_{real}}.foo	/^   create_mat(dim1,dim2) ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
destroy	vec{mat_{real}}.foo	/^   destroy ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	vec{mat_{real}}.foo	/^   nullify_ptr_part ::: get_from(VEC{MAT_{INTRINSIC}})$/;"	r
destroy_ptr_part	vec{mat_{real}}.foo	/^   destroy_ptr_part ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
created	vec{mat_{real}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{mat_{real}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{mat_{real}}.foo	/^   create_copy(m) ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
copy	vec{mat_{real}}.foo	/^   copy(m) ::: get_from(VEC{MAT_{INTRINSIC}}), leaky$/;"	r
lb	vec{mat_{real}}.foo	/^   lb result(res) ::: pure$/;"	r
ub	vec{mat_{real}}.foo	/^   ub result(res) ::: pure$/;"	r
make_gaussian_xyz_matrices	vec{mat_{real}}.foo	/^   make_gaussian_xyz_matrices(ptr) ::: leaky$/;"	r
to_product_of	vec{mat_{real}}.foo	/^   to_product_of(a,v,transpose_a)$/;"	r
weak_two_orthonormalise	vec{mat_{real}}.foo	/^   weak_two_orthonormalise(vec)$/;"	r
vec	vec{mat_{real}}.foo	/^     vec :: VEC{MAT_{REAL}}, IN$/;"	a
two_orthonormalise	vec{mat_{real}}.foo	/^   two_orthonormalise(eigenvectors)$/;"	r
eigenvectors	vec{mat_{real}}.foo	/^     eigenvectors :: MAT{REAL}, IN$/;"	a
new	vec{mat_{real}}.foo	/^     new :: MAT{REAL}*$/;"	a
resz	vec{mat_{real}}.foo	/^     resz :: VEC{REAL}*$/;"	a
vec	vec{mat_{real}}.foo	/^     vec :: VEC{REAL}*$/;"	a
fac	vec{mat_{real}}.foo	/^     fac :: REAL$/;"	a
strong_two_orthonormalise	vec{mat_{real}}.foo	/^   strong_two_orthonormalise(eigenvectors)$/;"	r
eigenvectors	vec{mat_{real}}.foo	/^     eigenvectors :: MAT{REAL}, IN$/;"	a
new	vec{mat_{real}}.foo	/^     new :: MAT{REAL}*$/;"	a
resz	vec{mat_{real}}.foo	/^     resz :: VEC{REAL}*$/;"	a
vec	vec{mat_{real}}.foo	/^     vec :: VEC{REAL}*$/;"	a
fac	vec{mat_{real}}.foo	/^     fac :: REAL$/;"	a
schmidt_orthonormalise	vec{mat_{real}}.foo	/^   schmidt_orthonormalise(S,scales,n_dependent,ld_tol)$/;"	r
scales	vec{mat_{real}}.foo	/^     scales :: VEC{REAL}, OUT$/;"	a
n_dependent	vec{mat_{real}}.foo	/^     n_dependent :: INT, OUT$/;"	a
ld_tol	vec{mat_{real}}.foo	/^     ld_tol :: REAL, optional$/;"	a
unorthovec	vec{mat_{real}}.foo	/^     unorthovec :: MAT{REAL}*$/;"	a
schmidt_orthonormalise	vec{mat_{real}}.foo	/^   schmidt_orthonormalise(S,keep,scales,n_dependent,ld_tol)$/;"	r
self	vec{mat_{real}}.foo	/^     self :: PTR$/;"	a
keep	vec{mat_{real}}.foo	/^     keep :: VEC{MAT_{REAL}}$/;"	a
scales	vec{mat_{real}}.foo	/^     scales :: VEC{REAL}, OUT$/;"	a
n_dependent	vec{mat_{real}}.foo	/^     n_dependent :: INT, OUT$/;"	a
ld_tol	vec{mat_{real}}.foo	/^     ld_tol :: REAL, optional$/;"	a
unorthovec	vec{mat_{real}}.foo	/^     unorthovec :: MAT{REAL}*$/;"	a
indices	vec{mat_{real}}.foo	/^     indices :: VEC{INT}*$/;"	a
flatten	vec{mat_{real}}.foo	/^   flatten(vec_vec)$/;"	r
vec_vec	vec{mat_{real}}.foo	/^     vec_vec :: VEC{VEC_{REAL}}*$/;"	a
counter	vec{mat_{real}}.foo	/^     counter :: INT$/;"	a
flatten	vec{mat_{real}}.foo	/^   flatten(mat)$/;"	r
mat	vec{mat_{real}}.foo	/^     mat :: MAT{REAL}*$/;"	a
counter	vec{mat_{real}}.foo	/^     counter :: INT$/;"	a
change_basis_using	vec{mat_{real}}.foo	/^   change_basis_using(mat,use_transpose)$/;"	r
mat	vec{mat_{real}}.foo	/^     mat :: MAT{REAL}, IN$/;"	a
use_transpose	vec{mat_{real}}.foo	/^     use_transpose :: BIN, optional$/;"	a
new	vec{mat_{real}}.foo	/^     new :: VEC{MAT_{REAL}}*$/;"	a
use_tr	vec{mat_{real}}.foo	/^     use_tr :: BIN$/;"	a
expand	vec{mat_{real}}.foo	/^   expand(dim) ::: leaky$/;"	r
self	vec{mat_{real}}.foo	/^     self :: PTR$/;"	a
dim	vec{mat_{real}}.foo	/^     dim :: INT, IN$/;"	a
old	vec{mat_{real}}.foo	/^     old :: VEC{MAT_{REAL}}*$/;"	a
old_size	vec{mat_{real}}.foo	/^     old_size :: INT$/;"	a
saved_self	vec{object}.foo	/^   saved_self :: VEC{OBJECT}*, private$/;"	g
create	vec{object}.foo	/^   create(dim) ::: leaky$/;"	r
create	vec{object}.foo	/^   create(dim) ::: leaky$/;"	r
create	vec{object}.foo	/^   create(dim) ::: leaky$/;"	r
create	vec{object}.foo	/^   create(lb,ub) ::: leaky$/;"	r
create	vec{object}.foo	/^   create(lb,ub) ::: leaky$/;"	r
create	vec{object}.foo	/^   create(bounds) ::: leaky$/;"	r
destroy	vec{object}.foo	/^   destroy ::: leaky$/;"	r
destroy	vec{object}.foo	/^   destroy ::: leaky$/;"	r
create_copy	vec{object}.foo	/^   create_copy(vec) ::: leaky$/;"	r
copy	vec{object}.foo	/^   copy(vec) ::: leaky$/;"	r
created	vec{object}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	vec{object}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
nullify_ptr_part	vec{object}.foo	/^   nullify_ptr_part$/;"	r
destroy_ptr_part	vec{object}.foo	/^   destroy_ptr_part ::: leaky$/;"	r
set_defaults	vec{object}.foo	/^   set_defaults$/;"	r
set_saved_self	vec{object}.foo	/^   set_saved_self $/;"	r
shrink	vec{object}.foo	/^   shrink(dim) ::: leaky$/;"	r
expand	vec{object}.foo	/^   expand(dim) ::: leaky$/;"	r
append	vec{object}.foo	/^   append(v) ::: leaky$/;"	r
append	vec{object}.foo	/^   append(value) ::: leaky$/;"	r
join	vec{object}.foo	/^   join(v) result (res) ::: leaky$/;"	r
join	vec{object}.foo	/^   join(v1,v2) result (res) ::: leaky$/;"	r
prune_element	vec{object}.foo	/^   prune_element(k) ::: leaky$/;"	r
sort	vec{object}.foo	/^   sort(decreasing_order) ::: pure$/;"	r
quick_sort	vec{object}.foo	/^   quick_sort(decreasing_order)$/;"	r
quick_sort_increasing	vec{object}.foo	/^   quick_sort_increasing ::: recursive, private$/;"	r
quick_sort_decreasing	vec{object}.foo	/^   quick_sort_decreasing ::: recursive, private$/;"	r
quick_sort	vec{object}.foo	/^   quick_sort(indices,decreasing_order)$/;"	r
quick_sort_increasing	vec{object}.foo	/^   quick_sort_increasing(indices) ::: recursive, private$/;"	r
quick_sort_decreasing	vec{object}.foo	/^   quick_sort_decreasing(indices) ::: recursive, private$/;"	r
reverse_order	vec{object}.foo	/^   reverse_order ::: pure$/;"	r
remove_repetitions	vec{object}.foo	/^   remove_repetitions ::: leaky$/;"	r
has_repetitions	vec{object}.foo	/^   has_repetitions result (res)$/;"	r
no_of_unique_elements	vec{object}.foo	/^   no_of_unique_elements result (res) ::: pure$/;"	r
read_keywords	vec{object}.foo	/^   read_keywords ::: recursive, leaky$/;"	r
read_list_keywords	vec{object}.foo	/^   read_list_keywords ::: recursive, leaky$/;"	r
process_list_keyword	vec{object}.foo	/^   process_list_keyword(keyword) ::: leaky$/;"	r
read_data	vec{object}.foo	/^   read_data(ignore_braces) ::: leaky$/;"	r
data_length	vec{object}.foo	/^   data_length result (length)$/;"	r
read_altered_data	vec{object}.foo	/^   read_altered_data ::: leaky$/;"	r
read_append_data	vec{object}.foo	/^   read_append_data ::: leaky$/;"	r
process_keys	vec{object}.foo	/^   process_keys ::: leaky$/;"	r
process_keys_once	vec{object}.foo	/^   process_keys_once $/;"	r
keys_created	vec{object}.foo	/^   keys_created result (res)$/;"	r
set_keys	vec{object}.foo	/^   set_keys(the_keys)$/;"	r
clear_keys	vec{object}.foo	/^   clear_keys$/;"	r
read_keys	vec{object}.foo	/^   read_keys$/;"	r
put_keys_table	vec{object}.foo	/^   put_keys_table$/;"	r
put_table_header	vec{object}.foo	/^   put_table_header$/;"	r
put_table_footer	vec{object}.foo	/^   put_table_footer$/;"	r
put	vec{object}.foo	/^   put$/;"	r
put_table	vec{object}.foo	/^   put_table$/;"	r
create	vec{quadrature}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{quadrature}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
nullify_ptr_part	vec{quadrature}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
destroy_ptr_part	vec{quadrature}.foo	/^   destroy_ptr_part ::: get_from(VEC{OBJECT}), leaky$/;"	r
created	vec{quadrature}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{quadrature}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{quadrature}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{quadrature}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
set_defaults	vec{quadrature}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
create	vec{real}.foo	/^   create(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create	vec{real}.foo	/^   create(lb,ub) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create	vec{real}.foo	/^   create(bounds) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
destroy	vec{real}.foo	/^   destroy ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create_copy	vec{real}.foo	/^   create_copy(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
copy	vec{real}.foo	/^   copy(v) ::: get_from(VEC{INTRINSIC})$/;"	r
created	vec{real}.foo	/^   created result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	vec{real}.foo	/^   destroyed result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
size	vec{real}.foo	/^   size result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
dim	vec{real}.foo	/^   dim result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
shrink	vec{real}.foo	/^   shrink(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
expand	vec{real}.foo	/^   expand(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
resize	vec{real}.foo	/^   resize(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append	vec{real}.foo	/^   append(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append	vec{real}.foo	/^   append(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prepend	vec{real}.foo	/^   prepend(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prepend	vec{real}.foo	/^   prepend(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
join	vec{real}.foo	/^   join(v) result (res) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
join	vec{real}.foo	/^   join(v1,v2) result (res) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prune	vec{real}.foo	/^   prune(values) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prune	vec{real}.foo	/^   prune(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prune_element	vec{real}.foo	/^   prune_element(k) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
equals	vec{real}.foo	/^   equals(v,eps) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
same_as	vec{real}.foo	/^   same_as(v,eps) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
are_all_equal	vec{real}.foo	/^   are_all_equal(eps) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
are_all_equal_to	vec{real}.foo	/^   are_all_equal_to(val,eps) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
is_zero	vec{real}.foo	/^   is_zero(eps) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
is_monotone	vec{real}.foo	/^   is_monotone result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
is_monotonically_increasing	vec{real}.foo	/^   is_monotonically_increasing result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
is_monotonically_decreasing	vec{real}.foo	/^   is_monotonically_decreasing result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
is_z_axis	vec{real}.foo	/^   is_z_axis(eps) result (res)$/;"	r
remove_repetitions	vec{real}.foo	/^   remove_repetitions ::: get_from(VEC{OBJECT}), leaky$/;"	r
has_repetitions	vec{real}.foo	/^   has_repetitions result (res) ::: get_from(VEC{OBJECT})$/;"	r
no_of_unique_elements	vec{real}.foo	/^   no_of_unique_elements result (res) ::: get_from(VEC{OBJECT}), pure$/;"	r
sort	vec{real}.foo	/^   sort(decreasing_order) ::: get_from(VEC{OBJECT})$/;"	r
quick_sort	vec{real}.foo	/^   quick_sort(decreasing_order) ::: get_from(VEC{OBJECT})$/;"	r
quick_sort_increasing	vec{real}.foo	/^   quick_sort_increasing ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
quick_sort_decreasing	vec{real}.foo	/^   quick_sort_decreasing ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
quick_sort	vec{real}.foo	/^   quick_sort(indices,decreasing_order) ::: get_from(VEC{OBJECT})$/;"	r
quick_sort_increasing	vec{real}.foo	/^   quick_sort_increasing(indices) ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
quick_sort_decreasing	vec{real}.foo	/^   quick_sort_decreasing(indices) ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
reverse_order	vec{real}.foo	/^   reverse_order ::: get_from(VEC{INTRINSIC})$/;"	r
swap_elements	vec{real}.foo	/^   swap_elements(e1,e2) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
set_to_flattened_reverse_of	vec{real}.foo	/^   set_to_flattened_reverse_of(b) ::: get_from(VEC{INTRINSIC})$/;"	r
set_to	vec{real}.foo	/^   set_to(v) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}), pure$/;"	r
plus	vec{real}.foo	/^   plus(v,mask) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}), pure$/;"	r
minus	vec{real}.foo	/^   minus(v,mask) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}), pure$/;"	r
to_scaled	vec{real}.foo	/^   to_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL), pure$/;"	r
plus_scaled	vec{real}.foo	/^   plus_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL), pure$/;"	r
dot	vec{real}.foo	/^   dot(v) result (res) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, RES_TYPE=>REAL), pure$/;"	r
cross	vec{real}.foo	/^   cross(v) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
to_cross_product_of	vec{real}.foo	/^   to_cross_product_of(u,v) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
to_product_of	vec{real}.foo	/^   to_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL})$/;"	r
plus_product_of	vec{real}.foo	/^   plus_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL})$/;"	r
minus_product_of	vec{real}.foo	/^   minus_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL})$/;"	r
to_scaled_product_of	vec{real}.foo	/^   to_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL)$/;"	r
plus_scaled_product_of	vec{real}.foo	/^   plus_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL)$/;"	r
rotate_by	vec{real}.foo	/^   rotate_by(a) ::: get_from(VEC{INTRINSIC})$/;"	r
translate_by	vec{real}.foo	/^   translate_by(v) ::: get_from(VEC{INTRINSIC})$/;"	r
seitz_multiply	vec{real}.foo	/^   seitz_multiply(seitz)$/;"	r
outer_product_with	vec{real}.foo	/^   outer_product_with(v) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
norm	vec{real}.foo	/^   norm result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
normalise	vec{real}.foo	/^   normalise ::: get_from(VEC{INTRINSIC})$/;"	r
distance_to	vec{real}.foo	/^   distance_to(a) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
mean	vec{real}.foo	/^   mean result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
variance	vec{real}.foo	/^   variance result (res) ::: pure$/;"	r
standard_deviation	vec{real}.foo	/^   standard_deviation result (res) ::: pure$/;"	r
arcsinh	vec{real}.foo	/^   arcsinh result (res)$/;"	r
chop_small_values	vec{real}.foo	/^   chop_small_values(val) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
chop_large_values	vec{real}.foo	/^   chop_large_values(val) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
chop_small_absolute_values	vec{real}.foo	/^   chop_small_absolute_values(val) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
chop_large_absolute_values	vec{real}.foo	/^   chop_large_absolute_values(val) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
zero_small_values	vec{real}.foo	/^   zero_small_values(eps) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
largest_value	vec{real}.foo	/^   largest_value result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
smallest_value	vec{real}.foo	/^   smallest_value result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
no_of_elements_larger_than	vec{real}.foo	/^   no_of_elements_larger_than(tol) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
all_in_range	vec{real}.foo	/^   all_in_range(range) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
in_range	vec{real}.foo	/^   in_range(range) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
is_in_range	vec{real}.foo	/^   is_in_range(low,high) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
range	vec{real}.foo	/^   range result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_maximum	vec{real}.foo	/^   index_of_maximum result (ind) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_minimum	vec{real}.foo	/^   index_of_minimum result (ind) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_largest_value	vec{real}.foo	/^   index_of_largest_value result (ind) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_smallest_value	vec{real}.foo	/^   index_of_smallest_value result (ind) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
index_of_first_nonzero_value	vec{real}.foo	/^   index_of_first_nonzero_value(eps) result (res) ::: pure$/;"	r
index_of_first_zero_value	vec{real}.foo	/^   index_of_first_zero_value result (res)$/;"	r
index_of_first_greater_than	vec{real}.foo	/^   index_of_first_greater_than(val) result (res) ::: get_from(VEC{INTRINSIC}, VAL_TYPE=>REAL), pure$/;"	r
index_of_value	vec{real}.foo	/^   index_of_value(val,eps) result(pos) ::: pure$/;"	r
find_opposite_pairs	vec{real}.foo	/^   find_opposite_pairs(pair,min,max)$/;"	r
find_pairs	vec{real}.foo	/^   find_pairs(pair,match_function,tol)$/;"	r
str_lengths	vec{real}.foo	/^   str_lengths(spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
str_length	vec{real}.foo	/^   str_length(spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
str_lengths_with_precision	vec{real}.foo	/^   str_lengths_with_precision(dp,spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
str_length_with_precision	vec{real}.foo	/^   str_length_with_precision(dp,spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure $/;"	r
to_str	vec{real}.foo	/^   to_str result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
to_str	vec{real}.foo	/^   to_str(format,left_justify) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
to_str	vec{real}.foo	/^   to_str(style,width,precision,left_justify) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
to_concatenated_str	vec{real}.foo	/^   to_concatenated_str(format,separator) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
to_str_no_zeros	vec{real}.foo	/^   to_str_no_zeros result (res)$/;"	r
convert_to	vec{real}.foo	/^   convert_to(units) ::: get_from(VEC{INTRINSIC}, nint=>)$/;"	r
convert_from	vec{real}.foo	/^   convert_from(units) ::: get_from(VEC{INTRINSIC}, nint=>)$/;"	r
alpha	vec{real}.foo	/^   alpha result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
beta	vec{real}.foo	/^   beta result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
alpha_set_to	vec{real}.foo	/^   alpha_set_to(X) ::: get_from(VEC{INTRINSIC})$/;"	r
beta_set_to	vec{real}.foo	/^   beta_set_to(X) ::: get_from(VEC{INTRINSIC})$/;"	r
bracket_root	vec{real}.foo	/^   bracket_root(z,direction,x1,x2,factor,val,max_it) ::: routinal$/;"	r
find_root_brent	vec{real}.foo	/^   find_root_brent(z,direction,x1,x2,tol,root,val,max_it) ::: routinal$/;"	r
find_isopoint	vec{real}.foo	/^   find_isopoint(z,direction,isovalue,tol,x1,x2) ::: routinal$/;"	r
minimise	vec{real}.foo	/^   minimise(new_direction,gradient,old_val,old_gradient,hessian)$/;"	r
minimise_BFGS	vec{real}.foo	/^   minimise_BFGS(dself,p,fret,tol,gtol,step,max_it) ::: routinal, public$/;"	r
minimise_FRPR	vec{real}.foo	/^   minimise_FRPR(dself,p,fret,tol,ftol,algorithm,step) ::: routinal$/;"	r
minimise_powell	vec{real}.foo	/^   minimise_powell(p,directions,fret,tol,ftol) ::: routinal$/;"	r
line_minimise_from	vec{real}.foo	/^   line_minimise_from(p,direction,fret,tol,f0,del) ::: routinal$/;"	r
bracket_minimum	vec{real}.foo	/^   bracket_minimum(p,direction,a,b,c,fa,fb,fc,fa0,fb0) ::: routinal$/;"	r
minimise_brent	vec{real}.foo	/^   minimise_brent(p,direction,a,b,c,xmin,f,tol,fb0) ::: routinal$/;"	r
minimise_golden	vec{real}.foo	/^   minimise_golden(p,direction,a,b,c,xmin,f,tol) ::: routinal$/;"	r
minimise_BFGS_v2	vec{real}.foo	/^   minimise_BFGS_v2(p,fret,tol,gtol,step,max_it) ::: routinal, public$/;"	r
minimise_FRPR_v2	vec{real}.foo	/^   minimise_FRPR_v2(p,fret,tol,ftol,algorithm,step) ::: routinal$/;"	r
line_minimise_from_v2	vec{real}.foo	/^   line_minimise_from_v2(p,direction,fret,tol,f0,del) ::: routinal$/;"	r
bracket_minimum_v2	vec{real}.foo	/^   bracket_minimum_v2(p,direction,a,b,c,fa,fb,fc,fa0,fb0) ::: routinal$/;"	r
minimise_brent_v2	vec{real}.foo	/^   minimise_brent_v2(p,direction,a,b,c,xmin,f,tol,fb0) ::: routinal$/;"	r
minimise_golden_v2	vec{real}.foo	/^   minimise_golden_v2(p,direction,a,b,c,xmin,f,tol) ::: routinal$/;"	r
make_R_harmonics	vec{real}.foo	/^   make_R_harmonics(Rc,Rs,point,l_max) ::: selfless, public, leaky$/;"	r
make_R_harmonics	vec{real}.foo	/^   make_R_harmonics(Rc,Rs,points,l_max) ::: selfless, leaky$/;"	r
make_R_multipoles	vec{real}.foo	/^   make_R_multipoles(qc,qs,charges,points,l_max) ::: selfless, leaky$/;"	r
make_R_mu_harmonics	vec{real}.foo	/^   make_R_mu_harmonics(Rm,points,l_max) ::: selfless, public, leaky$/;"	r
make_R_mu_multipoles	vec{real}.foo	/^   make_R_mu_multipoles(q,charges,points,l_max) ::: selfless$/;"	r
add_R_mu_multipoles	vec{real}.foo	/^   add_R_mu_multipoles(q,charges,points,l_max) ::: selfless$/;"	r
make_I_harmonics	vec{real}.foo	/^   make_I_harmonics(Ic,Is,point,l_max) ::: selfless, public, leaky$/;"	r
make_I_harmonics	vec{real}.foo	/^   make_I_harmonics(Ic,Is,points,l_max) ::: selfless, leaky$/;"	r
make_I_mu_harmonics	vec{real}.foo	/^   make_I_mu_harmonics(Im,points,l_max) ::: selfless, leaky$/;"	r
to_multipole_T_interaction_vec	vec{real}.foo	/^   to_multipole_T_interaction_vec(R,j_max)$/;"	r
saved_self	vec{reflection}.foo	/^   saved_self :: VEC{REFLECTION}*, private  DEFAULT_NULL$/;"	g
create	vec{reflection}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
create_copy	vec{reflection}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{reflection}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT})$/;"	r
destroy	vec{reflection}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
set_defaults	vec{reflection}.foo	/^   set_defaults$/;"	r
set_indices	vec{reflection}.foo	/^   set_indices(h,k,l)$/;"	r
set_F_calc	vec{reflection}.foo	/^   set_F_calc(F_calc)$/;"	r
set_F_pred	vec{reflection}.foo	/^   set_F_pred(F_pred)$/;"	r
set_F_exp	vec{reflection}.foo	/^   set_F_exp(F_exp)$/;"	r
set_F_sigma	vec{reflection}.foo	/^   set_F_sigma(F_sigma)$/;"	r
set_I_pred	vec{reflection}.foo	/^   set_I_pred(I_pred)$/;"	r
set_I_exp	vec{reflection}.foo	/^   set_I_exp(I_exp)$/;"	r
set_I_sigma	vec{reflection}.foo	/^   set_I_sigma(I_sigma)$/;"	r
set	vec{reflection}.foo	/^   set(ref)$/;"	r
scale_F_pred	vec{reflection}.foo	/^   scale_F_pred(fac)$/;"	r
scale_F_calc	vec{reflection}.foo	/^   scale_F_calc(fac)$/;"	r
scale_F_exp	vec{reflection}.foo	/^   scale_F_exp(fac)$/;"	r
scale_F_sigma	vec{reflection}.foo	/^   scale_F_sigma(fac)$/;"	r
created	vec{reflection}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{reflection}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
n_refl	vec{reflection}.foo	/^   n_refl result (res)$/;"	r
have_F_calc	vec{reflection}.foo	/^   have_F_calc result (res) ::: pure$/;"	r
have_F_pred	vec{reflection}.foo	/^   have_F_pred result (res) ::: pure$/;"	r
have_F_exp	vec{reflection}.foo	/^   have_F_exp result (res) ::: pure$/;"	r
have_F_sigma	vec{reflection}.foo	/^   have_F_sigma result (res) ::: pure$/;"	r
have_I_pred	vec{reflection}.foo	/^   have_I_pred result (res) ::: pure$/;"	r
have_I_exp	vec{reflection}.foo	/^   have_I_exp result (res) ::: pure$/;"	r
have_I_sigma	vec{reflection}.foo	/^   have_I_sigma result (res) ::: pure$/;"	r
have_indices	vec{reflection}.foo	/^   have_indices result (res) ::: pure$/;"	r
indices	vec{reflection}.foo	/^   indices(n) result (res) ::: pure$/;"	r
use_multiple_scale_factors	vec{reflection}.foo	/^   use_multiple_scale_factors result (res)$/;"	r
F_chi2	vec{reflection}.foo	/^   F_chi2 result (res) ::: pure$/;"	r
F2_chi2	vec{reflection}.foo	/^   F2_chi2 result (res) ::: pure$/;"	r
I_chi2	vec{reflection}.foo	/^   I_chi2 result (res) ::: pure$/;"	r
F_goodness_of_fit	vec{reflection}.foo	/^   F_goodness_of_fit result (res) ::: pure$/;"	r
I_goodness_of_fit	vec{reflection}.foo	/^   I_goodness_of_fit result (res) ::: pure$/;"	r
F_r_factor	vec{reflection}.foo	/^   F_r_factor result (res) ::: pure$/;"	r
F2_r_factor	vec{reflection}.foo	/^   F2_r_factor result (res) ::: pure$/;"	r
F_r_sigma	vec{reflection}.foo	/^   F_r_sigma result (res) ::: pure$/;"	r
F2_r_sigma	vec{reflection}.foo	/^   F2_r_sigma result (res) ::: pure$/;"	r
I_r_factor	vec{reflection}.foo	/^   I_r_factor result (res) ::: pure$/;"	r
F_weighted_r_factor	vec{reflection}.foo	/^   F_weighted_r_factor result (res) ::: pure$/;"	r
F2_weighted_r_factor	vec{reflection}.foo	/^   F2_weighted_r_factor result (res) ::: pure$/;"	r
F_val_r_factor	vec{reflection}.foo	/^   F_val_r_factor(core_reflection) result (res) $/;"	r
I_weighted_r_factor	vec{reflection}.foo	/^   I_weighted_r_factor result (res) ::: pure$/;"	r
F_calc	vec{reflection}.foo	/^   F_calc result (res) ::: pure$/;"	r
F_pred	vec{reflection}.foo	/^   F_pred result (res) ::: pure$/;"	r
F_exp	vec{reflection}.foo	/^   F_exp result (res) ::: pure$/;"	r
I_pred	vec{reflection}.foo	/^   I_pred result (res) ::: pure$/;"	r
F_sigma	vec{reflection}.foo	/^   F_sigma result (res) ::: pure$/;"	r
read_list_keywords	vec{reflection}.foo	/^   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky$/;"	r
process_list_keyword	vec{reflection}.foo	/^   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_data	vec{reflection}.foo	/^   read_data(ignore_braces) ::: get_from(VEC{OBJECT}), leaky$/;"	r
data_length	vec{reflection}.foo	/^   data_length result (length) ::: get_from(VEC{OBJECT})$/;"	r
read_altered_data	vec{reflection}.foo	/^   read_altered_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_append_data	vec{reflection}.foo	/^   read_append_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys	vec{reflection}.foo	/^   process_keys ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys_once	vec{reflection}.foo	/^   process_keys_once ::: get_from(VEC{OBJECT})$/;"	r
keys_created	vec{reflection}.foo	/^   keys_created result (res) ::: get_from(VEC{OBJECT})$/;"	r
set_keys	vec{reflection}.foo	/^   set_keys(the_keys) ::: get_from(VEC{OBJECT})$/;"	r
clear_keys	vec{reflection}.foo	/^   clear_keys ::: get_from(VEC{OBJECT})$/;"	r
read_keys	vec{reflection}.foo	/^   read_keys ::: get_from(VEC{OBJECT})$/;"	r
put_keys_table	vec{reflection}.foo	/^   put_keys_table ::: get_from(VEC{OBJECT})$/;"	r
put_table_header	vec{reflection}.foo	/^   put_table_header ::: get_from(VEC{OBJECT})$/;"	r
put_table_footer	vec{reflection}.foo	/^   put_table_footer ::: get_from(VEC{OBJECT})$/;"	r
redirect	vec{reflection}.foo	/^   redirect ::: get_from(OBJECT), leaky$/;"	r
revert	vec{reflection}.foo	/^   revert ::: get_from(OBJECT), leaky$/;"	r
read_keywords	vec{reflection}.foo	/^   read_keywords ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keyword	vec{reflection}.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
shrink	vec{reflection}.foo	/^   shrink(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
expand	vec{reflection}.foo	/^   expand(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{reflection}.foo	/^   append(v) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{reflection}.foo	/^   append(value) ::: get_from(VEC{OBJECT}), leaky$/;"	r
set_hkl_range	vec{reflection}.foo	/^   set_hkl_range ::: leaky$/;"	r
put	vec{reflection}.foo	/^   put(core_reflection)$/;"	r
put_structure_factor_data	vec{reflection}.foo	/^   put_structure_factor_data(core_reflection)$/;"	r
put_F_pred_data	vec{reflection}.foo	/^   put_F_pred_data$/;"	r
put_F_exp_data	vec{reflection}.foo	/^   put_F_exp_data$/;"	r
put_intensity_data	vec{reflection}.foo	/^   put_intensity_data$/;"	r
put_I_pred_data	vec{reflection}.foo	/^   put_I_pred_data$/;"	r
put_I_exp_data	vec{reflection}.foo	/^   put_I_exp_data$/;"	r
put_F_statistics	vec{reflection}.foo	/^   put_F_statistics(core_reflection,show_chi2)$/;"	r
put_I_stats	vec{reflection}.foo	/^   put_I_stats$/;"	r
put_F_qq_plot	vec{reflection}.foo	/^   put_F_qq_plot$/;"	r
put_labelled_F_qq_plot	vec{reflection}.foo	/^   put_labelled_F_qq_plot$/;"	r
make_F_qq_plot_grid	vec{reflection}.foo	/^   make_F_qq_plot_grid(grid,hkl)$/;"	r
simulate_new_F_exp	vec{reflection}.foo	/^   simulate_new_F_exp$/;"	r
add_random_error	vec{reflection}.foo	/^   add_random_error$/;"	r
saved_self	vec{shell}.foo	/^   saved_self :: VEC{SHELL}*, private  DEFAULT_NULL$/;"	g
create	vec{shell}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{shell}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
nullify_ptr_part	vec{shell}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
destroy_ptr_part	vec{shell}.foo	/^   destroy_ptr_part ::: get_from(VEC{OBJECT}), leaky$/;"	r
created	vec{shell}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{shell}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{shell}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{shell}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
shrink	vec{shell}.foo	/^   shrink(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
expand	vec{shell}.foo	/^   expand(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{shell}.foo	/^   append(v) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{shell}.foo	/^   append(value) ::: get_from(VEC{OBJECT}), leaky$/;"	r
set_spherical	vec{shell}.foo	/^   set_spherical(val)$/;"	r
read_list_keywords	vec{shell}.foo	/^   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky$/;"	r
process_list_keyword	vec{shell}.foo	/^   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_data	vec{shell}.foo	/^   read_data(ignore_braces) ::: get_from(VEC{OBJECT}), leaky$/;"	r
data_length	vec{shell}.foo	/^   data_length result (length) ::: get_from(VEC{OBJECT})$/;"	r
read_altered_data	vec{shell}.foo	/^   read_altered_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_append_data	vec{shell}.foo	/^   read_append_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys	vec{shell}.foo	/^   process_keys ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys_once	vec{shell}.foo	/^   process_keys_once ::: get_from(VEC{OBJECT})$/;"	r
keys_created	vec{shell}.foo	/^   keys_created result (res) ::: get_from(VEC{OBJECT})$/;"	r
set_keys	vec{shell}.foo	/^   set_keys(the_keys) ::: get_from(VEC{OBJECT})$/;"	r
clear_keys	vec{shell}.foo	/^   clear_keys ::: get_from(VEC{OBJECT})$/;"	r
read_keys	vec{shell}.foo	/^   read_keys ::: get_from(VEC{OBJECT})$/;"	r
put_keys_table	vec{shell}.foo	/^   put_keys_table ::: get_from(VEC{OBJECT})$/;"	r
put_table_header	vec{shell}.foo	/^   put_table_header ::: get_from(VEC{OBJECT})$/;"	r
put_table_footer	vec{shell}.foo	/^   put_table_footer ::: get_from(VEC{OBJECT})$/;"	r
redirect	vec{shell}.foo	/^   redirect ::: get_from(OBJECT), leaky$/;"	r
revert	vec{shell}.foo	/^   revert ::: get_from(OBJECT), leaky$/;"	r
read_keywords	vec{shell}.foo	/^   read_keywords ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keyword	vec{shell}.foo	/^   process_keyword(keyword) ::: leaky$/;"	r
unnormalise	vec{shell}.foo	/^   unnormalise$/;"	r
renormalise	vec{shell}.foo	/^   renormalise$/;"	r
maximum_l_value	vec{shell}.foo	/^   maximum_l_value result (res)$/;"	r
same_as	vec{shell}.foo	/^   same_as(sh) result (same)$/;"	r
no_of_shells	vec{shell}.foo	/^   no_of_shells result (res) ::: pure$/;"	r
no_of_primitive_shells	vec{shell}.foo	/^   no_of_primitive_shells result (res) ::: pure$/;"	r
no_of_basis_functions	vec{shell}.foo	/^   no_of_basis_functions result (res) ::: pure$/;"	r
no_of_sph_basis_functions	vec{shell}.foo	/^   no_of_sph_basis_functions result (res) ::: pure$/;"	r
no_of_primitives	vec{shell}.foo	/^   no_of_primitives result (res) ::: pure$/;"	r
no_of_sph_primitives	vec{shell}.foo	/^   no_of_sph_primitives result (res) ::: pure$/;"	r
min_exponent	vec{shell}.foo	/^   min_exponent result (res) ::: pure$/;"	r
r_max	vec{shell}.foo	/^   r_max(cutoff) result (res)$/;"	r
r2_max	vec{shell}.foo	/^   r2_max(cutoff) result (res)$/;"	r
put	vec{shell}.foo	/^   put$/;"	r
saved_self	vec{slaterbasis}.foo	/^   saved_self :: VEC{SLATERBASIS}*, private  DEFAULT_NULL$/;"	g
basis_library_directory	vec{slaterbasis}.foo	/^   basis_library_directory :: STR, private = ".\/basis_sets"$/;"	g
create	vec{slaterbasis}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{slaterbasis}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
create_copy	vec{slaterbasis}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{slaterbasis}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
nullify_ptr_part	vec{slaterbasis}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
destroy_ptr_part	vec{slaterbasis}.foo	/^   destroy_ptr_part ::: get_from(VEC{OBJECT}), leaky$/;"	r
created	vec{slaterbasis}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{slaterbasis}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	vec{slaterbasis}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
set_library_directory	vec{slaterbasis}.foo	/^   set_library_directory(directory) ::: get_from(VEC{BASIS})$/;"	r
library_file	vec{slaterbasis}.foo	/^   library_file(basis_kind) result (res) ::: get_from(VEC{BASIS})$/;"	r
read_list_keywords	vec{slaterbasis}.foo	/^   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky$/;"	r
process_list_keyword	vec{slaterbasis}.foo	/^   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_data	vec{slaterbasis}.foo	/^   read_data(ignore_braces) ::: get_from(VEC{OBJECT}), leaky$/;"	r
data_length	vec{slaterbasis}.foo	/^   data_length result (length) ::: get_from(VEC{OBJECT})$/;"	r
read_altered_data	vec{slaterbasis}.foo	/^   read_altered_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_append_data	vec{slaterbasis}.foo	/^   read_append_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys	vec{slaterbasis}.foo	/^   process_keys ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys_once	vec{slaterbasis}.foo	/^   process_keys_once ::: get_from(VEC{OBJECT})$/;"	r
keys_created	vec{slaterbasis}.foo	/^   keys_created result (res) ::: get_from(VEC{OBJECT})$/;"	r
set_keys	vec{slaterbasis}.foo	/^   set_keys(the_keys) ::: get_from(VEC{OBJECT})$/;"	r
clear_keys	vec{slaterbasis}.foo	/^   clear_keys ::: get_from(VEC{OBJECT})$/;"	r
read_keys	vec{slaterbasis}.foo	/^   read_keys ::: get_from(VEC{OBJECT})$/;"	r
put_keys_table	vec{slaterbasis}.foo	/^   put_keys_table ::: get_from(VEC{OBJECT})$/;"	r
put_table_header	vec{slaterbasis}.foo	/^   put_table_header ::: get_from(VEC{OBJECT})$/;"	r
put_table_footer	vec{slaterbasis}.foo	/^   put_table_footer ::: get_from(VEC{OBJECT})$/;"	r
redirect	vec{slaterbasis}.foo	/^   redirect ::: get_from(OBJECT), leaky$/;"	r
revert	vec{slaterbasis}.foo	/^   revert ::: get_from(OBJECT), leaky$/;"	r
read_keywords	vec{slaterbasis}.foo	/^   read_keywords ::: get_from(VEC{OBJECT}), recursive, leaky$/;"	r
process_keyword	vec{slaterbasis}.foo	/^   process_keyword(keyword) ::: get_from(VEC{BASIS})$/;"	r
read_library_directory	vec{slaterbasis}.foo	/^   read_library_directory ::: get_from(VEC{BASIS})$/;"	r
read_library_data	vec{slaterbasis}.foo	/^   read_library_data(library,labels,n_unique_labels) ::: get_from(VEC{BASIS}), leaky$/;"	r
shrink	vec{slaterbasis}.foo	/^   shrink(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
expand	vec{slaterbasis}.foo	/^   expand(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{slaterbasis}.foo	/^   append(v) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{slaterbasis}.foo	/^   append(value) ::: get_from(VEC{OBJECT}), leaky$/;"	r
unnormalise	vec{slaterbasis}.foo	/^   unnormalise$/;"	r
renormalise	vec{slaterbasis}.foo	/^   renormalise$/;"	r
put	vec{slaterbasis}.foo	/^   put ::: get_from(VEC{OBJECT})$/;"	r
saved_self	vec{slatershell}.foo	/^   saved_self :: VEC{SLATERSHELL}*, private  DEFAULT_NULL$/;"	g
create	vec{slatershell}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{slatershell}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
create_copy	vec{slatershell}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{slatershell}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
nullify_ptr_part	vec{slatershell}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
destroy_ptr_part	vec{slatershell}.foo	/^   destroy_ptr_part ::: get_from(VEC{OBJECT}), leaky$/;"	r
created	vec{slatershell}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{slatershell}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
set_defaults	vec{slatershell}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
set_saved_self	vec{slatershell}.foo	/^   set_saved_self ::: get_from(VEC{OBJECT})$/;"	r
read_list_keywords	vec{slatershell}.foo	/^   read_list_keywords ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_list_keyword	vec{slatershell}.foo	/^   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_data	vec{slatershell}.foo	/^   read_data(ignore_braces) ::: get_from(VEC{OBJECT}), leaky$/;"	r
data_length	vec{slatershell}.foo	/^   data_length result (length) ::: get_from(VEC{OBJECT})$/;"	r
read_altered_data	vec{slatershell}.foo	/^   read_altered_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
read_append_data	vec{slatershell}.foo	/^   read_append_data ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys	vec{slatershell}.foo	/^   process_keys ::: get_from(VEC{OBJECT}), leaky$/;"	r
process_keys_once	vec{slatershell}.foo	/^   process_keys_once ::: get_from(VEC{OBJECT})$/;"	r
keys_created	vec{slatershell}.foo	/^   keys_created result (res) ::: get_from(VEC{OBJECT})$/;"	r
set_keys	vec{slatershell}.foo	/^   set_keys(the_keys) ::: get_from(VEC{OBJECT})$/;"	r
clear_keys	vec{slatershell}.foo	/^   clear_keys ::: get_from(VEC{OBJECT})$/;"	r
read_keys	vec{slatershell}.foo	/^   read_keys ::: get_from(VEC{OBJECT})$/;"	r
put_keys_table	vec{slatershell}.foo	/^   put_keys_table ::: get_from(VEC{OBJECT})$/;"	r
put_table_header	vec{slatershell}.foo	/^   put_table_header ::: get_from(VEC{OBJECT})$/;"	r
put_table_footer	vec{slatershell}.foo	/^   put_table_footer ::: get_from(VEC{OBJECT})$/;"	r
redirect	vec{slatershell}.foo	/^   redirect ::: get_from(OBJECT), leaky$/;"	r
revert	vec{slatershell}.foo	/^   revert ::: get_from(OBJECT), leaky$/;"	r
read_keywords	vec{slatershell}.foo	/^   read_keywords ::: get_from(VEC{OBJECT}), recursive, leaky$/;"	r
process_keyword	vec{slatershell}.foo	/^   process_keyword(keyword)$/;"	r
maximum_l_value	vec{slatershell}.foo	/^   maximum_l_value result (res)$/;"	r
maximum_n_value	vec{slatershell}.foo	/^   maximum_n_value result (res)$/;"	r
min_exponent	vec{slatershell}.foo	/^   min_exponent result (res) ::: pure$/;"	r
same_as	vec{slatershell}.foo	/^   same_as(sh) result(same)$/;"	r
n_shell	vec{slatershell}.foo	/^   n_shell result (res) ::: pure$/;"	r
no_of_shells	vec{slatershell}.foo	/^   no_of_shells result (res) ::: pure$/;"	r
no_of_basis_functions	vec{slatershell}.foo	/^   no_of_basis_functions result (res) ::: pure$/;"	r
no_of_primitives	vec{slatershell}.foo	/^   no_of_primitives result (res) ::: pure$/;"	r
shrink	vec{slatershell}.foo	/^   shrink(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
expand	vec{slatershell}.foo	/^   expand(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{slatershell}.foo	/^   append(v) ::: get_from(VEC{OBJECT}), leaky$/;"	r
append	vec{slatershell}.foo	/^   append(value) ::: get_from(VEC{OBJECT}), leaky$/;"	r
density_at_radius	vec{slatershell}.foo	/^   density_at_radius(R) result (res)$/;"	r
densities_at_radii	vec{slatershell}.foo	/^   densities_at_radii(R) result (res)$/;"	r
density_value_at_radius	vec{slatershell}.foo	/^   density_value_at_radius(R) result (res) ::: selfless, public$/;"	r
density_value_at_sqrt_radius2	vec{slatershell}.foo	/^   density_value_at_sqrt_radius2(R2) result (res) ::: selfless, public$/;"	r
density_d1_value_at_radius	vec{slatershell}.foo	/^   density_d1_value_at_radius(R) result (res) ::: selfless, public$/;"	r
density_d2_value_at_radius	vec{slatershell}.foo	/^   density_d2_value_at_radius(R) result (res) ::: selfless, public$/;"	r
unnormalise	vec{slatershell}.foo	/^   unnormalise$/;"	r
renormalise	vec{slatershell}.foo	/^   renormalise$/;"	r
put	vec{slatershell}.foo	/^   put ::: get_from(VEC{OBJECT})$/;"	r
put_table	vec{slatershell}.foo	/^   put_table ::: get_from(VEC{OBJECT})$/;"	r
create	vec{str}.foo	/^   create(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create	vec{str}.foo	/^   create(lb,ub) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create	vec{str}.foo	/^   create(bounds) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
destroy	vec{str}.foo	/^   destroy ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
create_copy	vec{str}.foo	/^   create_copy(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
copy	vec{str}.foo	/^   copy(v) ::: get_from(VEC{INTRINSIC})$/;"	r
created	vec{str}.foo	/^   created result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
destroyed	vec{str}.foo	/^   destroyed result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
size	vec{str}.foo	/^   size result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
dim	vec{str}.foo	/^   dim result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo$/;"	r
shrink	vec{str}.foo	/^   shrink(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
expand	vec{str}.foo	/^   expand(dim) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append	vec{str}.foo	/^   append(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append	vec{str}.foo	/^   append(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
append_only_if_unique	vec{str}.foo	/^   append_only_if_unique(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prepend	vec{str}.foo	/^   prepend(v) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prepend	vec{str}.foo	/^   prepend(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
join	vec{str}.foo	/^   join(v) result (res) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
join	vec{str}.foo	/^   join(v1,v2) result (res) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prune	vec{str}.foo	/^   prune(values) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
prune	vec{str}.foo	/^   prune(value) ::: get_from(VEC{INTRINSIC}), leaky$/;"	r
equals	vec{str}.foo	/^   equals(v) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
same_as	vec{str}.foo	/^   same_as(v) result (res) ::: get_from(VEC{INTRINSIC})$/;"	r
remove_repetitions	vec{str}.foo	/^   remove_repetitions ::: get_from(VEC{OBJECT}), leaky$/;"	r
has_repetitions	vec{str}.foo	/^   has_repetitions result (res) ::: get_from(VEC{OBJECT})$/;"	r
no_of_unique_elements	vec{str}.foo	/^   no_of_unique_elements result (res) ::: get_from(VEC{OBJECT}), pure$/;"	r
sort	vec{str}.foo	/^   sort(decreasing_order) ::: get_from(VEC{OBJECT})$/;"	r
quick_sort	vec{str}.foo	/^   quick_sort(decreasing_order) ::: get_from(VEC{OBJECT})$/;"	r
quick_sort_increasing	vec{str}.foo	/^   quick_sort_increasing ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
quick_sort_decreasing	vec{str}.foo	/^   quick_sort_decreasing ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
quick_sort	vec{str}.foo	/^   quick_sort(indices,decreasing_order) ::: get_from(VEC{OBJECT})$/;"	r
quick_sort_increasing	vec{str}.foo	/^   quick_sort_increasing(indices) ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
quick_sort_decreasing	vec{str}.foo	/^   quick_sort_decreasing(indices) ::: get_from(VEC{OBJECT}), recursive, private$/;"	r
reverse_order	vec{str}.foo	/^   reverse_order ::: get_from(VEC{INTRINSIC})$/;"	r
swap_elements	vec{str}.foo	/^   swap_elements(e1,e2) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
has_any_included_in	vec{str}.foo	/^   has_any_included_in(string,at_start) result (res)$/;"	r
index_of_first_included_in	vec{str}.foo	/^   index_of_first_included_in(string) result (res)$/;"	r
has_any_including	vec{str}.foo	/^   has_any_including(string) result (res)$/;"	r
includes	vec{str}.foo	/^   includes(string,at_start) result (res)$/;"	r
index_of_first_that_includes	vec{str}.foo	/^   index_of_first_that_includes(string) result (res)$/;"	r
index_of	vec{str}.foo	/^   index_of(string) result (res)$/;"	r
index_of_matching_bracket	vec{str}.foo	/^   index_of_matching_bracket(symbol) result (res)$/;"	r
str_lengths	vec{str}.foo	/^   str_lengths(spaces) result (res) ::: pure$/;"	r
str_length	vec{str}.foo	/^   str_length(spaces) result (res) ::: get_from(VEC{INTRINSIC}), pure$/;"	r
to_lower_case	vec{str}.foo	/^   to_lower_case$/;"	r
to_upper_case	vec{str}.foo	/^   to_upper_case$/;"	r
replace_all	vec{str}.foo	/^   replace_all(a,b)$/;"	r
remove_blanks	vec{str}.foo	/^   remove_blanks$/;"	r
pad_with	vec{str}.foo	/^   pad_with(symbol,width,prepad)$/;"	r
create	vec{table_column}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{table_column}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
nullify_ptr_part	vec{table_column}.foo	/^   nullify_ptr_part ::: get_from(VEC{OBJECT})$/;"	r
destroy_ptr_part	vec{table_column}.foo	/^   destroy_ptr_part ::: get_from(VEC{OBJECT}), leaky$/;"	r
created	vec{table_column}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{table_column}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{table_column}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{table_column}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
set_defaults	vec{table_column}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
clear_columns	vec{table_column}.foo	/^   clear_columns$/;"	r
no_of_rows	vec{table_column}.foo	/^   no_of_rows result (res)$/;"	r
check_no_of_rows	vec{table_column}.foo	/^   check_no_of_rows ::: private$/;"	r
dash_width	vec{table_column}.foo	/^   dash_width(label_rows) result (res) ::: private$/;"	r
put	vec{table_column}.foo	/^   put(label_rows)$/;"	r
put_headings	vec{table_column}.foo	/^   put_headings(label_rows)$/;"	r
put_body	vec{table_column}.foo	/^   put_body(label_rows)$/;"	r
put_footer	vec{table_column}.foo	/^   put_footer(label_rows)$/;"	r
put_dash	vec{table_column}.foo	/^   put_dash(label_rows,symbol)$/;"	r
create	vec{unit_cell}.foo	/^   create(dim) ::: get_from(VEC{OBJECT}), leaky$/;"	r
destroy	vec{unit_cell}.foo	/^   destroy ::: get_from(VEC{OBJECT}), leaky$/;"	r
create_copy	vec{unit_cell}.foo	/^   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
copy	vec{unit_cell}.foo	/^   copy(vec) ::: get_from(VEC{OBJECT}), leaky$/;"	r
created	vec{unit_cell}.foo	/^   created result (res) ::: inlined_by_foo$/;"	r
destroyed	vec{unit_cell}.foo	/^   destroyed result (res) ::: inlined_by_foo$/;"	r
set_defaults	vec{unit_cell}.foo	/^   set_defaults ::: get_from(VEC{OBJECT})$/;"	r
create	vec{vec_{bin}}.foo	/^   create(dim) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create	vec{vec_{bin}}.foo	/^   create(dim,dimv) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create	vec{vec_{bin}}.foo	/^   create(dim,bounds) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	vec{vec_{bin}}.foo	/^   create_vec(dimv) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	vec{vec_{bin}}.foo	/^   create_vec(bounds) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
destroy	vec{vec_{bin}}.foo	/^   destroy ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	vec{vec_{bin}}.foo	/^   nullify_ptr_part ::: get_from(VEC{VEC_{INTRINSIC}})$/;"	r
destroy_ptr_part	vec{vec_{bin}}.foo	/^   destroy_ptr_part ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
created	vec{vec_{bin}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{vec_{bin}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{vec_{bin}}.foo	/^   create_copy(vec) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
max_element_dim	vec{vec_{bin}}.foo	/^   max_element_dim result (res) ::: get_from(VEC{VEC_{INTRINSIC}})$/;"	r
copy	vec{vec_{bin}}.foo	/^   copy(v) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
shrink	vec{vec_{bin}}.foo	/^   shrink(dim) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
expand	vec{vec_{bin}}.foo	/^   expand(dim) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
append	vec{vec_{bin}}.foo	/^   append(v) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
append	vec{vec_{bin}}.foo	/^   append(value) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
join	vec{vec_{bin}}.foo	/^   join(list) result (res) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create	vec{vec_{int}}.foo	/^   create(dim) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create	vec{vec_{int}}.foo	/^   create(dim,dimv) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create	vec{vec_{int}}.foo	/^   create(dim,bounds) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	vec{vec_{int}}.foo	/^   create_vec(dimv) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	vec{vec_{int}}.foo	/^   create_vec(bounds) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
destroy	vec{vec_{int}}.foo	/^   destroy ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	vec{vec_{int}}.foo	/^   nullify_ptr_part ::: get_from(VEC{VEC_{INTRINSIC}})$/;"	r
destroy_ptr_part	vec{vec_{int}}.foo	/^   destroy_ptr_part ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
created	vec{vec_{int}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{vec_{int}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{vec_{int}}.foo	/^   create_copy(vec) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
max_element_dim	vec{vec_{int}}.foo	/^   max_element_dim result (res) ::: get_from(VEC{VEC_{INTRINSIC}})$/;"	r
copy	vec{vec_{int}}.foo	/^   copy(v) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
shrink	vec{vec_{int}}.foo	/^   shrink(dim) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
expand	vec{vec_{int}}.foo	/^   expand(dim) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
append	vec{vec_{int}}.foo	/^   append(v) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
append	vec{vec_{int}}.foo	/^   append(value) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
join	vec{vec_{int}}.foo	/^   join(list) result (res) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
repetitions_in	vec{vec_{int}}.foo	/^   repetitions_in(list) ::: leaky$/;"	r
repetitions_in	vec{vec_{int}}.foo	/^   repetitions_in(list,unique) ::: leaky$/;"	r
item_str_length	vec{vec_{int}}.foo	/^   item_str_length(spaces) result (res)$/;"	r
list_str_length	vec{vec_{int}}.foo	/^   list_str_length(spaces) result (res)$/;"	r
create	vec{vec_{intrinsic}}.foo	/^   create(dim) ::: leaky$/;"	r
create	vec{vec_{intrinsic}}.foo	/^   create(dim,dimv) ::: leaky$/;"	r
create	vec{vec_{intrinsic}}.foo	/^   create(dim,bounds) ::: leaky$/;"	r
create_vec	vec{vec_{intrinsic}}.foo	/^   create_vec(dimv) ::: leaky$/;"	r
create_vec	vec{vec_{intrinsic}}.foo	/^   create_vec(bounds) ::: leaky$/;"	r
create_copy	vec{vec_{intrinsic}}.foo	/^   create_copy(vec) ::: leaky$/;"	r
nullify_ptr_part	vec{vec_{intrinsic}}.foo	/^   nullify_ptr_part$/;"	r
destroy	vec{vec_{intrinsic}}.foo	/^   destroy ::: leaky$/;"	r
destroy_ptr_part	vec{vec_{intrinsic}}.foo	/^   destroy_ptr_part ::: leaky$/;"	r
max_element_dim	vec{vec_{intrinsic}}.foo	/^   max_element_dim result (res)$/;"	r
copy	vec{vec_{intrinsic}}.foo	/^   copy(v) ::: leaky$/;"	r
shrink	vec{vec_{intrinsic}}.foo	/^   shrink(dim) ::: leaky$/;"	r
expand	vec{vec_{intrinsic}}.foo	/^   expand(dim) ::: leaky$/;"	r
append	vec{vec_{intrinsic}}.foo	/^   append(v) ::: leaky$/;"	r
append	vec{vec_{intrinsic}}.foo	/^   append(value) ::: leaky$/;"	r
join	vec{vec_{intrinsic}}.foo	/^   join(list) result (res) ::: leaky$/;"	r
create	vec{vec_{real}}.foo	/^   create(dim) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create	vec{vec_{real}}.foo	/^   create(dim,dimv) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create	vec{vec_{real}}.foo	/^   create(dim,bounds) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	vec{vec_{real}}.foo	/^   create_vec(dimv) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
create_vec	vec{vec_{real}}.foo	/^   create_vec(bounds) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
destroy	vec{vec_{real}}.foo	/^   destroy ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	vec{vec_{real}}.foo	/^   nullify_ptr_part ::: get_from(VEC{VEC_{INTRINSIC}})$/;"	r
destroy_ptr_part	vec{vec_{real}}.foo	/^   destroy_ptr_part ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
created	vec{vec_{real}}.foo	/^   created result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
destroyed	vec{vec_{real}}.foo	/^   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo$/;"	r
create_copy	vec{vec_{real}}.foo	/^   create_copy(vec) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
max_element_dim	vec{vec_{real}}.foo	/^   max_element_dim result (res) ::: get_from(VEC{VEC_{INTRINSIC}})$/;"	r
copy	vec{vec_{real}}.foo	/^   copy(v) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
shrink	vec{vec_{real}}.foo	/^   shrink(dim) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
expand	vec{vec_{real}}.foo	/^   expand(dim) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
append	vec{vec_{real}}.foo	/^   append(v) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
append	vec{vec_{real}}.foo	/^   append(value) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
join	vec{vec_{real}}.foo	/^   join(list) result (res) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
make_R_multipoles	vec{vec_{real}}.foo	/^   make_R_multipoles(qc,qs,charges,points,l_max) ::: selfless, leaky$/;"	r
unflatten	vec{vec_{real}}.foo	/^   unflatten(vec_mat)$/;"	r
vec_mat	vec{vec_{real}}.foo	/^     vec_mat :: VEC{MAT_{REAL}}*$/;"	a
counter	vec{vec_{real}}.foo	/^     counter :: INT$/;"	a
schmidt_orthonormalise	vec{vec_{real}}.foo	/^   schmidt_orthonormalise(S,scales,n_dependent)$/;"	r
scales	vec{vec_{real}}.foo	/^     scales :: VEC{REAL}, OUT$/;"	a
n_dependent	vec{vec_{real}}.foo	/^     n_dependent :: INT, OUT$/;"	a
keep	vec{vec_{real}}.foo	/^     keep :: VEC{REAL}*$/;"	a
skip	vec{vec_{real}}.foo	/^     skip :: VEC{BIN}*$/;"	a
fac	vec{vec_{real}}.foo	/^     fac :: REAL$/;"	a
tol	vec{vec_{real}}.foo	/^     tol :: REAL$/;"	a
norm	vec{vec_{real}}.foo	/^     norm :: REAL$/;"	a
create	vec{vec_{vec_{int}}}.foo	/^   create(dim) ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}})$/;"	r
create	vec{vec_{vec_{int}}}.foo	/^   create(dim,dimv) ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}}), leaky$/;"	r
create_vec	vec{vec_{vec_{int}}}.foo	/^   create_vec(dimv) ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}}), leaky$/;"	r
destroy	vec{vec_{vec_{int}}}.foo	/^   destroy ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}})$/;"	r
nullify_ptr_part	vec{vec_{vec_{int}}}.foo	/^   nullify_ptr_part ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}})$/;"	r
destroy_ptr_part	vec{vec_{vec_{int}}}.foo	/^   destroy_ptr_part ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}})$/;"	r
create_copy	vec{vec_{vec_{int}}}.foo	/^   create_copy(vec) ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}}), leaky$/;"	r
max_element_dim	vec{vec_{vec_{int}}}.foo	/^   max_element_dim result (res) ::: get_from(VEC{VEC_{INTRINSIC}})$/;"	r
copy	vec{vec_{vec_{int}}}.foo	/^   copy(v) ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}}), leaky$/;"	r
created	vec{vec_{vec_{int}}}.foo	/^   created result (res) ::: get_from(VEC{OBJECT}), inlined_by_foo$/;"	r
destroyed	vec{vec_{vec_{int}}}.foo	/^   destroyed result (res) ::: get_from(VEC{OBJECT}), inlined_by_foo$/;"	r
create	vec{vec_{vec_{intrinsic}}}.foo	/^   create(dim) ::: leaky$/;"	r
create	vec{vec_{vec_{intrinsic}}}.foo	/^   create(dim,dimv) ::: leaky$/;"	r
create_vec	vec{vec_{vec_{intrinsic}}}.foo	/^   create_vec(dimv) ::: leaky$/;"	r
nullify_ptr_part	vec{vec_{vec_{intrinsic}}}.foo	/^   nullify_ptr_part$/;"	r
destroy	vec{vec_{vec_{intrinsic}}}.foo	/^   destroy ::: leaky$/;"	r
destroy_ptr_part	vec{vec_{vec_{intrinsic}}}.foo	/^   destroy_ptr_part$/;"	r
create_copy	vec{vec_{vec_{intrinsic}}}.foo	/^   create_copy(vec) ::: leaky$/;"	r
copy	vec{vec_{vec_{intrinsic}}}.foo	/^   copy(v) ::: leaky$/;"	r
create	vec{vec_{vec_{real}}}.foo	/^   create(dim) ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
destroy	vec{vec_{vec_{real}}}.foo	/^   destroy ::: get_from(VEC{VEC_{INTRINSIC}}), leaky$/;"	r
nullify_ptr_part	vec{vec_{vec_{real}}}.foo	/^   nullify_ptr_part ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}})$/;"	r
destroy_ptr_part	vec{vec_{vec_{real}}}.foo	/^   destroy_ptr_part ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}})$/;"	r
create_copy	vec{vec_{vec_{real}}}.foo	/^   create_copy(vec) ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}}), leaky$/;"	r
max_element_dim	vec{vec_{vec_{real}}}.foo	/^   max_element_dim result (res) ::: get_from(VEC{VEC_{INTRINSIC}})$/;"	r
copy	vec{vec_{vec_{real}}}.foo	/^   copy(v) ::: get_from(VEC{VEC_{VEC_{INTRINSIC}}}), leaky$/;"	r
created	vec{vec_{vec_{real}}}.foo	/^   created result (res) ::: get_from(VEC{OBJECT}), inlined_by_foo$/;"	r
destroyed	vec{vec_{vec_{real}}}.foo	/^   destroyed result (res) ::: get_from(VEC{OBJECT}), inlined_by_foo$/;"	r
CHR_KIND	macros	/^# define CHR_KIND      1$/;"	m
INT_KIND	macros	/^# define INT_KIND      4$/;"	m
INT_1_KIND	macros	/^# define INT_1_KIND    1$/;"	m
INT_2_KIND	macros	/^# define INT_2_KIND    2$/;"	m
INT_4_KIND	macros	/^# define INT_4_KIND    4$/;"	m
INT_8_KIND	macros	/^# define INT_8_KIND    8$/;"	m
BIN_KIND	macros	/^# define BIN_KIND      4$/;"	m
BIN_1_KIND	macros	/^# define BIN_1_KIND    1$/;"	m
BIN_4_KIND	macros	/^# define BIN_4_KIND    4$/;"	m
REAL_KIND	macros	/^# define REAL_KIND     8$/;"	m
REAL_4_KIND	macros	/^# define REAL_4_KIND   4$/;"	m
REAL_8_KIND	macros	/^# define REAL_8_KIND   8$/;"	m
REAL_16_KIND	macros	/^# define REAL_16_KIND  16$/;"	m
CPX_KIND	macros	/^# define CPX_KIND      8$/;"	m
CPX_4_KIND	macros	/^# define CPX_4_KIND    4$/;"	m
CPX_8_KIND	macros	/^# define CPX_8_KIND    8$/;"	m
CPX_16_KIND	macros	/^# define CPX_16_KIND   16$/;"	m
CHR_SIZE	macros	/^# define CHR_SIZE      1$/;"	m
STR_SIZE	macros	/^# define STR_SIZE    512$/;"	m
BSTR_SIZE	macros	/^# define BSTR_SIZE   8192$/;"	m
INT_SIZE	macros	/^# define INT_SIZE      4$/;"	m
INT_1_SIZE	macros	/^# define INT_1_SIZE    1$/;"	m
INT_2_SIZE	macros	/^# define INT_2_SIZE    2$/;"	m
INT_4_SIZE	macros	/^# define INT_4_SIZE    4$/;"	m
INT_8_SIZE	macros	/^# define INT_8_SIZE    8$/;"	m
BIN_SIZE	macros	/^# define BIN_SIZE      4$/;"	m
BIN_1_SIZE	macros	/^# define BIN_1_SIZE    1$/;"	m
BIN_4_SIZE	macros	/^# define BIN_4_SIZE    4$/;"	m
PTR_SIZE	macros	/^# define PTR_SIZE      8$/;"	m
REAL_SIZE	macros	/^# define REAL_SIZE     8$/;"	m
REAL_4_SIZE	macros	/^# define REAL_4_SIZE   4$/;"	m
REAL_8_SIZE	macros	/^# define REAL_8_SIZE   8$/;"	m
REAL_16_SIZE	macros	/^# define REAL_16_SIZE  16$/;"	m
CPX_SIZE	macros	/^# define CPX_SIZE      16$/;"	m
CPX_4_SIZE	macros	/^# define CPX_4_SIZE    8$/;"	m
CPX_8_SIZE	macros	/^# define CPX_8_SIZE    16$/;"	m
CPX_16_SIZE	macros	/^# define CPX_16_SIZE   32$/;"	m
INT	macros	/^# define INT        integer(INT_KIND)$/;"	m
INT_1	macros	/^# define INT_1      integer(INT_1_KIND)$/;"	m
INT_2	macros	/^# define INT_2      integer(INT_2_KIND)$/;"	m
INT_4	macros	/^# define INT_4      integer(INT_4_KIND)$/;"	m
INT_8	macros	/^# define INT_8      integer(INT_8_KIND)$/;"	m
BIN	macros	/^# define BIN        logical(BIN_KIND)$/;"	m
BIN_1	macros	/^# define BIN_1      logical(BIN_1_KIND)$/;"	m
BIN_4	macros	/^# define BIN_4      logical(BIN_4_KIND)$/;"	m
REAL	macros	/^# define REAL       real(REAL_KIND)$/;"	m
REAL_4	macros	/^# define REAL_4     real(REAL_4_KIND)$/;"	m
REAL_8	macros	/^# define REAL_8     real(REAL_8_KIND)$/;"	m
REAL_16	macros	/^# define REAL_16    real(REAL_16_KIND)$/;"	m
CPX	macros	/^# define CPX        complex(CPX_KIND)$/;"	m
CPX_4	macros	/^# define CPX_4      complex(CPX_4_KIND)$/;"	m
CPX_8	macros	/^# define CPX_8      complex(CPX_8_KIND)$/;"	m
CPX_16	macros	/^# define CPX_16     complex(CPX_16_KIND)$/;"	m
CHR	macros	/^# define CHR        character$/;"	m
STR	macros	/^# define STR(X)                     character(X)$/;"	m
BSTR	macros	/^# define BSTR(X)                    character(X)$/;"	m
VEC	macros	/^# define VEC(X,A)                   X, dimension(A)$/;"	m
MAT	macros	/^# define MAT(X,A,B)                 X, dimension(A,B)$/;"	m
MAT3	macros	/^# define MAT3(X,A,B,C)              X, dimension(A,B,C)$/;"	m
MAT4	macros	/^# define MAT4(X,A,B,C,D)            X, dimension(A,B,C,D)$/;"	m
MAT5	macros	/^# define MAT5(X,A,B,C,D,E)          X, dimension(A,B,C,D,E)$/;"	m
MAT6	macros	/^# define MAT6(X,A,B,C,D,E,F)        X, dimension(A,B,C,D,E,F)$/;"	m
MAT7	macros	/^# define MAT7(X,A,B,C,D,E,F,G)      X, dimension(A,B,C,D,E,F,G)$/;"	m
ADDRESS_OF	macros	/^#    define ADDRESS_OF(X)             ,loc(X)$/;"	m
ADDRESS_OF	macros	/^#    define ADDRESS_OF(X)             ,loc(X)$/;"	m
ADDRESS_OF	macros	/^#    define ADDRESS_OF(X)             ,loc(X)$/;"	m
ADDRESS_OF	macros	/^#    define ADDRESS_OF(X)             ,pointer(X)$/;"	m
ADDRESS_OF	macros	/^#    define ADDRESS_OF(X)             $/;"	m
DIE0	macros	/^#    define DIE0(X)                   print *,X; stop$/;"	m
DIE_IF0	macros	/^#    define DIE_IF0(X,Y)              if (X) then; print *,Y; stop; end if$/;"	m
WARN0	macros	/^#    define WARN0(X)                  print *,X$/;"	m
WARN_IF0	macros	/^#    define WARN_IF0(X,Y)             if (X) print *,Y$/;"	m
ENSURE0	macros	/^#    define ENSURE0(X,Y)              if (.not. (X)) then; print *,Y; stop; end if$/;"	m
STACK0	macros	/^#    define STACK0(X)                 ! Starting routine X$/;"	m
UNSTACK0	macros	/^#    define UNSTACK0(X)               ! Ending routine ...$/;"	m
CHECK0	macros	/^#    define CHECK0(X)                 ! Normally check for memory leaks here ...$/;"	m
ADD_LOCATION0	macros	/^#    define ADD_LOCATION0(X,Y)        ! Keep track of memory location$/;"	m
ADD_MEMORY0	macros	/^#    define ADD_MEMORY0(X)            ! Keep track of memory location$/;"	m
DELETE_MEMORY0	macros	/^#    define DELETE_MEMORY0(X)         ! Keep track of memory location$/;"	m
IGNORE_MEMORY_LEAK0	macros	/^#    define IGNORE_MEMORY_LEAK0(X)    ! An intentional memory leak occurs in this routine ...$/;"	m
START_TIMER0	macros	/^#    define START_TIMER0(X)           ! Start routine timer ...$/;"	m
STOP_TIMER0	macros	/^#    define STOP_TIMER0               ! Stop routine timer ...$/;"	m
TONTO_FLUSH_BUFFER0	macros	/^#    define TONTO_FLUSH_BUFFER0(X)    ! Normally, flush output buffer$/;"	m
TONTO_CREATE0	macros	/^#    define TONTO_CREATE0             ! Normally, create tonto defaults (memory, parallel, etc ...)$/;"	m
TONTO_DESTROY0	macros	/^#    define TONTO_DESTROY0            ! Normally, destroy tonto object$/;"	m
TONTO_REPORT0	macros	/^#    define TONTO_REPORT0             ! Normally, produce a tonto report$/;"	m
TONTO_SET_STDERR0	macros	/^#    define TONTO_SET_STDERR0(X)      ! Normally, set the tonto error outpurt file$/;"	m
DIE0	macros	/^#    define DIE0(X)                   call SYSTEM_die(tonto,X)$/;"	m
DIE_IF0	macros	/^#    define DIE_IF0(X,Y)              call SYSTEM_die_if(tonto,X,Y)$/;"	m
WARN0	macros	/^#    define WARN0(X)                  call SYSTEM_warn(tonto,X)$/;"	m
WARN_IF0	macros	/^#    define WARN_IF0(X,Y)             call SYSTEM_warn_if(tonto,X,Y)$/;"	m
ENSURE0	macros	/^#    define ENSURE0(X,Y)              call SYSTEM_ensure(tonto,X,Y)$/;"	m
STACK0	macros	/^#    define STACK0(X)                 call SYSTEM_stack(tonto,X)$/;"	m
UNSTACK0	macros	/^#    define UNSTACK0(X)               call SYSTEM_unstack(tonto,X)$/;"	m
CHECK0	macros	/^#    define CHECK0(X)                 call SYSTEM_check(tonto,X)$/;"	m
ADD_LOCATION0	macros	/^#    define ADD_LOCATION0(X,Y)        call SYSTEM_add_memory(tonto,X ADDRESS_OF(Y))$/;"	m
ADD_MEMORY0	macros	/^#    define ADD_MEMORY0(X)            call SYSTEM_add_memory(tonto,X ADDRESS_OF(self))$/;"	m
DELETE_MEMORY0	macros	/^#    define DELETE_MEMORY0(X)         call SYSTEM_delete_memory(tonto,X ADDRESS_OF(self))$/;"	m
IGNORE_MEMORY_LEAK0	macros	/^#    define IGNORE_MEMORY_LEAK0(X)    call SYSTEM_ignore_memory_leak(tonto,X)$/;"	m
START_TIMER0	macros	/^#    define START_TIMER0(X)           call SYSTEM_start_timer(tonto,X)$/;"	m
STOP_TIMER0	macros	/^#    define STOP_TIMER0               call SYSTEM_stop_timer(tonto)$/;"	m
TONTO_FLUSH_BUFFER0	macros	/^#    define TONTO_FLUSH_BUFFER0(X)    call SYSTEM_flush_buffer(tonto,X)$/;"	m
TONTO_CREATE0	macros	/^#    define TONTO_CREATE0             call SYSTEM_create(tonto)$/;"	m
TONTO_DESTROY0	macros	/^#    define TONTO_DESTROY0            call SYSTEM_destroy(tonto)$/;"	m
TONTO_REPORT0	macros	/^#    define TONTO_REPORT0             call SYSTEM_report(tonto)$/;"	m
TONTO_SET_STDERR0	macros	/^#    define TONTO_SET_STDERR0(X)      call SYSTEM_set_error_output_file(tonto,X)$/;"	m
DIE0	macros	/^#    define DIE0(X)                   call die_(tonto,X)$/;"	m
DIE_IF0	macros	/^#    define DIE_IF0(X,Y)              call die_if_(tonto,X,Y)$/;"	m
WARN0	macros	/^#    define WARN0(X)                  call warn_(tonto,X)$/;"	m
WARN_IF0	macros	/^#    define WARN_IF0(X,Y)             call warn_if_(tonto,X,Y)$/;"	m
ENSURE0	macros	/^#    define ENSURE0(X,Y)              call ensure_(tonto,X,Y)$/;"	m
STACK0	macros	/^#    define STACK0(X)                 call stack_(tonto,X)$/;"	m
UNSTACK0	macros	/^#    define UNSTACK0(X)               call unstack_(tonto,X)$/;"	m
CHECK0	macros	/^#    define CHECK0(X)                 call check_(tonto,X)$/;"	m
ADD_LOCATION0	macros	/^#    define ADD_LOCATION0(X,Y)        call add_memory_(tonto,X ADDRESS_OF(Y))$/;"	m
ADD_MEMORY0	macros	/^#    define ADD_MEMORY0(X)            call add_memory_(tonto,X ADDRESS_OF(self))$/;"	m
DELETE_MEMORY0	macros	/^#    define DELETE_MEMORY0(X)         call delete_memory_(tonto,X ADDRESS_OF(self))$/;"	m
IGNORE_MEMORY_LEAK0	macros	/^#    define IGNORE_MEMORY_LEAK0(X)    call ignore_memory_leak_(tonto,X)$/;"	m
START_TIMER0	macros	/^#    define START_TIMER0(X)           call start_timer_(tonto,X)$/;"	m
STOP_TIMER0	macros	/^#    define STOP_TIMER0               call stop_timer_(tonto)$/;"	m
TONTO_FLUSH_BUFFER0	macros	/^#    define TONTO_FLUSH_BUFFER0(X)    call flush_buffer_(tonto,X)$/;"	m
TONTO_CREATE0	macros	/^#    define TONTO_CREATE0             call create_(tonto)$/;"	m
TONTO_DESTROY0	macros	/^#    define TONTO_DESTROY0            call destroy_(tonto)$/;"	m
TONTO_REPORT0	macros	/^#    define TONTO_REPORT0             call report_(tonto)$/;"	m
TONTO_SET_STDERR0	macros	/^#    define TONTO_SET_STDERR0(X)      call set_error_output_file_(tonto,X)$/;"	m
TONTO_FLUSH_BUFFER	macros	/^# define TONTO_FLUSH_BUFFER(X)        TONTO_FLUSH_BUFFER0(X)$/;"	m
TONTO_CREATE	macros	/^# define TONTO_CREATE                 TONTO_CREATE0    $/;"	m
TONTO_DESTROY	macros	/^# define TONTO_DESTROY                TONTO_DESTROY0 $/;"	m
TONTO_REPORT	macros	/^# define TONTO_REPORT                 TONTO_REPORT0$/;"	m
TONTO_SET_STDERR	macros	/^# define TONTO_SET_STDERR(X)          TONTO_SET_STDERR0(X)$/;"	m
PARALLEL_DO_START0	macros	/^#    define PARALLEL_DO_START0(X,Y)   X$/;"	m
PARALLEL_DO_STRIDE0	macros	/^#    define PARALLEL_DO_STRIDE0(X)    X$/;"	m
LOCK_PARALLEL_DO0	macros	/^#    define LOCK_PARALLEL_DO0(X)      ! Normally this is a parallel do loop ...$/;"	m
UNLOCK_PARALLEL_DO0	macros	/^#    define UNLOCK_PARALLEL_DO0(X)    ! End parallel do loop ...$/;"	m
IO_IS_ALLOWED0	macros	/^#    define IO_IS_ALLOWED0            TRUE$/;"	m
DO_IN_PARALLEL0	macros	/^#    define DO_IN_PARALLEL0           FALSE$/;"	m
PARALLEL_SUM0	macros	/^#    define PARALLEL_SUM0(X)        $/;"	m
PARALLEL_VECTOR_SUM0	macros	/^#    define PARALLEL_VECTOR_SUM0(X,Y)        $/;"	m
PARALLEL_SYMMETRIC_SUM0	macros	/^#    define PARALLEL_SYMMETRIC_SUM0(X)        $/;"	m
PARALLEL_BROADCAST0	macros	/^#    define PARALLEL_BROADCAST0(X,Y)$/;"	m
PARALLEL_DO_START0	macros	/^#    define PARALLEL_DO_START0(X,Y)   call SYSTEM_parallel_do_start(tonto,X,Y)$/;"	m
PARALLEL_DO_STRIDE0	macros	/^#    define PARALLEL_DO_STRIDE0(X)    call SYSTEM_parallel_do_stride(tonto,X)$/;"	m
LOCK_PARALLEL_DO0	macros	/^#    define LOCK_PARALLEL_DO0(X)      call SYSTEM_lock_parallel_do(tonto,X)$/;"	m
UNLOCK_PARALLEL_DO0	macros	/^#    define UNLOCK_PARALLEL_DO0(X)    call SYSTEM_unlock_parallel_do(tonto,X)$/;"	m
IO_IS_ALLOWED0	macros	/^#    define IO_IS_ALLOWED0            SYSTEM_IO_is_allowed(tonto)$/;"	m
DO_IN_PARALLEL0	macros	/^#    define DO_IN_PARALLEL0           SYSTEM_do_in_parallel(tonto)$/;"	m
PARALLEL_SUM0	macros	/^#    define PARALLEL_SUM0(X)           if (DO_IN_PARALLEL0) call SYSTEM_parallel_sum(tonto,X)$/;"	m
PARALLEL_VECTOR_SUM0	macros	/^#    define PARALLEL_VECTOR_SUM0(X,Y)  if (DO_IN_PARALLEL0) call SYSTEM_parallel_vector_sum(tonto,X,Y)$/;"	m
PARALLEL_SYMMETRIC_SUM0	macros	/^#    define PARALLEL_SYMMETRIC_SUM0(X) if (DO_IN_PARALLEL0) call SYSTEM_parallel_symmetric_sum(tonto,X)$/;"	m
PARALLEL_BROADCAST0	macros	/^#    define PARALLEL_BROADCAST0(X,Y)   if (DO_IN_PARALLEL0) call SYSTEM_broadcast(tonto,X,Y)$/;"	m
PARALLEL_DO_START0	macros	/^#    define PARALLEL_DO_START0(X,Y)   parallel_do_start_(tonto,X,Y)$/;"	m
PARALLEL_DO_STRIDE0	macros	/^#    define PARALLEL_DO_STRIDE0(X)    parallel_do_stride_(tonto,X)$/;"	m
LOCK_PARALLEL_DO0	macros	/^#    define LOCK_PARALLEL_DO0(X)      call lock_parallel_do_(tonto,X)$/;"	m
UNLOCK_PARALLEL_DO0	macros	/^#    define UNLOCK_PARALLEL_DO0(X)    call unlock_parallel_do_(tonto,X)$/;"	m
IO_IS_ALLOWED0	macros	/^#    define IO_IS_ALLOWED0            IO_is_allowed_(tonto)$/;"	m
DO_IN_PARALLEL0	macros	/^#    define DO_IN_PARALLEL0           do_in_parallel_(tonto)$/;"	m
PARALLEL_SUM0	macros	/^#    define PARALLEL_SUM0(X)           if (DO_IN_PARALLEL0) call parallel_sum_(tonto,X)$/;"	m
PARALLEL_VECTOR_SUM0	macros	/^#    define PARALLEL_VECTOR_SUM0(X,Y)  if (DO_IN_PARALLEL0) call parallel_vector_sum_(tonto,X,Y)$/;"	m
PARALLEL_SYMMETRIC_SUM0	macros	/^#    define PARALLEL_SYMMETRIC_SUM0(X) if (DO_IN_PARALLEL0) call parallel_symmetric_sum_(tonto,X)$/;"	m
PARALLEL_BROADCAST0	macros	/^#    define PARALLEL_BROADCAST0(X,Y)   if (DO_IN_PARALLEL0) call broadcast_(tonto,X,Y)$/;"	m
PARALLEL_DO_START	macros	/^#    define PARALLEL_DO_START(X,Y)    PARALLEL_DO_START0(X,Y)$/;"	m
PARALLEL_DO_STRIDE	macros	/^#    define PARALLEL_DO_STRIDE(X)     PARALLEL_DO_STRIDE0(X)$/;"	m
LOCK_PARALLEL_DO	macros	/^#    define LOCK_PARALLEL_DO(X)       LOCK_PARALLEL_DO0(X)$/;"	m
UNLOCK_PARALLEL_DO	macros	/^#    define UNLOCK_PARALLEL_DO(X)     UNLOCK_PARALLEL_DO0(X)$/;"	m
IO_IS_ALLOWED	macros	/^#    define IO_IS_ALLOWED             IO_IS_ALLOWED0$/;"	m
DO_IN_PARALLEL	macros	/^#    define DO_IN_PARALLEL            DO_IN_PARALLEL0$/;"	m
PARALLEL_SUM	macros	/^#    define PARALLEL_SUM(X)           PARALLEL_SUM0(X)$/;"	m
PARALLEL_VECTOR_SUM	macros	/^#    define PARALLEL_VECTOR_SUM(X,Y)  PARALLEL_VECTOR_SUM0(X,Y)$/;"	m
PARALLEL_SYMMETRIC_SUM	macros	/^#    define PARALLEL_SYMMETRIC_SUM(X) PARALLEL_SYMMETRIC_SUM0(X)$/;"	m
PARALLEL_BROADCAST	macros	/^#    define PARALLEL_BROADCAST(X,Y)   PARALLEL_BROADCAST0(X,Y)$/;"	m
PARALLEL_DO_START	macros	/^#    define PARALLEL_DO_START(X,Y)    X$/;"	m
PARALLEL_DO_STRIDE	macros	/^#    define PARALLEL_DO_STRIDE(X)     X$/;"	m
LOCK_PARALLEL_DO	macros	/^#    define LOCK_PARALLEL_DO(X)       ! Normally this is a parallel do loop ...$/;"	m
UNLOCK_PARALLEL_DO	macros	/^#    define UNLOCK_PARALLEL_DO(X)     ! End parallel do loop ...$/;"	m
IO_IS_ALLOWED	macros	/^#    define IO_IS_ALLOWED             TRUE$/;"	m
DO_IN_PARALLEL	macros	/^#    define DO_IN_PARALLEL            FALSE$/;"	m
PARALLEL_SUM	macros	/^#    define PARALLEL_SUM(X)        $/;"	m
PARALLEL_VECTOR_SUM	macros	/^#    define PARALLEL_VECTOR_SUM(X,Y)        $/;"	m
PARALLEL_SYMMETRIC_SUM	macros	/^#    define PARALLEL_SYMMETRIC_SUM(X)        $/;"	m
PARALLEL_BROADCAST	macros	/^#    define PARALLEL_BROADCAST(X,Y)$/;"	m
USE_CALL_STACK_MANAGEMENT	macros	/^#    define USE_CALL_STACK_MANAGEMENT$/;"	m
USE_PRECONDITIONS	macros	/^#    define USE_PRECONDITIONS$/;"	m
STACK	macros	/^#    define STACK(X)                  STACK0(X)     $/;"	m
UNSTACK	macros	/^#    define UNSTACK(X)                UNSTACK0(X)$/;"	m
CHECK	macros	/^#    define CHECK(X)                  CHECK0(X)$/;"	m
ADD_LOCATION	macros	/^#    define ADD_LOCATION(X,Y)         ADD_LOCATION0(X,Y)$/;"	m
ADD_MEMORY	macros	/^#    define ADD_MEMORY(X)             ADD_MEMORY0(X)$/;"	m
DELETE_MEMORY	macros	/^#    define DELETE_MEMORY(X)          DELETE_MEMORY0(X)$/;"	m
IGNORE_MEMORY_LEAK	macros	/^#    define IGNORE_MEMORY_LEAK(X)     IGNORE_MEMORY_LEAK0(X)$/;"	m
STACK	macros	/^#    define STACK(X)                  ! Starting routine X$/;"	m
UNSTACK	macros	/^#    define UNSTACK(X)                ! Ending routine ...$/;"	m
CHECK	macros	/^#    define CHECK(X)                  ! Normally check for memory leaks here ...$/;"	m
ADD_LOCATION	macros	/^#    define ADD_LOCATION(X,Y)         ! Normally keep track of new memory usage here ...$/;"	m
ADD_MEMORY	macros	/^#    define ADD_MEMORY(X)             ! Normally keep track of new memory usage here ...$/;"	m
DELETE_MEMORY	macros	/^#    define DELETE_MEMORY(X)          ! Normally delete old memory usage here ...$/;"	m
IGNORE_MEMORY_LEAK	macros	/^#    define IGNORE_MEMORY_LEAK(X)     ! An intentional memory leak occurs in this routine ...$/;"	m
USE_ERROR_MANAGEMENT	macros	/^#    define USE_ERROR_MANAGEMENT$/;"	m
ENSURE	macros	/^#    define ENSURE(X,Y)               ENSURE0(X,Y)$/;"	m
ENSURE	macros	/^#    define ENSURE(X,Y)               ! Ensure (X) or die and print: Y$/;"	m
DIE	macros	/^#    define DIE(X)                    DIE0(X)            $/;"	m
DIE_IF	macros	/^#    define DIE_IF(X,Y)               DIE_IF0(X,Y)     $/;"	m
WARN	macros	/^#    define WARN(X)                   WARN0(X)           $/;"	m
WARN_IF	macros	/^#    define WARN_IF(X,Y)              WARN_IF0(X,Y)      $/;"	m
DIE	macros	/^#    define DIE(X)                    ! Die and print: X$/;"	m
DIE_IF	macros	/^#    define DIE_IF(X,Y)               ! Die if (X) and print: Y $/;"	m
WARN	macros	/^#    define WARN(X)                   ! Warning message: X$/;"	m
WARN_IF	macros	/^#    define WARN_IF(X,Y)              ! Warn if (X) and print: Y$/;"	m
BROKEN_PURE	macros	/^#    define BROKEN_PURE$/;"	m
START_TIMER	macros	/^#    define START_TIMER(X)            START_TIMER0(X)$/;"	m
STOP_TIMER	macros	/^#    define STOP_TIMER                STOP_TIMER0$/;"	m
START_TIMER	macros	/^#    define START_TIMER(X)            ! Start routine timer ...$/;"	m
STOP_TIMER	macros	/^#    define STOP_TIMER                ! Stop routine timer ...$/;"	m
UNKNOWN	macros	/^# define UNKNOWN(X)    DIE("unknown case option: " \/\/ trim(X))$/;"	m
BROKEN_TYPE_INITIALIZATION	macros	/^#    define BROKEN_TYPE_INITIALIZATION$/;"	m
BROKEN_PURE	macros	/^#    define BROKEN_PURE$/;"	m
PURE	macros	/^#    define PURE $/;"	m
ELEMENTAL	macros	/^#    define ELEMENTAL $/;"	m
ALWAYS_PURE	macros	/^#    define ALWAYS_PURE $/;"	m
ALWAYS_ELEMENTAL	macros	/^#    define ALWAYS_ELEMENTAL $/;"	m
PURE	macros	/^#    define PURE                      pure$/;"	m
ELEMENTAL	macros	/^#    define ELEMENTAL                 elemental$/;"	m
ALWAYS_PURE	macros	/^#    define ALWAYS_PURE               pure$/;"	m
ALWAYS_ELEMENTAL	macros	/^#    define ALWAYS_ELEMENTAL          elemental$/;"	m
DEFAULT_NULL	macros	/^#    define DEFAULT_NULL$/;"	m
DEFAULT	macros	/^#    define DEFAULT(X)$/;"	m
DEFAULT	macros	/^#    define DEFAULT(X)                = X$/;"	m
DEFAULT_NULL	macros	/^#    define DEFAULT_NULL              => NULL()$/;"	m
AND	macros	/^# define AND        .and.$/;"	m
OR	macros	/^# define OR         .or.$/;"	m
NOT	macros	/^# define NOT        .not.$/;"	m
FALSE	macros	/^# define FALSE      .false.$/;"	m
TRUE	macros	/^# define TRUE       .true.$/;"	m
EQV	macros	/^# define EQV        .eqv.$/;"	m
NEQV	macros	/^# define NEQV       .neqv.$/;"	m
PTR	macros	/^# define PTR        pointer$/;"	m
IN	macros	/^# define IN         intent(in)$/;"	m
OUT	macros	/^# define OUT        intent(out)$/;"	m
INOUT	macros	/^# define INOUT      intent(inout)$/;"	m
PAR	macros	/^# define PAR        parameter$/;"	m
ZERO	macros	/^# define ZERO              0.00000000000000000000d0$/;"	m
ONE	macros	/^# define ONE               1.00000000000000000000d0$/;"	m
TWO	macros	/^# define TWO               2.00000000000000000000d0$/;"	m
THREE	macros	/^# define THREE             3.00000000000000000000d0$/;"	m
FOUR	macros	/^# define FOUR              4.00000000000000000000d0$/;"	m
FIVE	macros	/^# define FIVE              5.00000000000000000000d0$/;"	m
SIX	macros	/^# define SIX               6.00000000000000000000d0$/;"	m
SEVEN	macros	/^# define SEVEN             7.00000000000000000000d0$/;"	m
EIGHT	macros	/^# define EIGHT             8.00000000000000000000d0$/;"	m
NINE	macros	/^# define NINE              9.00000000000000000000d0$/;"	m
TEN	macros	/^# define TEN              10.00000000000000000000d0$/;"	m
HALF	macros	/^# define HALF              0.50000000000000000000d0$/;"	m
QUARTER	macros	/^# define QUARTER           0.25000000000000000000d0$/;"	m
EIGHTH	macros	/^# define EIGHTH            0.12500000000000000000d0$/;"	m
SIXTEENTH	macros	/^# define SIXTEENTH         0.06250000000000000000d0$/;"	m
THIRD	macros	/^# define THIRD             0.33333333333333333333d0$/;"	m
ONETHIRD	macros	/^# define ONETHIRD          0.33333333333333333333d0$/;"	m
TWOTHIRD	macros	/^# define TWOTHIRD          0.66666666666666666667d0$/;"	m
TWOTHIRDS	macros	/^# define TWOTHIRDS         0.66666666666666666667d0$/;"	m
FOURTHIRD	macros	/^# define FOURTHIRD         1.33333333333333333333d0$/;"	m
FOURTHIRDS	macros	/^# define FOURTHIRDS        1.33333333333333333333d0$/;"	m
SIXTH	macros	/^# define SIXTH             0.16666666666666666667d0$/;"	m
NINTH	macros	/^# define NINTH             0.11111111111111111111d0$/;"	m
TENTH	macros	/^# define TENTH             0.10000000000000000000d0$/;"	m
PI	macros	/^# define PI                3.14159265358979323846d0$/;"	m
SQRT_PI	macros	/^# define SQRT_PI           1.77245385090551596002d0$/;"	m
SQRT_2PI	macros	/^# define SQRT_2PI          2.50662827463100050242d0$/;"	m
EULER	macros	/^# define EULER             2.71828182845904523536d0$/;"	m
PI32	macros	/^# define PI32              5.56832799683170784528d0$/;"	m
TWOPI5ON2	macros	/^# define TWOPI5ON2         34.9868366552497256925d0$/;"	m
TOL	macros	/^# define TOL(N)            TEN**(-N)$/;"	m
REALIFY	macros	/^# define REALIFY(X)        real(X,kind=REAL_KIND)$/;"	m
IMAGIFY	macros	/^# define IMAGIFY(X)        (X,ZERO)$/;"	m
COPY_FROM_OBJECT	macros	/^# define COPY_FROM_OBJECT(X)        if (associated(self% X)) call create_copy_(self% X,object% X)$/;"	m
AVOGADROS_NUMBER	macros	/^# define AVOGADROS_NUMBER           6.0221415d+23$/;"	m
SPEED_OF_LIGHT_SI	macros	/^# define SPEED_OF_LIGHT_SI          2.99792458d+8$/;"	m
CHARGE_OF_ELECTRON_SI	macros	/^# define CHARGE_OF_ELECTRON_SI      1.60217653d-19$/;"	m
AMU_SI	macros	/^# define AMU_SI                     1.66053886d-27$/;"	m
BOHR_SI	macros	/^# define BOHR_SI                    0.5291772108d-10$/;"	m
MASS_OF_ELECTRON_SI	macros	/^# define MASS_OF_ELECTRON_SI        9.1093826d-31$/;"	m
MASS_OF_PROTON_SI	macros	/^# define MASS_OF_PROTON_SI          1.67262171d-27$/;"	m
MASS_OF_NEUTRON_SI	macros	/^# define MASS_OF_NEUTRON_SI         1.67492728d-27$/;"	m
BOHR_MAGNETON_SI	macros	/^# define BOHR_MAGNETON_SI           9.27400949d-24$/;"	m
NUCLEAR_MAGNETON_SI	macros	/^# define NUCLEAR_MAGNETON_SI        5.05078343d-27$/;"	m
G_FACTOR	macros	/^# define G_FACTOR                   2.0023193043718$/;"	m
BOLTZMANN_SI	macros	/^# define BOLTZMANN_SI               1.3806505d-23$/;"	m
HARTREE_SI	macros	/^# define HARTREE_SI                 4.35974417d-18$/;"	m
ANGSTROM_SI	macros	/^# define ANGSTROM_SI                1.0d-10$/;"	m
PLANCK_SI	macros	/^# define PLANCK_SI                  6.6260693d-34$/;"	m
BOHR_MAGNETON_AU	macros	/^# define BOHR_MAGNETON_AU           HALF      $/;"	m
SPEED_OF_LIGHT_AU	macros	/^# define SPEED_OF_LIGHT_AU          137.03599d0$/;"	m
PERMITTIVITY_OF_FREE_SPACE_SI	macros	/^# define PERMITTIVITY_OF_FREE_SPACE_SI  8.854187817d-12$/;"	m
AMU_PER_MASS_OF_ELECTRON	macros	/^# define AMU_PER_MASS_OF_ELECTRON (MASS_OF_ELECTRON_SI\/AMU_SI)$/;"	m
MASS_OF_ELECTRON_PER_AMU	macros	/^# define MASS_OF_ELECTRON_PER_AMU (AMU_SI\/MASS_OF_ELECTRON_SI)$/;"	m
ANGSTROM_PER_BOHR	macros	/^# define ANGSTROM_PER_BOHR        0.5291772108d0$/;"	m
BOHR_PER_ANGSTROM	macros	/^# define BOHR_PER_ANGSTROM        (1.0d0\/0.5291772108d0)$/;"	m
METER_PER_ANGSTROM	macros	/^# define METER_PER_ANGSTROM       1.0d-10$/;"	m
METER_PER_BOHR	macros	/^# define METER_PER_BOHR           0.5291772108d-10$/;"	m
METER_PER_AU	macros	/^# define METER_PER_AU             0.5291772108d-10$/;"	m
BOHR_PER_BOHR	macros	/^# define BOHR_PER_BOHR            ONE$/;"	m
WAVENUMBER_PER_HARTREE	macros	/^# define WAVENUMBER_PER_HARTREE   2.194746313705d+5$/;"	m
EV_PER_HARTREE	macros	/^# define EV_PER_HARTREE           27.2113845           $/;"	m
KELVIN_PER_HARTREE	macros	/^# define KELVIN_PER_HARTREE       3.1577465d+5         $/;"	m
JOULE_PER_HARTREE	macros	/^# define JOULE_PER_HARTREE        4.35974417d-18$/;"	m
HARTREE_PER_JOULE	macros	/^# define HARTREE_PER_JOULE        (1.0d0\/4.35974417d-18)$/;"	m
KJOULE_PER_HARTREE	macros	/^# define KJOULE_PER_HARTREE       4.35974417d-21$/;"	m
CAL_PER_HARTREE	macros	/^# define CAL_PER_HARTREE          1.042d-18        $/;"	m
KCAL_PER_HARTREE	macros	/^# define KCAL_PER_HARTREE         1.042d-21        $/;"	m
KCALMOL_PER_HARTREE	macros	/^# define KCALMOL_PER_HARTREE      627.5            $/;"	m
KJOULEMOL_PER_HARTREE	macros	/^# define KJOULEMOL_PER_HARTREE    2625.46          $/;"	m
JOULE_PER_CAL	macros	/^# define JOULE_PER_CAL            4.184            $/;"	m
DEGREE_PER_RADIAN	macros	/^# define DEGREE_PER_RADIAN        (180d0\/PI)$/;"	m
RADIAN_PER_DEGREE	macros	/^# define RADIAN_PER_DEGREE        (PI\/180d0)$/;"	m
DEBYE_PER_AU	macros	/^# define DEBYE_PER_AU             2.5418d0$/;"	m
AU_PER_DEBYE	macros	/^# define AU_PER_DEBYE             (ONE\/2.5418d0)$/;"	m
ELECTRIC_FIELD_SI_PER_AU	macros	/^# define ELECTRIC_FIELD_SI_PER_AU             5.14220642d+11$/;"	m
ELECTRIC_FIELD_GRADIENT_SI_PER_AU	macros	/^# define ELECTRIC_FIELD_GRADIENT_SI_PER_AU    9.71736182d+21$/;"	m
ELECTRIC_POLARISABILITY_SI_PER_AU	macros	/^# define ELECTRIC_POLARISABILITY_SI_PER_AU    1.648777274d-41$/;"	m
PERMITTIVITY_OF_FREE_SPACE_SI_PER_AU	macros	/^# define PERMITTIVITY_OF_FREE_SPACE_SI_PER_AU 1.112650056d-10$/;"	m
ADAPTIVE_QUADRATURE_ACCURACY	macros	/^# define ADAPTIVE_QUADRATURE_ACCURACY         TOL(3)$/;"	m
ATOM_BONDED_RANGE_FACTOR	macros	/^# define ATOM_BONDED_RANGE_FACTOR             0.4*BOHR_PER_ANGSTROM$/;"	m
ATOM_DUMMY_CHARGE_LABEL	macros	/^# define ATOM_DUMMY_CHARGE_LABEL              "q"$/;"	m
ATOM_DUMMY_CHARGE_INPUT_SYMBOL	macros	/^# define ATOM_DUMMY_CHARGE_INPUT_SYMBOL       "q:"$/;"	m
BECKE_GRID_KIND	macros	/^# define BECKE_GRID_KIND                      "mura_knowles"$/;"	m
BECKE_GRID_EXTRA_POINTS_PER_SHELL	macros	/^# define BECKE_GRID_EXTRA_POINTS_PER_SHELL    5$/;"	m
BECKE_GRID_REDUCE_CORE_ANGULAR_GRID	macros	/^# define BECKE_GRID_REDUCE_CORE_ANGULAR_GRID  TRUE$/;"	m
BECKE_GRID_REDUCE_H_ANGULAR_GRID	macros	/^# define BECKE_GRID_REDUCE_H_ANGULAR_GRID     TRUE$/;"	m
BECKE_GRID_SCALE_ATOMIC_GRIDS	macros	/^# define BECKE_GRID_SCALE_ATOMIC_GRIDS        TRUE$/;"	m
BECKE_GRID_PARTITION_POWER	macros	/^# define BECKE_GRID_PARTITION_POWER           3$/;"	m
BECKE_GRID_STRATMANN_SCUSERIA_A	macros	/^# define BECKE_GRID_STRATMANN_SCUSERIA_A      0.64d0$/;"	m
BECKE_GRID_PARTITION_SCHEME	macros	/^# define BECKE_GRID_PARTITION_SCHEME          "stratmann_scuseria"$/;"	m
BECKE_GRID_PARTITION_SCALING_SCHEME	macros	/^# define BECKE_GRID_PARTITION_SCALING_SCHEME  "none"$/;"	m
BECKE_GRID_PRUNING_SCHEME	macros	/^# define BECKE_GRID_PRUNING_SCHEME            "treutler_ahlrichs"$/;"	m
BECKE_GRID_ACCURACY	macros	/^# define BECKE_GRID_ACCURACY                  "low"$/;"	m
BECKE_GRID_BASIS_FUNCTION_CUTOFF	macros	/^# define BECKE_GRID_BASIS_FUNCTION_CUTOFF     TOL(10)$/;"	m
BECKE_GRID_PARTITION_CUTOFF	macros	/^# define BECKE_GRID_PARTITION_CUTOFF          TOL(4)$/;"	m
BECKE_GRID_RHO_CUTOFF	macros	/^# define BECKE_GRID_RHO_CUTOFF                TOL(6)$/;"	m
BUFFER_COMMENT_CHARS	macros	/^# define BUFFER_COMMENT_CHARS             "!#"$/;"	m
BUFFER_QUOTE_CHARS	macros	/^# define BUFFER_QUOTE_CHARS               "'"\/\/'"'$/;"	m
CIF_BH_BOND_LENGTH	macros	/^# define CIF_BH_BOND_LENGTH               1.190d0$/;"	m
CIF_CH_BOND_LENGTH	macros	/^# define CIF_CH_BOND_LENGTH               1.083d0$/;"	m
CIF_NH_BOND_LENGTH	macros	/^# define CIF_NH_BOND_LENGTH               1.009d0$/;"	m
CIF_OH_BOND_LENGTH	macros	/^# define CIF_OH_BOND_LENGTH               0.983d0$/;"	m
CLUSTER_GENERATION_METHOD	macros	/^# define CLUSTER_GENERATION_METHOD        "fragment"$/;"	m
CLUSTER_RADIUS	macros	/^# define CLUSTER_RADIUS                   ZERO$/;"	m
CLUSTER_ATOM_DENSITY_CUTOFF	macros	/^# define CLUSTER_ATOM_DENSITY_CUTOFF      TOL(10)$/;"	m
CLUSTER_DEFRAGMENT	macros	/^# define CLUSTER_DEFRAGMENT               FALSE$/;"	m
COPPENSORBITAL_VALUES_CUTOFF	macros	/^# define COPPENSORBITAL_VALUES_CUTOFF     TOL(6)$/;"	m
DIFFRACTION_DATA_DATA_KIND	macros	/^# define DIFFRACTION_DATA_DATA_KIND                "x-ray"$/;"	m
DIFFRACTION_DATA_WAVELENGTH	macros	/^# define DIFFRACTION_DATA_WAVELENGTH               0.71069d0*BOHR_PER_ANGSTROM$/;"	m
DIFFRACTION_DATA_TEMPERATURE	macros	/^# define DIFFRACTION_DATA_TEMPERATURE              ZERO$/;"	m
DIFFRACTION_DATA_F_SIGMA_CUTOFF	macros	/^# define DIFFRACTION_DATA_F_SIGMA_CUTOFF           TWO$/;"	m
DIFFRACTION_DATA_F2_SIGMA_CUTOFF	macros	/^# define DIFFRACTION_DATA_F2_SIGMA_CUTOFF          FOUR$/;"	m
DIFFRACTION_DATA_SYNTHESIZE_SIGMA_I	macros	/^# define DIFFRACTION_DATA_SYNTHESIZE_SIGMA_I       FALSE                             $/;"	m
DIFFRACTION_DATA_PARTITION_MODEL	macros	/^# define DIFFRACTION_DATA_PARTITION_MODEL          " "$/;"	m
DIFFRACTION_DATA_THERMAL_SMEARING_MODEL	macros	/^# define DIFFRACTION_DATA_THERMAL_SMEARING_MODEL   " "                                   $/;"	m
DIFFRACTION_DATA_OPTIMISE_SCALE	macros	/^# define DIFFRACTION_DATA_OPTIMISE_SCALE           TRUE$/;"	m
DIFFRACTION_DATA_SCALE_FACTOR	macros	/^# define DIFFRACTION_DATA_SCALE_FACTOR             ONE$/;"	m
DIFFRACTION_DATA_EXP_SCALE_FACTOR	macros	/^# define DIFFRACTION_DATA_EXP_SCALE_FACTOR         ONE                             $/;"	m
DIFFRACTION_DATA_OPTIMISE_EXTINCTION	macros	/^# define DIFFRACTION_DATA_OPTIMISE_EXTINCTION      TRUE                               $/;"	m
DIFFRACTION_DATA_EXTINCTION_FACTOR	macros	/^# define DIFFRACTION_DATA_EXTINCTION_FACTOR        ZERO                             $/;"	m
DIFFRACTION_DATA_CORRECT_DISPERSION	macros	/^# define DIFFRACTION_DATA_CORRECT_DISPERSION       FALSE                             $/;"	m
DIFFRACTION_DATA_MAX_ITER	macros	/^# define DIFFRACTION_DATA_MAX_ITER                 100$/;"	m
DIFFRACTION_DATA_MIN_ITER	macros	/^# define DIFFRACTION_DATA_MIN_ITER                 7$/;"	m
DIFFRACTION_DATA_TOL_SHIFT_CONV	macros	/^# define DIFFRACTION_DATA_TOL_SHIFT_CONV           TOL(5)$/;"	m
DIFFRACTION_DATA_MAX_SHIFT_ON_ESD	macros	/^# define DIFFRACTION_DATA_MAX_SHIFT_ON_ESD         TOL(2)$/;"	m
DIFFRACTION_DATA_MAX_ALLOWED_SHIFT	macros	/^# define DIFFRACTION_DATA_MAX_ALLOWED_SHIFT        TOL(2)$/;"	m
DIFFRACTION_DATA_TOL_0	macros	/^# define DIFFRACTION_DATA_TOL_0                    TOL(5)$/;"	m
DIFFRACTION_DATA_TOL_NEAR_0	macros	/^# define DIFFRACTION_DATA_TOL_NEAR_0               TOL(5)$/;"	m
DIFFRACTION_DATA_MIN_CORRELATION	macros	/^# define DIFFRACTION_DATA_MIN_CORRELATION          0.8d0$/;"	m
DFT_FUNCTIONAL_XALPHA	macros	/^# define DFT_FUNCTIONAL_XALPHA            0.7d0$/;"	m
DFT_FUNCTIONAL_RHO_CUTOFF	macros	/^# define DFT_FUNCTIONAL_RHO_CUTOFF        TOL(30)$/;"	m
DFTGRID_SPHERICAL_GRID_KIND	macros	/^# define DFTGRID_SPHERICAL_GRID_KIND      "lebedev"$/;"	m
DFTGRID_SPHERICAL_GRID_ORDER	macros	/^# define DFTGRID_SPHERICAL_GRID_ORDER     35$/;"	m
DFTGRID_RADIAL_GRID_KIND	macros	/^# define DFTGRID_RADIAL_GRID_KIND         "gauss-chebyshev"$/;"	m
DFTGRID_RADIAL_GRID_ORDER	macros	/^# define DFTGRID_RADIAL_GRID_ORDER        60$/;"	m
DFTGRID_BECKE_M_PARTITION_POWER	macros	/^# define DFTGRID_BECKE_M_PARTITION_POWER  TWO$/;"	m
DFTGRID_GAUSS_CHEBYSHEV_M	macros	/^# define DFTGRID_GAUSS_CHEBYSHEV_M        ONE$/;"	m
DFTGRID_GAUSS_CHEBYSHEV_ALPHA	macros	/^# define DFTGRID_GAUSS_CHEBYSHEV_ALPHA    THREE$/;"	m
DFTGRID_EULER_MACLAURIN_M	macros	/^# define DFTGRID_EULER_MACLAURIN_M        TWO$/;"	m
DFTGRID_EULER_MACLAURIN_ALPHA	macros	/^# define DFTGRID_EULER_MACLAURIN_ALPHA    TWO$/;"	m
DFTGRID_ARCHIVE_ROOT_NAME	macros	/^# define DFTGRID_ARCHIVE_ROOT_NAME        "dftgrid"$/;"	m
DFTGRID_ARCHIVE_NAME	macros	/^# define DFTGRID_ARCHIVE_NAME             "grid"$/;"	m
DIIS_GENRE	macros	/^# define DIIS_GENRE                       "fdiis"$/;"	m
DIIS_START_ITERATION	macros	/^# define DIIS_START_ITERATION             3$/;"	m
DIIS_SAVE_ITERATION	macros	/^# define DIIS_SAVE_ITERATION              1$/;"	m
DIIS_KEEP	macros	/^# define DIIS_KEEP                        8$/;"	m
DIIS_CONVERGENCE_TOLERANCE	macros	/^# define DIIS_CONVERGENCE_TOLERANCE       TOL(3)$/;"	m
DIIS_START_TOLERANCE	macros	/^# define DIIS_START_TOLERANCE             4*TOL(1)$/;"	m
DIIS_ENCORE_ITERATIONS	macros	/^# define DIIS_ENCORE_ITERATIONS           4$/;"	m
DIIS_REPLACEMENT_METHOD	macros	/^# define DIIS_REPLACEMENT_METHOD          "worst"$/;"	m
DIIS_FORCE_CONVEXITY	macros	/^# define DIIS_FORCE_CONVEXITY             FALSE$/;"	m
DIIS_MICRO_ITERATION_METHOD	macros	/^# define DIIS_MICRO_ITERATION_METHOD      "bfgs"$/;"	m
DIIS_MICRO_STARTING_GUESS	macros	/^# define DIIS_MICRO_STARTING_GUESS        "diis"$/;"	m
DIIS_MICRO_CONVERGENCE_TOL	macros	/^# define DIIS_MICRO_CONVERGENCE_TOL       TOL(6)$/;"	m
DIIS_MICRO_MAX_ITERATIONS	macros	/^# define DIIS_MICRO_MAX_ITERATIONS        10000$/;"	m
DIIS_MICRO_DAMP_FACTOR	macros	/^# define DIIS_MICRO_DAMP_FACTOR           0.9d0$/;"	m
DIIS_ERROR_TEMP_CUTOFF	macros	/^# define DIIS_ERROR_TEMP_CUTOFF           TOL(2)$/;"	m
FILE_BUFFER_LENGTH	macros	/^# define FILE_BUFFER_LENGTH               1024$/;"	m
INTERPOLATOR_INTERPOLATION_METHOD	macros	/^# define INTERPOLATOR_INTERPOLATION_METHOD "linear"$/;"	m
INTERPOLATOR_RANGE_MAPPING	macros	/^# define INTERPOLATOR_RANGE_MAPPING        "none"$/;"	m
INTERPOLATOR_DOMAIN_MAPPING	macros	/^# define INTERPOLATOR_DOMAIN_MAPPING       "none"$/;"	m
INTERPOLATOR_TABLE_LENGTH	macros	/^# define INTERPOLATOR_TABLE_LENGTH        30.0d0$/;"	m
INTERPOLATOR_TABLE_ORIGIN	macros	/^# define INTERPOLATOR_TABLE_ORIGIN        ZERO$/;"	m
INTERPOLATOR_TABLE_SPACING	macros	/^# define INTERPOLATOR_TABLE_SPACING       0.02d0$/;"	m
INTERPOLATOR_TABLE_EPS	macros	/^# define INTERPOLATOR_TABLE_EPS           TOL(6)$/;"	m
INTERPOLATOR_Y1_INITIAL	macros	/^# define INTERPOLATOR_Y1_INITIAL          huge(ONE) $/;"	m
INTERPOLATOR_Y1_FINAL	macros	/^# define INTERPOLATOR_Y1_FINAL            huge(ONE) $/;"	m
ISOSURFACE_ISO_VALUE	macros	/^# define ISOSURFACE_ISO_VALUE             ONE$/;"	m
ISOSURFACE_MINIMUM_SCAN_LEVEL	macros	/^# define ISOSURFACE_MINIMUM_SCAN_LEVEL     1         $/;"	m
ISOSURFACE_MINIMUM_SCAN_DIVISION	macros	/^# define ISOSURFACE_MINIMUM_SCAN_DIVISION  0.5d0$/;"	m
ISOSURFACE_VOXEL_PROXIMITY_FACTOR	macros	/^# define ISOSURFACE_VOXEL_PROXIMITY_FACTOR 1.5d0$/;"	m
ISOSURFACE_SURFACE_POINT	macros	/^# define ISOSURFACE_SURFACE_POINT         (\/TOL(6),TOL(6),TOL(6)\/)$/;"	m
ISOSURFACE_PROPERTY_LB	macros	/^# define ISOSURFACE_PROPERTY_LB           -huge(ONE)$/;"	m
ISOSURFACE_PROPERTY_UB	macros	/^# define ISOSURFACE_PROPERTY_UB           huge(ONE)$/;"	m
ISOSURFACE_PROPERTY_LB_ABS	macros	/^# define ISOSURFACE_PROPERTY_LB_ABS       TOL(10)$/;"	m
ISOSURFACE_PROPERTY_UB_ABS	macros	/^# define ISOSURFACE_PROPERTY_UB_ABS       huge(ONE)$/;"	m
ISOSURFACE_N_POINT	macros	/^# define ISOSURFACE_N_POINT               10000$/;"	m
ISOSURFACE_N_FACE	macros	/^# define ISOSURFACE_N_FACE                20000$/;"	m
ISOSURFACE_N_CAP	macros	/^# define ISOSURFACE_N_CAP                 10000$/;"	m
ISOSURFACE_INTERPOLATION_KIND	macros	/^# define ISOSURFACE_INTERPOLATION_KIND    "logarithmic_linear"$/;"	m
ISOSURFACE_TABLE_LENGTH	macros	/^# define ISOSURFACE_TABLE_LENGTH          30.0d0$/;"	m
ISOSURFACE_TABLE_ORIGIN	macros	/^# define ISOSURFACE_TABLE_ORIGIN          ZERO$/;"	m
ISOSURFACE_TABLE_SPACING	macros	/^# define ISOSURFACE_TABLE_SPACING         0.02d0$/;"	m
ISOSURFACE_TABLE_EPS	macros	/^# define ISOSURFACE_TABLE_EPS             TOL(9)$/;"	m
MAT_LINEAR_DEPENDENCE_TOL	macros	/^# define MAT_LINEAR_DEPENDENCE_TOL        TOL(10)$/;"	m
LINEAR_DEPENDENCE_TOL	macros	/^# define LINEAR_DEPENDENCE_TOL            TOL(4)$/;"	m
INTERNAL_GEMINAL_TOL	macros	/^# define INTERNAL_GEMINAL_TOL            TOL(8)$/;"	m
MO_LOCALISER_ALGORITHM	macros	/^# define MO_LOCALISER_ALGORITHM           "boys"$/;"	m
MO_LOCALISER_ACCURACY	macros	/^# define MO_LOCALISER_ACCURACY            TOL(3)$/;"	m
MO_LOCALISER_MAXIT	macros	/^# define MO_LOCALISER_MAXIT               20$/;"	m
MULTI_T_ADP_V_EXPANSION_ORDER	macros	/^# define MULTI_T_ADP_V_EXPANSION_ORDER        2$/;"	m
MULTI_T_ADP_MAX_ITER	macros	/^# define MULTI_T_ADP_MAX_ITER                 100$/;"	m
MULTI_T_ADP_MIN_ITER	macros	/^# define MULTI_T_ADP_MIN_ITER                 7$/;"	m
MULTI_T_ADP_TOL_SHIFT_CONV	macros	/^# define MULTI_T_ADP_TOL_SHIFT_CONV           TOL(1)$/;"	m
MULTI_T_ADP_MAX_SHIFT	macros	/^# define MULTI_T_ADP_MAX_SHIFT                TOL(2)$/;"	m
MULTI_T_ADP_TOL_0	macros	/^# define MULTI_T_ADP_TOL_0                    TOL(5)$/;"	m
MULTI_T_ADP_TOL_NEAR_0	macros	/^# define MULTI_T_ADP_TOL_NEAR_0               TOL(5)$/;"	m
MULTI_T_ADP_MIN_CORRELATION	macros	/^# define MULTI_T_ADP_MIN_CORRELATION          0.8d0$/;"	m
PLOT_GRID_MAXIMUM_CELL_DISTANCE	macros	/^# define PLOT_GRID_MAXIMUM_CELL_DISTANCE  5$/;"	m
PLOT_GRID_NX	macros	/^# define PLOT_GRID_NX                     75$/;"	m
PLOT_GRID_NY	macros	/^# define PLOT_GRID_NY                     75$/;"	m
PLOT_GRID_NZ	macros	/^# define PLOT_GRID_NZ                     1$/;"	m
PLOT_GRID_X_AXIS	macros	/^# define PLOT_GRID_X_AXIS                 (\/ ONE,ZERO,ZERO\/)$/;"	m
PLOT_GRID_Y_AXIS	macros	/^# define PLOT_GRID_Y_AXIS                 (\/ZERO, ONE,ZERO\/)$/;"	m
PLOT_GRID_Z_AXIS	macros	/^# define PLOT_GRID_Z_AXIS                 (\/ZERO,ZERO, ONE\/)$/;"	m
PLOT_GRID_WIDTH	macros	/^# define PLOT_GRID_WIDTH                  (\/ TWO, TWO,ZERO\/)$/;"	m
QUADRATURE_ACCURACY	macros	/^# define QUADRATURE_ACCURACY              TOL(6)$/;"	m
QUADRATURE_EPS	macros	/^# define QUADRATURE_EPS                   TOL(13)$/;"	m
QUADRATURE_MAXIT	macros	/^# define QUADRATURE_MAXIT                 10$/;"	m
REAL_EPSILON	macros	/^# define REAL_EPSILON                     TOL(12)$/;"	m
ROBY_OCCUPIED_ANO_CUTOFF	macros	/^# define ROBY_OCCUPIED_ANO_CUTOFF         0.05d0$/;"	m
ROBY_COVALENT_CUTOFF	macros	/^# define ROBY_COVALENT_CUTOFF             89.0d0$/;"	m
ROBY_IONIC_CUTOFF	macros	/^# define ROBY_IONIC_CUTOFF                77.0d0$/;"	m
ROBY_ZERO_CUTOFF	macros	/^# define ROBY_ZERO_CUTOFF                 TOL(4)$/;"	m
ROBY_PI_ON_2_CUTOFF	macros	/^# define ROBY_PI_ON_2_CUTOFF              90.0d0$/;"	m
ROBY_OUTPUT_THETA_INFO	macros	/^# define ROBY_OUTPUT_THETA_INFO           TRUE$/;"	m
ROBY_ANALYSE_ALL_ATOM_PAIRS	macros	/^# define ROBY_ANALYSE_ALL_ATOM_PAIRS      FALSE$/;"	m
ROBY_BOND_SCALE_FACTOR	macros	/^# define ROBY_BOND_SCALE_FACTOR           1.33$/;"	m
SCFDATA_DFT_EXCHANGE_FUNCTIONAL	macros	/^# define SCFDATA_DFT_EXCHANGE_FUNCTIONAL  "becke88"$/;"	m
SCFDATA_USING_GGA_EXCHANGE	macros	/^# define SCFDATA_USING_GGA_EXCHANGE       TRUE$/;"	m
SCFDATA_DFT_CORRELATION_FUNCTIONAL	macros	/^# define SCFDATA_DFT_CORRELATION_FUNCTIONAL "lyp"$/;"	m
SCFDATA_USING_GGA_CORRELATION	macros	/^# define SCFDATA_USING_GGA_CORRELATION    TRUE$/;"	m
SCFDATA_CONVERGENCE	macros	/^# define SCFDATA_CONVERGENCE              TOL(3)$/;"	m
SCFDATA_USING_DAMPING	macros	/^# define SCFDATA_USING_DAMPING            TRUE $/;"	m
SCFDATA_USING_LEVEL_SHIFT	macros	/^# define SCFDATA_USING_LEVEL_SHIFT        TRUE $/;"	m
SCFDATA_ERI_DISK_CUTOFF	macros	/^# define SCFDATA_ERI_DISK_CUTOFF          TOL(12)$/;"	m
SCFDATA_ERI_SCHWARZ_CUTOFF	macros	/^# define SCFDATA_ERI_SCHWARZ_CUTOFF       TOL(9)$/;"	m
SCFDATA_ERI_J_DENSITY_CUTOFF	macros	/^# define SCFDATA_ERI_J_DENSITY_CUTOFF     TOL(9)$/;"	m
SCFDATA_ERI_K_DENSITY_CUTOFF	macros	/^# define SCFDATA_ERI_K_DENSITY_CUTOFF     TOL(9)$/;"	m
SCFDATA_ERI_BF_OVERLAP_CUTOFF	macros	/^# define SCFDATA_ERI_BF_OVERLAP_CUTOFF    TOL(9)$/;"	m
SCFDATA_ERI_PAIR_CUTOFF	macros	/^# define SCFDATA_ERI_PAIR_CUTOFF          TOL(6)$/;"	m
SCFDATA_ATOM_OVERLAP_CUTOFF	macros	/^# define SCFDATA_ATOM_OVERLAP_CUTOFF      TOL(9)$/;"	m
SCFDATA_XC_ATOM_SEPARATION_CUTOFF	macros	/^# define SCFDATA_XC_ATOM_SEPARATION_CUTOFF 15.0$/;"	m
SCFDATA_MIN_ITERATIONS	macros	/^# define SCFDATA_MIN_ITERATIONS           1$/;"	m
SCFDATA_MAX_ITERATIONS	macros	/^# define SCFDATA_MAX_ITERATIONS           100$/;"	m
SCFDATA_DAMP_FACTOR	macros	/^# define SCFDATA_DAMP_FACTOR              0.5d0$/;"	m
SCFDATA_DAMP_FINISH	macros	/^# define SCFDATA_DAMP_FINISH              3$/;"	m
SCFDATA_LEVEL_SHIFT	macros	/^# define SCFDATA_LEVEL_SHIFT              0.3d0$/;"	m
SCFDATA_LEVEL_SHIFT_FINISH	macros	/^# define SCFDATA_LEVEL_SHIFT_FINISH       3$/;"	m
SCFDATA_LINEAR_DEPENDENCE_TOL	macros	/^# define SCFDATA_LINEAR_DEPENDENCE_TOL    TOL(8)$/;"	m
SCFDATA_LINEAR_DEPENDENCE_SHIFT	macros	/^# define SCFDATA_LINEAR_DEPENDENCE_SHIFT  1.0d6$/;"	m
SCFDATA_CLUSTER_RADIUS	macros	/^# define SCFDATA_CLUSTER_RADIUS           SIX$/;"	m
SHELL_IS_SPHERICAL	macros	/^# define SHELL_IS_SPHERICAL               FALSE$/;"	m
SHELL2_PAIR_CUTOFF	macros	/^# define SHELL2_PAIR_CUTOFF               TOL(6)$/;"	m
SHELL4_ERI_CUTOFF	macros	/^# define SHELL4_ERI_CUTOFF                1.0d-15$/;"	m
SHELL1QUARTET_ERI_PAIR_CUTOFF	macros	/^# define SHELL1QUARTET_ERI_PAIR_CUTOFF    TOL(6)$/;"	m
SPACEGROUP_MAX_UNIQUE_SYMOPS	macros	/^# define SPACEGROUP_MAX_UNIQUE_SYMOPS     1000$/;"	m
SYSTEM_ERROR_OUTPUT_UNIT	macros	/^# define SYSTEM_ERROR_OUTPUT_UNIT         7$/;"	m
SYSTEM_KEYWORD_ECHO	macros	/^# define SYSTEM_KEYWORD_ECHO              FALSE$/;"	m
SYSTEM_MEMORY_UNITS	macros	/^# define SYSTEM_MEMORY_UNITS              "Words"$/;"	m
SYSTEM_MEMORY_LIMIT	macros	/^# define SYSTEM_MEMORY_LIMIT              6*8000000$/;"	m
SYSTEM_STACK_LIMIT	macros	/^# define SYSTEM_STACK_LIMIT               20$/;"	m
TABLE_COLUMN_WIDTH	macros	/^# define TABLE_COLUMN_WIDTH               9$/;"	m
TABLE_COLUMN_REAL_PRECISION	macros	/^# define TABLE_COLUMN_REAL_PRECISION      6$/;"	m
TABLE_COLUMN_SPACING	macros	/^# define TABLE_COLUMN_SPACING             4$/;"	m
TABLE_COLUMN_SPACER	macros	/^# define TABLE_COLUMN_SPACER              " "$/;"	m
TABLE_COLUMN_CENTER	macros	/^# define TABLE_COLUMN_CENTER              FALSE$/;"	m
TABLE_COLUMN_LEFT_JUSTIFY	macros	/^# define TABLE_COLUMN_LEFT_JUSTIFY        FALSE$/;"	m
TEXTFILE_IOSTAT_EOF	macros	/^# define TEXTFILE_IOSTAT_EOF              -1$/;"	m
TEXTFILE_STDIN_UNIT	macros	/^# define TEXTFILE_STDIN_UNIT              5$/;"	m
TEXTFILE_STDOUT_UNIT	macros	/^# define TEXTFILE_STDOUT_UNIT             6$/;"	m
TEXTFILE_STDERR_UNIT	macros	/^# define TEXTFILE_STDERR_UNIT             7$/;"	m
TEXTFILE_COMMENT_CHARS	macros	/^# define TEXTFILE_COMMENT_CHARS           "!#"$/;"	m
TEXTFILE_QUOTE_CHARS	macros	/^# define TEXTFILE_QUOTE_CHARS             "'"""$/;"	m
TEXTFILE_USE_FIELDS	macros	/^# define TEXTFILE_USE_FIELDS              TRUE$/;"	m
TEXTFILE_USE_ARRAY_LABELS	macros	/^# define TEXTFILE_USE_ARRAY_LABELS        TRUE$/;"	m
TEXTFILE_MARGIN_WIDTH	macros	/^# define TEXTFILE_MARGIN_WIDTH            0$/;"	m
TEXTFILE_N_FIELDS_PER_LINE	macros	/^# define TEXTFILE_N_FIELDS_PER_LINE       5$/;"	m
TEXTFILE_SPACING	macros	/^# define TEXTFILE_SPACING                 4$/;"	m
TEXTFILE_REAL_WIDTH	macros	/^# define TEXTFILE_REAL_WIDTH              16$/;"	m
TEXTFILE_INT_WIDTH	macros	/^# define TEXTFILE_INT_WIDTH               8$/;"	m
TEXTFILE_REAL_PRECISION	macros	/^# define TEXTFILE_REAL_PRECISION          6$/;"	m
TEXTFILE_REAL_STYLE	macros	/^# define TEXTFILE_REAL_STYLE              " f"$/;"	m
UNIT_CELL_ANGLES	macros	/^# define UNIT_CELL_ANGLES                 (\/90.0d0,90.0d0,90.0d0\/)        $/;"	m
UNIT_CELL_LENGTHS	macros	/^# define UNIT_CELL_LENGTHS                (\/10.0d0,10.0d0,10.0d0\/)         $/;"	m
UNIT_NUMBER_STARTING_UNIT	macros	/^# define UNIT_NUMBER_STARTING_UNIT        10$/;"	m
