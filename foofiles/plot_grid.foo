!---------------------------------------------------------------------
!
! PLOT_GRID: for cartesian grid generation, e.g. for plots or surfaces.
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!
!---------------------------------------------------------------------

module PLOT_GRID

   implicit none

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   create(atom) ::: leaky
   ! Create object
      self :: PTR
      atom :: VEC{ATOM}*
      .create
      .set_atom_defaults(atom)
   end

   create_copy(grid) ::: leaky
   ! Create a grid object which is a duplicate of grid.
      self :: PTR
      grid :: PLOT_GRID, IN
      .create
      .copy(grid)
   end

   copy(grid)
   ! Copy the contents of grid to self.
      grid :: PLOT_GRID, IN
      self = grid
      .nullify_ptr_part
      if (grid.atom.created)              .atom.copy(grid.atom)
      if (grid.bond_density_atom.created) .bond_density_atom.copy(grid.bond_density_atom)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts
      nullify(.atom)
      nullify(.centre_atoms)
      nullify(.bond_density_atom)
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts

    ! if (.destroy_atom) then; .atom.destroy
    ! else;                    nullify(.atom)
    ! end

      nullify(.atom) ! do not destroy

      .bond_density_atom.destroy

   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

!  ============
!  Set routines
!  ============

   set_defaults
   ! Set up a default grid. 

      .plot_kind      = " "

      .orbital        = 0
      .HOMO_orbital   = 0
      .LUMO_orbital   = -1

      .projection_direction = [ZERO,ZERO,ZERO]

      .centre         = ZERO
      .offset         = ZERO
      .centre_atom    = 0

      .x_atom_1       = 0
      .x_atom_2       = 0
      .y_atom_1       = 0
      .y_atom_2       = 0

      .x_axis(:)      = PLOT_GRID_X_AXIS
      .y_axis(:)      = PLOT_GRID_Y_AXIS
      .z_axis(:)      = PLOT_GRID_Z_AXIS

      .n_x            = PLOT_GRID_NX
      .n_y            = PLOT_GRID_NY
      .n_z            = PLOT_GRID_NZ
      .width(:)       = PLOT_GRID_WIDTH
      .width(3)       = ZERO    ! assume a planar plot
      .del_x          = .width(1)/(PLOT_GRID_NX - 1)
      .del_y          = .del_x
      .del_z          = .del_x
      .x_width_set    = FALSE   ! These are set false only if the widths
      .y_width_set    = FALSE   ! are explicitly read in
      .z_width_set    = FALSE

      .use_bounding_box      = FALSE
      .box_centre            = ZERO
      .bounding_box          = PLOT_GRID_WIDTH
      .box_scale_factor      = ONE
      .box_axes(:,1)         = PLOT_GRID_X_AXIS
      .box_axes(:,2)         = PLOT_GRID_Y_AXIS
      .box_axes(:,3)         = PLOT_GRID_Z_AXIS
      .use_unit_cell_as_bbox = FALSE

      .x_axis_defined     = FALSE
      .y_axis_defined     = FALSE
      .z_axis_defined     = FALSE

      .desired_separation = ZERO

      .plot_units         = " "
      .plot_format        = " "

      .use_plot_max       = FALSE
      .use_plot_min       = FALSE
      .plot_max           = ZERO
      .plot_min           = ZERO

      nullify(.atom)
      nullify(.bond_density_atom)

    ! .destroy_atom = FALSE

   end

   set_defaults(atom)
   ! Set up atom defaults. "atom" is used to define an xyz bounding
   ! box for the molecule. 
      atom :: VEC{ATOM}*
    ! destroy_atom :: BIN, optional

      .set_defaults
      .set_atom_defaults(atom)

   end

   reset_defaults
   ! Reset a default grid. The only difference to set_defaults is that
   ! the bounding box and box_axes are not set again.
      .plot_kind           = " "
      .orbital        = 0
      .HOMO_orbital   = 0
      .LUMO_orbital   = -1
      .centre         = ZERO
      .offset         = ZERO
      .centre_atom    = 0
      .x_atom_1       = 0
      .x_atom_2       = 0
      .y_atom_1       = 0
      .y_atom_2       = 0
      .n_x            = PLOT_GRID_NX
      .n_y            = PLOT_GRID_NY
      .n_z            = PLOT_GRID_NZ
      .width(:)       = PLOT_GRID_WIDTH
      .width(3)       = ZERO    ! assume a planar plot
      .del_x          = .width(1)/(PLOT_GRID_NX - 1)
      .del_y          = .del_x
      .del_z          = .del_x
      .x_width_set    = FALSE   ! These are set TRUE only if the widths
      .y_width_set    = FALSE   ! are explicitly read in
      .z_width_set    = FALSE
      .x_axis_defined = FALSE
      .y_axis_defined = FALSE
      .z_axis_defined = FALSE
      .desired_separation = ZERO
      .plot_units = " "
      .plot_format = " "
   end

   set_for_marching_cubes
   ! Update and set the grid data to be consistent with the
   ! (non-recursive) marching cubes algorithm. Essentially, a
   ! gridpoint is added along all dimensions.
      WARN("adjusting grid by adding 2 extra points on all sides")
      .n_x = .n_x + 2
      .n_y = .n_y + 2
      .n_z = .n_z + 2
      ENSURE(.n_x>=4,"not enough x points for marching cube isosurface algorithm")
      ENSURE(.n_y>=4,"not enough y points for marching cube isosurface algorithm")
      ENSURE(.n_z>=4,"not enough z points for marching cube isosurface algorithm")
      ! center remains the same, extra points added around edges
      .width(1)  = .width(1)  + 2*.del_x
      .width(2)  = .width(2)  + 2*.del_y
      .width(3)  = .width(3)  + 2*.del_z
      .origin = .origin - .del_x*.x_axis
      .origin = .origin - .del_y*.y_axis
      .origin = .origin - .del_z*.z_axis
      .n_pt = .n_x*.n_y*.n_z
   end

   set_atom_defaults(atom)
   ! Set up atom defaults. "atom" is used to define an xyz bounding
   ! box for the molecule. 
      atom :: VEC{ATOM}*
    ! destroy_atom :: BIN, optional

      if (associated(atom)) then
         .atom => atom
         .set_bbox_with_axes_reordered(atom)
      end

    ! if (present(destroy_atom)) &
    !    .destroy_atom = destroy_atom

   end

   set_bbox(atom)
   ! Set up a default bounding box based on the "atom" size.
   ! NOTE: This does not mark the widths as having been inputted.
   ! NOTE: The principle axes are arranged so they lie as close
   ! as possible to the original input x-y-z axes
   ! NOTE: this is set using the use_bounding_box= option
      atom :: VEC{ATOM}*

   ENSURE(associated(atom),"no atom list")

      .use_bounding_box = TRUE
      .box_centre   = atom.centre_of_atoms
      .bounding_box = atom.bounding_box
      .bounding_box = .box_scale_factor*.bounding_box

   end

   set_bbox_with_axes_reordered(atom)
   ! Set up a bounding box based on the "atom" list and ensure that
   ! the x-y-z axis widths x-y-z go longest to shortest.  
   ! NOTE: This is set with a use_bounding_box_and_axes= option.
      atom :: VEC{ATOM}*

   ENSURE(associated(atom),"no atom list")

      sm :: VEC{REAL}(3)
      sa :: MAT{REAL}(3,3)
      order :: VEC{INT}(3)

      .use_bounding_box = TRUE

      ! Make shape moments and axes; keep order
      atom.make_shape_moments(sm,sa)

      ! Make the x-axis the longest
      sm.quick_sort(order)

      ! Swap
      sa = sa(:,order)
      if (sa.determinant<ZERO) sa(:,3) = -sa(:,3)

      if (.debugging("set_bbox_with_axes_reordered")) then
         stdout.text("sm")
         stdout.put(sm,by_column=TRUE)
         stdout.text("sa")
         stdout.put(sa,by_column=TRUE)
         stdout.text("order")
         stdout.put(order,by_column=TRUE)
      end

      ! Set box axes/centre
      .box_axes     = sa
      .box_centre   = atom.centre_of_atoms

      ! Set bounding box 
      .bounding_box = atom.bounding_box(sa)
      .bounding_box = .box_scale_factor*.bounding_box

      if (.debugging("set_bbox_with_axes_reordered")) then
         stdout.text("bounding_box")
         stdout.put(.bounding_box,by_column=TRUE)
      end

   end

   set_points_widths_origin
   ! Set the number of points along the x axis to be odd. Evaluate the grid
   ! point separation .del_x from the current x_width, .width(1); from this
   ! separation, evaluate the number of points along the y and z axes; adjust
   ! the y and z widths to be an exact multiple of .del_x; finally,
   ! set the origin once the widths are known.

      ! Make # of x axis points odd ...
      .n_x = 2*(.n_x/2) + 1                

      if (.n_x>1) then
         .del_x = .width(1)/(.n_x-1)
         .del_y = .del_x
         .del_z = .del_x
      else if (.n_x==1) then
         .width = ZERO
      end

      ! Adjust y width to the nearest grid point
      .n_y  = nint(.width(2)/.del_x)
      .n_y = 2*(.n_y/2) + 1
      .width(2) = .del_x*(.n_y-1)          

      ! Adjust z width to the nearest grid point
      .n_z = nint(.width(3)/.del_x)
      .n_z = 2*(.n_z/2) + 1
      .width(3) = .del_x*(.n_z-1)          

      .n_pt = .n_x*.n_y*.n_z

      .set_origin

   end

   set_desired_separation(del)
   ! Set the (approximate) desired separation "del" between grid points along an
   ! axis direction.  The *actual* separation used may not be the inputted
   ! separation, but may be slightly smaller: the current .x_width is used to
   ! work out the number of points along the x_axis which is then used to work
   ! out the actual .del.  NOTE: After this routine the y and z widths are
   ! changed to be the nearest multiple of "del" (actually, ".del") that exceeds
   ! their current value.
      del :: REAL
   ENSURE(.n_x>1,"# of x_points must be greater than 1")
   ENSURE(del>0,"del must be positive")
      WARN_IF(NOT .x_width_set,"default x_width used to calculate # of x_points")
      .desired_separation = del
      .n_x = ceiling(.width(1)/del)
      .set_points_widths_origin
   end

   set_centre_from_atom_list(atom)
   ! Set the .centre of the grid data from an "atom" list. The .origin of the
   ! plot isd also set using the current plot widths and plot centre.
      atom :: VEC{ATOM}*
   ENSURE(atom.created,"atom list not present")
   ENSURE(.centre_atom/=0,"no centre_atom")
      .centre = atom(.centre_atom).position
      .set_origin
   end

   set_centre_from_offset
   ! Offset the .centre by .offset along the current axes.
      .centre = .centre + .offset(1)*.x_axis
      .centre = .centre + .offset(2)*.y_axis
      .centre = .centre + .offset(3)*.z_axis
      .set_origin
   end

   set_origin
   ! Set the origin of the plot (the bottom, front, left-hand corner). It is
   ! equal to the .centre of the plot minus half the (current) .widths along the
   ! (current) x, y, and z axes.
      .origin = .centre
      .origin = .origin -.width(1)*HALF*.x_axis
      .origin = .origin -.width(2)*HALF*.y_axis
      .origin = .origin -.width(3)*HALF*.z_axis
   end

   set_x_axis_from_atom_list(atom)
   ! Set the x-axis of the grid data from an "atom" list. If the .x_width has
   ! not been explicitly set, it is set to twice the length between the atom
   ! separation (because probably the user wants to see at least those atoms in
   ! his plot!).
      atom :: VEC{ATOM}*
   ENSURE(atom.created,"atom list not present")
   ENSURE(.x_atom_1/=0,"no x_atom_1")
   ENSURE(.x_atom_2/=0,"no x_atom_2")
      .x_axis = atom(.x_atom_2).position - atom(.x_atom_1).position
      if (NOT .x_width_set) then
         .width(1) = TWO*.x_axis.norm
         .set_points_widths_origin
      end
      .set_xyz_axes_from_x_axis
   end

   set_y_axis_from_atom_list(atom)
   ! Set the y-axis of the grid data from an "atom" list. If the .y_width has
   ! not been explicitly set, it is set to twice the length between the atom
   ! separation (because probably the user wants to see at least those atoms in
   ! his plot!).
      atom :: VEC{ATOM}*
   ENSURE(atom.created,"atom list not present")
   ENSURE(.y_atom_1/=0,"no y_atom_1")
   ENSURE(.y_atom_2/=0,"no y_atom_2")
      .y_axis = atom(.y_atom_2).position - atom(.y_atom_1).position
      if (NOT .y_width_set) then
         .width(2) = TWO*.y_axis.norm
         .set_points_widths_origin
      end
      .set_xyz_axes_from_y_axis
   end

   set_z_axis_from_atom_list(atom)
   ! Set the z-axis of the grid data from an "atom" list. If the .z_width has
   ! not been explicitly set, it is set to twice the length between the atom
   ! separation (because probably the user wants to see at least those atoms in
   ! his plot!).
      atom :: VEC{ATOM}*
   ENSURE(atom.created,"atom list not present")
   ENSURE(.z_atom_1/=0,"no z_atom_1")
   ENSURE(.z_atom_2/=0,"no z_atom_2")
      .z_axis = atom(.z_atom_2).position - atom(.z_atom_1).position
      if (NOT .z_width_set) then
         .width(3) = TWO*.z_axis.norm
         .set_points_widths_origin
      end
      .set_xyz_axes_from_z_axis
   end

   set_xyz_axes_from_x_axis
   ! Set the x,y,z axes of the grid given a new x_axis vector. Also set the
   ! origin since that is dependent on the axes.
   ENSURE(NOT .x_axis_defined,"x_axis already explicitly defined")
   ENSURE(NOT .y_axis_defined,"define x_axis before y_axis")
   WARN_IF(.z_axis_defined,"orthonormalising inputted x_axis and y_axis to z_axis")
      .x_axis.normalise
      if (.z_axis_defined) then; .orthonormalise_x_y_to_z_axis
      else;                      .orthonormalise_y_z_to_x_axis
      end
      .set_origin
   end

   set_xyz_axes_from_y_axis
   ! Set the x,y,z axes of the grid given a new y_axis vector. Also set the
   ! origin since that is dependent on the axes.
   ENSURE(NOT .y_axis_defined,"y_axis already explicitly defined")
   ENSURE(NOT .z_axis_defined,"can't set y_axis: z_axis and x_axis are already defined")
   WARN("y_axis is *always* orthonormalised to x_axis")
      .y_axis.normalise
      DIE_IF(.y_axis.same_as(.x_axis),"y_axis is the same as x_axis")
      .orthonormalise_y_z_to_x_axis
      .set_origin
   end

   set_xyz_axes_from_z_axis
   ! Set the x,y,z axes of the grid given a new z_axis vector. Also set the
   ! origin since that is dependent on the axes.
   ENSURE(NOT .z_axis_defined,"z_axis already explicitly defined")
   WARN_IF(.x_or_y_axes_defined,"inputted x_axis, y_axis to be orthonormalised to inputted z_axis")
      .z_axis.normalise
      .orthonormalise_x_y_to_z_axis
      .set_origin
   end

   orthonormalise_x_y_to_z_axis ::: private
   ! Orthogonalise the x and y axes to the z axis.
      dot :: REAL
      if (.x_axis.same_as(.z_axis)) &        
         .x_axis = .y_axis                   ! Make sure x and z are different
      dot = dot_product(.z_axis,.x_axis)     ! Orthogonalise x_axis to z_axis
      .x_axis = .x_axis - dot*.z_axis
      .x_axis.normalise
      DIE_IF(.x_axis.is_zero,"x_axis is same as z_axis!")
      .y_axis.to_cross_product_of(.z_axis,.x_axis)
   end

   orthonormalise_y_z_to_x_axis ::: private
   ! Orthogonalise the x and y axes to the z axis.
      dot :: REAL
      if (.y_axis.same_as(.x_axis)) &        
         .y_axis = .z_axis                   ! Make sure y and x are different
      dot = dot_product(.x_axis,.y_axis)     ! Orthogonalise y_axis to x_axis
      .y_axis = .y_axis - dot*.x_axis
      .y_axis.normalise
      DIE_IF(.y_axis.is_zero,"y_axis is same as x_axis!")
      .z_axis.to_cross_product_of(.x_axis,.y_axis)
   end

   set_bbox_from_unit_cell(unit_cell)
   ! Use the "unit_cell" to set the bounding box. This bounding box
   ! has equal numbers of divisions along each axis to allow for a
   ! recursive marching cube algorithm. This means that the
   ! separations along each axis may be different. Note that the axes
   ! may not be orthogonal.
      unit_cell :: UNIT_CELL, IN
      .box_axes = unit_cell.direct_matrix
      .centre = matmul(.box_axes,[HALF,HALF,HALF]+.offset)
      .width(1) = .box_axes(:,1).norm      ! Widths are unit cell side lenths
      .width(2) = .box_axes(:,2).norm
      .width(3) = .box_axes(:,3).norm      ! Normalise the box axes
      .box_axes(:,1) = .box_axes(:,1)/.width(1)
      .box_axes(:,2) = .box_axes(:,2)/.width(2)
      .box_axes(:,3) = .box_axes(:,3)/.width(3)
      .width = .box_scale_factor*.width    ! Scale by requested factor
      .x_axis = .box_axes(:,1)
      .y_axis = .box_axes(:,2)
      .z_axis = .box_axes(:,3)
      if (.desired_separation>ZERO) then
         .n_x = ceiling(.width(1)/.desired_separation)
         .n_y = ceiling(.width(2)/.desired_separation)
         .n_z = ceiling(.width(3)/.desired_separation)
      end
      .set_box_from_widths
   end

   set_box_from_widths
   ! Forces the number of points in the three directions to be even
   ! Calculates the separations from these.
      .n_x = 2*(.n_x/2) + 1
      .n_y = 2*(.n_y/2) + 1
      .n_z = 2*(.n_z/2) + 1
      .n_pt = .n_x*.n_y*.n_z
      if (.n_x>1) then
         .del_x = .width(1)/(.n_x-1)
      else if (.n_x==1) then
         .width = ZERO
      end
      if (.n_y>1) then
         .del_y = .width(2)/(.n_y-1)
      else if (.n_y==1) then
         .width = ZERO
      end
      if (.n_z>1) then
         .del_z = .width(3)/(.n_z-1)
      else if (.n_z==1) then
         .width = ZERO
      end
      .set_origin
   end

   set_cube_from_widths
   ! Set a plot grid which is a cube from the different widths for each
   ! axis (as specified). These means that the separations on each
   ! axis will be different. NOTE: that the axes need not be orthogonal.
      .n_x = 2*(.n_x/2) + 1               ! Make # of axis points odd ...
      .n_y = .n_x                         ! Set other points from x
      .n_z = .n_x                         ! Equal points in all directions
      .n_pt = .n_x*.n_y*.n_z
      if (.n_x>1) then
         .del_x = .width(1)/(.n_x-1) 
         .del_y = .width(2)/(.n_y-1) 
         .del_z = .width(3)/(.n_z-1) 
      else if (.n_x==1) then
         .width = ZERO
      end
      .set_origin
   end

!  ==============
!  Bond alignment
!  ==============

   use_bond_axis_as_z_axis
   ! Align the bond axis (given in .bond_density_atoms) onto the z
   ! axis. Also print the positions of the bond axis atoms B and A and
   ! the neighbouring atoms of atom A in anticlockwise direction,
   ! along with the atomic numbers and rotation angles.

      pos :: MAT{REAL}*
      Z   :: VEC{INT}*
      theta :: VEC{REAL}*
      i :: INT

      ! Get the positions
      .get_bond_atoms_on_z_axis(pos,Z,theta)

      ! Print the positions of the atoms A, B and
      ! neighbour atoms n1,n2, .... in anticlockwise order
      stdout.text("Rotated positions of atoms B, A, n1, n2 ...")
      stdout.text("relative to the plot origin")
      do i = 1,Z.dim
         stdout.put(pos(1,i))
         stdout.put(pos(2,i))
         stdout.put(pos(3,i))
         stdout.put(Z(i))
         stdout.put(theta(i))
         stdout.flush
      end

      ! Clean up
      theta.destroy
      Z.destroy
      pos.destroy

   end

   get_bond_atoms_on_z_axis(pos,Z,theta) ::: leaky
   ! Get "pos", the positions of the atoms on the bond axis, aligned
   ! so that the bond axis is on the z axis. The atom positions are in
   ! the order B, A, followed by the neighbours of atom A, in
   ! anticlockwise order. Also get the atomic numbers "Z"
   ! corresponding to the atom positions in "pos", and the
   ! corresponding rotation angles "theta" around the bond axis
   ! NOTE: the routine sets the plot width to be the AB bond length
   ! times the .box_scale_factor
      pos :: MAT{REAL}*
      Z   :: VEC{INT}*
      theta :: VEC{REAL}*

   ENSURE(.bond_density_atom.created,"no bond_density_atoms")
   ENSURE(.bond_density_atom.dim==3,"must have 3 bond_density_atoms")
   ENSURE(.x_atom_1/=0 AND .x_atom_2/=0,"must have x axis atoms")
   ENSURE(.atom.created,"must have a list of atoms")

      a,b,c,n,i :: INT
      x,y,d_max :: REAL
      na,order :: VEC{INT}*
      v :: VEC{REAL}(3)
      R :: MAT{REAL}(3,3)

      ! Get a, b, c atoms
      a = .bond_density_atom(1)
      b = .bond_density_atom(2)
      c = .bond_density_atom(3) ! this must be either a or b

      ! If the third bond atom c is equal to b, swap 
      ! a and b so that atom a has neighbours.
      if (c==b) then
         b = a
         a = c
      end

      ! Get the neighbours of A
      na => .atom.neighbours_of(a)

      ! Get the plot axes. First make the z axis
      .z_axis = .atom(b).position - .atom(a).position
      .z_axis.normalise

      ! Make the x axis orthogonal to z axis
      .x_axis = .atom(.x_atom_2).position - .atom(.x_atom_1).position
      .x_axis = .x_axis - dot_product(.x_axis,.z_axis)*.z_axis
      .x_axis.normalise

      ! Now make the y axis
      .y_axis = .z_axis.cross(.x_axis)

      ! Set the center of the plot to be atom a position
      .centre = .atom(a).position

      ! Get the plot with as 2 times the largest bond 
      ! length to the central atom a
    ! n = na.dim
    ! d_max = ZERO
    ! do i = 1,n
    !    d_max = max(d_max,.atom.bond_distance(a,na(i)))
    ! end
    ! .width(1) = 2*d_max
    ! .width(2) = 2*d_max
    ! .width(3) = 2*d_max

      ! Make the plot size 2 times the bond length
      d_max = .atom.bond_distance(a,b)
      .width(1) = .box_scale_factor*d_max
      .width(2) = .box_scale_factor*d_max
      .width(3) = .box_scale_factor*d_max

      .set_points_widths_origin
      .x_width_set = TRUE
      .y_width_set = TRUE
      .z_width_set = TRUE

      ! Remove atom B from the neighbours of A
      na.prune(b)

      ! Allocate space for positions, atomic numbers, angles
      n = na.dim
      pos.create(3,n+2)
      Z.create(n+2)
      theta.create(n)

      ! Get the cos and sin of the neighbours
      ! and sort into anticlockwise order
      order.create(n)
      if (n>0) then
         do i = 1,n
            v = .atom(na(i)).position - .atom(a).position
            v.normalise
            x = dot_product(v,.x_axis)
            y = dot_product(v,.y_axis)
            theta(i) = atan2(y,x)*DEGREE_PER_RADIAN
         end
         theta.quick_sort(order)
         theta = theta(order)
         na = na(order)
      end
      order.destroy

      ! Make the rotation matrix which rotates the bond
      ! axis to the z axis
      R(1,:) = .x_axis 
      R(2,:) = .y_axis 
      R(3,:) = .z_axis

      ! Get the rotated position of atom B
      v = .atom(b).position - .centre
      pos(:,1) = matmul(R,v)
      Z(1)     = .atom(b).atomic_number

      ! Get the rotated position of atom A
      v = .atom(a).position - .centre
      pos(:,2) = matmul(R,v)
      Z(2)     = .atom(a).atomic_number

      ! Get the rotated position of neighbours of atom A
      if (n>0) then
         do i = 1,n
            v = .atom(na(i)).position - .centre
            pos(:,i+2) = matmul(R,v)
            Z(i+2)     = .atom(na(i)).atomic_number
         end
      end

      ! Add the theta angles for the B and A atoms
      theta.prepend([ZERO,ZERO])

      ! Clean up
      na.destroy

   end

   align_to_bond
   ! Make the rotation matrix R which aligns the bond axis given in
   ! .bond_density_atoms along the z axis
   ! WARNING: do not set n_points in the input after this routine

      pos,pos0,pos0r,pos_keep :: MAT{REAL}*
      Z,Z0   :: VEC{INT}*
      theta,theta0 :: VEC{REAL}*
      x,y :: VEC{REAL}(3)
      R :: MAT{REAL}(3,3)
      found :: BIN
      word :: STR
      fac_z,fac_r,r_ab,r_ab0,d2,angle,a,b,c,dist2,an,top,bot :: REAL
      n,i,s :: INT

      ! Get the positions
      .get_bond_atoms_on_z_axis(pos,Z,theta)

      ! Print out again the bond atom positions
      stdout.text("Rotated positions of bond atoms B, A, n1, n2 ...(N')")
      do i = 1,Z.dim
         stdout.put(pos(1,i))
         stdout.put(pos(2,i))
         stdout.put(pos(3,i))
         stdout.put(Z(i))
         stdout.put(theta(i))
         stdout.flush
      end

      ! Get the number of atoms including A and B
      n = Z.dim
      ENSURE(n>1,"must have at least two atoms!")

      ! Create space for reference positions, atomic numbers,
      ! and angles
      pos0.create(3,n)
      Z0.create(n)
      theta0.create(n)

      ! Read in the reference positions we align to
      stdin.read(word)
      ENSURE(word=="{","missing open curly bracket?")
      do i = 1,n
         stdin.read(pos0(:,i))
         stdin.read(Z0(i))
         stdin.read(theta0(i))
      end
      stdin.read(word)
      ENSURE(word=="}","missing close curly bracket?")

      ! Print out again the reference positions
      stdout.text("Rotated positions of REFERENCE bond atoms ... (N0)")
      do i = 1,Z0.dim
         stdout.put(pos0(1,i))
         stdout.put(pos0(2,i))
         stdout.put(pos0(3,i))
         stdout.put(Z0(i))
         stdout.put(theta0(i))
         stdout.flush
      end

      ! Find the cyclic permutation shift that causes the atomic
      ! numbers Z to match the reference ones in Z0
      found = FALSE
      do s = 0,n-3
         if (any(cshift(Z(3:),s)/=Z0(3:))) cycle
         found = TRUE
         exit
      end
      DIE_IF(NOT found,"a matching shift was not found!")
      stdout.show("shift left/up      =",s)

      Z(3:)     = cshift(Z(3:),s)
      theta(3:) = cshift(theta(3:),s)
      pos(:,3:) = cshift(pos(:,3:),s,dim=2)

      pos_keep.create_copy(pos)

      ! Print out again the bond atom positions
      stdout.text("Cyclic shifted neighbour positions ...")
      do i = 1,Z.dim
         stdout.put(pos(1,i))
         stdout.put(pos(2,i))
         stdout.put(pos(3,i))
         stdout.put(Z(i))
         stdout.put(theta(i))
         stdout.flush
      end

      ! Work out at the optimum rotation angle which rotates N0 to N'
      a = sum((pos0(1,3:)*pos0(1,3:) + pos0(2,3:)*pos0(2,3:) + pos0(3,3:)*pos0(3,3:)) ) &
        + sum(( pos(1,3:)* pos(1,3:) +  pos(2,3:)* pos(2,3:) +  pos(3,3:)* pos(3,3:)) ) &
        - TWO*sum(pos(3,3:)*pos0(3,3:))
      b = -TWO*sum(pos(1,3:)*pos0(1,3:)) - TWO*sum(pos(2,3:)*pos0(2,3:))
      c = -TWO*sum(pos(2,3:)*pos0(1,3:)) + TWO*sum(pos(1,3:)*pos0(2,3:))
      angle = atan(c/b)
      stdout.show("a =",a)
      stdout.show("b =",b)
      stdout.show("c =",c)

      ! Does this have a negative second derivative?
      ! If not, add pi to the solution
      d2 = -b*cos(angle) - c*sin(angle)
      if (d2<ZERO) angle = angle + PI
      dist2 = a + b*cos(angle) + c*sin(angle)
      stdout.show("rotation angle converting reference to this geometry (degrees) =",angle*DEGREE_PER_RADIAN)
      stdout.show("distance2                                                      =",dist2)

      ! Now, rotate the x and y plot axes by the angle
      x =  cos(angle)*.x_axis + sin(angle)*.y_axis
      y = -sin(angle)*.x_axis + cos(angle)*.y_axis 
      .x_axis = x
      .y_axis = y

      ! Get the matrix which rotates reference (N0) 
      ! to this position (N')
      R(:,3) = [ZERO,ZERO,ONE]
      R(3,:) = [ZERO,ZERO,ONE]
      R(1,1) = cos(angle); R(1,2) = -sin(angle)
      R(2,1) = sin(angle); R(2,2) =  cos(angle)

      stdout.text("Matrix which rotates reference (N0) to this position (N'):")
      stdout.put(R)

      ! Print out again the bond atom positions
      ! and check squared distance
      stdout.text("Rotated neighbour positions (R^T N') which match scaled reference (N0)")
      pos = matmul(transpose(R),pos)
      dist2 = ZERO
      do i = 1,Z.dim
         stdout.put(pos(1,i))
         stdout.put(pos(2,i))
         stdout.put(pos(3,i))
         stdout.put(Z(i))
         if (i>2) then
         stdout.put(theta(i)-angle*DEGREE_PER_RADIAN)
         dist2 = dist2 + sum((pos(:,i) - pos0(:,i))*(pos(:,i)-pos0(:,i)))
         else
         stdout.put(theta(i))
         end
         stdout.flush
      end
      stdout.show("distance2 (should be same as above)                            =",dist2)

      ! Get the z scale factor which scales reference N0
      ! to *this* geonmetry N'
      r_ab  = pos(3,1)  - pos(3,2)
      r_ab0 = pos0(3,1) - pos0(3,2)
      fac_z = r_ab/r_ab0
      stdout.show("Z scale factor scaling N0 to N1 =",fac_z)

      ! Get the radial scale factor from the
      ! rotated reference atom positions
      if (n==2) then 
         fac_r = ONE        ! no neighbours
      else                  
         top = ZERO
         bot = ZERO
         do i = 3,n
            top = top + dot_product(pos0(1:2,i), pos(1:2,i))
            bot = bot + dot_product(pos0(1:2,i),pos0(1:2,i))
         end
         fac_r = top/bot
      end
      stdout.show("radial scale factor =",fac_r)

      ! Rotate and stretch reference positions "pos0" so they
      ! match this set of positions "pos"
      ! No need to rotate as the plot axes are rotated
      ! to simulate a rotation of this molecule

    ! pos0 = matmul(R,pos0)
      pos0r.create_copy(matmul(R,pos0))

      ! Scale pos0
      pos0(3  ,:) = pos0(3  ,:)*fac_z
      pos0(1:2,:) = pos0(1:2,:)*fac_r

      ! Scale pos0r
      pos0r(3  ,:) = pos0r(3  ,:)*fac_z
      pos0r(1:2,:) = pos0r(1:2,:)*fac_r

      ! Now, scale the radial plot widths to match 
      ! the reference positions
      .width(1) = .width(1)*fac_r
      .width(2) = .width(2)*fac_r
      .width(3) = .width(3)
      .x_width_set = TRUE
      .y_width_set = TRUE
      .z_width_set = TRUE
      
      ! Make sure axes widths, etc, are OK. Checked.
      ! This grid has unequal spacings in z, y and x
      ! WARNING: do not set n_points after this routine
    ! .set_points_widths_origin
      .n_x = 2*(.n_x/2) + 1           
      if (.n_x>1) then
         .del_x = .width(1)/(.n_x-1)
         .del_y = .width(2)/(.n_y-1)
         .del_z = .width(3)/(.n_z-1)
      else if (.n_x==1) then
         .width = ZERO
      end
      .n_pt = .n_x*.n_y*.n_z
      .set_origin

      ! Print out the scaled reference atom positions
      ! "pos0" in cube file format ...
      stdout.text("Scaled, rotated reference positions (R N0) which match original positions (N')")
      stdout.text("Place these in the cube file")
      stdout.save                    ! Save settings
      stdout.set_real_style("e")     ! Gaussian format
      stdout.set_real_width(13)
      stdout.set_real_precision(5)
      dist2 = ZERO
      do i = 1,Z.dim
         stdout.put(Z0(i))           ! Z
         an = Z0(i)
         stdout.put(an,precision=1)  ! Charge
         stdout.put(pos0(1,i))       ! Pos in plot grid axis system
         stdout.put(pos0(2,i))
         stdout.put(pos0(3,i))
         stdout.flush
         if (i>2) then
         dist2 = dist2 + sum((pos0r(:,i) - pos_keep(:,i))*(pos0r(:,i)-pos_keep(:,i)))
         end
      end
      stdout.unsave                  ! Put back settings
      stdout.show("distance2 (should be smaller than above)                       =",dist2)

      ! Clean up
      theta0.destroy; Z0.destroy; pos0.destroy; pos0r.destroy
      theta.destroy;  Z.destroy;  pos.destroy; pos_keep.destroy

   end

!  ==============
!  Atom positions
!  ==============

   get_rotoranged_atom_positions(math_pos,z_range,valid) ::: leaky
   ! Calculate the positions "math_pos" of the valid atoms which have
   ! been rotated and shifted and scaled into grid point coordinates.
   ! Valid atoms are those which are within "z_range" of the plot
   ! plane; the indices of the valid atoms are stored in "valid"
      math_pos :: MAT{REAL}*
      z_range :: REAL, IN
      valid :: VEC{INT}*
   ENSURE(.atom.created,"no atoms!")
   ENSURE(z_range>ZERO,"z_range must be non-negative")
   ENSURE(valid.destroyed,"valid array already allocated")

      scale_factor :: VEC{REAL}(3)
      tr :: MAT{REAL}(3,3)
      pos :: MAT{REAL}*
      n,nv,a,i :: INT

      ! Get shifted atom positions
      n = .atom.dim
      pos.create(n,3)
      do a = 1, n
         pos(a,:) = .atom(a).position - .origin    !shift
      end

      ! Rotate positions into plot grid axis
      tr = .transposed_plot_axes
      do a = 1, n
         pos(a,:) = matmul(tr,pos(a,:))
      end

      ! Reject atoms far from plot plane, get valid atoms
      valid.create(0)
      do a = 1, n
        ! if ( abs(pos(a,z)) > z_range) cycle
         if ( abs(pos(a,3)) > z_range) cycle
         valid.append(a)
      end

      ! Create list of valid atoms positions
      nv = valid.dim
      math_pos.create(nv,3)
      i = 0
      do a = 1, n
         if ( abs(pos(a,3)) > z_range) cycle
         i = i + 1
         math_pos(i,:) = pos(a,:)
      end

      ! Finally, scale positions
      scale_factor(1) = (.n_x - ONE) / .width(1)
      scale_factor(2) = (.n_y - ONE) / .width(2)
      scale_factor(3) = ZERO 
      do a = 1,nv
         math_pos(a,:) = scale_factor * math_pos(a,:) + ONE ! since plot begins at 1
      end

      pos.destroy

   end

!  ===============
!  Inquiry methods
!  ===============

   atom_data_used result (res)
   ! Return TRUE if atom-based data was used to specify plot axes.
      res :: BIN
      res = .centre_atoms.created OR .x_atom_1/=0 OR .y_atom_1 /=0
   end

   x_or_y_axes_defined result (res)
   ! Return TRUE if either the x or y axes have been explicitly inputted.
      res :: BIN
      res = .x_axis_defined OR .y_axis_defined
   end

   plot_axes result (res)
   ! Return the plot axes as a matrix.
      res :: MAT{REAL}(3,3)
      res(:,1) = .x_axis 
      res(:,2) = .y_axis 
      res(:,3) = .z_axis 
   end

   has_orthogonal_plot_axes result (res)
   ! Return TRUE if the plot axes are orthogonal
      res :: BIN
      dot :: REAL
      dot = dot_product(.x_axis,.y_axis)
      res = dot.is_zero
      if (NOT res) return
      dot = dot_product(.x_axis,.z_axis)
      res = dot.is_zero
      if (NOT res) return
      dot = dot_product(.y_axis,.z_axis)
      res = dot.is_zero
   end

   has_equal_spacing result (res)
   ! Return TRUE if the plot spacings are all equal
      res :: BIN
      res = .del_x.equals(.del_y)
      if (NOT res) return
      res = .del_x.equals(.del_z)
      if (NOT res) return
      res = .del_y.equals(.del_z)
   end

   transposed_plot_axes result (res)
   ! Return the transposed plot axis matrix.
      res :: MAT{REAL}(3,3)
      res(1,:) = .x_axis 
      res(2,:) = .y_axis 
      res(3,:) = .z_axis 
   end

!  =============
!  Input methods
!  =============

   read_keywords ::: get_from(OBJECT), leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR

      word :: STR
      
      word = keyword
      word.to_lower_case

      select case (word)
         case ("}                         ")  ! exit case
         case ("align_to_bond=            "); .align_to_bond
         case ("bond_density_atoms=       "); .read_bond_density_atoms
         case ("box_scale_factor=         "); .read_box_scale_factor
         case ("centre=                   "); .read_centre
         case ("centre_atom=              "); .read_centre_atom
         case ("centre_atoms=             "); .read_centre_atoms
         case ("crystal_plane=            "); .read_z_axis
         case ("cube_scale_factor=        "); .read_cube_scale_factor
         case ("debug_off                 "); .read_debug_off
         case ("debug_on                  "); .read_debug_on
         case ("desired_separation=       "); .read_desired_separation
         case ("homo_orbital_plus=        "); .read_HOMO_orbital_plus
         case ("homo_orbital_minus=       "); .read_HOMO_orbital_minus
         case ("kind=                     "); .read_kind
         case ("lumo_orbital_plus=        "); .read_LUMO_orbital_plus
         case ("max_x_points=             "); .read_max_x_points
         case ("min_x_points=             "); .read_min_x_points
         case ("n_points=                 "); .read_x_points
         case ("normal=                   "); .read_z_axis
         case ("offset=                   "); .read_offset
         case ("orbital=                  "); .read_orbital
         case ("plot_format=              "); .read_plot_format
         case ("plot_max=                 "); .read_plot_max
         case ("plot_min=                 "); .read_plot_min
         case ("plot_units=               "); .read_plot_units
         case ("projection_direction=     "); .read_projection_direction
         case ("put                       "); .put
         case ("units=                    "); .read_units
         case ("use_bbox                  "); .use_bbox_with_axes_reordered
         case ("use_bbox_axes_reordered   "); .use_bbox_with_axes_reordered
         case ("use_bcube                 "); .use_bcube                
         case ("use_bond_axis_as_z_axis   "); .use_bond_axis_as_z_axis
         case ("use_bounding_box          "); .use_bbox_with_axes_reordered
         case ("use_bounding_box_and_axes "); .use_bbox_with_axes_reordered
         case ("use_bounding_cube         "); .use_bcube
         case ("use_plot_max=             "); .read_use_plot_max
         case ("use_plot_min=             "); .read_use_plot_min
         case ("use_unit_cell_as_bbox     "); .use_unit_cell_as_bbox = TRUE
         case ("x_axis=                   "); .read_x_axis
         case ("x_axis_atoms=             "); .read_x_axis_atoms
         case ("x_axis_atom_list=         "); .read_x_axis_atom_list
         case ("x_points=                 "); .read_x_points
         case ("x_width=                  "); .read_x_width
         case ("y_axis=                   "); .read_y_axis
         case ("y_axis_atoms=             "); .read_y_axis_atoms
         case ("y_axis_atom_list=         "); .read_y_axis_atom_list
         case ("y_width=                  "); .read_y_width
         case ("z_axis=                   "); .read_z_axis
         case ("z_width=                  "); .read_z_width
         case default;                    UNKNOWN(word)
      end

   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_plot_units 
   ! Read the units to which the plot should be converted to.
      stdin.read(.plot_units)
      .plot_units.to_lower_case
      ENSURE(.plot_units.is_known_unit,"unknown unit specified")
   end

   read_plot_format
   ! Read the units to which the plot should be converted to.
      stdin.read(.plot_format)
      .plot_format.to_lower_case
      select case (.plot_format)
         case ("all")
         case ("contour")
         case ("cube")
         case ("drishti")
         case ("gnuplot")
         case ("gaussian")
         case ("gaussian.cube")
         case ("mathematica")
         case ("vapor")
         case ("vtk")
         case ("xcrysden")
         case ("xdgraph")
         case default; UNKNOWN(.plot_format)
      end
   end

   read_plot_max
   ! Read the plot maximum to use
      stdin.read_quantity(.plot_max)
      .use_plot_max = TRUE
   end

   read_plot_min
   ! Read the plot minimum to use
      stdin.read_quantity(.plot_min)
      .use_plot_min = TRUE
   end

   read_use_plot_max
   ! Read whether to use the plot maximum
      stdin.read(.use_plot_max)
   end

   read_use_plot_min
   ! Read whether to use the plot minimum
      stdin.read(.use_plot_min)
   end

   read_kind
   ! Read in the plot kind
      stdin.read(.plot_kind)
      .plot_kind.to_lower_case
   end

   read_desired_separation
   ! Read the (approximate) desired separation between grid points along an axis
   ! direction.  The number of x points for the plot is adjusted so that the
   ! *actual* separation is less than the inputted separation. NOTE: the current
   ! .x_width is used to calculate the number of points.
   ENSURE(.n_x>1,"# of x_points must be greater than 1")
      del :: REAL
      WARN_IF(NOT .x_width_set,"default x_width used to calculate # of x_points")
      stdin.read_quantity(del)
      .set_desired_separation(del)
   end

   read_max_x_points
   ! Read the *maximum number* of x points to be used for the plot. 
   ! The number of points is adjusted to be no more than this.
      max_n_x :: INT
      stdin.read(max_n_x)
      if (.n_x<=max_n_x) return
      .n_x = max_n_x
      WARN_IF(.n_x.is_even,"resetting to nearest odd number")
      .set_points_widths_origin
   end

   read_min_x_points
   ! Read the *minimum number* of x points to be used for the plot. 
      min_n_x :: INT
      stdin.read(min_n_x)
      if (min_n_x<=.n_x) return
      .n_x = min_n_x
      WARN_IF(.n_x.is_even,"resetting to nearest odd number")
      .set_points_widths_origin
   end

   read_x_points
   ! Read the number of x points for the plot. This is the precision
   ! of the plot.
      stdin.read(.n_x)
      ENSURE( .n_x>0,"number of x_points must be positive")
      WARN_IF(.n_x.is_even,"resetting to nearest odd number")
      .set_points_widths_origin
   end

   read_offset
   ! Read a 3-vector, used to offset the plot along.
      stdin.read_quantity(.offset)
      .set_centre_from_offset
   end

   read_orbital
   ! Read the orbital to plot out
      stdin.read(.orbital)
   end

   read_HOMO_orbital_plus
   ! Read the HOMO orbital to plot out. This is actually the index "n", where
   ! the orbital plotted out is "HOMO+n". The default value for n is 0, i.e. the
   ! HOMO is plotted out.
      stdin.read(.HOMO_orbital)
      ENSURE(.HOMO_orbital<=0,"HOMO orbital must be less than or equal to zero")
   end

   read_HOMO_orbital_minus
   ! Read the minus HOMO orbital to plot out. This actually the index "n" where
   ! the orbital to be plotted out is "HOMO-n". The default value for n is 0,
   ! i.e. the HOMO is plotted out.
      orb :: INT
      stdin.read(orb)
      .HOMO_orbital = -orb
      ENSURE(.HOMO_orbital<=0,"HOMO orbital must be less than or equal to zero")
   end

   read_LUMO_orbital_plus
   ! Read the LUMO orbital to plot out. This is actually the index "n" where the
   ! orbital to be plotted out is "LUMO+n". The default value of n is -1, and
   ! the HOMO is plotted out by default; if thgis routine is called then the
   ! value must be non-zero and we know that the LUMO value was set.
      stdin.read(.LUMO_orbital)
      ENSURE(.LUMO_orbital>=0,"LUMO orbital must be greater than or equal to zero")
      .HOMO_orbital = .LUMO_orbital + 1
   end

   read_centre_atom
   ! Read the centre atom of the plot
      stdin.read(.centre_atom)
      .set_centre_from_atom_list(.atom)
   end

   read_centre_atoms ::: leaky
   ! Make the centre of the plot to be the centre of the list of atom indices.
   ENSURE(.atom.created,"atom list not present")
      i,n :: INT

      ! Read the centre atoms list (leaky)
      .centre_atoms.destroy
      stdin.read_ptr(.centre_atoms)
      ENSURE(.centre_atoms.dim>0,"no atoms specified in input")

      ! Get the centre
      .centre = ZERO
      n = .centre_atoms.dim
      do i = 1,n
         .centre = .centre + .atom(.centre_atoms(i)).position
      end
      .centre = .centre/REALIFY(n)

      ! Set the origin
      .set_origin

   end

   read_centre
   ! Read the centre position of the plot. Also adjust the origin of the plot.
      stdin.read_quantity(.centre)
      .set_origin
   end

   read_x_axis
   ! Read the x axis vector of the plot. Normally, the y and z axes are defined
   ! to be orthogonal to the inputted axes, based on the defualt axis settings.
   ! However, if the z axis has been explicitly defined before hand, then the x
   ! and y axes are orthogonalised to it.
      stdin.read(.x_axis)
      .set_xyz_axes_from_x_axis
      .x_axis_defined = TRUE
   end

   read_x_axis_atoms
   ! Read the atoms which define the x axis vector of the plot. If the z axis
   ! has been defined, then the x_axis is orthogonalised to it. Otherwise the y
   ! and z axes are orthogonalised to this vector.
      stdin.read(.x_atom_1)
      stdin.read(.x_atom_2)
      DIE_IF(.x_atom_1==.x_atom_2,"cannot specify same x axis atoms")
      .set_x_axis_from_atom_list(.atom)
      .x_axis_defined = TRUE
   end

   read_x_axis_atom_list
   ! Make the x-axis along the mean of two lists of atoms.
   ENSURE(.atom.created,"atom list not present")
      atom_list :: VEC{INT}*
      pos1,pos2 :: VEC{REAL}(3)
      i :: INT

      stdin.read_ptr(atom_list)
      ENSURE(atom_list.dim>0,"no atoms specified in input")

      pos1 = ZERO
      do i=1,atom_list.dim
         pos1 = pos1 + .atom(atom_list(i)).position
      end
      pos1 = pos1/atom_list.dim
      atom_list.destroy

      stdin.read_ptr(atom_list)
      ENSURE(atom_list.dim>0,"no atoms specified in input")

      pos2 = ZERO
      do i=1,atom_list.dim
         pos2 = pos2 + .atom(atom_list(i)).position
      end
      pos2 = pos2/atom_list.dim
      atom_list.destroy

      .x_axis = pos2 - pos1

      if (NOT .x_width_set) then
         .width(1) = TWO*.x_axis.norm
         .set_points_widths_origin
      end
      .set_xyz_axes_from_x_axis

      .x_axis_defined = TRUE
   end

   read_y_axis
   ! Read the y axis vector of the plot. It is an error to use this command if
   ! the .z_axis has already been inputted, because the .y_axis is made
   ! orthogonal to the x_axis and z_axis. Even if the z_axis has not been
   ! defined, the y_axis is made orthogonal to the x_axis.
      stdin.read(.y_axis)
      .set_xyz_axes_from_y_axis
      .y_axis_defined = TRUE
   end

   read_y_axis_atoms
   ! Read the atoms which define the y axis vector of the plot. It is an error
   ! to use this command if the .z_axis has already been inputted, because the
   ! .y_axis is made orthogonal to the x_axis and z_axis. Even if the z_axis has
   ! not been
      stdin.read(.y_atom_1)
      stdin.read(.y_atom_2)
      DIE_IF(.y_atom_1==.y_atom_2,"cannot specify same y axis atoms")
      .set_y_axis_from_atom_list(.atom)
      .y_axis_defined = TRUE
   end

   read_y_axis_atom_list
   ! Make the y-axis along the mean of two lists of atoms.
   ENSURE(.atom.created,"atom list not present")
      atom_list :: VEC{INT}*
      pos1,pos2 :: VEC{REAL}(3)
      i :: INT

      stdin.read_ptr(atom_list)
      ENSURE(atom_list.dim>0,"no atoms specified in input")

      pos1 = ZERO
      do i=1,atom_list.dim
         pos1 = pos1 + .atom(atom_list(i)).position
      end
      pos1 = pos1/atom_list.dim
      atom_list.destroy

      stdin.read_ptr(atom_list)
      ENSURE(atom_list.dim>0,"no atoms specified in input")

      pos2 = ZERO
      do i=1,atom_list.dim
         pos2 = pos2 + .atom(atom_list(i)).position
      end
      pos2 = pos2/atom_list.dim
      atom_list.destroy

      .y_axis = pos2 - pos1

      if (NOT .y_width_set) then
         .width(2) = TWO*.y_axis.norm
         .set_points_widths_origin
      end
      .set_xyz_axes_from_y_axis

      .y_axis_defined = TRUE

   end

   read_z_axis
   ! Read the z axis of the plot. NOTE: If it is inputted, the current x and y
   ! axes are made orthogonal to it.
      stdin.read(.z_axis)
      .set_xyz_axes_from_z_axis
      .z_axis_defined = TRUE
   end

   read_z_axis_atoms
   ! Read the atoms which define the z axis vector of the plot. 
      stdin.read(.z_atom_1)
      stdin.read(.z_atom_2)
      DIE_IF(.z_atom_1==.z_atom_2,"cannot specify same z axis atoms")
      .set_z_axis_from_atom_list(.atom)
      .z_axis_defined = TRUE
   end

   read_x_width
   ! Read the x width of the plot
      stdin.read_quantity(.width(1))
      .set_points_widths_origin
      .x_width_set = TRUE
   end

   read_y_width
   ! Read the y width of the plot
      stdin.read_quantity(.width(2))
      .set_points_widths_origin
      .y_width_set = TRUE
   end

   read_z_width
   ! Read the z width of the plot. This is normally 0.
      stdin.read_quantity(.width(3))
      .set_points_widths_origin
      .z_width_set = TRUE
   end

   read_bond_density_atoms ::: leaky
   ! Read bond density atoms
      n_atom :: INT

      .bond_density_atom.destroy
      stdin.read_ptr(.bond_density_atom)

      ! Check
      n_atom = .bond_density_atom.dim
      ENSURE(n_atom>=1 AND n_atom<=3,"wrong length for bond_density_atoms")
      if (n_atom==3) then
      ENSURE(any(.bond_density_atom(1:2)==.bond_density_atom(3)),"third atom does not match one of the first two")
      end

   end

   read_box_scale_factor
   ! Read the bounding box scale factor and apply it immediately.
      stdin.read(.box_scale_factor)
      ENSURE(.box_scale_factor>ZERO,"scale factor not positive")
      .use_bbox_with_axes_reordered
   end

   read_cube_scale_factor
   ! Read the bounding box scale factor and apply it immediately.
      stdin.read(.box_scale_factor)
      ENSURE(.box_scale_factor>ZERO,"scale factor not positive")
      .use_bcube
   end

   read_projection_direction
   ! Read the directionb to prject the vectors onto
      stdin.read(.projection_direction)
      .projection_direction.normalise
   end

!  ============
!  Bounding box
!  ============

   set_box_scale_factor(factor)
   ! Set the bounding box scale factor
      factor :: REAL
      .box_scale_factor = factor
      ENSURE(.box_scale_factor>ZERO,"scale factor not positive")
   end

!   use_bbox
!   ! Use the default bounding box centre and bounding box widths.
!      .set_bbox(.atom)
!      .centre = .box_centre
!      .width  = .bounding_box
!      .set_points_widths_origin
!   end

   use_bbox_with_axes_reordered
   ! Use the default bounding box centre, bounding box axes, and
   ! bounding box widths.
       .set_bbox_with_axes_reordered(.atom)
       .centre = .box_centre
       .width  = .bounding_box
       .x_axis = .box_axes(:,1)
       .y_axis = .box_axes(:,2)
       .z_axis = .box_axes(:,3)
       .set_points_widths_origin
   end

   use_bcube
   ! Use the default bounding box centre, bounding box axes, and
   ! bounding box widths.
       .set_bbox(.atom)
       .centre = .box_centre
       .width  = maxval(.bounding_box)
       .x_axis = .box_axes(:,1)
       .y_axis = .box_axes(:,2)
       .z_axis = .box_axes(:,3)
       .set_points_widths_origin
   end

!   use_unit_cell_as_bbox
!   ! Use the unit cell as the bounding box.  This sets a switch and
!   ! the axes must be obtained afterwards from a supplied cell.
!       .use_unit_cell_as_bbox = TRUE
!   end

!   widths_were_set result (res)
!   ! Return TRUE if any of the widths were inputted.
!      res :: BIN
!      res =  .x_width_set &
!          OR .y_width_set &
!          OR .z_width_set
!   end

!   read_crystal_plane(in,unit_cell)
!   ! To read in a vector which describes a plane in the crystal.
!   ! The vector is the normal of the plane.
!     in :: INPUT
!     unit_cell :: UNIT_CELL, IN
!     in.read( .z_axis )
!     .z_axis.rotate(unit_cell.cell_matrix)
!     .z_axis.normalise
!     .x_axis.normalise
!     .y_axis.to_cross_product_of( .z_axis, .x_axis)
!     .y_axis.normalise
!     .x_axis.to_cross_product_of( .y_axis, .z_axis)
!     .x_axis.normalise
!   end

!  ================
!  Make grid points
!  ================

   make_points(x_pt,y_pt,z_pt)
   ! Make a list of the grid points
      self :: IN
      x_pt,y_pt,z_pt :: VEC{REAL}, OUT
   ENSURE( size(x_pt) == .n_pt, "array of points not correct size")
   ENSURE( size(y_pt) == .n_pt, "array of points not correct size")
   ENSURE( size(z_pt) == .n_pt, "array of points not correct size")
      x1,x2,x3,y1,y2,y3,z1,z2,z3 :: REAL
      ox,oy,oz :: REAL
      ix,iy,iz,i_pt,t2,t3 :: INT
      ox = .origin(1);      oy = .origin(2);      oz = .origin(3)
      x1 = .del_x*.x_axis(1); x2 = .del_x*.x_axis(2); x3 = .del_x*.x_axis(3)
      y1 = .del_y*.y_axis(1); y2 = .del_y*.y_axis(2); y3 = .del_y*.y_axis(3)
      z1 = .del_z*.z_axis(1); z2 = .del_z*.z_axis(2); z3 = .del_z*.z_axis(3)
      t2 = .n_x*.n_y
      do i_pt = 1,.n_pt
         iz = (i_pt-1)/t2
         t3 = i_pt - iz*t2
         iy = (t3-1)/.n_x
         ix = t3 - iy*.n_x - 1
         x_pt(i_pt) = ox + ix*x1 + iy*y1 + iz*z1
         y_pt(i_pt) = oy + ix*x2 + iy*y2 + iz*z2
         z_pt(i_pt) = oz + ix*x3 + iy*y3 + iz*z3
      end
   end

   make_points(pt,first_pt,last_pt)
   ! Return a list of the grid points in "pt". Will return a subset of the grid
   ! points from "first_pt" to "last_pt", if these options are provided.
      self :: IN
      first_pt,last_pt :: INT, IN, optional
      pt :: MAT{REAL}, OUT
   ENSURE(.n_x/=0,"zero number of x points")
   ENSURE(.n_y/=0,"zero number of y points")
      x1,x2,x3,y1,y2,y3,z1,z2,z3 :: REAL
      ox,oy,oz :: REAL
      ix,iy,iz,i_pt,first,last,t2,t3 :: INT
      first = 1;          last = size(pt,1)
      if (present(first_pt))     first = first_pt
      if (present(last_pt))      last  = last_pt
      ox = .origin(1);      oy = .origin(2);      oz = .origin(3)
      x1 = .del_x*.x_axis(1); x2 = .del_x*.x_axis(2); x3 = .del_x*.x_axis(3)
      y1 = .del_y*.y_axis(1); y2 = .del_y*.y_axis(2); y3 = .del_y*.y_axis(3)
      z1 = .del_z*.z_axis(1); z2 = .del_z*.z_axis(2); z3 = .del_z*.z_axis(3)
      t2 = .n_x*.n_y
      do i_pt = first,last
         iz = (i_pt-1)/t2
         t3 = i_pt - iz*t2
         iy = (t3-1)/.n_x
         ix = t3 - iy*.n_x - 1
         pt(i_pt,1) = ox + ix*x1 + iy*y1 + iz*z1
         pt(i_pt,2) = oy + ix*x2 + iy*y2 + iz*z2
         pt(i_pt,3) = oz + ix*x3 + iy*y3 + iz*z3
      end
   end

   make_points(pt,fx,lx,fy,ly,fz,lz)
   ! Return a list of the grid points in "pt" in grid xyz order, starting from
   ! the first and last x, y, and z points: "fx", "lx", "fy", "ly", "fz", "lz"
   ! respectively
      self :: IN
      pt :: MAT{REAL}, OUT
      fx,lx,fy,ly,fz,lz :: INT, IN
   ENSURE(pt.dim1==(lx-fx+1)*(ly-fy+1)*(lz-fz+1),"wrong 1st dimension, pt")
   ENSURE(pt.dim2==3,"wrong 2nd dimension, pt")
      x1,x2,x3,y1,y2,y3,z1,z2,z3 :: REAL
      ox,oy,oz :: REAL
      x,y,z,ix,iy,iz,i_pt :: INT
      ox = .origin(1);      oy = .origin(2);      oz = .origin(3)
      x1 = .del_x*.x_axis(1); x2 = .del_x*.x_axis(2); x3 = .del_x*.x_axis(3)
      y1 = .del_y*.y_axis(1); y2 = .del_y*.y_axis(2); y3 = .del_y*.y_axis(3)
      z1 = .del_z*.z_axis(1); z2 = .del_z*.z_axis(2); z3 = .del_z*.z_axis(3)
      i_pt = 0
      do z = fz,lz
      do y = fy,ly
      do x = fx,lx
         ix = x - 1
         iy = y - 1
         iz = z - 1
         i_pt = i_pt + 1
         pt(i_pt,1) = ox + ix*x1 + iy*y1 + iz*z1
         pt(i_pt,2) = oy + ix*x2 + iy*y2 + iz*z2
         pt(i_pt,3) = oz + ix*x3 + iy*y3 + iz*z3
      end
      end
      end
   end

   point(x,y,z) result (res)
   ! Return one particular point "res" of the grid, given by grid coordinates
   ! "x", "y", and "z". (1,1,1) is the bottom (front) left hand corner.
      self  :: IN
      x,y,z :: INT, IN
      res   :: VEC{REAL}(3)
      x1,x2,x3,y1,y2,y3,z1,z2,z3,ox,oy,oz :: REAL
      ix,iy,iz :: INT
      ox = .origin(1);      oy = .origin(2);      oz = .origin(3)
      x1 = .del_x*.x_axis(1); x2 = .del_x*.x_axis(2); x3 = .del_x*.x_axis(3)
      y1 = .del_y*.y_axis(1); y2 = .del_y*.y_axis(2); y3 = .del_y*.y_axis(3)
      z1 = .del_z*.z_axis(1); z2 = .del_z*.z_axis(2); z3 = .del_z*.z_axis(3)
      ix = x - 1
      iy = y - 1
      iz = z - 1
         res(1) = ox + ix*x1 + iy*y1 + iz*z1
         res(2) = oy + ix*x2 + iy*y2 + iz*z2
         res(3) = oz + ix*x3 + iy*y3 + iz*z3
   end

!   make_cube_of_points(p,x,y,z) ::: public
!   ! Return a cube of 8 grid points "p", where the bottom (front) left hand
!   ! corner point has grid coordinates "x", "y", and "z". 
!      self  :: IN
!      p :: MAT4{REAL}(3,0:1,0:1,0:1)
!      x,y,z :: INT
!      x1,x2,x3,y1,y2,y3,z1,z2,z3,ox,oy,oz :: REAL
!      ix,iy,iz :: INT
!      x1 = .del_x*.x_axis(1); x2 = .del_x*.x_axis(2); x3 = .del_x*.x_axis(3)
!      y1 = .del_y*.y_axis(1); y2 = .del_y*.y_axis(2); y3 = .del_y*.y_axis(3)
!      z1 = .del_z*.z_axis(1); z2 = .del_z*.z_axis(2); z3 = .del_z*.z_axis(3)
!      ix = x - 1
!      iy = y - 1
!      iz = z - 1
!      ox = .origin(1) + ix*x1 + iy*y1 + iz*z1 ! cube origin
!      oy = .origin(2) + ix*x2 + iy*y2 + iz*z2
!      oz = .origin(3) + ix*x3 + iy*y3 + iz*z3
!      do iz = 0,1
!      do iy = 0,1
!      do ix = 0,1
!         p(1,ix,iy,iz) = ox + ix*x1 + iy*y1 + iz*z1
!         p(2,ix,iy,iz) = oy + ix*x2 + iy*y2 + iz*z2
!         p(3,ix,iy,iz) = oz + ix*x3 + iy*y3 + iz*z3
!      end
!      end
!      end
!   end

   make_cube_of_points(p,f,l,del_x,del_y,del_z,x,y,z,eval) ::: public
   ! Return a cube of points "p" where the cube edge points start from
   ! index "f" and end at index "l", and each point separated by
   ! distance "del_x", "del_y", "del_z" along a grid axis direction
   ! (these are *not* the same as the grid .del's).  The (0,0,0) point
   ! of the cube "p" corresponds to the plot grid coordinates "x", "y",
   ! "z", which are numbered from 0 (normally the first point is
   ! numbered from 1; these are grid coords in .del_x, .dely, .del_z).
   ! The axes of the cube are given by the plot grid axes. 
      self  :: IN
      f,l,x,y,z :: INT, IN
      p :: MAT{REAL}(3,*)
      del_x,del_y,del_z :: REAL, IN
      eval :: VEC{BIN}(*), optional

      x1,x2,x3,y1,y2,y3,z1,z2,z3,ox,oy,oz :: REAL
      ix,iy,iz,k :: INT

      ! Plot grid axes times plot grid del's
      x1 = .del_x*.x_axis(1); x2 = .del_x*.x_axis(2); x3 = .del_x*.x_axis(3)
      y1 = .del_y*.y_axis(1); y2 = .del_y*.y_axis(2); y3 = .del_y*.y_axis(3)
      z1 = .del_z*.z_axis(1); z2 = .del_z*.z_axis(2); z3 = .del_z*.z_axis(3)

      ! Cube origin in plotrgrid coords
      ox = .origin(1) + x*x1 + y*y1 + z*z1 
      oy = .origin(2) + x*x2 + y*y2 + z*z2
      oz = .origin(3) + x*x3 + y*y3 + z*z3

      ! Plotgrid axes times cube del's
      x1 = del_x*.x_axis(1); x2 = del_x*.x_axis(2); x3 = del_x*.x_axis(3) ! 
      y1 = del_y*.y_axis(1); y2 = del_y*.y_axis(2); y3 = del_y*.y_axis(3)
      z1 = del_z*.z_axis(1); z2 = del_z*.z_axis(2); z3 = del_z*.z_axis(3)

      if (NOT present(eval)) then
         k = 0
         do iz = f,l
         do iy = f,l
         do ix = f,l
            k = k + 1
            p(1,k) = ox + ix*x1 + iy*y1 + iz*z1
            p(2,k) = oy + ix*x2 + iy*y2 + iz*z2
            p(3,k) = oz + ix*x3 + iy*y3 + iz*z3
         end
         end
         end
      else
         k = 0
         do iz = f,l
         do iy = f,l
         do ix = f,l
            k = k + 1
            if (NOT eval(k)) cycle
            p(1,k) = ox + ix*x1 + iy*y1 + iz*z1
            p(2,k) = oy + ix*x2 + iy*y2 + iz*z2
            p(3,k) = oz + ix*x3 + iy*y3 + iz*z3
         end
         end
         end
      end
   end

   make_math_pos(math_pos,z_range,valid) ::: leaky
   ! Calculate the positions "math_pos" of the valid atoms which have
   ! been rotated and shifted and scaled into grid point coordinates.
   ! Valid atoms are those which are within "z_range" of the plot
   ! plane; the indices of the valid atoms are stored in "valid"
      math_pos :: MAT{REAL}*
      z_range :: REAL, IN
      valid :: VEC{INT}*
   ENSURE(.atom.created,"no atoms!")
   ENSURE(z_range>ZERO,"z_range must be non-negative")
   ENSURE(valid.destroyed,"valid array already allocated")

      scale_factor :: VEC{REAL}(3)
      tr :: MAT{REAL}(3,3)
      pos :: MAT{REAL}*
      n,nv,a,i :: INT

      ! Get shifted atom positions
      n = .atom.dim
      pos.create(n,3)
      do a = 1, n
         pos(a,:) = .atom(a).position - .origin    !shift
      end

      ! Rotate positions into plot grid axis
      tr = .transposed_plot_axes
      do a = 1, n
         pos(a,:) = matmul(tr,pos(a,:))
      end

      ! Reject atoms far from plot plane, get valid atoms
      valid.create(0)
      do a = 1, n
        ! if ( abs(pos(a,z)) > z_range) cycle
         if ( abs(pos(a,3)) > z_range) cycle
         valid.append(a)
      end

      ! Create list of valid atoms positions
      nv = valid.dim
      math_pos.create(nv,3)
      i = 0
      do a = 1, n
         if ( abs(pos(a,3)) > z_range) cycle
         i = i + 1
         math_pos(i,:) = pos(a,:)
      end

      ! Finally, scale positions
      scale_factor(1) = (.n_x - ONE) / .width(1)
      scale_factor(2) = (.n_y - ONE) / .width(2)
      scale_factor(3) = ZERO 
      do a = 1,nv
         math_pos(a,:) = scale_factor * math_pos(a,:) + ONE ! since plot begins at 1
      end

      pos.destroy

   end

!  ======
!  Output
!  ======

   put
   ! Put the grid data to "stdout"

      axes :: MAT{REAL}(3,3)
      wid :: INT

      stdout.flush
      stdout.text("================")
      stdout.text("Plot information")
      stdout.text("================")
      stdout.flush
      stdout.text("All coordinates are in au.")
      stdout.flush

      ! What is it?
      stdout.show("Kind of plot            =", .plot_kind)
      if (.orbital /= 0) &
      stdout.show("Plot orbital no.        =", .orbital)

      ! Point info ...
      stdout.flush
      stdout.text("No. of points:")
      stdout.show("Number of X grid points =",.n_x)
      stdout.show("Number of Y grid points =",.n_y)
      stdout.show("Number of Z grid points =",.n_z)
      stdout.show("Total number of points  =",.n_pt)
      stdout.show("Point separation (del)  =",.del_x)

      ! Nice width
      axes = .plot_axes
      wid  = maxval(len_trim(axes.to_str("f",50,stdout.real_precision))) + 1
      axes = .plot_axes

      ! Centering
      stdout.flush
      stdout.text("Plot centering (xyz) :")
      stdout.show("Plot center point       =",.centre,width=wid)
      if (NOT .offset.is_zero) &
      stdout.show("Centre offset           =",.offset,width=wid)
      stdout.show("Bottom-left-front point =",.origin,width=wid)

      ! Plot axes
      stdout.flush
      stdout.text("Plot widths & axes:")
      if (.use_bounding_box) &
      stdout.show("Bounding box used?      =",.use_bounding_box)

      stdout.show("Axis widths             =",.width,wid)
      stdout.show("Axis vector columns     =",axes(1,:),width=wid)
      stdout.show("                        =",axes(2,:),width=wid)
      stdout.show("                        =",axes(3,:),width=wid)

      ! Atom-based data
      if (.atom_data_used) then
      
      stdout.flush
      stdout.text("Atom-based specifications:")

      if (.centre_atoms.created) then
      stdout.show("Center atoms list       =",.centre_atoms.to_concatenated_str)
      else if (.centre_atom/=0) then
      stdout.show("Center atom             =",.centre_atom)
      end

      if (.x_atom_1/=0) then
      stdout.show("X axis atom 1           =",.x_atom_1)
      stdout.show("X axis atom 2           =",.x_atom_2)
      end

      if (.y_atom_1/=0) then
      stdout.show("Y axis atom 1           =",.y_atom_1)
      stdout.show("Y axis atom 2           =",.y_atom_2)
      end

      end

   end

!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{INT})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{CPX})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT3{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

end
