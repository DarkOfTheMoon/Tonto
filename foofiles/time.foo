! $Id$
!---------------------------------------------------------------------------
!  Time: time stuff.  Such as output date, time execution, etc.
!  (c) Daniel Grimwood, 1998
!---------------------------------------------------------------------------
module TIME

   use TYPES
   use MM
   use DBL

   implicit none         

#  include "macros"
#  include "time.int"

! type time_type
!   IVEC(8) :: started, stopped     ! Contains date_and_time
!   DBL :: start_cpu, stop_cpu      ! Contains cpu_time
! end

   TIME, public :: std_time

contains

  start
  ! starts the counter
    real :: time
    call date_and_time(values= .started)
    call cpu_time(time)
    .start_cpu = time
    .stopped = 0
  end

  reset
  ! Restarts the counter
    .start
  end

  stop
  ! Stop the counter.
    real :: time
    call date_and_time(values= .stopped)
    call cpu_time(time)
    .stop_cpu = time
  end

  current result (time)
  ! returns current time
    IVEC(8) :: time
    call date_and_time(values=time)
  end

  elapsed result (time)
  ! returns elapsed time
    IVEC(8) :: time
    time = .subtract_times( .stopped , .started)
  end

! *********************************************************************
! return time strings.
! *********************************************************************

  current_time result (res)
    STR(40) :: res
    res = "The current time is " // trim( .time_to_str( .current )) // "."
  end

  start_time result (res)
    STR(37) :: res
    res = "Timer started at " // trim( .time_to_str( .started )) // "."
  end

  stop_time result (res)
    STR(37) :: res
    res = "Timer stopped at " // trim( .time_to_str( .stopped )) // "."
  end

  time_taken(task) result (res)
  ! Returns time taken. "Time taken is ..."
  ! If task given, "Time taken for "task" is ..."
    STR :: res
    CHR(*), optional :: task
    .stop
    if (present(task)) then
      res = "Time taken for " // trim(task) // " is " // &
            trim( .elapsed_time_to_str( .elapsed )) // "."
    else
    res = "Time taken is " // trim( .elapsed_time_to_str( .elapsed )) // "."
    end
  end

  cpu_time_taken(task) result (res)
  ! Returns cpu time taken. "CPU time taken is ... CPU seconds."
  ! If task given, "CPU time taken for "task" is ... CPU seconds."
    STR :: res
    DBL :: time
    STR(*), optional :: task
    STR :: time_str
    .stop
    time = .stop_cpu - .start_cpu
    write(time_str,'(f15.3)') time
    if (present(task)) then
      res = "CPU time taken for " // trim(task) // " is " // &
             trim(adjustl(time_str)) // " CPU seconds."
    else
      res = "CPU time taken is " // trim(adjustl(time_str)) // " CPU seconds."
    end
  end

  elapsed_time_to_str(time) result (res)
   ! Returns the elapsed time as a string.
   ! Formatted as years, months, days, hours, min, sec, msec.
   ! If time is greater than a day, does not output min or smaller.
     IVEC(8), IN :: time
     STR :: res
     BIN :: comma
     comma = FALSE
     res = ""
     res =              .number_with_units(time(1),"year",comma)
     res = trim(res) // .number_with_units(time(2),"month",comma)
     res = trim(res) // .number_with_units(time(3),"day",comma)
     res = trim(res) // .number_with_units(time(5),"hour",comma)
     if ((time(1) == 0) AND (time(2) == 0) AND (time(3) == 0)) then
       res = trim(res) // .number_with_units(time(6),"minute",comma)
       res = trim(res) // .number_with_units(time(7),"second",comma)
       res = trim(res) // .number_with_units(time(8),"millisecond",comma)
     end
   end

  time_to_str(time) result (res)
  ! Return a string containing the time.
  ! Formatted as DD/MM/YYYY HH:MM:SS
    IVEC(8), IN :: time
    STR :: res1,res2,res3,res4,res5,res6
    STR(19) :: res
    INT :: i
    res = ""
    res1 = ""
    res2 = ""
    res3 = ""
    res4 = ""
    res5 = ""
    res6 = ""
    write(res1,fmt='(i2)') time(3)
    write(res2,fmt='(i2)') time(2)
    write(res3,fmt='(i4)') time(1)
    write(res4,fmt='(i2)') time(5)
    write(res5,fmt='(i2)') time(6)
    write(res6,fmt='(i2)') time(7)
    res = trim(res1) // "/" // trim(res2) // "/" // trim(res3) // " " &
       // trim(res4) // ":" // trim(res5) // ":" // trim(res6)
    do i=1,10
      if (res(i:i) == " ") res(i:i) = "0"
    end
    do i=12,len_trim(res)
      if (res(i:i) == " ") res(i:i) = "0"
    end
  end

! *********************************************************************
! private routines
! *********************************************************************

  number_with_units(number,unit,comma) result (res)
  ! Returns the number with its units, if the number is non-zero.
  ! Inserts a comma if comma is true.  If the number is non-zero,
  ! then comma is set to true.
    INT, IN :: number
    CHR(*), IN :: unit
    BIN :: comma
    STR :: res,res1
    res = ""
    if (number /= 0) then
      res1 = ""
      write(res1,'(i)') number
      res1 = adjustl(res1)
      if (comma) then
        if (number == 1) then
          res = ", " // trim(res1) // " " // unit
        else
          res = ", " // trim(res1) // " " // unit // "s"
        end
      else
        if (number == 1) then
          res = trim(res1) // " " // unit
        else
          res = trim(res1) // " " // unit // "s"
        end
      end
      comma = TRUE
    end
  end

  recursive :: subtract_times(time1,time2) result(res)
  ! result = time1 - time2
  ! No leap years yet.
    IVEC(8), IN :: time1,time2
    IVEC(8) :: res
    IVEC(8) :: temp_time1
    temp_time1 = time1
    res(8)=temp_time1(8)-time2(8)
    if (res(8) < 0) then
      res(8) = res(8) + 1000
      temp_time1(7) = temp_time1(7) - 1
    end
    res(7)=temp_time1(7)-time2(7)
    if (res(7) < 0) then
      res(7) = res(7) + 60
      temp_time1(6) = temp_time1(6) - 1
    end
    res(6)=temp_time1(6)-time2(6)
    if (res(6) < 0) then
      res(6) = res(6) + 60
      temp_time1(5) = temp_time1(5) - 1
    end
    res(5)=temp_time1(5)-time2(5)
    if (res(5) < 0) then
      res(5) = res(5) + 24
      temp_time1(3) = temp_time1(3) - 1
    end
    res(3)=temp_time1(3)-time2(3)
    if (res(3) < 0) then
      select case (temp_time1(2))
        case (1,3,7,8,10,12)
          res(2) = res(2) + 31
        case (4,6,9,11)
          res(2) = res(2) + 31
        case (2)
          res(2) = res(2) + 28
      end
      temp_time1(2) = temp_time1(2) - 1
    end
    res(2)=temp_time1(2)-time2(2)
    if (res(2) < 0) then
      res(2) = res(2) + 24
      temp_time1(1) = temp_time1(1) - 1
    end
    res(1)=temp_time1(1)-time2(1)
    if (res(1) < 0) then
      res = - .subtract_times(time2,time1)
    end
    res(4)=0 !no reason in particular.
  end

end
