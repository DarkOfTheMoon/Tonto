!-------------------------------------------------------------------------------
!
! DFT_FUNCTIONAL: Functionals for density functional calculations.
!
! This module collects together functionals and their derivatives
! neccesary for DFT calculations. A uniform notation is used for the
! routines and their arguments to make things easy to debug and check.
!
! Restricted and unrestricted functional forms:
!
! There are two types of routines: those for restricted (closed
! shell), and those for unrestricted (open shell) functionals. The
! restricted functionals are prefixed with "r_". The unrestricted
! functionals are prefixed with "u_".
!
! Contributions are *added*:
!
! Since functionals are usually separated into exchange and
! correlation parts, these routines always *add* their contributions.
! You must ensure that the output arrays they add to are zero
! beforehand.
!
! Copyright (C) Dylan Jayatilaka, University of Western Australia, 2005
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!
!-------------------------------------------------------------------------------

module DFT_FUNCTIONAL

   implicit none

contains


!  **************************
!  Create and destroy methods
!  **************************

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

   nullify_ptr_part
   ! Nullify the pointer parts 
   end

   destroy_ptr_part 
   ! Destroy the pointer parts
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(d) ::: leaky
   ! Copy a dftgrid "d"
      d :: DFT_FUNCTIONAL
      self = d
   end

   set_defaults
   ! Set up a defaults
      .name = "none"
      .Xalpha = DFT_FUNCTIONAL_XALPHA
      .rho_cutoff = DFT_FUNCTIONAL_RHO_CUTOFF
   end

   set_rho_cutoff(cutoff)
   ! If the density goes below ".rho_cutoff" then the functional, its energy
   ! density, and its potential are all set to zero.
      cutoff :: REAL
      .rho_cutoff = cutoff
   end

!  *************
!  Input methods
!  *************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR
      word :: STR
      word = keyword
      word.to_lower_case
      select case (word)
         case ("}            ")  ! exit case
         case ("name=        "); .read_name
         case ("xalpha=      "); .read_Xalpha
         case ("rho_cutoff=  "); .read_rho_cutoff
         case default;     UNKNOWN(word)
      end
   end

   read_name
   ! Read the ".name" of the DFT functional
      stdin.read(.name)
   end

   read_Xalpha
   ! Read ".Xalpha", the alpha value to use for the Xalpha functional.
      stdin.read(.Xalpha)
   end

   read_rho_cutoff
   ! If the density goes below ".rho_cutoff" then the functional, its energy
   ! density, and its potential are all set to zero.
      stdin.read(.rho_cutoff)
   end

! ***************
! Enquiry methods
! ***************

   is_GGA_functional(name) result (res)
   ! Return TRUE if the functional uses the GGA approximation.
      name :: STR, IN, optional
      res :: BIN
      kind :: STR
      kind = .name
      if (present(name)) kind = name
      select case (kind)
         case("           "); res = FALSE
         case("none       "); res = FALSE
         case("slater     "); res = FALSE
         case("xalpha     "); res = FALSE
         case("becke88    "); res = TRUE
         case("gill96     "); res = TRUE
         case("lyp        "); res = TRUE
         case default;        UNKNOWN(kind)
      end
   end

   is_LDA_functional(name) result (res)
   ! Return TRUE if the functional uses the GGA approximation.
      name :: STR, IN, optional
      res :: BIN
      kind :: STR
      kind = .name
      if (present(name)) kind = name
      select case (kind)
         case("           "); res = TRUE 
         case("none       "); res = TRUE 
         case("slater     "); res = TRUE 
         case("xalpha     "); res = TRUE 
         case("becke88    "); res = FALSE
         case("gill96     "); res = FALSE
         case("lyp        "); res = FALSE
         case default;        UNKNOWN(kind)
      end
   end

! *****************************************
! Functionals, energy densities, potentials
! *****************************************

   r_functional(name,E,rho0,rho1)
   ! For a DFT functional named "name", ADD the *restricted* functional "E"
   ! as a function of the (total) density "rho0" and its gradient "rho1".
      name :: STR, IN
      E    :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      rho1 :: MAT{REAL}, IN, optional
   ENSURE(present(rho1) OR .is_LDA_functional(name),"rho1 must be present for GGA functionals")
      .name = name
      select case (name)
         case ("none   ")  ! Don't add anything.
         case ("becke88"); .r_Becke88_x_functional(E,rho0,rho1)
         case ("lyp    "); .r_LYP_c_functional(E,rho0,rho1)
         case ("slater "); .r_LDA_x_functional(E,rho0)
         case ("xalpha "); .r_Xalpha_x_functional(E,rho0)
         case default;     UNKNOWN(name)
      end
   end

   u_functional(name,E,rho0a,rho0b,rho1a,rho1b)
   ! For a DFT functional named "name", ADD the *unrestricted* functional "E"
   ! as a function of the alpha and beta densities "rho0a" and "rho0b" and their
   ! gradients "rho1a", "rho1b".
      name :: STR, IN
      E    :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      rho1a,rho1b :: MAT{REAL}, IN, optional
   ENSURE(present(rho1a) OR .is_LDA_functional(name),"rho1a must be present for GGA functionals")
   ENSURE(present(rho1b) OR .is_LDA_functional(name),"rho1b must be present for GGA functionals")
      .name = name
      select case (name)
         case ("none   ")  ! Don't add anything.
         case ("becke88"); .u_Becke88_x_functional(E,rho0a,rho0b,rho1a,rho1b)
         case ("lyp    "); .u_LYP_c_functional(E,rho0a,rho0b,rho1a,rho1b)
         case ("slater "); .u_LDA_x_functional(E,rho0a,rho0b)
         case ("xalpha "); .u_Xalpha_x_functional(E,rho0a,rho0b)
         case default;     UNKNOWN(name)
      end
   end

   r_energy_density(name,E,rho0,rho1)
   ! For a DFT functional named "name", ADD the *restricted* functional energy
   ! density "E" (i.e. the functional divided by the density) as a function
   ! of the (total) density "rho0" and its gradient "rho1".
      name :: STR, IN
      E   :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      rho1 :: MAT{REAL}, IN, optional
   ENSURE(present(rho1) OR .is_LDA_functional(name),"rho1 must be present for GGA functionals")
      .name = name
      select case (name)
         case ("none   ")  ! Don't add anything.
         case ("becke88"); .r_Becke88_x_energy_density(E,rho0,rho1)
         case ("lyp    "); .r_LYP_c_energy_density(E,rho0,rho1)
         case ("slater "); .r_LDA_x_energy_density(E,rho0)
         case ("xalpha "); .r_Xalpha_x_energy_density(E,rho0)
         case default;     UNKNOWN(name)
      end
   end

   u_energy_density(name,E,rho0a,rho0b,rho1a,rho1b)
   ! For a DFT functional named "name", ADD the *unrestricted* functional energy
   ! density "E" (i.e. the functional divided by the total density) as a function
   ! of the (total) density "rho0" and its gradient "rho1".
      name :: STR, IN
      E    :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      rho1a,rho1b :: MAT{REAL}, IN, optional
   ENSURE(present(rho1a) OR .is_LDA_functional(name),"rho1a must be present for GGA functionals")
   ENSURE(present(rho1b) OR .is_LDA_functional(name),"rho1b must be present for GGA functionals")
      .name = name
      select case (name)
         case ("none   ")  ! Don't add anything.
         case ("becke88"); .u_Becke88_x_energy_density(E,rho0a,rho0b,rho1a,rho1b)
         case ("lyp    "); .u_LYP_c_energy_density(E,rho0a,rho0b,rho1a,rho1b)
         case ("slater "); .u_LDA_x_energy_density(E,rho0a,rho0b)
         case ("xalpha "); .u_Xalpha_x_energy_density(E,rho0a,rho0b)
         case default;     UNKNOWN(name)
      end
   end

   r_potential(name,V0,rho0,V1,rho1)
   ! For a DFT functional named "name", ADD the *restricted* potentials "V0"
   ! and "V1" as a function of the (total) density "rho0" and its gradient "rho1".
   ! "V0" and "V1" are defined by
   !       V0 = d F/d rho_a
   !       V1 = 2*(d F/d gamma_aa) + (d F/d gamma_ab)
   ! where 
   !       gamma_xy = nabla rho_x . nabla rho_y, 
   ! and 
   !       x,y = alpha or beta. 
   ! NOTE: the derivatives are w.r.t. rho_a, or gamma_aa, which involve the
   ! alpha and beta densities, but the inputs are the *restricted* density
   ! "rho0" and its gradient "rho1". In practical calculations, "V1" is
   ! integrated with nabla of the basis function pair to get the matrix element
   ! of the exchange correlation potential.
      name :: STR, IN
      V0   :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      V1   :: MAT{REAL}, INOUT, optional
      rho1 :: MAT{REAL}, IN, optional
   ENSURE(present(rho1) EQV present(V1),"rho1 and V1 must be both present, or both absent")
   ENSURE(present(rho1) OR .is_LDA_functional(name),"rho1 and V1 must be present for GGA functionals")
      .name = name
      select case (name)
         case ("none   ")  ! Don't add anything.
         case ("becke88"); .r_Becke88_x_potential(V0,rho0,V1,rho1)
         case ("lyp    "); .r_LYP_c_potential(V0,rho0,V1,rho1)
         case ("slater "); .r_LDA_x_potential(V0,rho0)
         case ("xalpha "); .r_Xalpha_x_potential(V0,rho0)
         case default;     UNKNOWN(name)
      end
   end

   u_potential(name,V0a,V0b,rho0a,rho0b,V1a,V1b,rho1a,rho1b)
   ! For a DFT functional named "name", ADD the *unrestricted* alpha and beta
   ! potentials "V0a", "V0b", "V1a", "V1b" as a function of the alpha and beta
   ! densities "rho0a", "rho0b" and their gradients "rho1a", "rho1b". The
   ! potentials are defined by
   !       V0a = d F/d rho_a
   !       V0b = d F/d rho_b
   !       V1a = 2*(d F/d gamma_aa) + (d F/d gamma_ab)
   !       V1b = 2*(d F/d gamma_bb) + (d F/d gamma_ba)
   ! where 
   !       gamma_xy = nabla rho_x . nabla rho_y, 
   ! and 
   !       x,y = alpha or beta. 
   ! In practical calculations, "V1" is integrated with nabla of the basis
   ! function pair to get the matrix element of the exchange correlation
   ! potential.
      name :: STR, IN
      V0a,V0b     :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      V1a,V1b     :: MAT{REAL}, INOUT, optional
      rho1a,rho1b :: MAT{REAL}, IN, optional
   ENSURE(present(rho1a) EQV present(V1a),"rhoa1 and Va1 must be both present, or both absent")
   ENSURE(present(rho1a) EQV present(V1a),"rhob1 and Vb1 must be both present, or both absent")
   ENSURE(present(rho1a) OR .is_LDA_functional(name),"rho1a and V1a must be present for GGA functionals")
   ENSURE(present(rho1b) OR .is_LDA_functional(name),"rho1b and V1b must be present for GGA functionals")
      .name = name
      select case (name)
         case ("none   ")  ! Don't add anything.
         case ("becke88"); .u_Becke88_x_potential(V0a,V0b,rho0a,rho0b,V1a,V1b,rho1a,rho1b)
         case ("lyp    "); .u_LYP_c_potential(V0a,V0b,rho0a,rho0b,V1a,V1b,rho1a,rho1b)
         case ("slater "); .u_LDA_x_potential(V0a,V0b,rho0a,rho0b)
         case ("xalpha "); .u_Xalpha_x_potential(V0a,V0b,rho0a,rho0b)
         case default;     UNKNOWN(name)
      end
   end


! Details of the functionals


   r_LDA_x_functional(E,rho0)
   ! The restricted LDA exchange functional
   ! LDA = -c \sum_s (\rho_s)^{4/3}, c = (3/2) (3/4\pi)^{1/3}
      self :: IN
      E    :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      const :: REAL
      const = THREE/FOUR * (THREE/PI)**THIRD
      E = E - const*rho0**FOURTHIRDS
   end

   r_LDA_x_energy_density(E,rho0)
   ! The restricted LDA exchange energy density
   ! LDA = -c \sum_s (\rho_s)^{1/3}, c = (3/2) (3/4\pi)^{1/3}
      self :: IN
      E    :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      const :: REAL
      const = THREE/FOUR * (THREE/PI)**THIRD
      E = E - const*rho0**(THIRD)
   end

   r_LDA_x_potential(V0,rho0)
   ! The restricted LDA exchange potential.
      self :: IN
      V0   :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      const :: REAL
      const = (THREE/PI)**THIRD
      V0 = V0 - const*rho0**THIRD
   end


   u_LDA_x_functional(E,rho0a,rho0b)
   ! Return the values of the local density exchange functional "E".
      E :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      const :: REAL
      const = THREE/TWO * (THREE/(FOUR*PI))**THIRD
      E = E - const * (rho0a**FOURTHIRDS + rho0b**FOURTHIRDS)
   end

   u_LDA_x_energy_density(E,rho0a,rho0b)
   ! Return the values of the local density exchange functional "E".
      E :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      const,rhoa,rhob,r_ba,r_ab,f_ba,f_ab :: REAL
      i :: INT
      const = THREE/TWO * (THREE/(FOUR*PI))**THIRD
      do i = 1,rho0a.dim
         rhoa = rho0a(i)
         rhob = rho0b(i)
         if (rhoa<.rho_cutoff) cycle
         if (rhob<.rho_cutoff) cycle
         r_ba = rhob/rhoa
         r_ab = ONE/r_ba
         f_ba = ONE/(ONE+r_ba)
         f_ab = ONE - f_ba
         E(i) = E(i) - const*(f_ba*rhoa**THIRD + f_ab*rhob**THIRD)
      end
   end

   u_LDA_x_potential(V0a,V0b,rho0a,rho0b)
   ! Return the derivatives of the local density exchange functional.
      V0a,V0b :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      const :: REAL
      const = TWO * (THREE/(FOUR*PI))**THIRD
      V0a = V0a - const*rho0a**THIRD
      V0b = V0b - const*rho0b**THIRD
   end


   r_Xalpha_x_functional(E,rho0)
   ! The restricted X alpha exchange functional. 
   ! Untested.
      self :: IN
      E    :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      const :: REAL
      const = NINE/EIGHT * .Xalpha * (THREE/PI)**THIRD
      E = E - const*rho0**FOURTHIRDS
   end

   r_Xalpha_x_energy_density(E,rho0)
   ! The restricted X alpha exchange energy density. 
   ! Untested.
      self :: IN
      E    :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      const :: REAL
      const = NINE/EIGHT * .Xalpha * (THREE/PI)**THIRD
      E = E - const*rho0**(THIRD)
   end

   r_Xalpha_x_potential(V0,rho0)
   ! The restricted X alpha exchange potential.
   ! Untested.
      self :: IN
      V0   :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      const :: REAL
      const = THREE/TWO * .Xalpha * (THREE/PI)**THIRD
      V0 = V0 - const*rho0**THIRD
   end


   u_Xalpha_x_functional(E,rho0a,rho0b)
   ! Return the values of the local density exchange functional "E".
   ! Untested
      E :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      const :: REAL
      const = NINE/FOUR * .Xalpha * (THREE/(FOUR*PI))**THIRD
      E = E - const * (rho0a**FOURTHIRDS + rho0b**FOURTHIRDS)
   end

   u_Xalpha_x_energy_density(E,rho0a,rho0b)
   ! Return the values of the local density exchange functional "E".
   ! Untested
      E :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      const,rhoa,rhob,r_ba,r_ab,f_ba,f_ab :: REAL
      i :: INT
      const = NINE/FOUR * .Xalpha * (THREE/(FOUR*PI))**THIRD
      do i = 1,rho0a.dim
         rhoa = rho0a(i)
         rhob = rho0b(i)
         if (rhoa<.rho_cutoff) cycle
         if (rhob<.rho_cutoff) cycle
         r_ba = rhob/rhoa
         r_ab = ONE/r_ba
         f_ba = ONE/(ONE+r_ba)
         f_ab = ONE - f_ba
         E(i) = E(i) - const*(f_ba*rhoa**THIRD + f_ab*rhob**THIRD)
      end
   end

   u_Xalpha_x_potential(V0a,V0b,rho0a,rho0b)
   ! Return the derivatives of the local density exchange functional.
   ! Untested
      V0a,V0b :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      const :: REAL
      const = THREE * .Xalpha * (THREE/(FOUR*PI))**THIRD
      V0a = V0a - const*rho0a**THIRD
      V0b = V0b - const*rho0b**THIRD
   end


   r_Becke88_x_functional(E,rho0,rho1)
   ! The restricted Becke 88 exchange functional.
      self :: IN
      E    :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      rho1 :: MAT{REAL}, IN
      beta,beta6,const,rho,rho_43,gx,gy,gz,gg,x,x2 :: REAL
      i :: INT
      beta = 0.0042d0  ! beta parameter
      beta6 = SIX*beta
      const = THREE/TWO * (THREE/(FOUR*PI))**THIRD
      do i = 1,rho0.dim
         rho = rho0(i)
         if (rho<.rho_cutoff) cycle
         rho_43 = (HALF*rho) ** (FOURTHIRDS)
         gx = rho1(i,1)
         gy = rho1(i,2)
         gz = rho1(i,3)
         gg = HALF*sqrt(gx*gx+gy*gy+gz*gz)
       ! x  = min(gg/rho_43,.rho_cutoff)
         x  = gg/rho_43
         x2 = x*x
         E(i) = E(i) - TWO*rho_43*(const+beta*x2/(ONE+beta6*x*log(x+sqrt(ONE+x2))))
      end
   end

   r_Becke88_x_energy_density(E,rho0,rho1)
   ! The restricted Becke 88 exchange energy density.
      self :: IN
      E    :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      rho1 :: MAT{REAL}, IN
      beta,beta6,const,two_m43,two_m13,rho,rho_13,rho_43,gx,gy,gz,gg,x,x2 :: REAL
      i :: INT
      beta = 0.0042d0  ! beta parameter
      beta6 = SIX*beta
      const = THREE/TWO * (THREE/(FOUR*PI))**THIRD
      two_m13 = TWO**(-THIRD)
      two_m43 = HALF*two_m13
      do i = 1,rho0.dim
         rho = rho0(i)
         if (rho<.rho_cutoff) cycle
         rho_13 = rho**(THIRD)
         rho_43 = two_m43 * rho * rho_13
         gx = rho1(i,1)
         gy = rho1(i,2)
         gz = rho1(i,3)
         gg = HALF*sqrt(gx*gx+gy*gy+gz*gz)
       ! x  = min(gg/rho_43,.rho_cutoff)
         x  = gg/rho_43
         x2 = x*x
         E(i) = E(i) - two_m13*rho_13*(const+beta*x2/(ONE+beta6*x*log(x+sqrt(ONE+x2))))
      end
   end

   r_Becke88_x_potential(V0,rho0,V1,rho1)
   ! The restricted Becke 88 exchange potential.  These equations are
   ! essentially the same as in the appendix of JCP 98(7) 5612-5626.
   ! Note that (A5) is in error because the \gamma variables should be square
   ! rooted. Note that (A6) is in error because the power of \rho_\alpha should
   ! be 1/3 not 4/3.
      self :: IN
      V0   :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      V1   :: MAT{REAL}, INOUT
      rho1 :: MAT{REAL}, IN
      beta,beta2,beta6,bbta6,const,rho,rho_13,rho_43 :: REAL
      gx,gy,gz,gg,x,x2,sq,as,d,d2,g0,g1 :: REAL
      i :: INT
      beta  = 0.0042d0  ! beta parameter
      beta2 = TWO*beta
      beta6 = SIX*beta
      bbta6 = SIX*beta*beta
      const = THREE/TWO * (THREE/(FOUR*PI))**THIRD
      do i = 1,rho0.dim
         rho = rho0(i)
         if (rho<.rho_cutoff) cycle
         rho = HALF*rho
         rho_13 = rho**(THIRD)
         rho_43 = rho*rho_13
         gx = rho1(i,1) ! should have a 1/2 here
         gy = rho1(i,2)
         gz = rho1(i,3) ! but it is put below
         gg = HALF*sqrt(gx*gx+gy*gy+gz*gz)
         x  = gg/rho_43
         x2 = x*x
         sq = sqrt(ONE+x2)
         as = log(x+sq)
         d  = ONE/(ONE+beta6*x*as)
         d2 = d*d
         g0 = const + beta*x2*d
         g1 = (beta2*x+bbta6*x2*(as-x/sq))*d2
         gg = HALF*g1/gg ! a factor 1/2 x 2 which cancel, here
         V0(i)   = V0(i) - FOURTHIRD*rho_13*(g0 - x*g1)
         V1(i,1) = V1(i,1) - gg*gx
         V1(i,2) = V1(i,2) - gg*gy
         V1(i,3) = V1(i,3) - gg*gz
      end
   end


   u_Becke88_x_functional(E,rho0a,rho0b,rho1a,rho1b)
   ! Return the values of the Becke 88 exchange functional.
      E :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      rho1a,rho1b :: MAT{REAL}, IN
      beta,beta6,const,rhoa,rhob,rhoa_43,rhob_43 :: REAL
      ax,ay,az,xa,xa2,bx,by,bz,xb,xb2 :: REAL
      i :: INT
      beta = 0.0042d0  ! beta parameter
      beta6 = SIX*beta
      const = THREE/TWO * (THREE/(FOUR*PI))**THIRD
      do i = 1,rho0a.dim
         rhoa = rho0a(i)
         rhob = rho0b(i)
         if (rhoa<.rho_cutoff) cycle
         if (rhob<.rho_cutoff) cycle
         rhoa_43 = rhoa**FOURTHIRDS
         rhob_43 = rhob**FOURTHIRDS
         ax = rho1a(i,1); ay = rho1a(i,2); az = rho1a(i,3)
         bx = rho1b(i,1); by = rho1b(i,2); bz = rho1b(i,3)
         xa = sqrt(ax*ax+ay*ay+az*az)/rhoa_43; xa2 = xa*xa
         xb = sqrt(bx*bx+by*by+bz*bz)/rhob_43; xb2 = xb*xb
         E(i) = E(i) &
              - rhoa_43 * (const + beta*xa2/(ONE+beta6*xa*log(xa+sqrt(ONE+xa2)))) &
              - rhob_43 * (const + beta*xb2/(ONE+beta6*xb*log(xb+sqrt(ONE+xb2))))
      end
   end

   u_Becke88_x_energy_density(E,rho0a,rho0b,rho1a,rho1b)
   ! Return the values of the Becke 88 exchange energy density functional.
      E :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      rho1a,rho1b :: MAT{REAL}, IN
      beta,beta6,const,rhoa,rhob,rhoa_13,rhob_13,rhoa_43,rhob_43 :: REAL
      ax,ay,az,xa,xa2,bx,by,bz,xb,xb2, r_ba,r_ab,f_ba,f_ab :: REAL
      i :: INT
      beta = 0.0042d0  ! beta parameter
      beta6 = SIX*beta
      const = THREE/TWO * (THREE/(FOUR*PI))**THIRD
      do i = 1,rho0a.dim
         rhoa = rho0a(i)
         rhob = rho0b(i)
         if (rhoa<.rho_cutoff) cycle
         if (rhob<.rho_cutoff) cycle
         rhoa_13 = rhoa**THIRD
         rhob_13 = rhob**THIRD
         rhoa_43 = rhoa_13*rhoa
         rhob_43 = rhob_13*rhob
         r_ba = rhob/rhoa
         r_ab = ONE/r_ba
         f_ba = ONE/(ONE+r_ba)
         f_ab = ONE - f_ba
         ax = rho1a(i,1); ay = rho1a(i,2); az = rho1a(i,3)
         bx = rho1b(i,1); by = rho1b(i,2); bz = rho1b(i,3)
         xa = sqrt(ax*ax+ay*ay+az*az)/rhoa_43; xa2 = xa*xa
         xb = sqrt(bx*bx+by*by+bz*bz)/rhob_43; xb2 = xb*xb
         E(i) = E(i) &
              - f_ba*rhoa_13 * (const + beta*xa2/(ONE+beta6*xa*log(xa+sqrt(ONE+xa2)))) &
              - f_ab*rhob_13 * (const + beta*xb2/(ONE+beta6*xb*log(xb+sqrt(ONE+xb2))))
      end
   end

   u_Becke88_x_potential(V0a,V0b,rho0a,rho0b,V1a,V1b,rho1a,rho1b)
   ! Return the derivatives of the Becke 88 exchange functional.
   ! These equations are essentially the same as in the appendix of JCP 98(7)
   ! 5612-5626.
      V0a,V0b     :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      V1a,V1b     :: MAT{REAL}, INOUT
      rho1a,rho1b :: MAT{REAL}, IN
      ax,ay,az,xa,xa2,bx,by,bz,xb,xb2,ka,kb,ka2,kb2,sa,sb,za,zb,nla,nlb :: REAL
      beta,beta6,d,e,rhoa,rhob,rhoa_13,rhob_13,rhoa_43,rhob_43 :: REAL
      i :: INT
      beta = 0.0042d0  ! beta parameter
      beta6 = SIX*beta
      d = -(SIX/PI)**THIRD
      e = FOURTHIRDS*beta
      do i = 1,rho0a.dim
         rhoa = rho0a(i)
         rhob = rho0b(i)
         if (rhoa<.rho_cutoff) cycle
         if (rhob<.rho_cutoff) cycle
         rhoa_13 = rhoa**THIRD
         rhob_13 = rhob**THIRD
         rhoa_43 = rhoa*rhoa_13
         rhob_43 = rhob*rhob_13
         ax = rho1a(i,1); ay = rho1a(i,2); az = rho1a(i,3)
         bx = rho1b(i,1); by = rho1b(i,2); bz = rho1b(i,3)
         xa = sqrt(ax*ax+ay*ay+az*az)/rhoa_43; xa2 = xa*xa
         xb = sqrt(bx*bx+by*by+bz*bz)/rhob_43; xb2 = xb*xb
         sa = sqrt(ONE+xa2)
         sb = sqrt(ONE+xb2)
         ka = ONE + beta6*xa*log(xa+sa)
         kb = ONE + beta6*xb*log(xb+sb)
         ka2 = ONE/(ka*ka)
         kb2 = ONE/(kb*kb)
         za = beta6*xa2/sa
         zb = beta6*xb2/sb
         V0a(i) = V0a(i) + rhoa_13*(d + e*xa2*(ONE-za)*ka2)
         V0b(i) = V0b(i) + rhob_13*(d + e*xb2*(ONE-zb)*kb2)
         nla = beta*(za-ONE-ka)*ka2/rhoa_43
         nlb = beta*(zb-ONE-kb)*ka2/rhob_43
         V1a(i,1) = V1a(i,1) + nla*ax
         V1a(i,2) = V1a(i,2) + nla*ay
         V1a(i,3) = V1a(i,3) + nla*az
         V1b(i,1) = V1b(i,1) + nlb*bx
         V1b(i,2) = V1b(i,2) + nlb*by
         V1b(i,3) = V1b(i,3) + nlb*bz
      end
   end


   r_LYP_c_functional(E,rho0,rho1)
   ! Return the values of the Lee-Yang-Parr functional.
      self :: IN
      E :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      rho1 :: MAT{REAL}, IN
      const,a,b,c,d,fac,rho,rho_m13,gx,gy,gz,gg :: REAL
      gamma_inv,a_b_omega,delta :: REAL
      i :: INT
      a = 0.04918d0
      b = 0.132d0
      c = 0.2533d0
      d = 0.349d0
      const = (THREE/TEN)*(3*PI*PI)**(TWOTHIRD)
      fac = TWO**(11*THIRD)*const
      do i = 1,rho0.dim
         rho = rho0(i)
         if (rho<.rho_cutoff) cycle
         rho_m13 = ONE/rho**THIRD
         rho  = HALF*rho
         gx = rho1(i,1)
         gy = rho1(i,2)
         gz = rho1(i,3)
         gg = QUARTER*(gx*gx+gy*gy+gz*gz)
         gamma_inv = ONE/(ONE+d*rho_m13)
         a_b_omega = a*b*exp(-c*rho_m13)*gamma_inv*rho_m13**11
         delta = (c+d*gamma_inv)*rho_m13
         E(i) = E(i) &
              - a*TWO*rho*gamma_inv &
              + a_b_omega*rho*rho*gg*(6+14*delta)*NINTH &
              - a_b_omega*fac*TWO*rho**(14*THIRD)
      end
   end

   r_LYP_c_energy_density(E,rho0,rho1)
   ! Return the values of the Lee-Yang-Parr energy density.
      self :: IN
      E :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      rho1 :: MAT{REAL}, IN
      const,a,b,c,d,fac,rho,rho_m13,gx,gy,gz,gg :: REAL
      gamma_inv,a_b_omega,delta :: REAL
      i :: INT
      a = 0.04918d0
      b = 0.132d0
      c = 0.2533d0
      d = 0.349d0
      const = (THREE/TEN)*(3*PI*PI)**(TWOTHIRD)
      fac = TWO**(11*THIRD)*const
      do i = 1,rho0.dim
         rho = rho0(i)
         if (rho<.rho_cutoff) cycle
         rho_m13 = ONE/rho**THIRD
         rho  = HALF*rho
         gx = rho1(i,1)
         gy = rho1(i,2)
         gz = rho1(i,3)
         gg = QUARTER*(gx*gx+gy*gy+gz*gz)
         gamma_inv = ONE/(ONE+d*rho_m13)
         a_b_omega = a*b*exp(-c*rho_m13)*gamma_inv*rho_m13**11
         delta = (c+d*gamma_inv)*rho_m13
         E(i) = E(i) &
              - a*gamma_inv &
              + HALF*a_b_omega*rho*gg*(6+14*delta)*NINTH &
              - a_b_omega*fac*rho**(11*THIRD)
      end
   end

!   r_LYP_c_functional(f,p,np)
!   ! Return the values of the Lee-Yang-Parr functional.
!   ! Untested
!     self :: IN
!     f :: VEC{REAL}, OUT
!     p :: VEC{REAL}, IN
!     np :: MAT{REAL}, IN
!     c_f,a,b,c,d,fac,p_i,npnp,p_third :: REAL
!     gamma,a_b_omega,delta,p2,fi :: REAL
!     i :: INT
!     c_f = (THREE/TEN)*(3*PI*PI)**(THIRD+THIRD)
!     a = 0.04918
!     b = 0.132
!     c = 0.2533
!     d = 0.349
!     fac = TWO**(11*THIRD)*c_f
!     if (DO_IN_PARALLEL) f = ZERO
!     parallel do i = 1,size(p)
!       p_i = HALF*p(i)
!       p2 = p_i*p_i
!       npnp = QUARTER*dot_product(np(i,:),np(i,:))
!       p_third = (TWO*p_i)**THIRD
!       gamma = ONE + d/p_third
!       a_b_omega = a*b*exp(-c/p_third)/(gamma*p_third**11)
!       delta = (c+d/gamma)/p_third
!       fi = -a * TWO*p_i/gamma &
!            +a_b_omega*p2*npnp*(6+14*delta)/NINE &
!            -a_b_omega*fac*TWO*p_i**(14*THIRD)
!       f(i) = f(i) + fi
!     end
!     PARALLEL_SUM(f)
!   end

   r_LYP_c_potential(V0,rho0,V1,rho1)
   ! Return the derivatives of the LYP correlation functional.
   ! These equations are essentially the same as in the appendix of JCP 98(7)
   ! 5612-5626.
      V0   :: VEC{REAL}, INOUT
      rho0 :: VEC{REAL}, IN
      V1   :: MAT{REAL}, INOUT
      rho1 :: MAT{REAL}, IN
      const,two_13,two_m13,two_113,two_m113,a,b,c,d,e,ab9 :: REAL
      rho,rho_13,rho_m13,rho_83,rho_m83,p_third,ax,ay,az,aa,fac :: REAL
      gamma_inv,mu,abw9_pa,delta :: REAL
      i :: INT
      const = (THREE/TEN)*(3*PI*PI)**(TWOTHIRDS)
      two_13   = TWO**THIRD
      two_m13  = ONE/two_13
      two_113  = 16*two_m13
      two_m113 = ONE/two_113
      a = 0.04918d0
      b = 0.132d0
      c = 0.2533d0
      d = 0.349d0
      e = two_113 * const
      ab9 = a*b*NINTH
      do i = 1,rho0.dim
         rho = rho0(i)
         if (rho<.rho_cutoff) cycle
         rho = HALF*rho
         ax  = HALF*rho1(i,1)
         ay  = HALF*rho1(i,2)
         az  = HALF*rho1(i,3)
         aa  = ax*ax+ay*ay+az*az
         rho_13  = rho**(THIRD)
         rho_m13 = ONE/rho_13
         rho_83  = rho*rho*rho*rho_m13
         rho_m83 = ONE/rho_83
         p_third = two_m13*rho_m13
         gamma_inv = ONE/(ONE+d*p_third)
         mu = d*gamma_inv*p_third
         abw9_pa = two_m113 * ab9*exp(-c*p_third) * rho_m83 * gamma_inv
         delta = c*p_third + mu
         V0(i) = V0(i) -a*gamma_inv*(ONE+THIRD*mu) &
           +abw9_pa*aa*(SEVEN*THIRD*(mu*mu+delta*delta)-13*delta-5) &
           -abw9_pa*e*(3*delta+9)*rho_83
         fac = abw9_pa*rho*(6+14*delta)
         V1(i,1) = V1(i,1) + fac*ax
         V1(i,2) = V1(i,2) + fac*ay
         V1(i,3) = V1(i,3) + fac*az
      end
   end

!   r_LYP_c_potential(local,p,non_local,np)
!   ! Return the derivatives of the LYP correlation functional.
!   ! These equations are essentially the same as in the appendix of JCP 98(7)
!   ! 5612-5626.
!     local :: VEC{REAL}
!     p :: VEC{REAL}, IN
!     non_local :: MAT{REAL}
!     np :: MAT{REAL}, IN
!     npa :: VEC{REAL}(3)
!     a,b,c,d,e,c_f,ab9 :: REAL
!     pa,pa_third,p_third,npanpa :: REAL
!     gamma_inv,mu,abw9_pa,delta :: REAL
!     i :: INT
!
!     c_f = (THREE/TEN)*(3*PI*PI)**(TWOTHIRDS)
!     a = 0.04918
!     b = 0.132
!     c = 0.2533
!     d = 0.349
!     e = (TWO)**(11*THIRD) * c_f
!     ab9 = a*b/NINE
!
!     do i=1,size(p)
!       pa = HALF*p(i)
!       npa = HALF*np(i,:)
!       npanpa = dot_product(npa,npa)
!       pa_third = pa**(THIRD)
!       p_third = TWO**(THIRD)*pa_third
!       gamma_inv = ONE/(ONE + d / p_third)
!       mu=d*gamma_inv/p_third
!       abw9_pa = (HALF)**4 * ab9*exp(-c/p_third) * p_third/(pa*pa*pa) * gamma_inv
!       delta = c/p_third + mu
!
!       local(i) = local(i) -a*gamma_inv*(ONE+THIRD*mu) &
!         +abw9_pa*npanpa*(SEVEN/3*(mu*mu+delta*delta)-13*delta-5) &
!         -abw9_pa*e*(3*delta+9)*pa*pa*pa/pa_third
!       non_local(i,:) = non_local(i,:) + abw9_pa*pa*npa*(6+14*delta)
!     end
!   end


   u_LYP_c_functional(f,rho0a,rho0b,rho1a,rho1b)
   ! Return the values of the Lee-Yang-Parr functional.
      f :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      rho1a,rho1b :: MAT{REAL}, IN
      c_f,a,b,c,d,fac,pa,pb,p,npanpa,npbnpb,npanpb,p_third :: REAL
      gamma,a_b_omega,delta,pa_pb_n,fi :: REAL
      i :: INT
      c_f = (THREE/TEN)*(3*PI*PI)**(THIRD+THIRD)
      a = 0.04918
      b = 0.132
      c = 0.2533
      d = 0.349
      fac = TWO**(11*THIRD)*c_f
      do i = 1,size(rho0a)
         pa = rho0a(i)
         pb = rho0b(i)
         if (pa<.rho_cutoff) cycle
         if (pb<.rho_cutoff) cycle
         p = pa + pb
         npanpa = dot_product(rho1a(i,:),rho1a(i,:))
         npbnpb = dot_product(rho1b(i,:),rho1b(i,:))
         npanpb = dot_product(rho1a(i,:),rho1b(i,:))
         p_third = p**THIRD
         gamma = ONE + d/p_third
         a_b_omega = a*b*exp(-c/p_third)/(gamma*p_third**11)
         delta = (c+d/gamma)/p_third
         pa_pb_n=pa*pb/NINE
         fi = -a * FOUR*pa*pb/(p*gamma)
         fi = fi - a_b_omega*fac*pa*pb*(pa**(EIGHT*THIRD)+pb**(EIGHT*THIRD))
         fi = fi + a_b_omega*(pa_pb_n*(FOUR*delta-ONE-(11*pa+pb*delta)/p) + pb*pb)*npanpa
         fi = fi + a_b_omega*(pa_pb_n*(FOUR*delta-ONE-(11*pb+pa*delta)/p) + pa*pa)*npbnpb
         fi = fi + a_b_omega*(12/NINE*p*p - pa_pb_n*(47-SEVEN*delta))*npanpb
         f(i) = f(i) + fi
      end
   end

   u_LYP_c_energy_density(f,rho0a,rho0b,rho1a,rho1b)
   ! Return the values of the Lee-Yang-Parr functional.
      f :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      rho1a,rho1b :: MAT{REAL}, IN
      c_f,a,b,c,d,fac,pa,pb,p,npanpa,npbnpb,npanpb,p_third :: REAL
      gamma,a_b_omega,delta,pa_pb_n,fi :: REAL
      i :: INT
      c_f = (THREE/TEN)*(3*PI*PI)**(THIRD+THIRD)
      a = 0.04918
      b = 0.132
      c = 0.2533
      d = 0.349
      fac = TWO**(11*THIRD)*c_f
      do i = 1,size(rho0a)
         pa = rho0a(i)
         pb = rho0b(i)
         if (pa<.rho_cutoff) cycle
         if (pb<.rho_cutoff) cycle
         p = pa + pb
         npanpa = dot_product(rho1a(i,:),rho1a(i,:))
         npbnpb = dot_product(rho1b(i,:),rho1b(i,:))
         npanpb = dot_product(rho1a(i,:),rho1b(i,:))
         p_third = p**THIRD
         gamma = ONE + d/p_third
         a_b_omega = a*b*exp(-c/p_third)/(gamma*p*p_third**11)
         delta = (c+d/gamma)/p_third
         pa_pb_n=pa*pb/NINE
         fi = -a * FOUR*pa*pb/(p*p*gamma)
         fi = fi - a_b_omega*fac*pa*pb*(pa**(EIGHT*THIRD)+pb**(EIGHT*THIRD))
         fi = fi + a_b_omega*(pa_pb_n*(FOUR*delta-ONE-(11*pa+pb*delta)/p) + pb*pb)*npanpa
         fi = fi + a_b_omega*(pa_pb_n*(FOUR*delta-ONE-(11*pb+pa*delta)/p) + pa*pa)*npbnpb
         fi = fi + a_b_omega*(12/NINE*p*p - pa_pb_n*(47-SEVEN*delta))*npanpb
         f(i) = f(i) + fi
      end
   end

   u_LYP_c_potential(V0a,V0b,rho0a,rho0b,V1a,V1b,rho1a,rho1b)
   ! Return the derivatives of the LYP correlation functional.
   ! These equations are essentially the same as in the appendix of JCP 98(7)
   ! 5612-5626.
      V0a,V0b     :: VEC{REAL}, INOUT
      rho0a,rho0b :: VEC{REAL}, IN
      V1a,V1b     :: MAT{REAL}, INOUT
      rho1a,rho1b :: MAT{REAL}, IN
      npa,npb :: VEC{REAL}(3)
      a,b,c,d,e,c_f,ab9 :: REAL
      pa,pb,p,p2,pa2,pb2,papb,p_third,npanpa,npbnpb,npanpb :: REAL
      gamma_inv,mu,abw9,abw27,delta,pa83,pb83,tmp1,tmp2 :: REAL
      dfdnpanpb,dfdnpanpa,dfdnpbnpb :: REAL
      i :: INT
 
      c_f = (THREE/TEN)*(3*PI*PI)**(THIRD+THIRD)
      a = 0.04918
      b = 0.132
      c = 0.2533
      d = 0.349
      e = TWO**(11*THIRD) * NINE * c_f
      ab9 = a*b/NINE
 
      do i = 1,rho0a.dim
         pa = rho0a(i)
         pb = rho0b(i)
         if (pa<.rho_cutoff) cycle
         if (pb<.rho_cutoff) cycle
         npa = rho1a(i,:)
         npb = rho1b(i,:)
         npanpa = dot_product(npa,npa)
         npbnpb = dot_product(npb,npb)
         npanpb = dot_product(npa,npb)
         p = pa + pb
         p_third = p**(THIRD)
         gamma_inv = ONE/(ONE + d / p_third)
         mu=d*gamma_inv/p_third
         p2=p*p
         abw9 = ab9*exp(-c/p_third) * p_third/(p2*p2) * gamma_inv
         abw27 = abw9*THIRD
         delta = c/p_third + mu
         pa2=pa*pa
         pb2=pb*pb
         pa83=pa2*pa/pa**THIRD
         pb83=pb2*pb/pb**THIRD
         tmp1 = pa*pb/p*(7*mu*mu+delta*(7*delta-131)+517)
         tmp2 = (delta-11)/p*(pb83+pa83)
         papb=pa*pb
  
         V0a(i) = V0a(i) -4*a*pb*gamma_inv/p2*(pb+THIRD*mu*pa) &
           +abw27*npanpb*(pa*(12*delta-60)+pb*(33*delta-201) + tmp1) &
           +abw27*npanpa*pb/p2*(96*pa2-160*papb-102*pb2 &
            +(-48*pa2-4*papb+18*pb2)*delta+pa*(4*p-pb)*(delta*delta+mu*mu)) &
           +abw27*npbnpb/p2*(-45*pa2*pa+17*pa2*pb+180*pa*pb2-36*pb2*pb &
            +(9*pa2*pa-19*pa2*pb-42*pa*pb2+12*pb2*pb)*delta &
            +papb*(4*p-pa)*(delta*delta+mu*mu)) &
           -abw27*pb*e*(pa*tmp2+11*pa83+3*pb83)
         V0b(i) = V0b(i) -4*a*pa*gamma_inv/p2*(pa+THIRD*mu*pb) &
           +abw27*npanpb*(pb*(12*delta-60)+pa*(33*delta-201) + tmp1) &
           +abw27*npbnpb*pa/p2*(96*pb2-160*papb-102*pa2 &
            +(-48*pb2-4*papb+18*pa2)*delta+pb*(4*p-pa)*(delta*delta+mu*mu)) &
           +abw27*npanpa/p2*(-45*pb2*pb+17*pb2*pa+180*pb*pa2-36*pa2*pa &
            +(9*pb2*pb-19*pb2*pa-42*pb*pa2+12*pa2*pa)*delta &
            +papb*(4*p-pb)*(delta*delta+mu*mu)) &
           -abw27*pa*e*(pb*tmp2+11*pb83+3*pa83)
  
         dfdnpanpb = abw9*(12*p2-papb*(47-7*delta))
         dfdnpanpa = abw9*(NINE*pb2+papb*(FOUR*delta-ONE-(11*pa+pb*delta)/p))
         dfdnpbnpb = abw9*(NINE*pa2+papb*(FOUR*delta-ONE-(11*pb+pa*delta)/p))
         V1a(i,:) = V1a(i,:) + TWO*dfdnpanpa*npa+dfdnpanpb*npb
         V1b(i,:) = V1b(i,:) + TWO*dfdnpbnpb*npb+dfdnpanpb*npa
      end
   end


   r_Gill96_x_functional(f,p,np)
   ! Return the values of the Gill 96 exchange functional.
   ! Untested
      self :: IN
      f :: VEC{REAL}, OUT
      p :: VEC{REAL}, IN
      np :: MAT{REAL}, IN
      np_i :: VEC{REAL}(3)
      alpha,fac,x,pft :: REAL
      i :: INT
      alpha = -THREE/TWO * (THREE/(FOUR*PI))**THIRD
      fac = ONE/137
      do i=1,size(p)
         pft = (HALF*p(i)) ** (FOURTHIRDS)
         np_i = HALF*np(i,:)
         x = max(sqrt(dot_product(np_i,np_i)) / pft,.rho_cutoff)
         f(i) = TWO*pft * (alpha - fac*x*sqrt(x))
      end
   end

   r_Gill96_x_potential(p,np,local,non_local)
   ! Return the derivatives of the Gill 96 exchange functional.
   ! Untested
      self :: IN
      p :: VEC{REAL}, IN
      np :: MAT{REAL}, IN
      local :: VEC{REAL}, OUT
      non_local :: MAT{REAL}, OUT
      np_i :: VEC{REAL}(3)
      alpha,fac,fac1,p_i,p_third,x,x2,nl :: REAL
      i :: INT
      alpha = -THREE/TWO * (THREE/(FOUR*PI))**THIRD
      fac = ONE/274
      fac1 = -THREE/548
      do i=1,size(p)
         p_i = HALF*p(i)
         np_i = HALF*np(i,:)
         p_third = p_i**(THIRD)
         x = max(sqrt(dot_product(np_i,np_i))/(p_i*p_third),.rho_cutoff)
         x2 = sqrt(x)
         local(i) = FOURTHIRDS*p_third*(alpha+fac*x*x2)
         if (x < TOL(19)) then
           non_local(i,:) = ZERO
         else
           nl = TWO*fac1*x2/(x*p_i*p_third)
           non_local(i,:) = nl*np_i(:)
         end
      end
   end


   u_Gill96_exchange_functional(f,rho0a,rho0b,rho1a,rho1b)
   ! Return the values of the Gill 96 exchange functional.
      f :: VEC{REAL}
      rho0a,rho0b :: VEC{REAL}, IN
      rho1a,rho1b :: MAT{REAL}, IN
      alpha,fac,xa,xb,paft,pbft :: REAL
      i :: INT
      alpha = -THREE/TWO * (THREE/(FOUR*PI))**THIRD
      fac = ONE/137
      do i=1,size(rho0a)
         paft = (rho0a(i)) ** (FOURTHIRDS)
         pbft = (rho0b(i)) ** (FOURTHIRDS)
         xa = max(sqrt(dot_product(rho1a(i,:),rho1a(i,:))) / paft,.rho_cutoff)
         xb = max(sqrt(dot_product(rho1b(i,:),rho1b(i,:))) / pbft,.rho_cutoff)
         f(i) = paft * (alpha - fac*xa*sqrt(xa)) + pbft * (alpha - fac*xb*sqrt(xb))
      end
   end

   u_Gill96_x_potential(V0a,V0b,rho0a,rho0b,V1a,V1b,rho1a,rho1b)
   ! Return the derivatives of the Gill 96 exchange functional.
      V0a,V0b     :: VEC{REAL}, OUT
      rho0a,rho0b :: VEC{REAL}, IN
      V1a,V1b     :: MAT{REAL}, OUT
      rho1a,rho1b :: MAT{REAL}, IN
      npa,npb :: VEC{REAL}(3)
      alpha,fac,fac1,pa,pb,pa_third,pb_third,xa,xb,xa2,xb2,nla,nlb :: REAL
      i,n_pt :: INT
      n_pt = size(rho0a)
      alpha = -THREE/TWO * (THREE/(FOUR*PI))**THIRD
      fac = ONE/274
      fac1 = -THREE/548
      do i=1,n_pt
         pa = rho0a(i)
         pb = rho0b(i)
         npa = rho1a(i,:)
         npb = rho1b(i,:)
         pa_third = pa**(THIRD)
         pb_third = pb**(THIRD)
         xa = max(sqrt(dot_product(npa,npa))/(pa*pa_third),.rho_cutoff)
         xb = max(sqrt(dot_product(npb,npb))/(pb*pb_third),.rho_cutoff)
         xa2 = sqrt(xa)
         xb2 = sqrt(xb)
         V0a(i) = FOURTHIRDS*pa_third*(alpha+fac*xa*xa2)
         V0b(i) = FOURTHIRDS*pb_third*(alpha+fac*xb*xb2)
         if (xa < TOL(19)) then
           V1a(i,:) = ZERO
         else
           nla = TWO*fac1*xa2/(xa*pa*pa_third)
           V1a(i,:) = nla*npa(:)
         end
         if (xb < TOL(19)) then
           V1b(i,:) = ZERO
         else
           nlb = TWO*fac1*xb2/(xb*pb*pb_third)
           V1b(i,:) = nlb*npb(:)
         end
      end
   end

end
