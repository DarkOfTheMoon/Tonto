!-------------------------------------------------------------------------------
!
! OPMAT: Operator matrices. 
!
! Provide a basis set (matrix) representation of a one-electron quantum 
! mechanical operator. Can cope with polymorphic types of basis representations,
! including restricted, unrestricted, and general basis orbital matrices.
! Also, complex types for all these matrices.
!
! Basically, its a polymorphic matrix type.
!
! (c) dylan jayatilaka 1998
!
! $Id$
!-------------------------------------------------------------------------------
module OPMAT

   use TYPES
   use SYSTEM
   use STR

   use VEC
   use MAT
   use CMAT

   implicit none         

#  include "macros"
#  include "opmat.int"

!  type opmat_type
!     INT       :: n_bf                   ! AO basis set size
!     MAT, PTR  :: restricted             ! Restricted spinorbital representation
!     MAT, PTR  :: alpha                  ! Alpha part of a DODS representation
!     MAT, PTR  :: beta                   ! Beta  part of a DODS representation
!     MAT, PTR  :: general                ! General mixed alpha-beta matrix representation
!     CMAT, PTR :: restricted_complex     ! Complex restricted representation
!     CMAT, PTR :: alpha_complex          ! Complex alpha part of a DODS representation
!     CMAT, PTR :: beta_complex           ! Complex beta  part of a DODS representation
!     CMAT, PTR :: general_complex        ! Complex general mixed alpha-beta matrix representation
!     VEC, PTR  :: triangle               ! Space saving : lower traingle
!     CVEC, PTR :: square                 ! Space saving : lower traingle for real part, upper for imaginary
!  end 

contains

   create(n_bf,kind)
   ! Create an opmat object, in a basis set with "n_bf" spatial orbitals
      PTR :: self
      INT, IN :: n_bf
      STR(*), optional :: kind
      nullify(self)
      allocate(self)
      ADD_MEM(OPMAT_SIZE)
      .nullify_ptr_part
      .n_bf = n_bf
      if (present(kind)) .create(kind)
   end

   destroy 
   ! Destroy an opmat object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(OPMAT_SIZE)
      deallocate(self)
   end

   create(kind)
   ! Create the appropriate spinorbital kind the opmat
      STR(*) :: kind
      INT :: n_bf
      n_bf = .n_bf
      select case (kind)
         case ("restricted");           .restricted.create(n_bf,n_bf)
         case ("unrestricted");         .alpha.create(n_bf,n_bf)
                                        .beta.create(n_bf,n_bf)
         case ("alpha");                .alpha.create(n_bf,n_bf)
         case ("beta");                 .beta.create(n_bf,n_bf)
         case ("general");              .general.create(2*n_bf,2*n_bf)
         case ("restricted_complex");   .restricted_complex.create(n_bf,n_bf)
         case ("unrestricted_complex"); .alpha_complex.create(n_bf,n_bf)
                                        .beta_complex.create(n_bf,n_bf)
         case ("alpha_complex");        .alpha_complex.create(n_bf,n_bf)
         case ("beta_complex");         .beta_complex.create(n_bf,n_bf)
         case ("general_complex");      .general_complex.create(2*n_bf,2*n_bf)
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   destroy(kind)
   ! Destroy the appropriate spinorbital kind of the opmat
      STR(*) :: kind
      select case (kind)
         case ("restricted");           .restricted.destroy
         case ("unrestricted");         .alpha.destroy; .beta.destroy
         case ("alpha");                .alpha.destroy
         case ("beta");                 .beta.destroy
         case ("general");              .general.destroy
         case ("restricted_complex");   .restricted_complex.destroy
         case ("unrestricted_complex"); .alpha_complex.destroy
                                        .beta_complex.destroy
         case ("alpha_complex");        .alpha_complex.destroy
         case ("beta_complex");         .beta_complex.destroy
         case ("general_complex");      .general_complex.destroy
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the opmat object
      nullify(.restricted)
      nullify(.alpha)
      nullify(.beta)
      nullify(.general)
      nullify(.restricted_complex)
      nullify(.alpha_complex)
      nullify(.beta_complex)
      nullify(.general_complex)
      nullify(.triangle)
      nullify(.square)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of the opmat object
      .restricted.destroy
      .alpha.destroy
      .beta.destroy
      .general.destroy
      .restricted_complex.destroy
      .alpha_complex.destroy
      .beta_complex.destroy
      .general_complex.destroy
      .triangle.destroy
      .square.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   any_created result(res)
   ! Returns true if any component of self has been created
      BIN :: res
      BIN, dimension(6) :: c
      c(1) = .restricted.created
      c(2) = .alpha.created
      c(3) = .general.created
      c(4) = .restricted_complex.created
      c(5) = .alpha_complex.created
      c(6) = .general_complex.created
      res = any(c)
   end

   all_destroyed result(res)
   ! Returns true if all components of self have been destroyed
      BIN :: res
      BIN, dimension(6) :: d
      d(1) = .restricted.destroyed
      d(2) = .alpha.destroyed
      d(3) = .general.destroyed
      d(4) = .restricted_complex.destroyed
      d(5) = .alpha_complex.destroyed
      d(6) = .general_complex.destroyed
      res = all(d)
   end

   created(kind) result(res)
   ! Returns true if subkind "kind" of self has been created
      PTR :: self
      STR(*) :: kind
      BIN :: res
      if (NOT associated(self)) then
                                           res = FALSE; RETURN
      else
         select case (kind)
            case ("restricted");           res = .restricted.created
            case ("unrestricted");         res = .alpha.created
            case ("general");              res = .general.created
            case ("restricted_complex");   res = .restricted_complex.created
            case ("unrestricted_complex"); res = .alpha_complex.created
            case ("general_complex");      res = .general_complex.created
            case default; DIE("unknown spinorbital kind, " // kind.trim)
         end
      end
   end

  destroyed(kind) result(res)
  ! Returns true if subkind "kind" of self has *not* been created
    PTR :: self
    STR(*) :: kind
    BIN :: res
    if (NOT associated(self)) then
                                       res = TRUE; RETURN
    else
      select case (kind)
        case ("restricted");           res = .restricted.destroyed
        case ("unrestricted");         res = .alpha.destroyed
        case ("general");              res = .general.destroyed
        case ("restricted_complex");   res = .restricted_complex.destroyed
        case ("unrestricted_complex"); res = .alpha_complex.destroyed
        case ("general_complex");      res = .general_complex.destroyed
        case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
    end
  end

   set(n_bf)
   ! Set with "n_bf" spatial orbitals
      INT :: n_bf
      .n_bf = n_bf
   end

   set_to(m) [leaky]
   ! Set self to "m". 
      OPMAT :: m
      .set( m.n_bf)
      if ( m.all_destroyed) return
      if ( m.restricted.created) then
         .destroy("restricted"); .create("restricted")
         .restricted = m.restricted
      end
      if ( m.alpha.created) then
         .destroy("alpha"); .create("alpha")
          .alpha = m.alpha
      end
      if ( m.beta.created) then
         .destroy("beta"); .create("beta")
         .beta = m.beta
      end
      if ( m.general.created) then
         .destroy("general"); .create("general")
         .general = m.general
      end
      if ( m.restricted_complex.created) then
         .destroy("restricted_complex"); .create("restricted_complex")
         .restricted_complex = m.restricted_complex
      end
      if ( m.alpha_complex.created) then
         .destroy("alpha_complex"); .create("alpha_complex")
         .alpha_complex = m.alpha_complex
      end
      if ( m.beta_complex.created) then
         .destroy("beta_complex"); .create("beta_complex")
         .beta_complex = m.beta_complex
      end
      if ( m.general_complex.created) then
         .destroy("general_complex"); .create("general_complex")
         .general_complex = m.general_complex
      end
   end

   spinorbital_kind result(res)
   ! Return the kind of spinorbitals used in the representation
   ! The simplest spinorbital kind in use is the one returned.
      STR :: res
      if      ( .restricted.created )         then; res = "restricted"
      else if ( .alpha.created )              then; res = "unrestricted"
      else if ( .general.created )            then; res = "general"
      else if ( .restricted_complex.created ) then; res = "restricted_complex"
      else if ( .alpha_complex.created )      then; res = "unrestricted_complex"
      else if ( .general_complex.created )    then; res = "general_complex"
      else; DIE("no object created")
      end
   end

   number_kind result(res)
   ! Return the kind of numbers used in the representation
      STR :: res
      if      ( .restricted.created )         then; res = "real"
      else if ( .alpha.created )              then; res = "real"
      else if ( .general.created )            then; res = "real"
      else if ( .restricted_complex.created ) then; res = "complex"
      else if ( .alpha_complex.created )      then; res = "complex"
      else if ( .general_complex.created )    then; res = "complex"
      else; DIE("no object created")
      end
   end

   guess_scf_kind result(res)
   ! Guess the kind of SCF to be used from the spinorbitals used in the
   ! representation.
      STR :: res
      if      ( .restricted.created )         then; res = "rhf"
      else if ( .alpha.created )              then; res = "uhf"
      else if ( .general.created )            then; res = "ghf"
      else if ( .restricted_complex.created ) then; res = "rchf"
      else if ( .alpha_complex.created )      then; res = "uchf"
      else if ( .general_complex.created )    then; res = "gchf"
      else; DIE("no object created")
      end
   end

   zero
   ! Set self to zero
      STR :: kind
      kind = .spinorbital_kind
      select case(kind)
         case("restricted");           .restricted = ZERO
         case("unrestricted");         .alpha = ZERO; .beta = ZERO
         case("alpha");                .alpha = ZERO
         case("beta");                 .beta = ZERO
         case("general");              .general = ZERO
         case("restricted_complex");   .restricted = ZERO
         case("unrestricted_complex"); .alpha_complex = ZERO
                                       .beta_complex = ZERO
         case("alpha_complex");        .alpha_complex = ZERO
         case("beta_complex");         .beta_complex = ZERO
         case("general_complex");      .general_complex = ZERO
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   convert_to(newkind,factor) [leaky]
   ! Convert self to a new basis kind "newkind".  To convert MO's please use
   ! the next routine.
      STR(*) :: newkind
      DBL, optional :: factor
      DBL :: fac
      STR :: oldkind
      fac = ONE
      if (present(factor)) fac = factor
      oldkind = .spinorbital_kind
      if (newkind==oldkind) return
      .create(newkind)
      select case (oldkind)
         case("restricted")
            select case (newkind)
               case("unrestricted")
                  .alpha = fac*.restricted
                  .beta  = fac*.restricted
               case("general")
                  .general = ZERO
                  .general.alpha_alpha_set_to(.restricted,factor=fac)
                  .general.beta_beta_set_to(.restricted,factor=fac)
               case("restricted_complex")
                  .restricted_complex = .restricted
               case("unrestricted_complex")
                  .alpha_complex = fac*.restricted
                  .beta_complex  = fac*.restricted
               case("general_complex")
                  .general_complex = ZERO
                  .general_complex.alpha_alpha_set_to(.restricted,factor=fac)
                  .general_complex.beta_beta_set_to(.restricted,factor=fac)
               case default
                  DIE("cant convert kind " // oldkind // " to kind " // newkind)
            end
         case("unrestricted")
            select case (newkind)
               case("restricted")
                  .restricted = fac*.alpha
               case("general")
                  .general = ZERO
                  .general.alpha_alpha_set_to(.alpha)
                  .general.beta_beta_set_to(.beta)
               case("unrestricted_complex")
                  .alpha_complex = .alpha
                  .beta_complex  = .beta
               case("general_complex")
                  .general_complex = ZERO
                  .general_complex.alpha_alpha_set_to(.alpha)
                  .general_complex.beta_beta_set_to(.beta)
               case default
                  DIE("cant convert kind " // oldkind // " to kind " // newkind)
            end
         case("general")
            select case (newkind)
               case("unrestricted")
                  .alpha = .general.alpha_alpha
                  .beta  = .general.beta_beta
               case("general_complex")
                  .general_complex = .general
               case default
                  DIE("cant convert kind " // oldkind // " to kind " // newkind)
            end
         case default; DIE("cant convert old kind " // oldkind)
      end
      .destroy(oldkind)
   end

  convert_to(newkind,n_bf,n_a,n_b) [leaky]
  ! Convert self (which is regarded to be a set of MO's) to a
  ! new basis kind "newkind"
    STR(*) :: newkind
    INT :: n_bf,n_a,n_b
    STR :: oldkind
    INT :: n_e
    n_e = n_a + n_b
    oldkind = .spinorbital_kind
    if (newkind==oldkind) return
    .create(newkind)
    select case (oldkind)
      case("restricted")
        select case (newkind)
          case("unrestricted")
            .alpha = .restricted
            .beta  = .restricted
          case("general")
            .general = ZERO
            .general(1:n_bf ,1:2*n_b-1:2)  = .restricted(:,1:n_b)
            .general(n_bf+1:,2:2*n_b  :2)  = .restricted(:,1:n_b)
            .general(1:n_bf ,2*n_b+1:n_e)  = .restricted(:,n_b+1:n_a)
            .general(n_bf+1:,n_e+1:2*n_a)  = .restricted(:,n_b+1:n_a)
            .general(1:n_bf ,2*n_a+1:2*n_bf-1:2) = .restricted(:,n_a+1:n_bf)
            .general(n_bf+1:,2*n_a+2:2*n_bf  :2) = .restricted(:,n_a+1:n_bf)
          case("restricted_complex")
            .restricted_complex = .restricted
          case("unrestricted_complex")
            .alpha_complex = .restricted
            .beta_complex  = .restricted
          case("general_complex")
            .general_complex = ZERO
            .general_complex(1:n_bf ,1:2*n_b-1:2)  = .restricted(:,1:n_b)
            .general_complex(n_bf+1:,2:2*n_b  :2)  = .restricted(:,1:n_b)
            .general_complex(1:n_bf ,2*n_b+1:n_e)  = .restricted(:,n_b+1:n_a)
            .general_complex(n_bf+1:,n_e+1:2*n_a)  = .restricted(:,n_b+1:n_a)
            .general_complex(1:n_bf ,2*n_a+1:2*n_bf-1:2) = .restricted(:,n_a+1:n_bf)
            .general_complex(n_bf+1:,2*n_a+2:2*n_bf  :2) = .restricted(:,n_a+1:n_bf)
          case default
            DIE("cant convert kind " // oldkind // " to kind " // newkind)
        end
      case("unrestricted")
        select case (newkind)
          case("restricted","alpha")
            .restricted = .alpha ! Loss of information here
            WARN("Conversion from "//oldkind//" to "//newkind//" ignores beta orbitals")
          case("beta")
            .restricted = .beta  ! Loss of information here
            WARN("Conversion from "//oldkind//" to "//newkind//" ignores alpha orbitals")
          case("general")
            .general = ZERO
            .general(1:n_bf ,1:2*n_b-1:2)  = .alpha(:,1:n_b)
            .general(n_bf+1:,2:2*n_b  :2)  = .beta(:,1:n_b)
            .general(1:n_bf ,2*n_b+1:n_e)  = .alpha(:,n_b+1:n_a)
            .general(n_bf+1:,n_e+1:2*n_a)  = .beta(:,n_b+1:n_a)
            .general(1:n_bf ,2*n_a+1:2*n_bf-1:2) = .alpha(:,n_a+1:n_bf)
            .general(n_bf+1:,2*n_a+2:2*n_bf  :2) = .beta(:,n_a+1:n_bf)
          case("unrestricted_complex")
            .alpha_complex = .alpha
            .beta_complex  = .beta
          case("general_complex")
            .general_complex = ZERO
            .general_complex(1:n_bf ,1    :n_a)       = .alpha(:,1:n_a)
            .general_complex(1:n_bf ,n_e+1:n_b+n_bf)  = .alpha(:,n_a+1:)
            .general_complex(n_bf+1:,n_a+1:n_e)       = .beta(:,1:n_b)
            .general_complex(n_bf+1:,n_e+n_bf-n_a+1:) = .beta(:,n_b+1:)
          ! .general_complex(1:n_bf ,1:2*n_b-1:2)  = .alpha(:,1:n_b)
          ! .general_complex(n_bf+1:,2:2*n_b  :2)  = .beta(:,1:n_b)
          ! .general_complex(1:n_bf ,2*n_b+1:n_e)  = .alpha(:,n_b+1:n_a)
          ! .general_complex(n_bf+1:,n_e+1:2*n_a)  = .beta(:,n_b+1:n_a)
          ! .general_complex(1:n_bf ,2*n_a+1:2*n_bf-1:2) = .alpha(:,n_a+1:n_bf)
          ! .general_complex(n_bf+1:,2*n_a+2:2*n_bf  :2) = .beta(:,n_a+1:n_bf)
          case default
            DIE("cant convert kind " // oldkind // " to kind " // newkind)
        end
      case("general")
        select case (newkind)
          case("unrestricted")
            .general.alpha_alpha_put_to(.alpha)
            .general.beta_beta_put_to(.beta)
            WARN("Conversion from "//oldkind//" to "//newkind//" not recommended!")
          case("general_complex")
            .general_complex = .general
          case default
            DIE("cant convert kind " // oldkind // " to kind " // newkind)
        end
      case default; DIE("cant convert old kind " // oldkind)
    end
    .destroy(oldkind)
  end

   l_compress(kind) result(res)
   ! Return the length of the compressed object
      INT :: res
      STR(*), optional :: kind
      STR :: k
      if (present(kind)) then; k = kind
      else;                    k = .spinorbital_kind
      end
      select case (k)
         case("restricted");           res = HALF*.n_bf*(.n_bf+1)
         case("unrestricted");         res = .n_bf*(.n_bf+1)
         case("general");              res = .n_bf*(2*.n_bf+1)
         case("restricted_complex");   res = .n_bf*.n_bf
         case("unrestricted_complex"); res = 2*.n_bf*.n_bf
         case("general_complex");      res = 4*.n_bf*.n_bf
      end
   end

   compress(kind) [leaky]
   ! Compress the opmat into a triangle or square vector to save space
      STR(*), optional :: kind
      STR :: k
      k = .spinorbital_kind
      if (present(kind)) k = kind
      select case (k)
         case("restricted")
            .triangle.destroy
            .triangle.create(.l_compress(k))
            .restricted.to_tri(.triangle)
            .restricted.destroy
         case("unrestricted")
            .triangle.destroy
            .triangle.create(.l_compress(k))
            .alpha.to_tri( .triangle.alpha)
            .beta.to_tri( .triangle.beta)
            .alpha.destroy
            .beta.destroy
         case("general")
            .triangle.destroy
            .triangle.create(.l_compress(k))
            .general.to_tri(.triangle)
         case("restricted_complex")
            .square.destroy
            .square.create(.l_compress(k))
            .restricted_complex.to_square(.square)
            .restricted_complex.destroy
         case("unrestricted_complex")
            .square.destroy
            .square.create(.l_compress(k))
            .alpha_complex.to_square( .square.alpha)
            .beta_complex.to_square( .square.beta)
            .alpha_complex.destroy
            .beta_complex.destroy
         case("general_complex")
            .square.destroy
            .square.create(.l_compress(k))
            .general_complex.to_square( .square)
            .general_complex.destroy
      end
   end

   uncompress [leaky]
   ! Uncompress the opmat
      INT :: l_compress
      if (.triangle.created) l_compress = size(.triangle)
      if (.square.created)   l_compress = size(.square)
      if (l_compress==.l_compress("restricted")) then
            .destroy("restricted")
            .create("restricted")
            .restricted.from_tri(.triangle)
            .triangle.destroy
      else if (l_compress==.l_compress("unrestricted")) then
            .destroy("unrestricted")
            .create("unrestricted")
            .alpha.from_tri( .triangle.alpha)
            .beta.from_tri( .triangle.beta)
            .triangle.destroy
      else if (l_compress==.l_compress("general")) then
            .destroy("general")
            .create("general")
            .general.from_tri(.triangle)
            .triangle.destroy
      else if (l_compress==.l_compress("restricted_complex")) then
            .destroy("restricted_complex")
            .create("restricted_complex")
            .restricted_complex.from_square(.square)
            .square.destroy
      else if (l_compress==.l_compress("unrestricted_complex")) then
            .destroy("unrestricted_complex")
            .create("unrestricted_complex")
            .alpha_complex.from_square( .square.alpha)
            .beta_complex.from_square( .square.beta)
            .square.destroy
      else if (l_compress==.l_compress("general_complex")) then
            .destroy("general_complex")
            .create("general_complex")
            .general_complex.from_square(.square)
            .square.destroy
      end
   end

   schmidt_orthonormalise(mat)
   ! Schmidt Orthonormalise self.  (For molecular orbitals).
      MAT, IN :: mat
      STR :: kind
      kind = .spinorbital_kind
      select case(kind)
         case("restricted")
                  .restricted.schmidt_orthonormalise(mat)
         case("unrestricted")
                  .alpha.schmidt_orthonormalise(mat)
                  .beta.schmidt_orthonormalise(mat)
         case("alpha")
                  .alpha.schmidt_orthonormalise(mat)
         case("beta")
                  .beta.schmidt_orthonormalise(mat)
         case("general")
                  .general.schmidt_orthonormalise(mat)
         case("restricted_complex")
                  .restricted.schmidt_orthonormalise(mat)
         case("unrestricted_complex")
                  .alpha_complex.schmidt_orthonormalise(mat)
                  .beta_complex.schmidt_orthonormalise(mat)
         case("alpha_complex")
                  .alpha_complex.schmidt_orthonormalise(mat)
         case("beta_complex")
                  .beta_complex.schmidt_orthonormalise(mat)
         case("general_complex")
                  .general_complex.schmidt_orthonormalise(mat)
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

end 
