! $Id$
!---------------------------------------------------------------------------
!  BASISVEC: BASIS vectors
!  (c) dylan jayatilaka, 1998
!---------------------------------------------------------------------------
module BASISVEC

   use TYPES
   use ERROR
   use MM
   use INPUT
   use OUTPUT
   use BASIS

   implicit none

#  include "macros"
#  include "basisvec.int"

contains

!  ******************
!  Allocation methods
!  ******************

   create(dim)
   ! Create space for a shell vector
      PTR :: self
      INT :: dim
      nullify(self)
      allocate(self(dim))
      std_mm.add(dim*BASIS_SIZE)
      .nullify_ptr_part
   end

   destroy
   ! Destroy space for a string vector
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      std_mm.delete(size(self)*BASIS_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      INT :: b
      do b = 1,size(self)
         self(b).nullify_ptr_part
      end
   end

   destroy_ptr_part
   ! Destroy the pointer parts of self
      INT :: b
      do b = 1,size(self)
         self(b).destroy_ptr_part
      end
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

!  *************
!  Input methods
!  *************

   read(in) [leaky]
   ! Read in a list of atomic basis sets from file "in"
      PTR :: self
      INPUT :: in
      INT :: line,n_basis,b
      STR :: word
      BASIS, PTR :: basis
      DIE_IF(associated(self),"basis already created")
      line = in.line_number+1               ! Store line of basis list
      n_basis = 0
      do                                    ! Read ahead for the number of shells
         in.read(word)
         if (word=="end") exit
         in.move_to_previous_item
         basis.create
         basis.read(in)
         basis.destroy
         n_basis = n_basis + 1
      end
      DIE_IF(n_basis==0,"empty basis set list")
      self.create(n_basis)
      in.move_to_line(line)                 ! Move back to the start of the atom list
      do b = 1,n_basis                      ! Read the atom list
         self(b).read(in)
         self(b).unnormalise
      end
      in.read(word)
      DIE_IF(word/="end","end keyword wrongly positioned")
   end

   put(out)
   ! Output the molecule basis set information
      OUTPUT :: out
      INT :: b
      out.text("Basis sets:")
      out.flush
      do b = 1,size(self)
         self(b).put(out)
         out.flush
      end 
   end 
      
end 
