!---------------------------------------------------------------------------
!
!  BASISVEC: BASIS vectors
!
!  (c) dylan jayatilaka, 1998
!
! $Id$
!---------------------------------------------------------------------------
module BASISVEC

   use TYPES
   use SYSTEM
   use STR
   use TEXTFILE
   use BASIS

   implicit none

#  include "macros"
#  include "basisvec.int"

contains

!  ******************
!  Allocation methods
!  ******************

   create(dim)
   ! Create space for a shell vector
      PTR :: self
      INT :: dim
      nullify(self)
      allocate(self(dim))
      ADD_MEM(dim*BASIS_SIZE)
      .nullify_ptr_part
   end

   destroy
   ! Destroy space for a string vector
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(size(self)*BASIS_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      INT :: b
      do b = 1,size(self)
         self(b).nullify_ptr_part
      end
   end

   destroy_ptr_part
   ! Destroy the pointer parts of self
      INT :: b
      do b = 1,size(self)
         self(b).destroy_ptr_part
      end
   end

   create_copy(basisvec)
   ! Create space for an basis vector
      BASISVEC :: basisvec
      PTR :: self
      INT :: dim
      dim = size(basisvec)
      .create(dim)
      .copy(basisvec)
   end
 
   copy(basisvec)
   ! Copy basisvec to self.
   ! Pointers are copied as pointers, so be careful with destroys.
      BASISVEC :: basisvec
      PTR :: self
      INT :: a
      ENSURE(size(self)==size(basisvec), "basisvec size does not match")
      ENSURE( .created, "self not created")
      do a=1,size(basisvec)
        self(a).nullify_ptr_part
        self(a).copy(basisvec(a))
      end
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

!  *************
!  Input methods
!  *************

  read [leaky]
  ! Read in data in the standard order from "stdin".
  ! NOTE: Will create a BASISVEC, if required
    PTR :: self
    STRVEC* :: keywords
    STR :: word
    stdin.read(word)
    ENSURE(word=="{","expecting open bracket symbol, {")
    stdin.read(word)
    ENSURE(word/="}","empty data list!")
    stdin.move_to_previous_item
    nullify(keywords)
    keywords.create(BASIS_INPUT_DATA_ORDER)
    read_loop: do                 ! Loop over input keywords
      stdin.read(word)
      word.to_lower_case
      select case (word)
        case("}");                exit read_loop
        case("data_order=")
          keywords.destroy
          stdin.read_ptr(keywords)
        case("data=")
          stdin.read(word)
          ENSURE(word=="{","expecting open bracket symbol, {")
          .read_data(keywords)
          stdin.read(word)
          ENSURE(word=="}","expecting close bracket symbol, }")
        case("{")
          DIE('use the "data= { ... }" sequence, or remove any brackets "{ ... }"')
        case default
          stdin.move_to_previous_item
          .read_data(keywords)
      end
    end do read_loop
    keywords.destroy
  end

  read_data(keywords) [leaky]
    PTR :: self
    STRVEC, IN :: keywords
    INT :: length
    length = .data_length(keywords)
    if (.created) then
      DIE_IF(length/=size(self),"list length is wrong")
    end
    if (.destroyed) .create(length)
    .process_input(keywords)
  end

  data_length(keywords) result (length) [leaky]
  ! Read ahead to get the number of data items in the vector.
  ! The list data begins with the first data item, not a "{" symbol.
  ! The list data must be terminated by a "}" symbol.
    PTR :: self
    INT :: length
    STRVEC, IN :: keywords
    BASIS* :: basis
    STR :: word
    INT :: line,item
    stdin.read(word)
    ENSURE(word/="}","empty data list!")
    length = 0                             ! Read ahead to get the number
    line = stdin.line_number               ! of bases
    item = stdin.previous_line_item
    do
      stdin.move_to_previous_item
      basis.create
      basis.process_input(keywords)
      basis.destroy
      length = length + 1
      stdin.read(word)
      word.to_lower_case
      if (word=="}") exit
    end
    stdin.move_to_line(line)
    stdin.move_to_line_item(item)
  end

  process_input(keywords) [leaky]
  ! Read in the list information from "stdin".
    PTR :: self
    STRVEC :: keywords
    INT :: s
    do s = 1,size(self)             ! Read the list
      self(s).process_input(keywords)
      self(s).unnormalise
    end
  end

   shrink(length) [leaky]
   ! Shrink the basis vector "self" to "length". Basis sets after this
   ! index are discarded
      PTR :: self
      INT :: length
      INT :: i
      BASISVEC* :: new
      ENSURE(length<.n_basis,"new length must be less than vector length")
      ENSURE(length>0       ,"new length must be positive")
      new.create(length)
      do i = 1,length
         new(i).copy(self(i))
      end
      self.destroy
      self => new
   end

   expand(length) [leaky]
   ! Expand the basis vector "self" to "length". New slots are left
   ! undefined.
      PTR :: self
      INT :: length
      INT :: i
      BASISVEC* :: new
      ENSURE(length>.n_basis,"new length must be bigger than vector length")
      ENSURE(length>0       ,"new length must be positive")
      new.create(length)
      do i = 1,.n_basis
         new(i).copy(self(i))
      end
      self.destroy
      self => new
   end

   unnormalise
   ! Take the normalisation factors out of the primitives, assuming
   ! that the contraction coeff's refer to normalised basis functions
      INT :: b
      do b = 1,size(self)
         self(b).unnormalise
      end
   end

   renormalise
   ! Put back in the normalisation factors of the primitives, assuming
   ! that the contraction coeff's refer to unnormalised basis functions
      INT :: b
      do b = 1,size(self)
         self(b).renormalise
      end
   end

   put
   ! Output the molecule basis set information
      INT :: b
      do b = 1,size(self)
         self(b).put
         stdout.flush
      end
   end

   put_table
   ! Output tables of molecule basis set information
      INT :: b
      do b = 1,size(self)
         self(b).put_table
         stdout.flush
      end
   end

   n_basis result (res)
   ! Return the number of basis sets
      INT :: res
      res = size(self)
   end

  maximum_basis_set_l_value result (res)
  ! Returns the maximum basis set l value
    IN :: self
    INT :: res
    INT :: i,j,l
    res = 0
    do i = 1,size(self)
      do j = 1,size(self(i).shell)
        l = self(i).shell(j).l
        res = max(l,res)
      end
    end
  end

end
