!-------------------------------------------------------------------------------
!
! MOL_io: these routines required by several modules in mol.
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_IO

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL
   use BUFFER
   use IVEC
   use VEC
   use MAT
   use OPVEC
   use OPMAT
   use TEXTFILE
   use ARCHIVE
   use VECDIIS
   use SHELL
   use SHELLVEC
   use BASIS
   use BASISVEC
   use ATOM
   use ATOMVEC
   use POINTGROUP
   use SPACEGROUP
   use CRYSTAL
   use PLOTGRID
   use DFTGRID
   use SCFDATA
   use MOL_COMMON
   use MOL_CRYSTAL

   implicit none         

#  include "macros"
#  include "mol_io.int"

contains

!  ************
!  Read methods
!  ************

   read_multiplicity
   ! Read in the spin multiplicity
      .in.read(.mult)
      ENSURE(.mult/=0,"cannot have zero multiplicity")
   end

   read_gauge_origin
   ! Read in the gauge origin vector for an applied external magnetic field
      .in.read(.gauge_origin)
      .delete_gauge_integrals
   end

   delete_gauge_integrals
   ! Delete all integral files which depend on the gauge origin. 
   ! This is required whenever the gauge origin is changed.
      ARCHIVE :: archive
      archive.set(.name,"Lx_matrix"); archive.delete
      archive.set(.name,"Ly_matrix"); archive.delete
      archive.set(.name,"Lz_matrix"); archive.delete
   end

   read_plotgrid [leaky]
   ! Read in the plot grid data
      if ( .crystal.destroyed) then
        .grid.read(.in,.atom)
      else if ( .crystal.created) then
        .grid.read(.in,.atom,.crystal)
      end
   end

   read_dftgrid [leaky]
   ! Read in the DFT grid data
      .dftgrid.destroy
      .dftgrid.create
      .dftgrid.read(.in)
      .dftgrid.archive.set_root_name(.name)
   end

   read_crystal [leaky]
   ! Read in the crystal data
      .crystal.destroy
      .crystal.create
      .crystal.read(.in)
      if (associated(.atom)) then
         .resolve_axis_system
         .crystal.make_reduced_group_data(.atom)
      end
   end

   read_pointgroup [leaky]
   ! Read in the pointgroup data
      .pointgroup.destroy
      .pointgroup.create
      .pointgroup.read(.in)
   end

   read_scfdata [leaky] 
   ! Read in the scf data
      .scfdata.destroy
      .scfdata.create
      .scfdata.read(.in)
      if (.scfdata.using_diis) then
      .scfdata.diis.set_archive_root_name(.name) 
      .scfdata.diis.set_archive_name("fock_matrix,DIIS")
      end
   end

   read_atoms [leaky]
   ! Read in the atom list information
      .atom.read
      DIE_IF(.atom.bases_are_part_labeled,"some empty basis labels exist")
      .resolve_basis_labels
      .set_atom_info
      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_reduced_group_data(.atom)
      end
   end
  
!  read_basis_labels
!  ! Read in a list of basis set labels for every atom in the molecule
!  ! If a basis set is defined, all atoms must have a resolved basis set
!     ENSURE( .atom.created,"no atoms in atom list")
!     .atom.read_basis_labels
!     .resolve_basis_labels
!  end

   read_basis_sets [leaky]
   ! Read in a list of atomic basis sets for the molecule
      .basis.read
      .resolve_basis_labels
   end

   read_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g.
   ! "restricted".
   ! For use with TONTO generated archives.
      STR :: name,kind
      ARCHIVE :: archive
      ENSURE(.in.buffer.n_items==3, "must specify an archive and a kind")
      .in.read(name)
      .in.read(kind)
      .out.text("reading archive : " // trim(name))
      archive.set(.name,name,kind)
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals)
         case ("density_matrix");     archive.read(.density_matrix)
         case ("natural_orbitals");   archive.read(.natural_orbitals)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("covalent_orbitals");  archive.read(.natural_orbitals)
         case ("ionic_orbitals");     archive.read(.natural_orbitals)
         case default;                DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_ascii_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g.
   ! "restricted".
   ! If required, the input order may be specified as "by_row" (default) or
   ! "by_column".
      STR :: name,kind,order
      ARCHIVE :: archive
      ENSURE(.in.buffer.n_items==3, "must specify an archive and a kind")
      .in.read(name)
      .in.read(kind)
      order = "by_row"
      if ( .in.buffer.not_exhausted) .in.read(order)
      archive.set(.name,name,kind,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.read(.density_matrix,order=order)
         case ("natural_orbitals");   archive.read(.natural_orbitals,order=order)
         case ("occupation");         archive.read(.occupation)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("fock_matrix");        .fock_matrix.create("restricted")
                                      archive.read(.fock_matrix,order=order)
         case default; DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_g94_checkpoint_file [leaky]
   ! Read a g94 checkpoint file (after fchk conversion to ASCII) into TONTO
      STR :: name
      TEXTFILE, PTR :: chkfile
      IVEC, PTR :: shell_l, nps, shell_to_atom, e_atom
      IVEC, PTR :: tmp_nps, tmp_sta, tmp_shells
      VEC, PTR :: tmp_pe, tmp_cc
      VEC, PTR :: pe, cc, extra_cc, temp_vec
      MAT, PTR :: temp_mat
      OPMAT, PTR :: temp_spin, temp_total
      INT :: c, t, a, s, u, m1, m2, prims, i,n_basis
      INT :: n_shell, n_comp, n_cc
      BIN :: same
      BASIS, PTR :: basis
      ARCHIVE :: archive
      if ( .basis.created) .basis.destroy
      if ( .atom.created)  .atom.destroy
      name = trim(.name)      ! not name.fchk, so have to rename checkpoint file
      if ( .in.buffer.not_exhausted) .in.read(name)
      chkfile.create(name)
      chkfile.open_for_read
      chkfile.read_line
      chkfile.look_for("Number of atoms")
      chkfile.move_to_line_item(5); chkfile.read( .n_atom)
      chkfile.look_for("Charge")
      chkfile.move_to_line_item(3); chkfile.read( .charge)
      chkfile.look_for("Multiplicity")
      chkfile.move_to_line_item(3); chkfile.read( .mult)
      chkfile.look_for("Number of electrons")
      chkfile.move_to_line_item(5); chkfile.read( .n_e)
      chkfile.look_for("Number of alpha electrons")
      chkfile.move_to_line_item(6); chkfile.read( .n_a)
      chkfile.look_for("Number of beta electrons")
      chkfile.move_to_line_item(6); chkfile.read( .n_b)
      chkfile.look_for("Number of basis functions")
      chkfile.move_to_line_item(6); chkfile.read( .n_bf)
      chkfile.look_for("Number of contracted shells") 
      chkfile.move_to_line_item(6); chkfile.read( .n_shell)
      chkfile.look_for("Number of primitive shells")
      chkfile.move_to_line_item(6); chkfile.read( .n_prim)
      chkfile.look_for("Total Energy")
      chkfile.move_to_line_item(4)
      .scfdata.create; chkfile.read_dbl( .scfdata.energy )
      chkfile.look_for("Atomic numbers"); chkfile.read_line
      .atom.create( .n_atom)
      do a = 1, .n_atom
         chkfile.read( .atom(a).atomic_number )
         .atom(a).label = .atom(a).chemical_symbol.trim // a.to_str.trim
      end
      chkfile.look_for("Current cartesian coordinates")
      chkfile.read_line
      do a = 1, .n_atom
         chkfile.read( .atom(a).pos)
      end
      chkfile.look_for("Shell types"); chkfile.read_line
      tmp_shells.create( .n_shell); tmp_nps.create( .n_shell)
      tmp_sta.create( .n_shell); tmp_pe.create( .n_prim)
      tmp_cc.create( .n_prim)
      nps.create( .n_shell); shell_to_atom.create( .n_shell)
      extra_cc.create( .n_prim)
      chkfile.read( tmp_shells)
      chkfile.look_for("Number of primitives per shell")
      chkfile.read_line; chkfile.read( tmp_nps)
      chkfile.look_for("Shell to atom map"); chkfile.read_line
      chkfile.read( tmp_sta)
      chkfile.look_for("Primitive exponents"); chkfile.read_line
      chkfile.read( tmp_pe)
      chkfile.look_for("Contraction coefficients"); chkfile.read_line
      chkfile.read( tmp_cc)
      e_atom.create( .n_atom); e_atom.zero
      prims = .n_prim
      if (any( tmp_shells == (-1) )) then
        do a = 1, .n_shell
           if (tmp_shells(a) == (-1)) then
              e_atom(tmp_sta(a)) = e_atom(tmp_sta(a)) + 1
              prims = prims + tmp_nps(a)
           end
        end
        chkfile.look_for("P(S=P)"); chkfile.read_line
        chkfile.read( extra_cc)
      end
      s = .n_shell + sum(e_atom)
      shell_l.create(s); nps.create(s)
      pe.create( prims); cc.create( prims)
      shell_to_atom.create(s)
      a = 0
      m1 = 1; m2 = 1
      do c = 1, .n_shell
        a = a + 1
        if (tmp_shells(c) == (-1)) then
           shell_l(a) = 0
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+tmp_nps(c)-1) = tmp_pe(m2:m2+tmp_nps(c)-1)
           cc(m1:m1+tmp_nps(c)-1) = tmp_cc(m2:m2+tmp_nps(c)-1)
           a = a+1; m1=m1+tmp_nps(c)
           shell_l(a) = 1
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+tmp_nps(c)-1) = tmp_pe(m2:m2+tmp_nps(c)-1)
           cc(m1:m1+tmp_nps(c)-1) = extra_cc(m2:m2+tmp_nps(c)-1)
        else
           pe(m1:m1+tmp_nps(c)-1) = tmp_pe(m2:m2+tmp_nps(c)-1)    
           cc(m1:m1+tmp_nps(c)-1) = tmp_cc(m2:m2+tmp_nps(c)-1)
           shell_l(a) = tmp_shells(c)
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c) 
        end
        m1 = m1 + tmp_nps(c); m2 = m2 + tmp_nps(c)
      end
      tmp_shells.destroy; tmp_sta.destroy
      tmp_nps.destroy; tmp_pe.destroy; tmp_cc.destroy
      .n_shell = s
      .n_prim = prims
      c = 0      ! for recording number of primitives read
      t = 0      ! for recording number of shells read
      n_basis = 0
      .basis.create(n_basis)
      do a = 1, .n_atom
         basis.create
         basis.label = .atom(a).label.trim // "_g94_basis"
         n_shell = count(shell_to_atom==a)
         basis.n_shell = n_shell
         basis.shell.create(n_shell)
         basis.shell.nullify_ptr_part
         do s = 1, n_shell
            n_comp = shell_l(t+s).n_comp
            n_cc = nps(t+s)
            basis.shell(s).l = shell_l(t+s)
            basis.shell(s).n_comp = n_comp
            basis.shell(s).n_cc = n_cc
            basis.shell(s).ex.create( n_cc )
            basis.shell(s).cc.create( n_cc )
            basis.shell(s).ex = pe( c+1 : c+n_cc )
            basis.shell(s).cc = cc( c+1 : c+n_cc )
            c = c + n_cc
         end
         basis.n_bf = basis.no_of_basis_functions
         basis.n_prim = basis.no_of_primitives
         basis.unnormalise
         t = t + n_shell
         same = FALSE
         do i = 1,n_basis
            if (.basis(i).same_as(basis)) then
               same = TRUE
               exit
            end
         end
         .atom(a).basis.create
         if (same) then
            .atom(a).basis.label = .basis(i).label
         else
            .atom(a).basis.label =  basis.label
            n_basis = n_basis + 1
            .basis.expand(n_basis)
            .basis(n_basis).copy(basis)
         end
         basis.destroy
      end
      .resolve_basis_labels
      .set_atom_info
      temp_vec.create( .n_bf)
      chkfile.look_for("Alpha Orbital Energies")
      chkfile.read_line; chkfile.read( temp_vec)      
      if (chkfile.next_str == "Beta") then
         u = 1
         .scfdata.kind = "uhf"
         .orbital_energies.create(.n_bf, "beta")
         chkfile.read_line; chkfile.read( .orbital_energies.beta)
         .orbital_energies.alpha => temp_vec
         nullify(temp_vec)
      else
         u = 0
         .scfdata.kind = "rhf"
         .orbital_energies.create(.n_bf)
         .orbital_energies.restricted => temp_vec
         nullify(temp_vec)
      end
      temp_mat.create( .n_bf, .n_bf)
      chkfile.look_for("Alpha MO"); chkfile.read_line
      chkfile.read( temp_mat)
      temp_mat.to_transpose
      if (chkfile.next_str == "Beta") then
         .molecular_orbitals.create( .n_bf, "beta")
         chkfile.read_line; chkfile.read( .molecular_orbitals.beta)
         .molecular_orbitals.beta.to_transpose
         .molecular_orbitals.alpha => temp_mat
         nullify(temp_vec)
         .swap_g94_orbital_order(.molecular_orbitals.alpha,"row") 
         .swap_g94_orbital_order(.molecular_orbitals.beta, "row") 
      else
         .molecular_orbitals.create(.n_bf)
         .molecular_orbitals.restricted => temp_mat
         nullify(temp_vec)
         .swap_g94_orbital_order(.molecular_orbitals.restricted,"row") 
      end
      if (u==0) then
         .density_matrix.create( .n_bf, "restricted")
         .density_matrix.triangle.create( .density_matrix.l_compress( "restricted"))
         chkfile.look_for( "Total SCF Density"); chkfile.read_line
         chkfile.read( .density_matrix.triangle)
         .density_matrix.uncompress
         .swap_g94_orbital_order(.density_matrix.restricted,"row") 
         .swap_g94_orbital_order(.density_matrix.restricted,"column") 
      else
         temp_total.create( .n_bf, "restricted")
         temp_spin.create( .n_bf, "restricted")
         temp_total.triangle.create( temp_total.l_compress( "restricted"))
         chkfile.look_for( "Total SCF Density"); chkfile.read_line
         chkfile.read( temp_total.triangle)
         temp_total.uncompress
         temp_spin.triangle.create( temp_spin.l_compress( "restricted"))
         chkfile.look_for( "Spin SCF Density"); chkfile.read_line    
         chkfile.read( temp_spin.triangle)
         temp_spin.uncompress
         .density_matrix.create( .n_bf, "alpha")
         .density_matrix.create( "beta")
         .density_matrix.beta = (temp_total.restricted - temp_spin.restricted)/2
         .density_matrix.alpha = (temp_spin.restricted + temp_total.restricted)/2 
         temp_spin.destroy
         temp_total.destroy
         .swap_g94_orbital_order(.density_matrix.alpha,"row") 
         .swap_g94_orbital_order(.density_matrix.alpha,"column") 
         .swap_g94_orbital_order(.density_matrix.beta, "row") 
         .swap_g94_orbital_order(.density_matrix.beta, "column") 
         .make_unrestricted_NOs
      end
      .make_natural_orbitals
      pe.destroy; cc.destroy; extra_cc.destroy
      shell_to_atom.destroy; nps.destroy; e_atom.destroy
      shell_l.destroy; chkfile.close; chkfile.destroy
      ! Save data in archive files
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)
   end

   swap_g94_orbital_order(X,swap) 
   ! Swap the order of f orbitals on matrix "X" after reading a g94 checkpoint
   ! file, for "swap" equal to "row" or "1", or "coloumn" or "2". 
      MAT :: X
      STR(*) :: swap
      INT :: n,f,l
      IVEC(10) :: ff = (/ 1, 2, 3, 5, 6, 4, 9, 7, 8,10 /)
      select case (swap)
         case("row","1")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(f:l,:) = X(f-1+ff,:)
               end
            end
         case("column","2")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(:,f:l) = X(:,f-1+ff)
               end
            end
         case default
            DIE("unknown swap option")
      end
   end

   write_wfn_file [leaky]
   ! writes a .wfn file for input to morphy98
      STR :: name
      TEXTFILE, PTR :: wfnfile
      IVEC, PTR :: lvec
      VEC, PTR :: evec
      MAT, PTR :: dmatrix, cc
      INT :: i, j, pcount, n_orbitals, b, a, l
      STR, parameter :: title_format = "(A80)"
      STR, parameter :: n_vars_format = "(A8, 12X, I3, 17X, I3, 17X, I3, 17X)"
      STR, parameter :: atom_format = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      STR, parameter :: c_assignment_format = "('CENTRE ASSIGNMENTS  ', 20I3)"
      STR, parameter :: t_assignment_format = "('TYPE ASSIGNMENTS    ', 20I3)"
      STR, parameter :: exponent_format = "('EXPONENTS ', 5E14.7)"
      STR, parameter :: mol_title_format = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      STR, parameter :: coefficient_format = "(5E16.8)"
      STR, parameter :: e_v_format = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"
      name = .name 
      if (.in.buffer.not_exhausted) .in.read(name)
      wfnfile.create(name)
      wfnfile.open_for_write
      if (mod( .n_e, 2) == 0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end
      write( unit = wfnfile.unit, fmt = title_format) trim( name) // " computed by TONTO"
      write( unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write( unit = wfnfile.unit, fmt = atom_format) ( .atom(i).label, i, i, &
         .atom(i).pos, dble( .atom(i).atomic_number ) , i = 1, .n_atom)
      write( unit = wfnfile.unit, fmt = c_assignment_format) (( j, i = 1, .atom(j).n_prim ), j = 1, .n_atom )
      pcount = 1
      lvec.create( .n_prim)
      evec.create( .n_prim)
      do a = 1, .n_atom
         do b = 1, .basis(a).n_shell
            l = .atom(a).basis.shell(b).l.n_comp_sum - .atom(a).basis.shell(b).n_comp
            do j = pcount, pcount + .atom(a).basis.shell(b).n_prim - 1, .atom(a).basis.shell(b).n_comp
               do i = 1, .atom(a).basis.shell(b).n_comp
                  evec( j + i - 1) = .atom(a).basis.shell(b).ex(1 + (j - pcount) / .atom(a).basis.shell(b).n_comp)
                  lvec( j + i - 1) = l + i
               end
            end
            pcount = pcount + .atom(a).basis.shell(b).n_prim
         end
      end
      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write( unit = wfnfile.unit, fmt = exponent_format) evec 
      lvec.destroy
      evec.destroy
      dmatrix.create( .n_prim, .n_bf)
      dmatrix.zero
      cc.create(.n_prim, .n_bf);    .make_contraction_matrix(cc)
      dmatrix.to_product(cc,.molecular_orbitals.restricted)
      do i = 1, n_orbitals
         write( unit = wfnfile.unit, fmt = mol_title_format) "MO  ", i, "OCC NO = ", &
            .occupation.restricted(i), " ORB. ENERGY = ", .orbital_energies.restricted(i)
         write( unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end
      write( unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
      write( unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy
   end
   
   write_ascii_archive
   ! Write the archive called "name". The kind is defined by the object to be written.
   ! If required, the output order may be specified as "by_row" (default) or "by_column".
      STR :: name,order
      ARCHIVE :: archive
      .in.read(name)
      order = "by_row"
      if ( .in.buffer.not_exhausted) .in.read(order)
      archive.set(.name,name,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.write(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.write(.density_matrix,order=order)
         case ("natural_orbitals");   archive.write(.natural_orbitals,order=order)
         case ("occupation");         archive.write(.occupation,order=order)
         case ("fock_matrix");        archive.write(.fock_matrix,order=order)
         case default;     DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

!  **************
!  Output methods
!  **************

   put
   ! Put all the available molecule information on file "out"
      stdout.flush
      stdout.text("Molecule information:")
      stdout.flush
      stdout.show("Name                   =",.name)
      stdout.show("Charge                 =",.charge)
      stdout.show("Multiplicity           =",.mult)
      stdout.show("Applied E Field        =",.E_field(1),.E_field(2),.E_field(3))
      stdout.show("Applied B Field        =",.B_field(1),.B_field(2),.B_field(3))
      stdout.show("B field Gauge origin   =",.gauge_origin)
      if (.atom.created)        .put_atoms
      if (.pointgroup.created)  .put_pointgroup
      if (.crystal.created)     .put_crystal
!     if (.grid.created)        .put_grid
      if (.dftgrid.created)     .put_dftgrid
   end

   put_atoms
   ! Output the atom coordinate and basis set information
      ENSURE(.atom.created,"no atom list")
      stdout.flush
      stdout.text("Molecule atom information:")
      stdout.flush
      stdout.show("Chemical Formula       =",trim(.chemical_formula))
      stdout.show("No of atoms            =",.n_atom)
      stdout.show("No of electrons        =",.n_e)
      stdout.show("No of alpha electrons  =",.n_a)
      stdout.show("No of beta  electrons  =",.n_b)
      .atom.put_coord_info
      .put_bases
      .put_atom_thermal_tensors
   end

   put_bases
   ! Output the molecule basis set information, if the bases are all resolved.
      ENSURE(.atom.created,"no atom list")
      RETURN_IF(.atom.bases_are_unresolved)
      ENSURE(.basis.created,"no basis set list")
      stdout.flush
      stdout.text("Molecule atom basis set information:")
      stdout.flush
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.n_shell_pairs)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      .basis.put
   end 

  put_atom_thermal_tensors
  ! Output the thermal tensors if they exist.
    INT :: i
    STR :: thermal_smearing_model
    RETURN_IF(.crystal.destroyed)
    thermal_smearing_model = .crystal.thermal_smearing_model
    if (thermal_smearing_model=="") then
      stdout.flush
      stdout.put("No thermal smearing.")
      stdout.flush
    else
      stdout.flush
      stdout.put("Thermal tensor information:")
      stdout.flush
      stdout.show("Thermal smearing model = ", thermal_smearing_model.trim)
      stdout.flush
      ENSURE(.atom.created,"no atom list data")
      ENSURE(.crystal.created,"no crystal data")
      .atom.put_thermal_tensors(.crystal)
    end
  end

   put_basis
   ! Output the molecule basis set information
      ENSURE(.basis.created,"no basis set list")
      stdout.flush
      stdout.text("Molecule atom basis set information:")
      stdout.flush
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.n_shell_pairs)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      .basis.put
   end 

   put_pointgroup
   ! Output the current pointgroup
      .pointgroup.put(.out)
   end

  put_plotgrid
  ! Output the current grid.
    ENSURE(.grid.created,"no plot grid to output")
    .grid.put(.out)
  end

  put_dftgrid
  ! Output the current DFT grid.
    ENSURE(.dftgrid.created,"no DFT grid to output")
    .dftgrid.put(.out)
  end

   put_crystal
   ! Output the current crystal
      if (.atom.created) then; .crystal.put(.out,.atom)
      else;                    .crystal.put(.out)
      end
   end

   put_molecular_orbitals
   ! Output the current associated molecular orbitals
      .out.flush
      .out.text("Molecular orbitals:")
      .out.put( .molecular_orbitals)
   end

   put_mos_and_energies
   ! Output the current associated molecular orbitals and their energies
      .out.flush
      .out.text("Molecular orbital energies:")
      .out.put( .orbital_energies, format="column")
      .out.flush
      .out.text("Molecular orbitals:")
      .out.put( .molecular_orbitals)
   end

   put_natural_orbitals
   ! Output the current associated molecular orbitals
      .out.flush
      .out.text("Natural orbital occupations:")
      .out.put( .occupation, format="column")
      .out.flush
      .out.text("Natural orbitals:")
      .out.put( .natural_orbitals)
   end

   put_density_matrix
   ! Output the current associated density matrix 
      ENSURE(.density_matrix.created,"no density matrix")
      .out.flush
      .out.text("Density matrix:")
      .out.put( .density_matrix)
   end

   put_fock_matrix
   ! Output the current associated fock matrix 
      ENSURE(.fock_matrix.created,"no fock matrix")
      .out.flush
      .out.text("Fock matrix:")
      .out.put( .fock_matrix)
   end

   put_PND_sf
   ! Output the magnetic structure factors
      CVEC, PTR :: FM_s, FM_l, FM_r
      ARCHIVE :: archive
      INT :: n
      FM_s.create( .crystal.n_refl)
      archive.set(.name,"PND_spin_sf")
      archive.read(FM_s)
      FM_l.create( .crystal.n_refl)
      archive.set(.name,"PND_nabla_sf")
      archive.read(FM_l)
      FM_r.create( .crystal.n_refl)
      archive.set(.name,"PND_r_sf")
      archive.read(FM_r)
      .out.text("PND magnetic structure factors:")
      .out.flush
      .out.dash(int_fields=3,dbl_fields=4)
      .out.put("h", int_width=TRUE)
      .out.put("k", int_width=TRUE)
      .out.put("l", int_width=TRUE)
      .out.put("FM_s")
      .out.put("FM_l")
      .out.put("FM_r")
      .out.put("FM")
      .out.flush
      .out.dash(int_fields=3,dbl_fields=4)
      do n = 1, .crystal.n_refl
         .out.put( .crystal.h(n))
         .out.put( .crystal.k(n))
         .out.put( .crystal.l(n))
         .out.put( real(FM_s(n)) )
         .out.put( real(FM_l(n)) )
         .out.put( real(FM_r(n)) )
         .out.put( real(FM_s(n)+FM_l(n)+FM_r(n)) )
         .out.flush
      end
      .out.dash(int_fields=3,dbl_fields=4)
      FM_r.destroy
      FM_l.destroy
      FM_s.destroy
   end

  put_cluster_operations
  ! Outputs a list of the symmetry operations and translations of the molecules
  ! which are within distance_max of the centre of the molecule.
  ! Optional input position must be in crystal coordinates.
    IMAT, PTR :: op_list
    VEC, PTR :: dist_list
    INT :: q
    DBL :: dist_max
    VEC(3) :: position
    STR :: word

    ! defaults
    dist_max  = 5
    position = (/ZERO,ZERO,ZERO/)

    read_loop : do
      .in.read(word)
      word.to_lower_case
      select case (word)
         case("end");                     exit read_loop
         case("distance");                .in.read(dist_max)
         case("position");                .in.read(position)
         case("centre");                  .in.read(position)
      end
    end do read_loop
    position.rotate_by(.crystal.direct_cell_matrix)

    .crystal.create_closest_molecule_list(op_list,dist_list,position,dist_max)

    q=size(op_list,2)
    if (op_list(1,1) == 0) q=0

    .out.flush
    .out.text("Cluster operations.")
    .out.show("No of molecules                = ", q)
    .out.show("Cutoff radius of cluster (au)  = ", dist_max)
    if (q>0) then
      .out.put("symop",int_width=TRUE)
      .out.put("h",int_width=TRUE)
      .out.put("k",int_width=TRUE)
      .out.put("l",int_width=TRUE)
      .out.put("distance (au)")
      .out.flush
      do q=1,size(dist_list)
        if (op_list(1,q)==0) exit
        .out.put(op_list(1,q))
        .out.put(op_list(2,q))
        .out.put(op_list(3,q))
        .out.put(op_list(4,q))
        .out.put(dist_list(q))
        .out.flush
      end
    end
    op_list.destroy
    dist_list.destroy
  end

  put_cluster_input
  ! Outputs the input data for a cluster of molecules around the centre of the
  ! molecule.
  ! Optional input position must be in crystal coordinates.
  ! Output atom positions are in crystal coordinates.
  ! Output of thermal tensors is optional.

    ATOMVEC, PTR :: atomvec_frac,atomvec
    IMAT, PTR :: op_list
    VEC, PTR :: dist_list
    VEC(3) :: pos
    STR :: word
    MAT3, PTR :: therm1
    MAT(3,3) :: therm
    MAT, PTR :: pos1,pos2
    VEC(3) :: position
    INT :: s,h,k,l,n,q,i,j
    DBL :: dist_max
    BIN :: put_thermal

    ENSURE(.crystal.created,            "no crystal data")
    ENSURE(.atom.created,               "no atom data")
    ENSURE(.atom.bases_are_all_labeled, "atoms must all have basis labes")

    ! defaults
    dist_max  = 5
    position = (/ZERO,ZERO,ZERO/)
    put_thermal = FALSE

    read_loop : do
      .in.read(word)
      word.to_lower_case
      select case (word)
         case("end");                     exit read_loop
         case("put_thermal_tensors");     .in.read(put_thermal)
         case("distance");                .in.read(dist_max)
         case("position");                .in.read(position)
         case("centre");                  .in.read(position)
      end
    end do read_loop
    position.rotate_by(.crystal.direct_cell_matrix)

    .crystal.create_closest_molecule_list(op_list,dist_list,position,dist_max)
    dist_list.destroy

    q=size(op_list,2)
    if (op_list(1,1) == 0) q=0

    .out.flush
    .out.text("Cluster input.")
    .out.show("No of molecules                = ", q)
    .out.show("Cutoff radius of cluster (au)  = ", dist_max)
    if (put_thermal) then
    .out.show("Thermal tensor axis system     = ", "crystal")
    .out.show("Thermal tensor units           = ", "A^2")
    end

    if (q>0) then
      .out.put_text("atoms")
      .out.flush
      .out.put_text('data_order label "axis_system crystal" pos basis_label')
      if (put_thermal) &
      .out.put_text(' thermal_tensor "thermal_axis_system crystal"')
      .out.text(' end')
      .out.text("loop")
  
      pos1.create(3,.n_atom)
      pos2.create(3,.n_atom)
      pos1 = .crystal.fragment_geometry
      .crystal.move_to_unit_cell(pos1)
  
      therm1.create(3,3,.n_atom)
      do n = 1, .n_atom
        therm1(:,:,n) = .atom(n).thermal_tensor
      end
  
      do q=1,size(dist_list)
        s = op_list(1,q)
        if (s==0) exit
        h = op_list(2,q)
        k = op_list(3,q)
        l = op_list(4,q)
        pos2 = pos1
        .crystal.transform_geometry(pos2,s)
        do n = 1, .n_atom
          therm = therm1(:,:,n)
          therm.change_basis(.crystal.spacegroup.seitz(1:3,1:3,s))
          pos = pos2(:,n) + (/h,k,l/)
          .out.put_text(trim(.atom(n).label),int_width=TRUE)
          .out.put(pos(1))
          .out.put(pos(2))
          .out.put(pos(3))
          .out.put_text(" " // trim(.atom(n).basis.label))
          if (put_thermal) then
            .out.put(therm(1,1))
            .out.put(therm(2,2))
            .out.put(therm(3,3))
            .out.put(therm(1,2))
            .out.put(therm(1,3))
            .out.put(therm(2,3))
          end
          .out.flush
        end
      end
      .out.text("end end",flush=2)
  
      therm1.destroy
      pos2.destroy
      pos1.destroy
    end
    op_list.destroy
  end

end 
