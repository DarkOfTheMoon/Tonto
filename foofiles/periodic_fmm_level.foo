!---------------------------------------------------------------------------
!
! PERIODIC_FMM_LEVEL : One level of the periodic FMM method.  See Lambert,
! Darden and Board, J. Comp. Phys., 126, 274-285 (1996).
!
! Copyright (C) Daniel Grimwood, 2003
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------
module PERIODIC_FMM_LEVEL

  implicit none

contains

!  *****************
!  Memory allocation
!  *****************

   create ::: get_from(OBJECT)
   ! Create an object
   end

   create(mol,charges,positions) ::: leaky
   ! Create an object
      self :: PTR
      mol :: MOLECULE, IN
      charges :: VEC{REAL}*, optional
      positions :: MAT{REAL}*, optional
      if (present(charges) AND present(positions)) then
   ENSURE(charges.created,"no charges")
   ENSURE(positions.created,"no positions")
   ENSURE(charges.dim==positions.dim2,"position and charges arrays are inconsistent")
   ENSURE(positions.dim1==3,"1st dimensions of position array must be 3")
      end
      .create
      .set_defaults(mol,charges,positions)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the type.
      nullify(.crystal)
      nullify(.fragment_charges)
      nullify(.fragment_positions)
      nullify(.charges)
      nullify(.positions)
      nullify(.indices_for_box)
      nullify(.total_charge_for_box)
      nullify(.total_charge_for_1st_subsubbox)
      nullify(.multipoles_for_box)
      nullify(.multipoles_for_1st_subsubbox)
   end
 
   destroy_ptr_part
   ! Destroy the pointer parts of the type.
      nullify(.crystal) ! never destroy this
      .fragment_charges.destroy
      .fragment_positions.destroy
      .charges.destroy
      .positions.destroy
      .indices_for_box.destroy
      .total_charge_for_box.destroy
      nullify(.total_charge_for_1st_subsubbox)
      .multipoles_for_box.destroy
      nullify(.multipoles_for_1st_subsubbox)
   end
 
   set_defaults
   ! Set default values for parts of the type. 
      .level_number            = 0
      .scale_factor            = ONE
      .l_max                   = 0
      .potential_method        = "none"
      .preferred_potential_method = "cell-centred-multipole"
    ! .preferred_potential_method = "point-centred-monopole"
   end
 
   set_defaults(mol,charges,positions)
   ! Set default values for parts of the type. This is usually used for level 0.
      mol :: MOLECULE
      charges :: VEC{REAL}*, optional
      positions :: MAT{REAL}*, optional
   ENSURE(mol.saved.created,"no saved molecule information")
   ENSURE(mol.saved.atom.created,"no saved molecule atoms information")
   ENSURE(mol.crystal.created,"no crystal info for molecule object")
   ENSURE(mol.crystal.fragment_info_made,"no crystal fragment info for molecule object")
   ENSURE(mol.crystal.unit_cell.info_made,"no crystal unit cell info for molecule object")
   ENSURE(mol.crystal.Z.is_int(TOL(3)),"crystal must have integer Z")
   ENSURE(mol.scfdata.created,"no scfdata info for molecule object")
   ENSURE(mol.scfdata.scf_kind=="crystal_rhf","wrong scf method for molecule object")
      if (present(charges) AND present(positions)) then
   ENSURE(charges.created,"no charges")
   ENSURE(positions.created,"no positions")
   ENSURE(charges.dim==positions.dim2,"position and charges arrays are inconsistent")
   ENSURE(positions.dim1==3,"1st dimensions of position array must be 3")
      end
      .level_number            = 0
      .crystal                => mol.crystal
      .centre                  = mol.saved.atom.centre_of_atoms
      .accuracy                = mol.scfdata.fmm_accuracy
      .scale_factor            = ONE
      .crystallite_side_length = mol.scfdata.crystallite_side_length
      .divisions               = mol.scfdata.unit_cell_axis_divisions
      .subsubbox_radius_0      = .enclosing_subsubbox_radius
      .subsubbox_radius        = .subsubbox_radius_0
      .unit_cell_charge        = TWO*sum(mol.saved.atom.atomic_number)*mol.crystal.Z
      .l_max                   = 0
      .potential_method        = "none"
      .preferred_potential_method = "cell-centred-multipole"
    ! .preferred_potential_method = "point-centred-monopole"
      ! Get the origin, or bottom left hand corner, in fractionals
      .origin = .centre
      .crystal.unit_cell.change_into_fractional(.origin)
      .origin = .origin - [HALF,HALF,HALF]*.scale_factor
      .unit_cell_origin = .origin
      if (present(charges))   .fragment_charges => charges
      if (present(positions)) .fragment_positions => positions
   end
 
   set_defaults(level_minus_1)
   ! Make the basic information ".level_number" etc.  for the current level from
   ! the "level_minus_1" (which is smaller than the current level). NOTE: This
   ! does not make the multipoles.
     level_minus_1 :: PERIODIC_FMM_LEVEL
     ! Copy over previous information
     self = level_minus_1
     ! Change level number, and scale
     .level_number = .level_number + 1
     .scale_factor = THREE**.level_number
     .subsubbox_radius = THREE*.subsubbox_radius 
     ! Get the origin, or bottom left hand corner, in fractionals
     .origin = .centre
     .crystal.unit_cell.change_into_fractional(.origin)
     .origin = .origin - [HALF,HALF,HALF]*.scale_factor
   end
 
   set_number_of_divisions(n_div)
   ! Set the number of divisions of the shortest unit cell length to be n_div.
   ! The other unit cell lengths will be subdivided to be at least as short as
   ! this.
     n_div :: INT, IN
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
     min_len :: REAL
     ! What is the shortest unit cell length?
     min_len = minval(.crystal.unit_cell.length)
     ! Multiply n_div by ratio of lengths.
     .divisions = ceiling(.crystal.unit_cell.length/min_len)*n_div
   end

!  ***************
!  Maximum numbers
!  ***************
 
   level_max  result (res)
   ! Return the maximum level "res" at which any side of the periodic fmm cuboid
   ! will be greater than or equal to the desired crystallite side length.
     self :: IN
     res :: INT
     res = ceiling( (log(.crystallite_side_length)-log(.longest_cell_length))/log(THREE) )
   end
 
   set_l_max(level_minus_1)
   ! Make the ".l_max" for the current level from the "level_minus_1" (which is
   ! smaller than the current level).  NOTE: This does not make the multipoles.
     level_minus_1 :: PERIODIC_FMM_LEVEL
   ENSURE(level_minus_1.level_number==(.level_number-1),"inconsistent level number")
     l_mono,l_multi :: INT
     .l_max = 0
     .potential_method = "none"
     if (.level_number==2) then
        l_mono  = .multipole_l_max("point-centred-monopole")
        l_multi = .multipole_l_max("cell-centred-multipole")
        .l_max = min(l_mono,l_multi)
        if      (l_mono< l_multi) then; .potential_method = "point-centred-monopole"
        else if (l_mono==l_multi) then; .potential_method = .preferred_potential_method
        else                          ; .potential_method = "cell-centred-multipole"
        end
     end
     if (.level_number>2) then
        l_mono  = .multipole_l_max("point-centred-monopole")
        l_multi = .multipole_l_max("cell-centred-multipole")
        .l_max = l_multi
        .potential_method = "cell-centred-multipole"
     end
   end
 
   multipole_l_max(potential_method) result (res)
   ! Return the order "res" of the multipoles required at this level, in order
   ! that the multipole expansion of the electrostatic potential is accurate to
   ! ".accuracy". This depends on the "potential_method" used to evaluate the
   ! electrostatic potential. See eqn (9.13.29) in the book by Helgaker et al.
   ! NOTE: the level must be greater than 1.
     self :: IN
     potential_method :: STR
     res :: INT
   ENSURE(.level_number>1,"level must be two or more")
   ENSURE(.total_charge_for_1st_subsubbox.created,"no total subsubbox charges")
     slim :: MAT{INT}(2,3)
     s1,s2,s3,u1,u2,u3,l_max :: INT
     subsubbox_charge :: REAL
 ! stdout.show("--> LEVEL =",.level_number)
     ! What range of subsubboxes is next to the *central* cell at THIS level?
     slim(1,:) = nint(THREE*.divisions)   ! min
     slim(2,:) = nint(SIX*.divisions) + 1 ! max
     res = 0
     do s1 = slim(1,1),slim(2,1)
     do s2 = slim(1,2),slim(2,2)
     do s3 = slim(1,3),slim(2,3)
        if (all([s1,s1]/=slim(:,1)) AND all([s2,s2]/=slim(:,2)) AND all([s3,s3]/=slim(:,3))) cycle
        u1 = mod(s1-1,.divisions(1)) + 1
        u2 = mod(s2-1,.divisions(2)) + 1
        u3 = mod(s3-1,.divisions(3)) + 1
 ! stdout.show("1st subsubbox =",[u1,u2,u3])
        subsubbox_charge = .total_charge_for_1st_subsubbox(u1,u2,u3)
        l_max = .multipole_l_max(s1,s2,s3,subsubbox_charge,method=potential_method)
        res = max(res,l_max)
     end
     end
     end
   end
 
   multipole_l_max(s1,s2,s3,subsubbox_charge,method) result (res)
   ! Return the order "res" of the multipoles required for the subsubbox with
   ! indices "s1", "s2", "s3", and total charge "subsubbox_charge", in order
   ! that the multipole expansion of the electrostatic potential is accurate to
   ! ".accuracy". See eqn (9.13.29) in the book by Helgaker et al. Useful for
   ! reducing the number of multipoles used to evaluate the potential at a given
   ! level. 
     self :: IN
     s1,s2,s3 :: INT
     subsubbox_charge :: REAL
     method :: STR
     res :: INT
   ENSURE(.level_number>1,"level must be two or more")
   ENSURE(.subsubbox_radius>ZERO,"the enclosing subsubbox radius is not set")
     R_QP,del_r12,top :: REAL
     select case (method)
        case("point-centred-monopole")
           del_r12 = .subsubbox_radius
           R_QP = .distance_to_uc_from_subsubbox(s1,s2,s3)
        case("cell-centred-multipole")
           del_r12 = .subsubbox_radius + 9*.subsubbox_radius_0
           R_QP = .distance_to_ucc_from_subsubbox(s1,s2,s3)
        case default
           UNKNOWN(method)
     end
     DIE_IF(del_r12>=R_QP,"enclosing sphere for unit cell subsubbox overlaps, at level "//.level_number.to_str.trim)
   ! res = ceiling( (log(.accuracy)+TWO*log(R_QP-del_r12))/(log(del_r12)-log(R_QP)) - 1)
   ! subbox_charge = .unit_cell_charge*(3**(3*.level_number-6))/product(.divisions)
     top = log(.accuracy)+log(R_QP-del_r12)-log(subsubbox_charge)
     res = ceiling( top/(log(del_r12)-log(R_QP)) - 1)
     res = max(res,0)
 ! stdout.show("subsubbox =",[s1,s2,s3])
 ! stdout.show("charge    =",subsubbox_charge)
 ! stdout.show("del_r12   =",del_r12)
 ! stdout.show("R_QP      =",R_QP)
 ! stdout.show("R_QP/side =",R_QP*9/(.scale_factor*.longest_cell_length))
 ! stdout.show("l_max     =",res)
   end
 
!   multipole_l_max(s1,s2,s3,subsubbox_charge) result (res)
!   ! Return the order "res" of the multipoles required for the subsubbox with
!   ! indices "s1", "s2", "s3", and total charge "subsubbox_charge", in order
!   ! that the multipole expansion of the electrostatic potential is accurate to
!   ! ".accuracy". This version calculates the distance to the centre of the unit
!   ! cell, and uses an enclosing spohere around a unit cellbox. See eqn
!   ! (9.13.29) in the book by Helgaker et al. Useful for reducing the number of
!   ! multipoles used to evaluate the potential at a given level. 
!     self :: IN
!     s1,s2,s3 :: INT
!     subsubbox_charge :: REAL
!     res :: INT
!   ENSURE(.level_number>1,"level must be two or more")
!   ENSURE(.subsubbox_radius>ZERO,"the enclosing subsubbox radius is not set")
!   ENSURE(.subsubbox_radius_0>ZERO,"the enclosing subsubbox radius at level 0 is not set")
!     R_QP,del_r12,top :: REAL
!     del_r12 = .subsubbox_radius + 9*.subsubbox_radius_0
!     R_QP = .distance_to_ucc_from_subsubbox(s1,s2,s3)
!     DIE_IF(del_r12>=R_QP,"enclosing sphere for unit cell subsubbox overlaps, at level "//.level_number.to_str.trim)
!   ! res = ceiling( (log(.accuracy)+TWO*log(R_QP-del_r12))/(log(del_r12)-log(R_QP)) - 1)
!   ! subbox_charge = .unit_cell_charge*(3**(3*.level_number-6))/product(.divisions)
!     top = log(.accuracy)+log(R_QP-del_r12)-log(subsubbox_charge)
!     res = ceiling( top/(log(del_r12)-log(R_QP)) - 1)
!     res = max(res,0)
!   end

   box_multipoles_dim result (res)
   ! Return the length of the first created box multipoles vector at this level.
   ! We need this routine because not all boxes may have multipoles.
     res :: INT
   ENSURE(.multipoles_for_box.created,"no subbox multipoles")
     b1,b2,b3 :: INT
     res = 0
     do b1 = 1,.divisions(1)
     do b2 = 1,.divisions(2)
     do b3 = 1,.divisions(3)
        if (.multipoles_for_box(b1,b2,b3).element.destroyed) cycle
        res = .multipoles_for_box(b1,b2,b3).element.dim
        exit
     end
     end
     end
     DIE_IF(res==0,"There are no box multipoles at this level")
   end
 
!   multipole_l_max result (res)
!   ! Return the order "res" of the multipoles required at this level, in order
!   ! that the multipole expansion of the electrostatic potential is accurate to
!   ! ".accuracy". See eqn (9.13.29) in the book by Helgaker et al.
!   ! NOTE: subbox_radius_0 must be set and the level must be greater than 1.
!     self :: IN
!     res :: INT
!   ENSURE(.level_number>1,"level must be two or more")
!   ENSURE(.unit_cell_charge>ZERO,"must have positive unit cell charge")
!     R_QP,del_r12,top,subbox_charge :: REAL
!     del_r12 = .subbox_radius_0 + .enclosing_subbox_radius
!     R_QP = .shortest_distance_to_unit_cell
!     DIE_IF(del_r12>=R_QP,"enclosing spheres for a unit cell subbox and a subbox at level "//.level_number.to_str.trim//" overlap")
!   ! res = ceiling( (log(.accuracy)+TWO*log(R_QP-del_r12))/(log(del_r12)-log(R_QP)) - 1)
!     subbox_charge = .unit_cell_charge*(3**(3*.level_number-6))/product(.divisions)
!     top = log(.accuracy)+log(R_QP-del_r12)-log(subbox_charge)
!     res = ceiling( top/(log(del_r12)-log(R_QP)) - 1)
!     res = max(res,0)
!   end

!   subbox_multipoles_dim result (res)
!   ! Return the length of the subbox multipoles vector at this level. We need
!   ! this routine because not all subboxes may have multipoles.
!     res :: INT
!   ENSURE(.multipoles_for_subbox.created,"no subbox multipoles")
!     h1,h2,h3 :: INT
!     do h1 = 1,.divisions(1)
!     do h2 = 1,.divisions(2)
!     do h3 = 1,.divisions(3)
!        if (.multipoles_for_subbox(h1,h2,h3).element.destroyed) cycle
!        res = .multipoles_for_subbox(h1,h2,h3).element.dim
!        exit
!     end
!     end
!     end
!   end

!  *******************
!  Important distances
!  *******************
 
   longest_cell_length result (res)
   ! Return the longest unit cell length
     self :: IN
     res :: REAL
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
     res = maxval(.crystal.unit_cell.length)
   end
 
   enclosing_subsubbox_radius result (res)
   ! Return HALF the longest subsubbox body diagonal. This is used to determine
   ! the radius of an enclosing sphere for calculating the maximum order "L" of
   ! multipoles to use in a multipole expansion.
     self :: IN
     res :: REAL
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
     i :: INT
     c :: MAT{REAL}(3,4)
     half_sub_lengths,centre,diag :: VEC{REAL}(3)
     ! Half the length of a subsubbox along each lattice direction.
     half_sub_lengths = .scale_factor/(TWO*NINE*.divisions)
     ! The four inversion-unique corners of a subsubbox
     c(:,1) = [ 1, 1, 1]*half_sub_lengths
     c(:,2) = [-1, 1, 1]*half_sub_lengths
     c(:,3) = [ 1,-1, 1]*half_sub_lengths
     c(:,4) = [ 1, 1,-1]*half_sub_lengths
     .crystal.unit_cell.change_from_fractional(c)
     ! The centre of a subsubbox
     centre = [ZERO,ZERO,ZERO]
     res = ZERO
     do i = 1,4
        diag = c(:,i) - centre
        res = max(res,diag.norm)
     end
   end
 
   distance_to_uc_from_subsubbox(s1,s2,s3) result (res)
   ! Return the *shortest* distance from the centre of a subsubbox with indices
   ! "s1", "s2", "s3"  at the current level to any face of the unit cell. 
   ! NOTE: the indices must be one of those closest to the unit cell.
     self :: IN
     s1,s2,s3 :: INT
     res :: REAL
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
     c1,c2,c3,p :: VEC{REAL}(3)
     slim :: MAT{INT}(2,3)
     ! What range of subsubboxes is next to the *central* cell at THIS level?
     slim(1,:) = nint(THREE*.divisions)   ! min
     slim(2,:) = nint(SIX*.divisions) + 1 ! max
     if      (s1==slim(1,1)) then
        c1 = .unit_cell_corner(1,1,1)
        c2 = .unit_cell_corner(1,2,1)
        c3 = .unit_cell_corner(1,1,2)
     else if (s1==slim(2,1)) then
        c1 = .unit_cell_corner(2,1,1)
        c2 = .unit_cell_corner(2,2,1)
        c3 = .unit_cell_corner(2,1,2)
     else if (s2==slim(1,2)) then
        c1 = .unit_cell_corner(1,1,1)
        c2 = .unit_cell_corner(2,1,1)
        c3 = .unit_cell_corner(1,1,2)
     else if (s2==slim(2,2)) then
        c1 = .unit_cell_corner(1,2,1)
        c2 = .unit_cell_corner(2,2,1)
        c3 = .unit_cell_corner(1,2,2)
     else if (s3==slim(1,3)) then
        c1 = .unit_cell_corner(1,1,1)
        c2 = .unit_cell_corner(2,1,1)
        c3 = .unit_cell_corner(1,2,1)
     else if (s3==slim(2,3)) then
        c1 = .unit_cell_corner(1,1,2)
        c2 = .unit_cell_corner(2,1,2)
        c3 = .unit_cell_corner(1,2,2)
     else
        DIE("indices out of range")
     end
     p = .centre_for_subsubbox(s1,s2,s3) 
     res = .shortest_distance_to_plane(c1,c2,c3,p)
   end
 
   shortest_distance_to_plane(c1,c2,c3,p) result (res)
   ! Return the shortest distance to the planar face bounded by points "c1",
   ! "c2", "c3" from point "p". 
      self :: IN
      c1,c2,c3,p :: VEC{REAL}(3), IN
      res :: REAL
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
      q,x,y,z,p1,p2,p3,p4 :: VEC{REAL}(3)
      c,s,t,dx,dy,qx,qy :: REAL
      q =  p - c1           ! q is the vector to p from c1
      x = c2 - c1; dx = sqrt(dot_product(x,x)); x = x/dx
      y = c3 - c1; dy = sqrt(dot_product(y,y)); y = y/dy
      c = dot_product(x,y)
      s = sqrt(ONE-c*c)
      y = y - c*x; y = y/sqrt(dot_product(y,y))
      qx = dot_product(x,q) ! x and y are orthonormal
      qy = dot_product(y,q)
      dy = s*dy
      t = c/s
      if (t*qy<=qx AND qx<=dx+t*qy AND t*qx<=qy AND qy<=dy+t*qx) then
         z = x.cross(y)     ! Get the perpendicular distance to the plane
         res = abs(dot_product(z,q))
      else                  ! q is not above the planar segment c1-c2-c3
         p1 = p - c1
         p2 = p - c2
         p3 = p - c3
         p4 = p - (c2+c3-c1)
         res = min(dot_product(p1,p1),dot_product(p2,p2),dot_product(p3,p3),dot_product(p4,p4))
         res = sqrt(res)
      end
   end
 
   distance_to_ucc_from_subsubbox(s1,s2,s3) result (res)
   ! Return the distance from the centre of a subsubbox with indices "s1", "s2",
   ! "s3"  at the current level to the centre of the unit cell. 
   ! NOTE: the indices must be one of those closest to the unit cell.
     self :: IN
     s1,s2,s3 :: INT
     res :: REAL
     p :: VEC{REAL}(3)
     p = .centre_for_subsubbox(s1,s2,s3) - .centre
     res = sqrt(dot_product(p,p))
   end
 
!   distance_to_uc_from_subsubbox(s1,s2,s3) result (res)
!   ! Return the *shortest* distance from the centre of a subsubbox with indices
!   ! "s1", "s2", "s3"  at the current level to a subsubbox of the unit cell.
!   ! NOTE: the indices must be one of those closest to the unit cell.
!     self :: IN
!     s1,s2,s3 :: INT
!     res :: REAL
!   ENSURE(.crystal.created,"no crystal info")
!   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
!     x,diff,ucentre,hcentre,c1,c2,c3,c4 :: VEC{REAL}(3)
!     slim,ulim :: MAT{INT}(2,3)
!     dist :: REAL
!     u1,u2,u3 :: INT
!     ! "dist" is just an upper bound on res**2. This initial value is not really
!     ! important as long as it's big enough.
!     x = .scale_factor
!     .crystal.unit_cell.change_from_fractional(x)
!     dist = (maxval(x))**2
!     ! The range of unit cell subsubboxes (we will skip those not on the outer skin).
!     ulim(1,:) = [1,1,1]         ! min
!     ulim(2,:) = 9*.divisions    ! max
!     ! What range of subsubboxes is next to the *central* cell at THIS level?
!     slim(1,:) = nint(THREE*.divisions)   ! min
!     slim(2,:) = nint(SIX*.divisions) + 1 ! max
!     ! Loop over the subsubboxes on the outside of the unit cell at level 0.
!     do u1 = ulim(1,1),ulim(2,1)
!     do u2 = ulim(1,2),ulim(2,2)
!     do u3 = ulim(1,3),ulim(2,3)
!         if (all([u1,u1]/=ulim(:,1)) AND all([u2,u2]/=ulim(:,2)) AND all([u3,u3]/=ulim(:,3))) cycle
!         ! Get the centre of the (outer skin) unit cell subsubbox
!         ucentre = .centre_for_subsubbox(u1,u2,u3) - .centre
!         ucentre = ucentre/.scale_factor + .centre
!         diff    = .centre_for_subsubbox(s1,s2,s3) - ucentre
!         dist    = min(dist,dot_product(diff,diff))
!     end
!     end
!     end
!     res = sqrt(dist)
!     if      (s1==slim(1,1)) then
!        c1 = .unit_cell_corner(1,1,1)
!        c2 = .unit_cell_corner(1,2,1)
!        c3 = .unit_cell_corner(1,1,2)
!        c4 = .unit_cell_corner(1,2,2)
!        p  = .centre_for_subsubbox(s1,s2,s3) 
!        res = .shortest_distance_to_plane(c1,c2,c3,c4,p)
!     else if (s1==slim(2,1)) then
!   end
 
!   shortest_distance_to_unit_cell result (res)
!   ! Return the shortest distance from the centre of a subsubbox at the current
!   ! level to a subsubbox of the unit cell. Recall that a subsubbox is nine
!   ! times smaller than a box.
!     self :: IN
!     res :: REAL
!   ENSURE(.crystal.created,"no crystal info")
!   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
!     x,diff,ucentre :: VEC{REAL}(3)
!     slim,ulim :: MAT{INT}(2,3)
!     dist, new :: REAL
!     u1,u2,u3,s1,s2,s3 :: INT
!     ! "dist" is just an upper bound on res**2. This initial value is not really
!     ! important as long as it's big enough.
!     x = .scale_factor
!    ! stdout.show("scal=",.scale_factor)
!     .crystal.unit_cell.change_from_fractional(x)
!     dist = (maxval(x))**2
!     ! The range of unit cell subsubboxes (we will skip those not on the outer skin).
!     ulim(1,:) = [1,1,1]         ! min
!     ulim(2,:) = 9*.divisions    ! max
!     ! What range of subsubboxes is next to the *central* cell at THIS level?
!     slim(1,:) = nint(THREE*.divisions)   ! min
!     slim(2,:) = nint(SIX*.divisions) + 1 ! max
!     ! Loop over the subsubboxes on the outside of the unit cell at level 0.
!     do u1 = ulim(1,1),ulim(2,1)
!     do u2 = ulim(1,2),ulim(2,2)
!     do u3 = ulim(1,3),ulim(2,3)
!         if (all([u1,u1]/=ulim(:,1)) AND all([u2,u2]/=ulim(:,2)) AND all([u3,u3]/=ulim(:,3))) cycle
!         ! Get the centre of the (outer skin) unit cell subsubbox
!    ! stdout.show("u   =",[u1,u2,u3])
!         ucentre = .centre_for_subsubbox(u1,u2,u3) - .centre
!    ! stdout.show("uc1 =",ucentre)
!         ucentre = ucentre/.scale_factor + .centre
!    ! stdout.show("uc2 =",ucentre)
!         ! Loop over boxes in this level. Only loop over those boxes which are next
!         ! to the central cell at this level
!         do s1 = slim(1,1),slim(2,1)
!         do s2 = slim(1,2),slim(2,2)
!         do s3 = slim(1,3),slim(2,3)
!             if (all([s1,s1]/=slim(:,1)) AND all([s2,s2]/=slim(:,2)) AND all([s3,s3]/=slim(:,3))) cycle
!    ! stdout.ssow("s   =",[s1,s2,s3])
!             diff = .centre_for_subsubbox(s1,s2,s3) - ucentre
!    ! stdout.show("hc1 =",hcentre-.box_centre)
!    ! stdout.show("hc2 =",hcentre)
!    ! stdout.show("diff=",diff)
!    ! new = dot_product(diff,diff)
!    ! if (new<dist) then
!    ! stdout.show("u   =",[u1,u2,u3])
!    ! stdout.show("h   =",[h1,h2,h3])
!    ! stdout.show("new =",new)
!    ! stdout.show("uc1 =",ucentre-.centre)
!    ! stdout.show("hc1 =",hcentre-.centre)
!    ! stdout.show("diff=",diff)
!    ! end
!             dist = min(dist,dot_product(diff,diff))
!    ! stdout.show("d   =",sqrt(dist))
!         end
!         end
!         end
!     end
!     end
!     end
!     res = sqrt(dist)
!   end

!  **************************************
!  Box centers, Cell centres, and corners
!  **************************************
 
   centre_for_box(b1,b2,b3) result (res)
   ! Return the centre of the box with indices "b1", "b2", "b3", in cartesians.
   ! Recall that a box is defined by a certain number of .divisions of the unit
   ! cell.
      b1,b2,b3 :: INT
      res :: VEC{REAL}(3)
   ENSURE(all([b1,b2,b3]<=.divisions) AND all([b1,b2,b3]>=1),"indices out of range")
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
      box_lengths :: VEC{REAL}(3)
      box_lengths = .scale_factor/(.divisions)
      res = .origin + [b1-HALF,b2-HALF,b3-HALF]*box_lengths
      .crystal.unit_cell.change_from_fractional(res)
   end
 
   centre_for_subcell(c1,c2,c3) result (res)
   ! Return the centre of the subcell with indices "c1", "c2", "c3", in
   ! cartesians.  Recall that a subcell is three times smaller than a cell.
      c1,c2,c3 :: INT
      res :: VEC{REAL}(3)
   ENSURE(all([c1,c2,c3]<=3) AND all([c1,c2,c3]>=1),"indices out of range")
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
      subcell_lengths :: VEC{REAL}(3)
      subcell_lengths = .scale_factor/THREE
      res = .origin + [c1-HALF,c2-HALF,c3-HALF]*subcell_lengths
      .crystal.unit_cell.change_from_fractional(res)
   end
 
   centre_for_subbox(s1,s2,s3) result (res)
   ! Return the centre of the subbox with indices "s1", "s2", "s3", in
   ! cartesians.  Recall that a subsubbox is nine times smaller than a box, a
   ! subbox is three times smaller than a box, and a box is defined by a certain
   ! number of .divisions of the unit cell.
      s1,s2,s3 :: INT
      res :: VEC{REAL}(3)
   ENSURE(all([s1,s2,s3]<=3*.divisions) AND all([s1,s2,s3]>=1),"indices out of range")
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
     subbox_lengths :: VEC{REAL}(3)
     subbox_lengths = .scale_factor/(3*.divisions)
     res = .origin + [s1-HALF,s2-HALF,s3-HALF]*subbox_lengths
     .crystal.unit_cell.change_from_fractional(res)
   end
 
   centre_for_subsubbox(s1,s2,s3) result (res)
   ! Return the centre of the subsubbox with indices "s1", "s2", "s3", in
   ! cartesians.  Recall that a subsubbox is nine times smaller than a box, a
   ! subbox is three times smaller than a box, and a box is defined by a certain
   ! number of .divisions of the unit cell.
      s1,s2,s3 :: INT
      res :: VEC{REAL}(3)
   ENSURE(all([s1,s2,s3]<=9*.divisions) AND all([s1,s2,s3]>=1),"indices out of range")
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
     subsubbox_lengths :: VEC{REAL}(3)
     subsubbox_lengths = .scale_factor/(9*.divisions)
     res = .origin + [s1-HALF,s2-HALF,s3-HALF]*subsubbox_lengths
     .crystal.unit_cell.change_from_fractional(res)
   end
 
   cell_corner(c1,c2,c3) result (res)
   ! Return the cell corner indices "c1", "c2", "c3", in cartesians.  
   ! The corners are numbered 1 or 2 along each axis.
      c1,c2,c3 :: INT
      res :: VEC{REAL}(3)
   ENSURE(all([c1,c2,c3]<=2) AND all([c1,c2,c3]>=1),"indices out of range")
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
      d1,d2,d3 :: INT
      d1 = c1 - 1
      d2 = c2 - 1
      d3 = c3 - 1
      res = .origin + [d1,d2,d3]*.scale_factor
      .crystal.unit_cell.change_from_fractional(res)
   end
 
   unit_cell_corner(c1,c2,c3) result (res)
   ! Return the cell corner indices "c1", "c2", "c3", in cartesians.  
   ! The corners are numbered 1 or 2 along each axis.
      c1,c2,c3 :: INT
      res :: VEC{REAL}(3)
   ENSURE(all([c1,c2,c3]<=2) AND all([c1,c2,c3]>=1),"indices out of range")
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
      d1,d2,d3 :: INT
      d1 = c1 - 1
      d2 = c2 - 1
      d3 = c3 - 1
      res = .unit_cell_origin + [d1,d2,d3]
      .crystal.unit_cell.change_from_fractional(res)
   end
 
!   make_centre_for_box(centre_for_box) ::: leaky
!   ! Work out what the centre of each box is.  This is in cartesians.
!   ! Recall that a subsubbox is nine times smaller than a box, a subbox is three
!   ! times smaller than a box, and a box is defined by a certain number of
!   ! .divisions of the unit cell.
!     centre_for_box :: MAT4{REAL}*
!   ENSURE(.crystal.created,"no crystal info")
!   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
!     b1,b2,b3 :: INT
!     .centre_for_box.create(3,.divisions(1),.divisions(2),.divisions(3))
!     do b1 = 1,.divisions(1)
!     do b2 = 1,.divisions(2)
!     do b3 = 1,.divisions(3)
!        centre_for_box(:,s1,s2,s3) = .centre_for_box(b1,b2,b3)
!     end
!     end
!     end
!   end
 
!   make_centre_for_subbox(centre_for_subbox) ::: leaky
!   ! Work out what the centre of each subbox is.  This is in cartesians.
!   ! Recall that a subsubbox is nine times smaller than a box, a subbox is three
!   ! times smaller than a box, and a box is defined by a certain number of
!   ! .divisions of the unit cell.
!     centre_for_subbox :: MAT4{REAL}*
!   ENSURE(.crystal.created,"no crystal info")
!   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
!     s1,s2,s3 :: INT
!     centre_for_subbox.create(3,3*.divisions(1),3*.divisions(2),3*.divisions(3))
!     do s1 = 1,9*.divisions(1)
!     do s2 = 1,9*.divisions(2)
!     do s3 = 1,9*.divisions(3)
!        centre_for_subbox(:,s1,s2,s3) = .centre_for_subbox(s1,s2,s3)
!     end
!     end
!     end
!   end
 
!   make_centre_for_subsubbox(centre_for_subsubbox) ::: leaky
!   ! Work out what the centre of each subsubbox is.  This is in cartesians.
!   ! Recall that a subsubbox is nine times smaller than a box, a subbox is three
!   ! times smaller than a box, and a box is defined by a certain number of
!   ! .divisions of the unit cell.
!     centre_for_subsubbox :: MAT4{REAL}*
!   ENSURE(.crystal.created,"no crystal info")
!   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
!     s1,s2,s3 :: INT
!     centre_for_subsubbox.create(3,9*.divisions(1),9*.divisions(2),9*.divisions(3))
!     do s1 = 1,9*.divisions(1)
!     do s2 = 1,9*.divisions(2)
!     do s3 = 1,9*.divisions(3)
!        centre_for_subsubbox(:,s1,s2,s3) = .centre_for_subsubbox(s1,s2,s3)
!     end
!     end
!     end
!   end
 
!   make_centre_for_subsubbox ::: leaky
!   ! Work out what the centre of each subsubbox is.  This is in cartesians.
!   ! Recall that a subsubbox is nine times smaller than a box, a subbox is
!   ! three times smaller than a box, and a box is defined by a certain number of
!   ! .divisions of the unit cell.
!   ENSURE(.crystal.created,"no crystal info")
!   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
!     s1,s2,s3 :: INT
!     origin,subsubbox_lengths,subsubbox_centre :: VEC{REAL}(3)
!     ! The length of a subbox along each lattice direction.
!     subsubbox_lengths = .scale_factor/(9*.divisions)
!     ! Get the centre in fractionals
!     origin = .centre
!     .crystal.unit_cell.change_into_fractional(origin)
!     ! The lower left corner of the box, in fractionals
!     origin = origin - [HALF,HALF,HALF]*.scale_factor
!     .centre_for_subsubbox.create(3,9*.divisions(1),9*.divisions(2),9*.divisions(3))
!     do s1 = 1,9*.divisions(1)
!     do s2 = 1,9*.divisions(2)
!     do s3 = 1,9*.divisions(3)
!        ! Get the result in fractionals, and change to cartesians
!        subsubbox_centre = origin + [s1-HALF,s2-HALF,s3-HALF]*subsubbox_lengths
!        .crystal.unit_cell.change_from_fractional(subsubbox_centre)
!        .centre_for_subsubbox(s1,s2,s3) = subsubbox_centre
!     end
!     end
!     end
!   end
 
!   make_corners(corners)
!   ! Return the coordinates of the corners, in the lattice coordinate system.
!     corners :: MAT{REAL}
!   ENSURE(corners.dim1==3,"dimension 1 of matrix should be 3")
!   ENSURE(corners.dim2==8,"dimension 2 of matrix should be 8")
!   ENSURE(.crystal.created,"no crystal info")
!   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
!     centre :: VEC{REAL}(3)
!     ! The cube centre in fractionals
!     centre = .centre
!     .crystal.unit_cell.change_into_fractional(centre)
!     corners(:,1) = centre + (/ HALF, HALF, HALF/)*.scale_factor
!     corners(:,2) = centre + (/ HALF, HALF,-HALF/)*.scale_factor
!     corners(:,3) = centre + (/ HALF,-HALF, HALF/)*.scale_factor
!     corners(:,4) = centre + (/ HALF,-HALF,-HALF/)*.scale_factor
!     corners(:,5) = centre + (/-HALF, HALF, HALF/)*.scale_factor
!     corners(:,6) = centre + (/-HALF, HALF,-HALF/)*.scale_factor
!     corners(:,7) = centre + (/-HALF,-HALF, HALF/)*.scale_factor
!     corners(:,8) = centre + (/-HALF,-HALF,-HALF/)*.scale_factor
!   end

!  **************************
!  Sorting charges into boxes 
!  **************************

   make_L0_positions_and_charges ::: leaky
   ! Make a list of point charges that accurately represents the total charge of
   ! the initial level (i.e. unit cell) from a given set of ".fragment_charges"
   ! and ".fragment_positions".  Includes contributions from electrons and nuclei.
   ENSURE(.level_number==0,"must be level zero")
   ENSURE(.fragment_charges.created,"no fragment charges")
   ENSURE(.fragment_positions.created,"no fragment positions")
   ENSURE(.crystal.created,"no crystal data")
   ENSURE(.crystal.Z.is_int(TOL(3)), "must have an integer number of fragments in the unit cell")
   ENSURE(.crystal.symop_for_frag_cell_atom.created,"fragment cell map not created")
   ENSURE(all(.crystal.symop_for_frag_cell_atom(1:.crystal.n_fragment_atoms)==1),"symops not 1 for fragment")
     pos,new_pos :: MAT{REAL}*
     Z,n_ch,n_pt,n,f,l,s :: INT
     charge_sum :: REAL
     ! Create space for the unit cell charges and positions
     Z = nint(.crystal.Z)
     n_ch = .fragment_charges.dim
     n_pt = .fragment_charges.dim*Z
     .charges.create(n_pt)
     .positions.create(3,n_pt)
     ! Change fragment positions into fractionals
     pos.create_copy(.fragment_positions)
     .crystal.unit_cell.change_into_fractional(pos)
     new_pos.create(pos.dim1,pos.dim2)
     ! Use symmetry to generate the effective charges and their positions in the
     ! whole unit cell. This assumes that the fragment cell is generated from
     ! the *whole* fragment by .crystal.Z symops.
     l = 0
     do n = 1,Z
        f = l + 1
        l = l + n_ch
        .charges(f:l) = .fragment_charges
        new_pos = pos
        s = .crystal.symop_for_frag_cell_atom(1+(n-1)*.crystal.n_fragment_atoms)
        .crystal.transform_geometry(new_pos,op=s)
        .put_to_unit_cell(new_pos,fractional=TRUE)
        .positions(:,f:l) = new_pos ! in cartesians
     end
     new_pos.destroy; pos.destroy
     ! Sum charges
     charge_sum = sum(.fragment_charges)
     stdout.show("sum of charges =",charge_sum)
   end
 
   make_L0_positions_into_boxes ::: leaky
   ! Make the ".indices_for_box" which gives the indices of the unit cell
   ! ".positions" which are in a given box h1,h2,h3. In the best case, a box
   ! will simply be the entire cube for the current level.
   ENSURE(.level_number==0,"must be level zero")
   ENSURE(.positions.created,"no positions for the charges")
   ENSURE(.positions.dim1==3,"incorrect dimensions for array of positions")
      box_for_position :: VEC{VEC_{INT}}*
      box_count :: MAT3{INT}*
      h1,h2,h3,n,i :: INT
      .indices_for_box.create(.divisions) ! leaky
      if (product(.divisions)==1) then
         .indices_for_box(1,1,1).element.create(.positions.dim2) ! leaky
         .indices_for_box(1,1,1)[:] = [(i,i=1,.positions.dim2)]
      else
         box_for_position.create(.positions.dim2,3)
         box_count.create(.divisions)
         .make_box_for_position(box_for_position)
         .make_box_count(box_count,box_for_position)
         do h1 = 1,.divisions(1)
         do h2 = 1,.divisions(2)
         do h3 = 1,.divisions(3)
            .indices_for_box(h1,h2,h3).element.create(box_count(h1,h2,h3)) ! leaky
         end
         end
         end
         box_count.destroy
         do h1 = 1,.divisions(1)
         do h2 = 1,.divisions(2)
         do h3 = 1,.divisions(3)
            i = 0
            do n = 1,.positions.dim2
               if (any(box_for_position(n).element/=[h1,h2,h3])) cycle
               i = i + 1
               .indices_for_box(h1,h2,h3)[i] = n
            end
          ! stdout.flush
          ! stdout.show("box =",[h1,h2,h3])
          ! stdout.text("Indices:")
          ! stdout.put(.indices_for_box(h1,h2,h3).element,"column")
         end
         end
         end
         box_for_position.destroy
      end
   end
 
   make_box_for_position(box_for_position) ::: private
   ! Make "box_for_position(i)"  which tells which box each point
   ! ".positions(:,i)" is in.
     box_for_position :: VEC{VEC_{INT}}
   ENSURE(.level_number==0,"must be level zero")
   ENSURE(.positions.created,"no positions for the charges")
   ENSURE(.positions.dim1==3,"incorrect dimensions for array of positions")
   ENSURE(box_for_position.dim==.positions.dim2,"incorrect dimension for box_for_position")
   ENSURE(box_for_position(1).element.created,"box_for_position element not created")
   ENSURE(box_for_position(1).element.dim==3,"box_for_position element has wrong size")
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
     positions :: MAT{REAL}*
     box_lengths :: VEC{REAL}(3)
     i :: INT
     ! Convert positions to fractionals
     positions.create_copy(.positions)
     .crystal.unit_cell.change_into_fractional(positions)
     ! Make positions relative to 1,1,1 origin
     positions = positions - spread(.origin,dim=2,ncopies=positions.dim2)
     ! Covert to box indices
     box_lengths = .divisions/.scale_factor
     do i = 1,box_for_position.dim
        box_for_position(i)[:] = floor(positions(:,i)*box_lengths) + 1
        stdout.show("position "//i.to_str.trim//", ratios =",positions(:,i)*box_lengths)
     end
     positions.destroy
   end
 
   put_to_unit_cell(positions,fractional) 
   ! Shift the cartesian "positions" so that they are relative to the fragment
   ! molecule centre before changing to the unit cell -- so the unit cell
   ! surrounds the centre of the box i.e. the central fragment molecule.
   ! Actually, this should not be necessary but it looks nicer ... 
   ! If "fractional" is present and TRUE, then "positions" is asumed in
   ! fractional coordinates but the final result is STILL returned in
   ! cartesians.
      positions :: MAT{REAL}
      fractional :: BIN, optional
   ENSURE(positions.dim1==3,"incorrect dimensions for array of positions")
      centre,shift :: VEC{REAL}(3)
      change :: BIN
      change = FALSE
      if (present(fractional)) change = fractional
      if (change) .crystal.unit_cell.change_into_fractional(positions)
      ! When added to any fractional position, "shift" will convert that position
      ! to be such that the .centre becomes the centre of the unit cell. 
      centre = .centre
      .crystal.unit_cell.change_into_fractional(centre)
      shift = [HALF,HALF,HALF] - centre
      ! Now put the positions to the unit cell ...
      positions = positions + spread(shift,dim=2,ncopies=positions.dim2)
      .crystal.put_to_unit_cell(positions)
      positions = positions - spread(shift,dim=2,ncopies=positions.dim2)
      .crystal.unit_cell.change_from_fractional(positions)
   end
 
!   make_box_for_position(box_for_position,positions) ::: private
!   ! Make "box_for_position(i)"  which tells which box each point
!   ! "positions(:,i)" is in.
!     box_for_position :: VEC{VEC_{INT}}
!     positions :: MAT{REAL}
!   ENSURE(.level_number==0,"must be level zero")
!   ENSURE(positions.dim1==3,"incorrect dimensions for array of positions")
!   ENSURE(box_for_position.dim==positions.dim2,"incorrect dimension for box_for_position")
!   ENSURE(box_for_position(1).element.created,"box_for_position element not created")
!   ENSURE(box_for_position(1).element.dim==3,"box_for_position element has wrong size")
!   ENSURE(.crystal.created,"no crystal info")
!   ENSURE(.crystal.unit_cell.info_made,"no crystal unit cell info")
!     pos :: MAT{REAL}*
!     box_lengths :: VEC{REAL}(3)
!     i :: INT
!     ! Convert positions to fractionals
!     pos.create_copy(positions)
!     .crystal.unit_cell.change_into_fractional(pos)
!     ! Make positions relative to 1,1,1 origin
!     pos = pos - spread(.origin,dim=2,ncopies=pos.dim2)
!     ! Covert to box indices
!     box_lengths = .divisions/.scale_factor
!     do i = 1,box_for_position.dim
!        box_for_position(i)[:] = floor(pos(:,i)*box_lengths) + 1
!        stdout.show("position "//i.to_str.trim//", ratios =",pos(:,i)*box_lengths)
!     end
!     pos.destroy
!   end
 
   make_box_count(box_count,box_for_position) ::: private
   ! Make "box_count(h1,h2,h3)" which is the number of points in a particular box
   ! h1,h2,h3 of the cell. This is used to create the point charge arrays with the
   ! correct size.
     box_count :: MAT3{INT}
     box_for_position :: VEC{VEC_{INT}}
   ENSURE(.level_number==0,"must be level zero")
   ENSURE(all(box_count.shape==.divisions), "wrong shape for box_count")
   ENSURE(.positions.created, "no positions")
   ENSURE(box_for_position.dim==.positions.dim2, "array dimensions inconsistent")
     b1,b2,b3,n :: INT
     box_count = 0
     do n = 1,box_for_position.dim
        b1 = box_for_position(n).element(1)
        b2 = box_for_position(n).element(2)
        b3 = box_for_position(n).element(3)
        box_count(b1,b2,b3) = box_count(b1,b2,b3) + 1
     end
     .put_box_count(box_count)
     DIE_IF(sum(box_count)/=.positions.dim2,"not all charges are in a box")
   end

!  ****************************
!  Making the total box charges
!  ****************************
 
   make_L0_total_box_charges ::: leaky
   ! Make the list of charges in each box at level 0, used for making the box
   ! multipoles and box total charges.
   ENSURE(.level_number==0,"must be level zero")
   ENSURE(.charges.created,"no charges")
   ENSURE(.positions.created,"no positions for the charges")
   ENSURE(.positions.dim1==3,"incorrect dimensions for array of positions")
   ENSURE(.charges.dim==.positions.dim2,"inconsistent charges and positions")
   ENSURE(.indices_for_box.created,"no indices_for_box information")
   ENSURE(.total_charge_for_box.destroyed,"total_charge_for_box exists")
      b1,b2,b3,dim :: INT
      .total_charge_for_box.create(.divisions)
      if (product(.divisions)==1) then
         .total_charge_for_box(1,1,1) = sum(abs(.charges))
 ! stdout.show("BOX          =",[1,1,1])
 ! stdout.show("total charge =",.total_charge_for_box(1,1,1))
      else
         do b1 = 1,.divisions(1)
         do b2 = 1,.divisions(2)
         do b3 = 1,.divisions(3)
            .total_charge_for_box(b1,b2,b3) = sum(abs(.charges(.indices_for_box(b1,b2,b3)[:])))
         end
         end
         end
      end
   end
 
   make_total_box_charges(level_minus_1) ::: leaky
   ! Set the total box charges from the previous level box charges.
      level_minus_1 :: PERIODIC_FMM_LEVEL
   ENSURE(.level_number>0,"level number must be greater than 0")
   ENSURE(.total_charge_for_box.destroyed,"total charges exist")
   ENSURE(level_minus_1.level_number==(.level_number-1),"inconsistent level number")
   ENSURE(level_minus_1.total_charge_for_box.created,"no total charges for level_minus_1")
      h1,h2,h3,b1,b2,b3,u1,u2,u3 :: INT
      total :: REAL
      .total_charge_for_box.create(.divisions)
      .total_charge_for_box = ZERO
      do b1 = 1,.divisions(1)       ! Loop over BOXES in THIS level
      do b2 = 1,.divisions(2)
      do b3 = 1,.divisions(3)
         total = ZERO
         do h1 = 3*b1-2,3*b1        ! Loop over groups of three, which are the boxes level_minus_1
         do h2 = 3*b2-2,3*b2        ! which maps onto box (b1,b2,b3) at the current level
         do h3 = 3*b3-2,3*b3                   
            u1 = mod(h1-1,.divisions(1)) + 1
            u2 = mod(h2-1,.divisions(2)) + 1
            u3 = mod(h3-1,.divisions(3)) + 1
            total = total + level_minus_1.total_charge_for_box(u1,u2,u3)
         end
         end
         end
 ! stdout.show("BOX          =",[b1,b2,b3])
 ! stdout.show("total charge =",total)
         .total_charge_for_box(b1,b2,b3) = total
      end
      end
      end
   end
 
   make_total_subsubbox_charges(level_minus_2)
   ! Set the total subsubbox charges from the total box charges of "level_minus_2".
   ! In fact, they are the same, so we only set the first subsubbox total charges.
     level_minus_2 :: PERIODIC_FMM_LEVEL
   ENSURE(.level_number>1,"level number must be greater than 1")
   ENSURE(level_minus_2.level_number==(.level_number-2),"inconsistent level number")
   ENSURE(level_minus_2.total_charge_for_box.created,"no total charges for level_minus_2")
     .total_charge_for_1st_subsubbox => level_minus_2.total_charge_for_box
   end

!  *************************
!  Making the box multipoles
!  *************************

   make_L0_box_multipoles(l_max) ::: leaky
   ! Make the initial box multipoles up to order "l_max" from a given set of
   ! ".charges" and ".positions". NOTE: this should be applied to level zero in
   ! the first instance (level 1 is the buffer zone).
      l_max :: INT
   ENSURE(.level_number==0,"Must be at level 0")
   ENSURE(.charges.created,"no charges")
   ENSURE(.positions.created,"no positions for the charges")
   ENSURE(.positions.dim1==3,"wrong 1st dimension, positions")
   ENSURE(.charges.dim==.positions.dim2,"inconsistent charges and positions")
   ENSURE(.indices_for_box.created,"no indices_for_box information")
   ENSURE(.indices_for_box(1,1,1).element.created,"no indices_for_box information")
   ENSURE(.multipoles_for_box.destroyed,"box multipoles already exist")
      b1,b2,b3, n,dim :: INT
      ind :: MAT3{VEC_{INT}}*
      box_centres :: MAT3{VEC_{REAL}}*
      positions :: MAT{REAL}*
      box_multipoles,charges :: VEC{REAL}*
      ! Create space the boxes for the multipole -- leaky here
      .multipoles_for_box.create(.divisions)            ! LEAKY
      dim = (l_max+1)*(l_max+1)
      if (product(.divisions)==1) then
            .multipoles_for_box(1,1,1).element.create(dim)
            box_multipoles => .multipoles_for_box(1,1,1).element
            ! Make position relative to the centre of the box
            positions.create_copy(transpose(.positions))
            positions = positions - spread(.centre,dim=1,ncopies=positions.dim1)
            VEC{REAL}:make_R_mu_multipoles(box_multipoles,.charges,positions,l_max)
            positions.destroy
            box_multipoles(1) = ZERO
      else
         do b1 = 1,.indices_for_box.dim1
         do b2 = 1,.indices_for_box.dim2
         do b3 = 1,.indices_for_box.dim3
            n = .indices_for_box(b1,b2,b3).element.dim
            if (n==0) cycle
            .multipoles_for_box(b1,b2,b3).element.create(dim)
            box_multipoles => .multipoles_for_box(b1,b2,b3).element
            charges.create_copy(.charges(.indices_for_box(b1,b2,b3)[:]))
            ! Make position relative to the centre of the box
            positions.create_copy(transpose(.positions(:,.indices_for_box(b1,b2,b3)[:])))
            positions = positions - spread(.centre_for_box(b1,b2,b3),dim=1,ncopies=positions.dim1)
            VEC{REAL}:make_R_mu_multipoles(box_multipoles,charges,positions,l_max)
            positions.destroy
            charges.destroy
            box_multipoles(1) = ZERO
         end
         end
         end
      end
   end

!   make_L1_box_multipoles(l_max) ::: leaky
!   ! Make the box multipoles for level one in the case where divisions is all
!   ! one. This is for checking of the translation of multipoles from level 0.
!      l_max :: INT
!   ENSURE(.level_number==1,"Must be at level 1")
!   ENSURE(.charges.created,"no charges")
!   ENSURE(.positions.created,"no positions for the charges")
!   ENSURE(.positions.dim1==3,"wrong 1st dimension, positions")
!   ENSURE(.charges.dim==.positions.dim2,"inconsistent charges and positions")
!   ENSURE(product(.divisions)==1,"must have no divisions")
!      c1,c2,c3, f,l,dim :: INT
!      shift :: VEC{REAL}(3)
!      box_multipoles,charges :: VEC{REAL}*
!      positions :: MAT{REAL}*
!      dim = .charges.dim
!      positions.create(dim,3)
!      .multipoles_for_box.destroy
!      .multipoles_for_box.create(.divisions)            ! LEAKY
!      dim = (l_max+1)*(l_max+1)
!      .multipoles_for_box(1,1,1).element.create(dim)
!      box_multipoles => .multipoles_for_box(1,1,1).element
!      box_multipoles = ZERO
!      do c1 = 1,3               
!      do c2 = 1,3
!      do c3 = 1,3
!         shift = .centre_for_subcell(c1,c2,c3) - .centre_for_subcell(2,2,2)
!      stdout.show("cell  =",[c1,c2,c3])
!      stdout.show("shift =",shift)
!         positions = transpose(.positions)
!         positions = positions + spread(shift,dim=1,ncopies=.positions.dim2)
!         ! Make position relative to the centre of the box
!         positions = positions - spread(.centre,dim=1,ncopies=positions.dim1)
!         VEC{REAL}:add_R_mu_multipoles(box_multipoles,.charges,positions,l_max)
!      end
!      end
!      end
!      positions.destroy
!   end
 
   make_box_multipoles(level_minus_1) ::: leaky
   ! Assign the box multipoles from the "level_minus_1".
      level_minus_1 :: PERIODIC_FMM_LEVEL
   ENSURE(.level_number>0,"level number must be greater than 0")
   ENSURE(.multipoles_for_box.destroyed,"box multipoles exist")
   ENSURE(level_minus_1.level_number==(.level_number-1),"inconsistent level number")
   ENSURE(level_minus_1.multipoles_for_box.created,"no box multipoles for level_minus_1")
      W :: MAT{REAL}*
      P,Pbar :: VEC{REAL}(3)
      old_multipoles,new_multipoles :: VEC{REAL}*
      h1,h2,h3,b1,b2,b3,c1,c2,c3,u1,u2,u3,d1,d2,d3, dim,l_max :: INT
      found :: BIN
      .multipoles_for_box.create(.divisions)
      dim = level_minus_1.box_multipoles_dim
      l_max = nint(sqrt(float(dim))) - 1
    ! dim = (.l_max+1)*(.l_max+1)
      W.create(dim,dim)
      do b1 = 1,.divisions(1)                   ! Loop over BOXES in THIS level
      do b2 = 1,.divisions(2)
      do b3 = 1,.divisions(3)
         c1 = 3*b1 - 1                          ! The indices of the central SUBBOX in a group of three
         c2 = 3*b2 - 1
         c3 = 3*b3 - 1
         Pbar = .centre_for_subbox(c1,c2,c3)    ! This is where we are translating the multipoles TO
         .multipoles_for_box(b1,b2,b3).element.create(dim) 
         new_multipoles => .multipoles_for_box(b1,b2,b3).element
         new_multipoles = ZERO                  ! These are the new multipoles we are making ...
         do d1 = 1,.divisions(1)                ! Loop over ACCEPTABLE divisions in level_minus_1
         do d2 = 1,.divisions(2)
         do d3 = 1,.divisions(3)
            if (level_minus_1.multipoles_for_box(d1,d2,d3).element.destroyed) cycle
            old_multipoles => level_minus_1.multipoles_for_box(d1,d2,d3).element
            W = ZERO                            ! This is the translation matrix for these divisions
            found = FALSE                       ! Are there any acceptable divisons ... ?
            do h1 = c1-1,c1+1                   ! Loop over groups of three, which are the boxes level_minus_1
            do h2 = c2-1,c2+1                   ! which maps onto box (b1,b2,b3) at the current level, and
            do h3 = c3-1,c3+1                   ! translate multipoles from  "P" to central box "Pbar"
               u1 = mod(h1-1,.divisions(1)) + 1
               u2 = mod(h2-1,.divisions(2)) + 1
               u3 = mod(h3-1,.divisions(3)) + 1
               if (u1/=d1 OR u2/=d2 OR u3/=d3) cycle
               found = TRUE                     ! OK, this division is used
               P = .centre_for_subbox(h1,h2,h3)
               W.add_multipole_W_translation_mx(P-Pbar,l_max)
               ! debug = TRUE
               ! if (debug) then
               !   stdout.show("shifting u =",[u1,u2,u3])
               !   stdout.text("W:")
               !   stdout.put(W)
               ! end
               ! end
            end
            end
            end
            if (found) new_multipoles.plus_product_of(W,old_multipoles)
            ! if (.level_number==2 AND all([h1,h2,h3]==[1,1,1])) then
            !   stdout.text("new:")
            !   stdout.put(new_multipoles,"column")
            ! end
         end
         end
         end
      end
      end
      end
   end
 
   make_subsubbox_multipoles(level_minus_2)
   ! Make the subsubbox multipoles from the box multipoles of "level_minus_2".
   ! In fact, they are the same, so we only set the first subsubbox multipoles.
     level_minus_2 :: PERIODIC_FMM_LEVEL
   ENSURE(.level_number>1,"level number must be greater than 1")
   ENSURE(level_minus_2.level_number==(.level_number-2),"inconsistent level number")
   ENSURE(level_minus_2.multipoles_for_box.created,"no box multipoles for level_minus_2")
   ENSURE(level_minus_2.multipoles_for_box(1,1,1).element.created,"no box multipoles for level_minus_2")
     .multipoles_for_1st_subsubbox => level_minus_2.multipoles_for_box
   end
 
!   make_subbox_multipoles(level_minus_1) ::: leaky
!   ! Make the current level box multipoles from the box multipoles of the
!   ! "level_minus_1" (which is one smaller than the current level). 
!      level_minus_1 :: PERIODIC_FMM_LEVEL
!   ENSURE(level_minus_1.multipoles_for_subbox.created,"no level_minus_1 subbox multipoles")
!   ENSURE(level_minus_1.level_number==(.level_number-1),"inconsistent level number")
!   ENSURE(.level_number>0,"level number must be greater than 0")
!   ENSURE(.multipoles_for_subbox.destroyed,"subbox multipoles already exist")
!      h1,h2,h3, u1,u2,u3, f1,f2,f3,l1,l2,l3, dim :: INT
!      fac :: REAL
!      W :: MAT{REAL}*
!      .multipoles_for_subbox.create(.divisions)
!      ! Check if the number of multipoles on the previous level is OK
!      fac = level_minus_1.multipoles_for_subbox_dim
!      fac = sqrt(fac)
!      ENSURE(fac.is_int(TOL(3)),"length for subbox multipoles must be a square number")
!  !   .l_max = max(.l_max,nint(fac)-1)
!  !   .l_max = 3
!      ! Loop and make the multipoles for box (1,1,1). All other boxes are
!      ! equivalent to (1,1,1) after level 2, so we pointer copy all subboxes to
!      ! the first one.
!      dim = (.l_max+1)*(.l_max+1)
!      W.create(dim,dim)
!      do h1 = 1,.divisions(1)
!      do h2 = 1,.divisions(2)
!      do h3 = 1,.divisions(3)
!         first_box = h1<=.divisions(1) AND h2<=.divisions(2) AND h3<=.divisions(3)
!         u1 = mod(h1-1,.divisions(1)) 
!         u2 = mod(h2-1,.divisions(2)) 
!         u3 = mod(h3-1,.divisions(3)) 
!         if (NOT first_box) then
!            u1 = u1 + 1 
!            u2 = u2 + 1 
!            u3 = u3 + 1 
!            .multipoles_for_subbox(h1,h2,h3).element => .multipoles_for_subbox(u1,u2,u3).element
!         else if (do_first) then
!            f1 = 9*u1 + 1; l1 = f1 + 8
!            f2 = 9*u2 + 1; l2 = f2 + 8
!            f3 = 9*u3 + 1; l3 = f3 + 8
!            .make_subbox_multipoles([h1,h2,h3],level_minus_1,[f1,f2,f3],[l1,l2,l3],W) ! LEAKY
!         end
!      end
!      end
!      end
!      W.destroy
!   end
 
!   make_subbox_multipoles(h,level_minus_1,f,l,W) ::: leaky
!   ! Make the current level multipoles for the subbox with indices "h", from the
!   ! "level_minus_1" subbox multipoles with indices in the range "f" to "l".
!   ! "W" is workspace for the translation matrix, used to avoid excessive
!   ! allocation and deallocation. 
!      h,f,l :: VEC{INT}(3), IN
!      level_minus_1 :: PERIODIC_FMM_LEVEL, IN
!      W :: MAT{REAL}*
!   ENSURE(all(h>[0,0,0]),"subbox must be positive")
!   ENSURE(all(l-f==[2,2,2]),"range must be 3")
!   ENSURE(level_minus_1.centre_for_subbox.created,"no previous level subbox_centre info")
!   ENSURE(level_minus_1.multipoles_for_subbox.created,"no level_minus_2 subbox multipoles")
!   ENSURE(W.created,"Workspace not allocated")
!   ENSURE(W.is_square,"Workspace not square")
!   ENSURE(W.dim1==(.l_max+1)*(.l_max+1),"Workspace not square")
!   ENSURE(.centre_for_subbox.created,"no subbox_centre info")
!      c :: VEC{INT}(3)
!      dim,u1,u2,u3 :: INT
!      P,PP :: VEC{REAL}(3)
!      old_multipoles,new_multipoles :: VEC{REAL}*
!      ! The indices of the central box
!      c = f + 4 
!      ! This is where we are translating the multipoles TO
!      PP = level_minus_1.centre_for_subbox(:,c(1),c(2),c(3))
!      ! Create space for the new multipoles
!      dim = W.dim1
!      .multipoles_for_subbox(h(1),h(2),h(3)).element.destroy     ! LEAKY here!
!      .multipoles_for_subbox(h(1),h(2),h(3)).element.create(dim) ! LEAKY here!
!      .multipoles_for_subbox(h(1),h(2),h(3)).element = ZERO
!      new_multipoles => .multipoles_for_subbox(h(1),h(2),h(3)).element(1:dim)
!      ! Loop over previous level subboxes which map onto [h1,h2,h3] and
!      ! translate the multipoles from the previous level to the new subbox
!      ! centre "P" from "PP".
!      do u1 = f(1),l(1)
!      do u2 = f(2),l(2)
!      do u3 = f(3),l(3)
!         if (level_minus_1.multipoles_for_subbox(u1,u2,u3).element.destroyed) cycle
!         old_multipoles => level_minus_1.multipoles_for_subbox(u1,u2,u3).element(1:dim)
!         P = level_minus_1.centre_for_subbox(:,u1,u2,u3)
!         W.to_multipole_W_translation_mx(P-PP,.l_max)
!       ! debug = TRUE
!       ! if (debug) then
!       !   stdout.show("shifting u =",[u1,u2,u3])
!       !   stdout.text("W:")
!       !   stdout.put(W)
!       !   stdout.text("old:")
!       !   stdout.put(old_multipoles,"column")
!       ! end
!         new_multipoles.plus_product_of(W,old_multipoles)
!       ! if (.level_number==2 AND all([h1,h2,h3]==[1,1,1])) then
!       !   stdout.text("new:")
!       !   stdout.put(new_multipoles,"column")
!       ! end
!      end
!      end
!      end
!   end
 
   add_potential_to(values,positions,adjust_surface_dipoles) 
   ! To "values", add the electric potential coming from the subbox multipoles
   ! or effective point charges at this level. The "values are evaluated at
   ! "positions".  If present TRUE, "adjust_surface_dipoles" causes most of the
   ! dipoles on the surface of this level to be reversed, to simulate the
   ! neutralisation of the surface charge, in order to get a potential close to
   ! the Ewald potential.  Add the "values" of the potential at "points" from
   ! the set of subbox multipoles at this level. If present TRUE,
   ! "adjust_surface_dipoles" causes most of the dipoles on the surface of this
   ! level to be reversed, to simulate the neutralisation of the surface charge,
   ! in order to get a potential close to the Ewald potential.
   ! NOTE: values is *incremented*, so you must set it to zero beforehand!
     values :: VEC{REAL}
     positions :: MAT{REAL}
     adjust_surface_dipoles :: BIN, optional
   ENSURE(.fragment_charges.created,"no fragment_charges")
   ENSURE(values.dim==.fragment_charges.dim,"inconsistent length for values")
   ENSURE(.level_number>=1,"cannot have level 0; its contribution is in level 1")
     if (.level_number==1) then; .add_point_charge_potential_to(values,positions)
     else;   .add_multipole_potential_to(values,positions,adjust_surface_dipoles)
     end
   end
 
   add_point_charge_potential_to(values,positions) ::: private
   ! To "values", add the electric potential which arises from the set of
   ! effective point ".charges" within the level 1 buffer zone, INCLUDING the
   ! charges from the initial fragment (which should be evaluated exactly in
   ! another way). The "values" are evaluated at "positions".
   ! NOTE: values is *incremented*, so you must set it to zero beforehand!
      values :: VEC{REAL}
      positions :: MAT{REAL}
   ENSURE(.level_number<=1,"must be level 0 or level 1")
   ENSURE(.charges.created,"no unit cell charges")
   ENSURE(.positions.created,"no unit cell positions")
   ENSURE(.charges.dim==.positions.dim2,"inconsistent charges and positions arrays")
   ENSURE(.positions.dim1==3,"wrong 1st dim, positions")
   ENSURE(values.dim==.fragment_charges.dim,"inconsistent length for values")
      c1,c2,c3,n,i :: INT
      q,qx,qy,qz,px,py,pz,rx,ry,rz,R :: REAL
      shift :: VEC{REAL}(3)
      pos :: MAT{REAL}*
      pos.create_copy(positions)
      .put_to_unit_cell(pos,fractional=FALSE) 
      ! Loop over subcells which are equivalent to the unit cell
      do c1 = 1,3               
      do c2 = 1,3
      do c3 = 1,3
         shift = .centre_for_subcell(c1,c2,c3) - .centre_for_subcell(2,2,2)
         .positions = .positions + spread(shift,dim=2,ncopies=.positions.dim2)
         ! Loop over charges in each subbox
         do n = 1,.charges.dim  
            q  = .charges(n)
            qx = .positions(1,n)
            qy = .positions(2,n)
            qz = .positions(3,n)
            ! Loop over values and positions in unit cell.
            do i = 1,values.dim 
               px = pos(1,i)
               py = pos(2,i)
               pz = pos(3,i)
               rx = qx - px
               ry = qy - py
               rz = qz - pz
               R = sqrt(rx*rx+ry*ry+rz*rz)
               if (abs(R)<TOL(10)) cycle
               values(i) = values(i) + q/R
            end
         end
         .positions = .positions - spread(shift,dim=2,ncopies=.positions.dim2)
      end
      end
      end
      pos.destroy
   end
 
   add_multipole_potential_to(values,positions,adjust_surface_dipoles) ::: private
   ! To "values", add the electric potential which arises from the set of
   ! subsubbox multipoles at this level. The "values" are evaluated at
   ! "positions".  If present TRUE, "adjust_surface_dipoles" causes most of the
   ! dipoles on the surface of this level to be reversed, to simulate the
   ! neutralisation of the surface charge, in order to get a potential close to
   ! the Ewald potential.  NOTE: values is *incremented*, so you must set it to
   ! zero beforehand!
      values :: VEC{REAL}
      positions :: MAT{REAL}
      adjust_surface_dipoles :: BIN, optional
   ENSURE(.level_number>=2,"no multipoles for levels 0 and 1")
   ENSURE(values.dim==positions.dim2,"inconsistent length for values arrays")
   ENSURE(.multipoles_for_1st_subsubbox.created,"no subsubbox multipoles")
   ENSURE(.multipoles_for_1st_subsubbox(1,1,1).element.created,"no subsubbox multipoles")
   ENSURE(.l_max<=(nint(sqrt(float(.multipoles_for_1st_subsubbox(1,1,1).element.dim)))-1),"wrong l_max")
      select case (.potential_method)
         case("point-centred-monopole"); .add_multipole_mono_pot_to(values,positions,adjust_surface_dipoles)
         case("cell-centred-multipole"); .add_multipole_mult_pot_to(values,positions,adjust_surface_dipoles)
         case default; UNKNOWN(.potential_method)
      end
   end
 
   add_multipole_mono_pot_to(values,positions,adjust_surface_dipoles) ::: private
   ! To "values", add the electric potential which arises from the set of
   ! subsubbox multipoles at this level. The "values" are evaluated at
   ! "positions".  If present TRUE, "adjust_surface_dipoles" causes most of the
   ! dipoles on the surface of this level to be reversed, to simulate the
   ! neutralisation of the surface charge, in order to get a potential close to
   ! the Ewald potential.  This version only uses the monopole expansion to
   ! evaluate the potential, so the interaction matrix T becomes a vector.
   ! NOTE: values is *incremented*, so you must set it to zero beforehand!
      values :: VEC{REAL}
      positions :: MAT{REAL}
      adjust_surface_dipoles :: BIN, optional
   ENSURE(.level_number>=2,"no multipoles for levels 0 and 1")
   ENSURE(values.dim==positions.dim2,"inconsistent length for values arrays")
   ENSURE(.multipoles_for_1st_subsubbox.created,"no subsubbox multipoles")
   ENSURE(.multipoles_for_1st_subsubbox(1,1,1).element.created,"no subsubbox multipoles")
   ENSURE(.l_max<=(nint(sqrt(float(.multipoles_for_1st_subsubbox(1,1,1).element.dim)))-1),"wrong l_max")
      adjust_dipoles :: BIN
      d1,d2,d3,h1,h2,h3,u1,u2,u3,n,dim :: INT
      fac :: REAL
      lim :: MAT{INT}(2,3)
      pos :: MAT{REAL}*
      Q,P :: VEC{REAL}(3)
      subsubbox_multipoles,T :: VEC{REAL}*
      adjust_dipoles = FALSE        ! Adjust surface dipoles?
      if (present(adjust_surface_dipoles)) adjust_dipoles = adjust_surface_dipoles
      ! Make the positions in the unit cell so there are no overlaps between the
      ! multipole convergence spheres.
      pos.create_copy(positions)   ! <<<<<<<<<<<<<
      .put_to_unit_cell(pos,fractional=FALSE) 
      dim = (.l_max+1)*(.l_max+1)
      T.create(dim)
      lim(1,:) = nint(THREE*.divisions) + 1  ! min
      lim(2,:) = nint(SIX*.divisions)        ! max
      do d1 = 1,.divisions(1)       ! Loop over ACCEPTABLE divisions 
      do d2 = 1,.divisions(2)
      do d3 = 1,.divisions(3)
         subsubbox_multipoles => .multipoles_for_1st_subsubbox(d1,d2,d3)[1:dim]
         T = ZERO
         do h1 = 1,9*.divisions(1)  ! Loop over subsubboxes, calculate potential from the multipoles
         do h2 = 1,9*.divisions(2)  ! Skip the subsubboxes in the central subcell
         do h3 = 1,9*.divisions(3)  ! Skip the subsubboxes with unacceptable divisions
            if (h1.is_in_range(lim(:,1)) AND h2.is_in_range(lim(:,2)) AND h3.is_in_range(lim(:,3))) cycle
            u1 = mod(h1-1,.divisions(1)) + 1
            u2 = mod(h2-1,.divisions(2)) + 1
            u3 = mod(h3-1,.divisions(3)) + 1
            if (u1/=d1 OR u2/=d2 OR u3/=d3) cycle
            Q = .centre_for_subsubbox(h1,h2,h3)
     ! stdout.show("centre shift =",[h1,h2,h3])
     ! stdout.show("divisions    =",[u1,u2,u3])
     ! stdout.show("shift        =",Q-.centre)
            if (NOT adjust_dipoles) then
               do n = 1,pos.dim2
                  P = pos(:,n)
                  T.to_multipole_T_interaction_vec(Q-P,.l_max) ! only the monopole term
                  values(n) = values(n) + dot_product(T,subsubbox_multipoles)
               end
            else
               fac = .edge_factor(h1,h2,h3,9*.divisions)
               do n = 1,pos.dim2
                  P = pos(:,n)
                  T.to_multipole_T_interaction_vec(Q-P,.l_max)
                  values(n) = values(n) + fac*dot_product(T,subsubbox_multipoles)
               end
            end
         end
         end
         end
      end
      end
      end
      T.destroy
      pos.destroy
   end
 
   add_multipole_mult_pot_to(values,positions,adjust_surface_dipoles) ::: private
   ! To "values", add the electric potential which arises from the set of
   ! subsubbox multipoles at this level. The "values" are evaluated at
   ! "positions".  If present TRUE, "adjust_surface_dipoles" causes most of the
   ! dipoles on the surface of this level to be reversed, to simulate the
   ! neutralisation of the surface charge, in order to get a potential close to
   ! the Ewald potential.  NOTE: values is *incremented*, so you must set it to
   ! zero beforehand!
      values :: VEC{REAL}
      positions :: MAT{REAL}
      adjust_surface_dipoles :: BIN, optional
   ENSURE(.level_number>=2,"no multipoles for levels 0 and 1")
   ENSURE(values.dim==positions.dim2,"inconsistent length for values array")
   ENSURE(.multipoles_for_1st_subsubbox.created,"no subsubbox multipoles")
   ENSURE(.multipoles_for_1st_subsubbox(1,1,1).element.created,"no subsubbox multipoles")
   ENSURE(.l_max<=(nint(sqrt(float(.multipoles_for_1st_subsubbox(1,1,1).element.dim)))-1),"wrong l_max")
      adjust_dipoles,found :: BIN
      d1,d2,d3,h1,h2,h3,u1,u2,u3,n,dim :: INT
      fac :: REAL
      lim :: MAT{INT}(2,3)
      Q,P :: VEC{REAL}(3)
      T,R,pos :: MAT{REAL}*
      TQ,subsubbox_Q_multipoles :: VEC{REAL}*
      adjust_dipoles = FALSE        ! Adjust surface dipoles?
      if (present(adjust_surface_dipoles)) adjust_dipoles = adjust_surface_dipoles
      ! First get the multipoles in the unit cell
      dim = (.l_max+1)*(.l_max+1)
      TQ.create(dim); TQ = ZERO
      T.create(dim,dim)
      lim(1,:) = nint(THREE*.divisions) + 1  ! min
      lim(2,:) = nint(SIX*.divisions)        ! max
      do d1 = 1,.divisions(1)       ! Loop over ACCEPTABLE divisions 
      do d2 = 1,.divisions(2)
      do d3 = 1,.divisions(3)
         T = ZERO
         found = FALSE
         do h1 = 1,9*.divisions(1)  ! Loop over subboxes and calculate the potential from the multipoles
         do h2 = 1,9*.divisions(2)  ! Skip the subsubboxes in the central subcell
         do h3 = 1,9*.divisions(3)  ! Skip the subsubbxes with unacceptable divisions
            if (h1.is_in_range(lim(:,1)) AND h2.is_in_range(lim(:,2)) AND h3.is_in_range(lim(:,3))) cycle
            u1 = mod(h1-1,.divisions(1)) + 1
            u2 = mod(h2-1,.divisions(2)) + 1
            u3 = mod(h3-1,.divisions(3)) + 1
            if (u1/=d1 OR u2/=d2 OR u3/=d3) cycle
            found = TRUE            ! OK, this division is used
            Q = .centre_for_subsubbox(h1,h2,h3)
     ! stdout.show("centre shift =",[h1,h2,h3])
     ! stdout.show("divisions    =",[u1,u2,u3])
     ! stdout.show("shift        =",Q-.centre)
            if (NOT adjust_dipoles) then
               T.add_multipole_T_interaction_mx(Q-.centre,.l_max,.l_max) 
            else
               DIE("not implemented yet")
               fac = .edge_factor(h1,h2,h3,9*.divisions)
            end
         end
         end
         end
         if (found) then
            subsubbox_Q_multipoles => .multipoles_for_1st_subsubbox(d1,d2,d3)[1:dim]
            TQ.plus_product_of(T,subsubbox_Q_multipoles)
         end
      end
      end
      end
      T.destroy
      ! Now evaluate the potential at the positions
      R.create(values.dim,dim)
      pos.create_copy(positions)
      .put_to_unit_cell(pos,fractional=FALSE) 
      pos = pos - spread(.centre,dim=2,ncopies=pos.dim2)
      R.to_R_mu_multipole_mx(transpose(pos),.l_max)
      pos.destroy
      values.plus_product_of(R,TQ)
      R.destroy
      TQ.destroy
   end
 
   subtract_fragment_potential(values)
   ! From "values", subtract the electric potential which arises from the set of
   ! effective point ".charges" located at ".fragment_positions".
      values :: VEC{REAL}
   ENSURE(.level_number<=1,"must be level 0 or level 1")
   ENSURE(.fragment_charges.created,"no fragment_charges")
   ENSURE(.fragment_positions.created,"no fragment_positions")
   ENSURE(.fragment_charges.dim==.fragment_positions.dim2,"inconsistent fragment charges and positions")
   ENSURE(.fragment_positions.dim1==3,"wrong 1st dim, fragment_positions")
   ENSURE(values.dim==.fragment_charges.dim,"inconsistent length for values")
      n,i :: INT
      q,qx,qy,qz,px,py,pz,rx,ry,rz,R :: REAL
      stdout.text("fragment charges")
      stdout.put(.fragment_charges,"column")
      stdout.text("fragment positions")
      stdout.put(.fragment_positions,"transpose")
      ! Subtract potential from fragment charges
      do n = 1,.fragment_charges.dim  
         q  = .fragment_charges(n)
         qx = .fragment_positions(1,n)
         qy = .fragment_positions(2,n)
         qz = .fragment_positions(3,n)
         ! Loop over values and positions in unit cell.
         do i = 1,values.dim 
            px = .fragment_positions(1,i)
            py = .fragment_positions(2,i)
            pz = .fragment_positions(3,i)
            rx = qx - px
            ry = qy - py
            rz = qz - pz
            R = sqrt(rx*rx+ry*ry+rz*rz)
            if (abs(R)<TOL(10)) cycle
            values(i) = values(i) - q/R
         end
      end
   end
 
   edge_factor(h1,h2,h3,div) result(fac)
   ! Return the edge factor "fac" which tells whether the subbox with indices
   ! "h1", "h2", "h3" is on a corner (then fac=-1/7) or an edge (then fac=-1/3)
   ! or neither (then fac=-1).  "div" is the number of divisions per edge. This
   ! routine is used to rescale the dipoles on the surface, to neutralise the
   ! surface charge.
      h1,h2,h3 :: INT, IN
      div :: VEC{INT}(3), IN
      fac :: REAL
      on_outer_skin,on_outer_edge,on_the_corner :: BIN
      on_outer_skin = h1==1 OR h1==div(1) &
                   OR h2==1 OR h2==div(2) &
                   OR h3==1 OR h3==div(3)
      on_outer_edge = ((h1==1 OR h1==div(1)) AND (h2==1 OR h2==div(2))) & 
                   OR ((h1==1 OR h1==div(1)) AND (h3==1 OR h3==div(3))) & 
                   OR ((h2==1 OR h2==div(2)) AND (h3==1 OR h3==div(3))) 
      on_the_corner = on_outer_edge AND &
                      (h1<=2 OR h1>=(div(1)-1)) OR &
                      (h2<=2 OR h2>=(div(2)-1)) OR &
                      (h3<=2 OR h3>=(div(3)-1)) 
      if      (on_the_corner) then; fac = -ONE/SEVEN
      else if (on_outer_edge) then; fac = -ONE/THREE
      else if (on_outer_skin) then; fac = -ONE
      end
   end
 
!   edge_factor_for(h1,h2,h3,fac,u1,u2,u3)
!   ! Return the edge factor "fac" which tells whether the subbox with indices
!   ! "h1", "h2", "h3" is on a corner (then fac=-1/7) or an edge (then fac=-1/3)
!   ! or neither (then fac=-1). Also returns the cube inside the outer
!   ! skin which is related to subbox (h1,h2,h3). This is used to rescale the
!   ! dipoles on the surface, to neutralise the surface charge.
!      h1,h2,h3 :: INT, IN
!      fac :: REAL, OUT
!      u1,u2,u3 :: INT, OUT
!      on_outer_skin,on_outer_edge,on_the_corner :: BIN
!      div :: VEC{INT}(3)
!      div = .divisions
!      on_outer_skin = h1==1 OR h1==div(1) &
!                   OR h2==1 OR h2==div(2) &
!                   OR h3==1 OR h3==div(3)
!      on_outer_edge = ((h1==1 OR h1==div(1)) AND (h2==1 OR h2==div(2))) & 
!                   OR ((h1==1 OR h1==div(1)) AND (h3==1 OR h3==div(3))) & 
!                   OR ((h2==1 OR h2==div(2)) AND (h3==1 OR h3==div(3))) 
!      on_the_corner = on_outer_edge AND &
!                      (h1<=2 OR h1>=(div(1)-1)) OR &
!                      (h2<=2 OR h2>=(div(2)-1)) OR &
!                      (h3<=2 OR h3>=(div(3)-1)) 
!      if (on_the_corner) then
!         ! Get the subbox diagonally in from the CORNER
!         if (h1<=2) then; u1 = 2
!         else;            u1 = div(1) - 1
!         end
!         if (h2<=2) then; u2 = 2
!         else;            u2 = div(2) - 1
!         end
!         if (h3<=2) then; u3 = 2
!         else;            u3 = div(2) - 1
!         end
!         fac = -ONE/SEVEN
!      else if (on_outer_edge) then
!         ! Get the subbox diagonally in from the EDGE
!         if      (h1==1) then;      u1 = 2
!         else if (h1==div(1)) then; u1 = div(1) - 1
!         else;                      u1 = h1
!         end
!         if      (h2==1) then;      u2 = 2
!         else if (h2==div(2)) then; u2 = div(2) - 1
!         else;                      u2 = h2
!         end
!         if      (h3==1) then;      u3 = 2
!         else if (h3==div(3)) then; u3 = div(3) - 1
!         else;                      u3 = h3
!         end
!         fac = -ONE/THREE
!      else if (on_outer_skin) then
!         fac = -ONE
!      end
!   end

!  ******
!  Output
!  ******

   put
   ! Output information
      encl,short,del_r12,ratio :: REAL
      stdout.flush
      stdout.text("PERIODIC_FMM_LEVEL:")
      stdout.flush
      stdout.show("level_number               =",.level_number)
      stdout.show("scale_factor               =",.scale_factor)
      stdout.show("centre (cartesian)         =",.centre)
      stdout.show("divisions                  =",.divisions)
      stdout.show("crystallite_side_length    =",.crystallite_side_length)
      stdout.show("accuracy                   =",.accuracy)
      stdout.show("preferred potential method =",.preferred_potential_method)
      stdout.show("potential method           =",.potential_method)
      stdout.show("L_max                      =",.l_max)
      stdout.show("total unit cell_charge     =",.unit_cell_charge)
      stdout.show("subsubbox_radius           =",.subsubbox_radius)
      .put_charges_and_positions
      .put_subsubbox_multipoles
   end

   put_charges_and_positions
   ! Output charge nd position information
      i :: INT
      if (NOT .charges.created OR NOT .positions.created) return
      if (.level_number/=0) return
      stdout.flush
      stdout.text("Fragment charges and positions:")
      stdout.flush
      stdout.show("n_charges        =",.fragment_charges.dim)
      stdout.show("sum of (charges) =",sum(.fragment_charges))
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.put("#",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("Charge")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.flush
      do i = 1,.fragment_charges.dim
         stdout.put(i)
         stdout.put(.fragment_positions(1,i))
         stdout.put(.fragment_positions(2,i))
         stdout.put(.fragment_positions(3,i))
         stdout.put(.fragment_charges(i))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=4)
      stdout.flush
      stdout.text("Unit cell charges and positions:")
      stdout.flush
      stdout.show("n_charges        =",.charges.dim)
      stdout.show("sum of (charges) =",sum(.charges))
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.put("#",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("Charge")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.flush
      do i = 1,.charges.dim
         stdout.put(i)
         stdout.put(.positions(1,i))
         stdout.put(.positions(2,i))
         stdout.put(.positions(3,i))
         stdout.put(.charges(i))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=4)
   end

   put_box_multipoles
   ! Output box multipole information
      h1,h2,h3,n,l_max,l,m :: INT
      dist,ratio,val :: REAL
      if (NOT .multipoles_for_box.created) return
      stdout.flush
      stdout.text("Box multipoles:")
      do h1 = 1,.divisions(1)
      do h2 = 1,.divisions(2)
      do h3 = 1,.divisions(3)
         stdout.flush
         stdout.show("Box             =",[h1,h2,h3])
         stdout.show("Box centre      =",.centre_for_box(h1,h2,h3))
         stdout.flush
         if (.multipoles_for_box(h1,h2,h3).element.destroyed) then
         stdout.text("no multipoles for this box")
         else
         n = .multipoles_for_box(h1,h2,h3).element.dim
         l_max = nint(sqrt(float(n))) - 1
         stdout.show("n_multipoles    =",n)
         stdout.flush
         stdout.set_real_style("e")
         stdout.dash(int_fields=1,real_fields=1)
         stdout.put("L",int_width=TRUE)
         stdout.put("Max |q_LM|")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=1)
         stdout.flush
         m = 0
         do l = 0,l_max
            m = l*l + 1
            val = maxval(abs(.multipoles_for_box(h1,h2,h3).element(m:m+2*l)))
            stdout.put(l)
            stdout.put(val)
            stdout.flush
         end
         stdout.dash(int_fields=1,real_fields=1)
         stdout.set_real_style("f")
         ! stdout.put(.multipoles_for_box(h1,h2,h3).element,"column")
         end
      end
      end
      end
   end

   put_subsubbox_multipoles
   ! Output subbox multipole information
      h1,h2,h3,n,l_max,l,m :: INT
      dist,ratio,val :: REAL
      if (NOT .multipoles_for_1st_subsubbox.created) return
      stdout.flush
      stdout.text("First Subsubbox multipoles:")
      do h1 = 1,.divisions(1)
      do h2 = 1,.divisions(2)
      do h3 = 1,.divisions(3)
         stdout.flush
         stdout.show("Subsubbox             =",[h1,h2,h3])
         stdout.show("subsubbox centre      =",.centre_for_subsubbox(h1,h2,h3))
       ! if (.level_number>0) then
       ! dist  = .distance_to_uc_from_subsubbox(h1,h2,h3)
       ! ratio = .subsubbox_radius/dist
       ! stdout.show("distance to unit cell =",dist)
       ! stdout.show("Subsubbox radius      =",.subsubbox_radius)
       ! stdout.show("Subsubbox radius/dist =",ratio)
       ! end
         stdout.flush
         if (.multipoles_for_1st_subsubbox(h1,h2,h3).element.destroyed) then
         stdout.text("no multipoles for this subsubbox")
         else
         n = .multipoles_for_1st_subsubbox(h1,h2,h3).element.dim
         l_max = nint(sqrt(float(n))) - 1
         stdout.show("n_multipoles          =",n)
         stdout.show("l_max                 =",l_max)
         stdout.show("l_max required        =",.l_max)
         stdout.flush
         stdout.set_real_style("e")
         stdout.dash(int_fields=1,real_fields=1)
         stdout.put("L",int_width=TRUE)
         stdout.put("Max |q_LM|")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=1)
         stdout.flush
         m = 0
         do l = 0,l_max
            m = l*l + 1
            val = maxval(abs(.multipoles_for_1st_subsubbox(h1,h2,h3).element(m:m+2*l)))
            stdout.put(l)
            stdout.put(val)
            stdout.flush
         end
         stdout.dash(int_fields=1,real_fields=1)
         stdout.set_real_style("f")
         ! stdout.put(.multipoles_for_1st_subsubbox(h1,h2,h3).element,"column")
         end
      end
      end
      end
   end

   put_box_count(box_count)
   ! Output the box count
      box_count :: MAT3{INT}
      h1,h2,h3 :: INT
      stdout.flush
      stdout.text("# of points per box:")
      stdout.flush
      stdout.show("n_positions        =",.positions.dim2)
      stdout.show("sum of (box_count) =",sum(box_count))
      stdout.flush
      stdout.dash(int_fields=4)
      stdout.put("h1",int_width=TRUE)
      stdout.put("h2",int_width=TRUE)
      stdout.put("h3",int_width=TRUE)
      stdout.put(" #",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=4)
      stdout.flush
      do h3 = 1,.divisions(3)
      do h2 = 1,.divisions(2)
      do h1 = 1,.divisions(1)
         stdout.put(h1)
         stdout.put(h2)
         stdout.put(h3)
         stdout.put(box_count(h1,h2,h3))
         stdout.flush
      end
      end
      end
      stdout.dash(int_fields=4)
   end

end

