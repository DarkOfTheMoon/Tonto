!-------------------------------------------------------------------------------
!
! MOL: crystal routines for a molecule.
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_CRYSTAL

   use TYPES
   use SYSTEM
   use STR
   use FILE
   use ARCHIVE

   use VEC
   use BINVEC
   use MAT
   use IMAT
   use CVEC
   use CMAT
   use CMAT3
   use CMAT4
   use CMAT5
   use OPMAT

   use SHELL
   use SHELL2
   use ATOM
   use ATOMVEC
   use VECDIIS
   use POINTGROUP
   use CRYSTAL
   use MOL_COMMON

   implicit none         

#  include "macros"
#  include "mol_crystal.int"

contains

   make_ft(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [size(k_pts,1)]
      MAT, target :: dens
      MAT, IN :: k_pts
      CVEC :: res
      INT :: k_max,k,fa,fb,la,lb,q,a,b,atom_a,atom_b
      DBL :: fac
      SHELL2 :: shell
      CMAT3, PTR :: ft_ab
      MAT, PTR :: dens_ba
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      k_max = size(k_pts,1)
      res = ZERO
      do q = 1, .n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab.create(k_max,shell%a%n_comp,shell%b%n_comp)
         .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
         dens_ba => dens(fb:lb,fa:la)
         fac = TWO; if (a==b) fac=ONE
         do k = 1,k_max
            res(k) = res(k) + fac * ft_ab(k,:,:).trace_of_product(dens_ba)
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
   end

   make_ft(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [size(k_pts,1)].
      CMAT, target :: dens
      MAT :: k_pts
      CVEC :: res
      INT :: k_max,q,k,a,b,fa,la,fb,lb,atom_a,atom_b
      DBL :: fac
      SHELL2 :: shell
      CMAT3, PTR :: ft_ab
      CMAT, PTR :: dens_ba
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      k_max = size(k_pts,1)
      res = ZERO
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab.create(k_max,shell%a%n_comp,shell%b%n_comp)
         .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
         dens_ba => dens(fb:lb,fa:la)
         fac = TWO
         if (a==b) fac=ONE
         do k = 1,k_max
            res(k) = res(k) + fac * ft_ab(k,:,:).trace_of_product(dens_ba)
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
   end

  make_ft_deriv_U(res,dens,k_pts)
  ! Fourier transform of a density described by AO density matrix dens
  ! evaluated at a series of reciprocal space points k_pts
  ! Size of res is [k_max,n_atom*6]
    MAT, target :: dens
    MAT, IN :: k_pts
    CMAT :: res
    CDBL :: ft_ab2,tmp1,tmp2
    INT :: k_max,k,fa,fb,la,lb,q,a,b,atom_a,atom_b,n,base
    DBL :: fac,delta,g,separation
    SHELL2 :: shell
    CMAT3, PTR :: ft_ab
    MAT, PTR :: dens_ba
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    k_max = size(k_pts,1)
    res = ZERO
    do q = 1, .n_shell_pairs
      .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
      ft_ab.create(k_max,shell%a%n_comp,shell%b%n_comp)
      .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
      dens_ba => dens(fb:lb,fa:la)
      fac = TWO; if (a==b) fac=ONE
      ft_ab = ft_ab * fac

      separation = (.atom(atom_a)%pos-.atom(atom_b)%pos).norm
      g=HALF
      if (separation > 2.5d0) g=QUARTER
      g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

      do n = 1, .n_atom
        if (NOT (atom_a == n OR atom_b == n)) cycle
        delta = ZERO
        if (atom_a == n) delta = delta + ONE
        if (atom_b == n) delta = delta + ONE
        delta = delta * g

        base = (n-1) * 6
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba) * delta
          tmp1 = ft_ab2 * k_pts(k,1)
          tmp2 = ft_ab2 * k_pts(k,2)
          res(k,base+1) = res(k,base+1) + tmp1 * k_pts(k,1)
          res(k,base+2) = res(k,base+2) + tmp1 * k_pts(k,2)
          res(k,base+3) = res(k,base+3) + tmp1 * k_pts(k,3)
          res(k,base+4) = res(k,base+4) + tmp2 * k_pts(k,2)
          res(k,base+5) = res(k,base+5) + tmp2 * k_pts(k,3)
          res(k,base+6) = res(k,base+6) + ft_ab2 * k_pts(k,3) * k_pts(k,3)
        end
      end

      ft_ab.destroy
      shell.destroy_ptr_part
    end
  end

  make_ft_deriv_U(res,dens,k_pts)
  ! Fourier transform of a density described by AO density matrix dens
  ! evaluated at a series of reciprocal space points k_pts
  ! Size of res is [k_max,n_atom,6]
    CMAT, target :: dens
    MAT, IN :: k_pts
    CMAT :: res
    CDBL :: ft_ab2,tmp1,tmp2
    INT :: k_max,k,fa,fb,la,lb,q,a,b,atom_a,atom_b,n,base
    DBL :: fac,delta,g,separation
    SHELL2 :: shell
    CMAT3, PTR :: ft_ab
    CMAT, PTR :: dens_ba
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    k_max = size(k_pts,1)
    res = ZERO
    do q = 1, .n_shell_pairs
      .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
      ft_ab.create(k_max,shell%a%n_comp,shell%b%n_comp)
      .make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
      dens_ba => dens(fb:lb,fa:la)
      fac = TWO; if (a==b) fac=ONE
      ft_ab = ft_ab * fac

      separation = (.atom(atom_a)%pos-.atom(atom_b)%pos).norm
      g=HALF
      if (separation > 2.5d0) g=QUARTER
      g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

      do n = 1, .n_atom
        if (NOT (atom_a == n OR atom_b == n)) cycle
        delta = ZERO
        if (atom_a == n) delta = delta + ONE
        if (atom_b == n) delta = delta + ONE
        delta = delta * g

        base = (n-1) * 6
        do k = 1,k_max
          ft_ab2 = ft_ab(k,:,:).trace_of_product(dens_ba) * delta
          tmp1 = ft_ab2 * k_pts(k,1)
          tmp2 = ft_ab2 * k_pts(k,2)
          res(k,base+1) = res(k,base+1) + tmp1 * k_pts(k,1)
          res(k,base+2) = res(k,base+2) + tmp1 * k_pts(k,2)
          res(k,base+3) = res(k,base+3) + tmp1 * k_pts(k,3)
          res(k,base+4) = res(k,base+4) + tmp2 * k_pts(k,2)
          res(k,base+5) = res(k,base+5) + tmp2 * k_pts(k,3)
          res(k,base+6) = res(k,base+6) + ft_ab2 * k_pts(k,3) * k_pts(k,3)
        end
      end

      ft_ab.destroy
      shell.destroy_ptr_part
    end
  end

  make_ft_pair(ft_ab,k_pts,shell,atom_a,atom_b)
  ! Make_ft for one pair of gaussians.
  ! Includes partitioning, dispersion and thermal smearing.
    CMAT3 :: ft_ab
    MAT, IN :: k_pts
    SHELL2, IN :: shell
    INT, IN :: atom_a,atom_b
    MAT3, PTR :: thermal
    MAT, PTR :: partition
    DBL :: factor_a,factor_b
    INT :: k_max
    k_max = size(k_pts,1)
    partition.create(shell%a%n_cc,shell%b%n_cc)
    thermal.create(k_max,shell%a%n_cc,shell%b%n_cc)
    .thermal_smearing_correction(thermal,k_pts,atom_a,atom_b,shell)
    select case (.partition_model.trim)
      case ("")
        partition = ONE
      case ("mulliken")
        factor_a = ONE / .crystal.repetition_factor(atom_a)
        factor_b = ONE / .crystal.repetition_factor(atom_b)
        partition = HALF * ( factor_a + factor_b )
      case ("gaussian")
        factor_a = ONE / .crystal.repetition_factor(atom_a)
        factor_b = ONE / .crystal.repetition_factor(atom_b)
        shell.make_gaussian_partition(partition,factor_a,factor_b)
      case default
        DIE("Unknown partition method : " // .partition_model.trim)
    end
    shell.make_ft(ft_ab,k_pts,thermal,partition)
    thermal.destroy
    partition.destroy
  end

  thermal_smearing_correction(res,k_pts,a,b,shell)
  ! Makes the thermal smearing correction term.  Note that res
  ! is done over the contraction coefficients.
  ! Dimensions of "res" are [k_max,.a%n_cc,.b%n_cc].
    MAT3, OUT :: res
    MAT, IN :: k_pts
    INT, IN :: a,b
    SHELL2, IN :: shell
    MAT(3,3) :: Ua,Ub,Uab
    VEC(3) :: S,US
    INT :: k_max,k
    DBL :: separation,bondlength,Ta,Tb,fac,g

    k_max = size(k_pts,1)
    select case (.thermal_smearing_model)
      case (0)
        res = ONE
      case (1) ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
        Ua = -HALF * .atom(a)%thermal_tensor
        Ub = -HALF * .atom(b)%thermal_tensor
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Ua,S)
           Ta = dot_product(S,US)
           US = matmul(Ub,S)
           Tb = dot_product(S,US)
           fac = HALF*(exp(Ta)+exp(Tb))
           res(k,:,:) = fac
        end
      case (2) ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4
        bondlength=2.5
        Ua = .atom(a)%thermal_tensor
        Ub = .atom(b)%thermal_tensor
        Uab = Ua + Ub
        separation = (.atom(a)%pos-.atom(b)%pos).norm
        g=HALF
        if (separation > bondlength) g=QUARTER
        Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Uab,S)
           Ta = dot_product(S,US)
           res(k,:,:) = exp(Ta)
        end
      case (3) ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
        Ua = .atom(a)%thermal_tensor
        Ub = .atom(b)%thermal_tensor
        shell.make_tanaka_thermal_smearing(res,k_pts,Ua,Ub)
    end
  end

  ft_thermally_smear(ft_ab,k_pts,a,b)
  ! Thermally smear the fourier transform integrals "ft_ab" evaluated 
  ! on "k_pts" for shell pair (ab) centered on atoms "a" and "b" .
  ! .thermal_smearing_model = 0 means no smearing
  ! .thermal_smearing_model = 1 means use Stewarts model
  ! .thermal_smearing_model = 2 means use Coppens model
  ! .thermal_smearing_model = 3 means use Tanaka model
    INT :: a,b
    MAT :: k_pts 
    CMAT3 :: ft_ab
    MAT(3,3) :: Ua,Ub,Uab
    VEC(3) :: S,US
    DBL :: separation,bondlength,Ta,Tb,fac,g
    INT :: k,k_max
    k_max = size(k_pts,1)
    select case (.thermal_smearing_model)
      case (1) ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
        Ua = -HALF * .atom(a)%thermal_tensor
        Ub = -HALF * .atom(b)%thermal_tensor
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Ua,S)
           Ta = dot_product(S,US)
           US = matmul(Ub,S)
           Tb = dot_product(S,US)
           fac = HALF*(exp(Ta)+exp(Tb))
           ft_ab(k,:,:) = fac*ft_ab(k,:,:)
        end
      case (2) ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4
        bondlength=2.5
        Ua = .atom(a)%thermal_tensor
        Ub = .atom(b)%thermal_tensor
        Uab = Ua + Ub
        separation = (.atom(a)%pos-.atom(b)%pos).norm
        g=HALF
        if (separation > bondlength) g=QUARTER
        Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
        do k = 1,k_max
           S = k_pts(k,:)
           US = matmul(Uab,S)
           Ta = dot_product(S,US)
           ft_ab(k,:,:) = exp(Ta)*ft_ab(k,:,:)
        end
      case (3)
        DIE("cannot thermally smear at contracted level.")
      case default
        DIE("unknown thermal smearing model.")
    end
  end

  add_dispersion_correction(ft,k_pts)
  ! Adds the dispersion correction.
    MAT :: k_pts
    CVEC :: ft
    CDBL :: disp,phase
    VEC(3) :: pos
    MAT(3,3) :: U
    VEC(3) :: S,US
    DBL :: x,y,z,T
    INT :: n,k,k_max

   if (.crystal.correct_dispersion) then
      if (.thermal_smearing_model == 0) then
        do n=1,.n_atom
          pos = .atom(n).pos
          x = pos(1); y = pos(2); z = pos(3)
          disp = .atom(n).dispersion_correction(.crystal.wavelength)
          ft(:) = ft(:) + disp * exp(cmplx(ZERO,(k_pts(:,1)*x + k_pts(:,2)*y + k_pts(:,3)*z)))
        end
      else
        k_max = size(k_pts,1)
        do n=1,.n_atom
          U = -HALF * self%atom(n)%thermal_tensor
          pos = .atom(n).pos
          x = pos(1); y = pos(2); z = pos(3)
          disp = .atom(n).dispersion_correction(.crystal.wavelength)
          do k = 1,k_max
            S = k_pts(k,:)
            US = matmul(U,S)
            T = (dot_product(S,US))
            phase = exp(cmplx(T,(k_pts(k,1)*x + k_pts(k,2)*y + k_pts(k,3)*z)))
            ft(k) = ft(k) + disp * phase
          end
        end
      end
    end
  end

  get_ft_ints
  ! Get the fourier transform of the overlap integrals.
  ! If the archive file exists, read it; otherwise make it.
     ARCHIVE :: archive
     archive.set(.name,"ft_ints")
     if (archive.doesnt_exist) .make_ft_ints
  end

   make_ft_ints
   ! Make the fourier transform of the overlap integrals on an archive file
      ARCHIVE :: archive
      MAT, PTR :: k_pts
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
      SHELL2, PTR :: shell
      CMAT3, PTR :: ft_ab_eq,ft_ab

      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"ft_ints")
      archive.open(for="write-only",buffered=TRUE,type="cdbl")
      k_pts.create( .crystal.unique_k_pts_size )
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell%a%n_comp,shell%b%n_comp)
         ft_ab.create( .crystal%n_refl,shell%a%n_comp,shell%b%n_comp)
         .make_ft_pair(ft_ab_eq,k_pts,shell,atom_a,atom_b)
         .crystal.sum_ft_ints(ft_ab,ft_ab_eq)
         archive%file.put(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

  convert_cadpac_ft_ints
      ARCHIVE :: archive
      INT :: q,a,b,fa,la,fb,lb
      INT :: n,i,j,bs,bf,n_pass,n_batch
      SHELL2, PTR :: shell
      MAT3, PTR :: ft_ab
      CMAT3, PTR :: ft_ab_c

      ft_ab.create( .crystal%n_refl, .n_bf, .n_bf)
      n_pass = 1
      n_batch = 5

      open(98,form='formatted',status='unknown',file='FTINTS.txt')
      do b = 1,n_pass
         bs = (b-1)*n_batch+1
         bf = bs+n_batch-1
         bf = min( .crystal%n_refl,bf)
         do n = bs,bf
            do i = 1, .n_bf
            do j = 1,i
               read(98,'(D16.8)') ft_ab(n,i,j)
            end
            end
         end
      end
      close(98)

      archive.set(.name,"ft_ints.cadpac")
      archive.open(for="write-only",type="dbl")
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_ab_c.create(.crystal%n_refl,la-fa+1,lb-fb+1)
         ft_ab_c = ft_ab(:,fa:la,fb:lb)
         archive%file.put(ft_ab_c)
         ft_ab_c.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close

      ft_ab.destroy
  end

  convert_to_cadpac_ft_ints
      ARCHIVE :: archive
      INT :: q,a,b,fa,la,fb,lb
      INT :: n,i,j,bs,bf,n_pass,n_batch,l_tri,ij,ijij,k_max
      SHELL2, PTR :: shell
      MAT3, PTR :: ft_ab
      CMAT3, PTR :: ft_ab_c
      VEC, PTR :: ft_ints

      n_pass = 1
      n_batch = 58
      l_tri = .n_bf * ( .n_bf + 1) /2

      ft_ab.create( .crystal%n_refl, .n_bf, .n_bf)

      archive.set(.name,"ft_ints")
      archive.open(for="read-only",type="dbl")
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_ab_c.create(.crystal%n_refl,la-fa+1,lb-fb+1)
         archive%file.get(ft_ab_c)
         ft_ab(:,fa:la,fb:lb) = ft_ab_c
         ft_ab_c.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close

      ft_ints.create(n_batch*l_tri)
      open(99,form='unformatted',status='unknown',file='FTINTS')
      do b = 1,n_pass
        bs = (b-1)*n_batch+1
        bf = bs+n_batch-1
        bf = min( .crystal%n_refl, bf)
        k_max = (bf-bs+1)

        ijij = 0
        do n = bs,bf
           ij = 0
           do i = 1, .n_bf
           do j = 1,i
              ij = ij + 1
              ijij = ijij + 1
              ft_ints(ijij) = ft_ab(n,i,j)
           enddo
           enddo
        enddo

        write(99) (ft_ints(i),i=1,l_tri*k_max)
      enddo
      close(99)
      ft_ints.destroy

      open(98,form='formatted',status='unknown',file='FTINTS.txt_tonto')
      do b = 1,n_pass
         bs = (b-1)*n_batch+1
         bf = bs+n_batch-1
         bf = min( .crystal%n_refl,bf)
         do n = bs,bf
            do i = 1, .n_bf
            do j = 1,i
               write(98,'(D16.8)') ft_ab(n,i,j)
            end
            end
         end
      end
      close(98)

      ft_ab.destroy
  end

  fit_thermal_parameters [leaky]
  ! Make the structure factors for this molecule.
    VEC, PTR :: deriv,deriv_old,U,U_old,direction,temp_U,deriv_temp,lambda
    MAT, PTR :: hessian
    DBL :: chi2,old_chi2,start_lambda
    VECDIIS :: diis
    BINVEC, PTR :: ok
    INT :: i,j,dim,total,old_n,n,base
    ENSURE( .crystal.created, "no crystal")
    ENSURE( .atom.created, "no atoms to fit")

    dim = .n_atom * 6
    direction.create(dim)
    deriv_old.create(dim)
    deriv.create(dim)
    U_old.create(dim)
    U.create(dim)
    hessian.create(dim,dim)
    hessian.to_unit_mat
    ok.create(dim)
    deriv_temp.create(dim)
    temp_U.create(dim)
    lambda.create(dim)

    if (.crystal.no_F_calc) .make_structure_factors

    .crystal.update_scaled_gof_parameters;      chi2 = .crystal%chi2
    .make_d_chi2_d_U(deriv)

    ! Make the next value using dx = - f(x) / f'(x).  We go the wrong direction
    ! so we know for sure that f(x) < f(x+dx)
    do n=1, .n_atom
      base = (n-1) * 6
      U(base+1) = .atom(n)%thermal_tensor(1,1)
      U(base+2) = .atom(n)%thermal_tensor(1,2)
      U(base+3) = .atom(n)%thermal_tensor(1,3)
      U(base+4) = .atom(n)%thermal_tensor(2,2)
      U(base+5) = .atom(n)%thermal_tensor(2,3)
      U(base+6) = .atom(n)%thermal_tensor(3,3)
    end
    do n = 1, dim
      if (abs(deriv(n)) > 0.000000001d0) then ! so we don't divide by zero
         U_old(n) = U(n) + 0.001d0 * chi2 / deriv(n)
      else
         U_old(n) = U(n)
      end
    end
    do n=1, .n_atom
      base = (n-1) * 6
      .atom(n)%thermal_tensor(1,1) = U_old(base+1)
      .atom(n)%thermal_tensor(1,2) = U_old(base+2)
      .atom(n)%thermal_tensor(1,3) = U_old(base+3)
      .atom(n)%thermal_tensor(2,1) = U_old(base+2)
      .atom(n)%thermal_tensor(2,2) = U_old(base+4)
      .atom(n)%thermal_tensor(2,3) = U_old(base+5)
      .atom(n)%thermal_tensor(3,1) = U_old(base+3)
      .atom(n)%thermal_tensor(3,2) = U_old(base+5)
      .atom(n)%thermal_tensor(3,3) = U_old(base+6)
    end
    .make_structure_factors
    .crystal.update_scaled_gof_parameters;      chi2 = .crystal%chi2
    .make_d_chi2_d_U(deriv_old)

    do n=1, .n_atom                                   ! Put back original U.
      base = (n-1) * 6
      .atom(n)%thermal_tensor(1,1) = U(base+1)
      .atom(n)%thermal_tensor(1,2) = U(base+2)
      .atom(n)%thermal_tensor(1,3) = U(base+3)
      .atom(n)%thermal_tensor(2,1) = U(base+2)
      .atom(n)%thermal_tensor(2,2) = U(base+4)
      .atom(n)%thermal_tensor(2,3) = U(base+5)
      .atom(n)%thermal_tensor(3,1) = U(base+3)
      .atom(n)%thermal_tensor(3,2) = U(base+5)
      .atom(n)%thermal_tensor(3,3) = U(base+6)
    end

    .make_structure_factors
    .crystal.update_scaled_gof_parameters;      chi2 = .crystal%chi2
    .make_d_chi2_d_U(deriv)

    start_lambda = 0.1d0
    total = 0
    old_n = 0
    diis.set_default
    diis.set(keep=10,start=1)
    diis.set_archive_root_name(.name)
    diis.set_archive_name("thermal_parameters,DIIS")

    do i=1,100! loop until converged to minimum.
      do n=1, .n_atom                        ! get thermal parameters into array
        base = (n-1) * 6
        U(base+1) = .atom(n)%thermal_tensor(1,1)
        U(base+2) = .atom(n)%thermal_tensor(1,2)
        U(base+3) = .atom(n)%thermal_tensor(1,3)
        U(base+4) = .atom(n)%thermal_tensor(2,2)
        U(base+5) = .atom(n)%thermal_tensor(2,3)
        U(base+6) = .atom(n)%thermal_tensor(3,3)
      end
      direction = - deriv                                  ! dU = - dchi2/dU.
      direction = sign(min(abs(direction),HALF),direction) ! limit size of dU.

      temp_U = U
      deriv_temp = deriv
      ok = FALSE
      if (old_n >1) start_lambda = start_lambda / 10
      lambda = start_lambda
      old_chi2 = chi2

      j=0
      do
        j=j+1
        do n=1,dim                      ! decrease the step size where necessary
          if (NOT ok(n)) then
            lambda(n) = lambda(n) / TEN
            U(n) = temp_U(n) + lambda(n) * direction(n)
          end
        end
        do n=1, .n_atom               ! replace thermal parameters with new ones
          base = (n-1) * 6
          .atom(n)%thermal_tensor(1,1) = U(base+1)
          .atom(n)%thermal_tensor(1,2) = U(base+2)
          .atom(n)%thermal_tensor(1,3) = U(base+3)
          .atom(n)%thermal_tensor(2,1) = .atom(n)%thermal_tensor(1,2)
          .atom(n)%thermal_tensor(2,2) = U(base+4)
          .atom(n)%thermal_tensor(2,3) = U(base+5)
          .atom(n)%thermal_tensor(3,1) = .atom(n)%thermal_tensor(1,3)
          .atom(n)%thermal_tensor(3,2) = .atom(n)%thermal_tensor(2,3)
          .atom(n)%thermal_tensor(3,3) = U(base+6)
        end
        .make_structure_factors
        .crystal.update_scaled_gof_parameters;      chi2 = .crystal%chi2
        .make_d_chi2_d_U(deriv)
        ok = abs(deriv) < abs(deriv_temp)
        if (chi2 < old_chi2) exit
        if (2*count(ok)>dim) exit
        if (j>10) exit
      end
      total = total + j
      old_n = j

      diis.extrapolate(U,deriv)      ! get better thermals using DIIS.
      do n=1, .n_atom                ! replace thermal parameters with new ones
        base = (n-1) * 6
        .atom(n)%thermal_tensor(1,1) = U(base+1)
        .atom(n)%thermal_tensor(1,2) = U(base+2)
        .atom(n)%thermal_tensor(1,3) = U(base+3)
        .atom(n)%thermal_tensor(2,1) = .atom(n)%thermal_tensor(1,2)
        .atom(n)%thermal_tensor(2,2) = U(base+4)
        .atom(n)%thermal_tensor(2,3) = U(base+5)
        .atom(n)%thermal_tensor(3,1) = .atom(n)%thermal_tensor(1,3)
        .atom(n)%thermal_tensor(3,2) = .atom(n)%thermal_tensor(2,3)
        .atom(n)%thermal_tensor(3,3) = U(base+6)
      end
      .make_structure_factors
      .crystal.update_scaled_gof_parameters;      chi2 = .crystal%chi2
      .make_d_chi2_d_U(deriv)

write(*,'(2i7,2f15.8)') i,total, deriv.norm / sqrt(real(dim,kind=DBL_KIND)), chi2
      if (deriv.norm / sqrt(real(dim,kind=DBL_KIND)) < 0.01) exit ! if near the minimum
      if (chi2 > old_chi2) exit              ! we're having convergence problems

    end
write(*,*) "finished"

    diis.delete_archives
    lambda.destroy
    temp_U.destroy
    ok.destroy
    deriv_temp.destroy
    hessian.destroy
    U.destroy
    U_old.destroy
    deriv.destroy
    deriv_old.destroy
    direction.destroy
  end

  make_d_chi2_d_U(res)
  ! Evaluate the gradient of the chi2 with respect to the thermal parameters.
  ! Size of res is [n_atom * 6]
    CMAT, PTR :: sf_deriv,sf_deriv_eq
    MAT, PTR :: k_pts
    VEC, PTR :: F_c
    BIN :: complex
    VEC :: res
    DBL :: temp
    INT :: n,j,k,base

    k_pts.create( .crystal.unique_k_pts_size )
    .crystal.make_unique_k_pts(k_pts)

    sf_deriv.create( .crystal%n_refl, .n_atom * 6) ! d_Fc/d_U
    sf_deriv_eq.create(size(k_pts,1), .n_atom * 6)

    complex = .density_matrix.spinorbital_kind.includes("complex")
    if (complex) then
      .make_ft_deriv_U(sf_deriv_eq,.density_matrix%restricted_complex,k_pts) 
    else 
      .make_ft_deriv_U(sf_deriv_eq,.density_matrix%restricted,k_pts) 
    end
    .crystal.sum_unique_sf_deriv_U(sf_deriv,sf_deriv_eq)
    sf_deriv_eq.destroy

    F_c.create( .crystal%n_refl )
    F_c = .crystal.scaled_Fc

    ! Sum over the structure factors
    res = ZERO
    do k = 1, .crystal%n_refl
      temp = ( sign(.crystal%F_exp(k),F_c(k)) - F_c(k)) &
             / ( .crystal%sigma(k) * .crystal%sigma(k) )
      res = res + real(sf_deriv(k,:)) * temp
    end

    F_c.destroy
    sf_deriv.destroy
    k_pts.destroy

    res = res * (-2.0d0 / max(.crystal%n_refl-1,1))
  end

   make_structure_factors [leaky]
   ! Make the structure factors for this molecule.
      CVEC, PTR :: sf,sf_eq
      MAT, PTR :: k_pts
      ARCHIVE :: archive
      BIN :: complex
      ENSURE( .crystal.created, "no crystal")
      ENSURE( .density_matrix.created, "no density matrix")
      .crystal%F_calc.destroy
      .crystal%F_calc.create( .crystal%n_refl)
      k_pts.create( .crystal.unique_k_pts_size )
      .crystal.make_unique_k_pts(k_pts)
      sf_eq.create(size(k_pts,1))
      .make_ao_density_matrix
      complex = .density_matrix.spinorbital_kind.includes("complex")
      if (complex) then
        .make_ft(sf_eq,.density_matrix.restricted_complex,k_pts) 
      else 
        .make_ft(sf_eq,.density_matrix.restricted,k_pts) 
      end
!  .add_dispersion_correction(sf_eq,k_pts)
      sf.create( .crystal%n_refl)
      .crystal.sum_unique_sf(sf,sf_eq)
      if (.crystal%spacegroup%centrosymmetric) then; .crystal%F_calc = sf
      else;                                       .crystal%F_calc = sqrt(sf*conjg(sf))
      end
      sf.destroy
      sf_eq.destroy
      k_pts.destroy
      archive.set(.name,"structure_factors")
      archive.write( .crystal%F_calc) 
   end

  get_structure_factors [leaky]
  ! Get the structure factors on disk or remake if they don't already exist
    ARCHIVE :: archive
    archive.set(.name,"structure_factors")
    if (archive.exists) then
      ENSURE( .crystal.created, "no crystal")
      .crystal%F_calc.destroy
      .crystal%F_calc.create( .crystal%n_refl)
      archive.read( .crystal%F_calc) 
    else
      .make_structure_factors
    end
  end

   make_sz_structure_factors [leaky]
   ! Make the structure factors for this molecule.
      CVEC, PTR :: sf,sf_eq
      MAT, PTR :: k_pts
      ARCHIVE :: archive
      BIN :: complex
      ENSURE( .crystal.created, "no crystal")
      .crystal%F_calc.destroy
      .crystal%F_calc.create( .crystal%n_refl)
      k_pts.create( .crystal.unique_k_pts_size )
      .crystal.make_unique_k_pts(k_pts)
      sf_eq.create(size(k_pts,1))
      .make_ao_sz_density_matrix
      complex = .density_matrix.spinorbital_kind.includes("complex")
      if (complex) then
        .make_ft(sf_eq,.density_matrix%restricted_complex,k_pts) 
      else 
        .make_ft(sf_eq,.density_matrix%restricted,k_pts) 
      end
      sf.create( .crystal%n_refl)
      .crystal.sum_unique_sf(sf,sf_eq)
      .crystal%F_calc = sqrt(sf*conjg(sf))
      sf.destroy
      sf_eq.destroy
      k_pts.destroy
      archive.set(.name,"sz_structure_factors")
      archive.write( .crystal%F_calc) 
   end

   make_PND_scalar_magnetic_sf [leaky]
   ! Make the PND scalar magnetic structure factors and assign them
   ! To the crystal objects structure factors for analysis
      CVEC, PTR :: FM_s, FM_l, FM_r
      ARCHIVE :: archive
      .make_PND_spin_sf
      FM_s.create( .crystal%n_refl)
      archive.set(.name,"PND_spin_sf")
      archive.read(FM_s)
      .make_PND_nabla_sf
      FM_l.create( .crystal%n_refl)
      archive.set(.name,"PND_nabla_sf")
      archive.read(FM_l)
      .make_PND_r_sf
      FM_r.create( .crystal%n_refl)
      archive.set(.name,"PND_r_sf")
      archive.read(FM_r)
      .crystal%F_calc.destroy
      .crystal%F_calc.create( .crystal%n_refl)
      .crystal%F_calc = FM_r + FM_s + FM_l 
      .crystal%n_param = 0
      archive.set(.name,"PND_scalar_magnetic_sf")
      archive.write( .crystal%F_calc)
      FM_r.destroy
      FM_l.destroy
      FM_s.destroy
   end

   make_PND_spin_sf [leaky]
   ! Make the scalar spin magnetic structure factors assuming an applied field
   ! in the z direction
      ARCHIVE :: archive
      DBL :: fac,ans
      CMAT, PTR :: d_aa,d_bb,d_ba
      CMAT5, PTR :: ft_ab
      CVEC, PTR :: FM
      CDBL :: ci
      SHELL2, PTR :: shell
      INT :: k_max,i,q,a,b,fa,la,fb,lb
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_spin_ints")
      if (archive.doesnt_exist) .make_PND_ft_spin_ints
      archive.open(for="read-only",type="dbl")
      ci = (ZERO,ONE)
      k_max = .crystal%n_refl
      FM.create(k_max)
      FM = ZERO
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_ab.create(k_max,shell%a%n_comp,shell%b%n_comp,3,3)
         archive%file.read(ft_ab)
         d_aa => .density_matrix%general_complex(      fb:      lb,      fa:      la)
         d_bb => .density_matrix%general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         d_ba => .density_matrix%general_complex(.n_bf+fb:.n_bf+lb,      fa:      la)
         fac = TWO 
         if (a==b) fac=ONE
         do i = 1,k_max
            ans =          ft_ab(i,:,:,3,1).trace_of_product(d_ba) ! real part ?
            ans = ans - ci*ft_ab(i,:,:,3,2).trace_of_product(d_ba)
            ans = ans -    ft_ab(i,:,:,1,1).trace_of_product(d_aa)
            ans = ans +    ft_ab(i,:,:,1,1).trace_of_product(d_bb)
            ans = ans -    ft_ab(i,:,:,2,2).trace_of_product(d_aa)
            ans = ans +    ft_ab(i,:,:,2,2).trace_of_product(d_bb)
            FM(i) = FM(i) + fac*ans
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close
      archive.set(.name,"PND_spin_sf")
      archive.write(FM)
      FM.destroy
   end

   make_PND_nabla_sf [leaky]
   ! Make the scalar nabla magnetic structure factors assuming an applied field
   ! in the z direction
      ARCHIVE :: archive
      DBL :: fac
      CMAT, PTR :: dens
      CMAT4, PTR :: ft_ab
      CVEC, PTR :: FM
      SHELL2, PTR :: shell
      INT :: k_max,i,q,a,b,fa,la,fb,lb
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_nabla_ints")
      if (archive.doesnt_exist) .make_PND_ft_nabla_ints
      archive.open(for="read-only",type="dbl")
      k_max = .crystal%n_refl
      FM.create(k_max)
      FM = ZERO
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_ab.create(k_max,shell%a%n_comp,shell%b%n_comp,3)
         archive%file.read(ft_ab)
         dens.create(shell%b%n_comp,shell%a%n_comp)
         dens =        .density_matrix%general_complex(      fb:      lb,      fa:      la)
         dens = dens + .density_matrix%general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         fac = TWO 
         if (a==b) fac=ONE
         do i = 1,k_max
            FM(i) = FM(i) + fac*ft_ab(i,:,:,3).trace_of_product(dens)
         end
         dens.destroy
         ft_ab.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close
      archive.set(.name,"PND_nabla_sf")
      archive.write(FM)
      FM.destroy
   end

   make_PND_r_sf [leaky]
   ! Make the scalar dipole magnetic structure factors assuming an applied field
   ! in the z direction
      ARCHIVE :: archive
      DBL :: fac,ans
      CMAT, PTR :: d_aa,d_bb
      CMAT4, PTR :: ft_ab
      CVEC, PTR :: FM
      SHELL2, PTR :: shell
      INT :: k_max,i,q,a,b,fa,la,fb,lb
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_r_ints")
      if (archive.doesnt_exist) .make_PND_ft_r_ints
      archive.open(for="read-only",type="dbl")
      k_max = .crystal%n_refl
      FM.create(k_max)
      FM = ZERO
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_ab.create(k_max,shell%a%n_comp,shell%b%n_comp,3)
         archive%file.read(ft_ab)
         d_aa => .density_matrix%general_complex(      fb:      lb,      fa:      la)
         d_bb => .density_matrix%general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         fac = TWO
         if (a==b) fac=ONE
         do i = 1,k_max
            ans =       fac*ft_ab(i,:,:,3).trace_of_product(d_aa)
            ans = ans + fac*ft_ab(i,:,:,3).trace_of_product(d_bb)
            FM(i) = FM(i) + ans 
         end
         ft_ab.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      archive.close
      archive.set(.name,"PND_r_sf")
      archive.write(FM)
      FM.destroy
   end

   get_PND_ft_spin_ints
   ! Get the PND ft spin integrals on disk if they don't already exist
      ARCHIVE :: archive
      archive.set(.name,"PND_ft_spin_ints")
      if (archive.doesnt_exist) .make_PND_ft_spin_ints
   end

   make_PND_ft_spin_ints
   ! Make the fourier transform of the PND spin integrals on the archive
      ARCHIVE :: archive
      MAT, PTR :: k_pts
      SHELL2, PTR :: shell
      CMAT3, PTR :: ft_ab_eq
      CMAT5, PTR :: ft_ab
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_spin_ints")
      archive.open(for="write-only",type="dbl")
      k_pts.create( .crystal.unique_k_pts_size )
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell%a%n_comp,shell%b%n_comp)
         .make_ft_pair(ft_ab_eq,k_pts,shell,atom_a,atom_b)
         ft_ab.create( .crystal%n_refl,shell%a%n_comp,shell%b%n_comp,3,3)
         .crystal.sum_ft_spin_ints(ft_ab,ft_ab_eq) 
         archive%file.put(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

   get_PND_ft_nabla_ints
   ! Get the PND ft nabla integrals on disk if they don't already exist
      ARCHIVE :: archive
      archive.set(.name,"PND_ft_nabla_ints")
      if (archive.doesnt_exist) .make_PND_ft_nabla_ints
   end

   make_PND_ft_nabla_ints
   ! Make the fourier transform of the nabla integrals on the archive
      ARCHIVE :: archive
      MAT, PTR :: k_pts
      SHELL2, PTR :: shell
      CMAT4, PTR :: ft_ab_eq, ft_ab
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_nabla_ints")
      archive.open(for="write-only",type="dbl")
      k_pts.create( .crystal.unique_k_pts_size )
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell%a%n_comp,shell%b%n_comp,3)
         shell.make_ft_nabla(ft_ab_eq,k_pts)
         .ft_thermally_smear(ft_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
         ft_ab.create( .crystal%n_refl,shell%a%n_comp,shell%b%n_comp,3 )
         .crystal.sum_ft_nabla_ints(ft_ab,ft_ab_eq)
         archive%file.put(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

   get_PND_ft_r_ints
   ! Get the PND ft r integrals on disk if they don't already exist
      ARCHIVE :: archive
      archive.set(.name,"PND_ft_r_ints")
      if (archive.doesnt_exist) .make_PND_ft_r_ints
   end

   make_PND_ft_r_ints
   ! Make the fourier transform of the dipole "r" integrals on the archive
      ARCHIVE :: archive
      MAT, PTR :: k_pts
      SHELL2, PTR :: shell
      CMAT4, PTR :: ft_ab_eq, ft_ab
      INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
      ENSURE( .crystal.created, "no crystal")
      archive.set(.name,"PND_ft_r_ints")
      archive.open(for="write-only",type="dbl")
      k_pts.create( .crystal.unique_k_pts_size )
      .crystal.make_unique_k_pts(k_pts)
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),shell%a%n_comp,shell%b%n_comp,3)
         shell.make_ft_r(ft_ab_eq,k_pts)
         .ft_thermally_smear(ft_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
         ft_ab.create( .crystal%n_refl,shell%a%n_comp,shell%b%n_comp,3)
         .crystal.sum_ft_r_ints(ft_ab,ft_ab_eq,.B_field) 
         archive%file.put(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      k_pts.destroy
      archive.close
   end

   make_PND_fit_ints(ints,lambda)
   ! Make the PND constraint integrals on the archive
      CMAT, target :: ints
      DBL :: lambda
      ARCHIVE :: spin_archive,nabla_archive,r_archive
      VEC, PTR :: F_calc,F_exp,sigma
      CMAT, PTR :: ints_aa,ints_bb,ints_ba
      CMAT4, PTR :: nabla,r
      CMAT5, PTR :: spin
      SHELL2, PTR :: shell
      CDBL :: ci
      DBL :: fac
      INT :: i,q,a,b,fa,la,fb,lb
      INT :: n_bf,n_refl
      .get_PND_ft_spin_ints
      .get_PND_ft_nabla_ints
      .get_PND_ft_r_ints
      spin_archive.set(.name,"PND_ft_spin_ints")
      nabla_archive.set(.name,"PND_ft_nabla_ints")
      r_archive.set(.name,"PND_ft_r_ints")
      spin_archive.open(for="read-only",type="dbl")
      nabla_archive.open(for="read-only",type="dbl")
      r_archive.open(for="read-only",type="dbl")
      ci = (ZERO,ONE)
      n_bf   =  .n_bf
      n_refl =  .crystal%n_refl
      F_calc => .crystal%F_calc
      F_exp  => .crystal%F_exp
      sigma  => .crystal%sigma
      ints = ZERO
      shell.create
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         spin.create(n_refl,shell%a%n_comp,shell%b%n_comp,3,3)
         spin_archive%file.read(spin)
         ints_aa => ints(     fa:     la,     fb:     lb)
         ints_bb => ints(n_bf+fa:n_bf+la,n_bf+fb:n_bf+lb)
         ints_ba => ints(n_bf+fa:n_bf+la,     fb:     lb)
         do i = 1,n_refl
            fac = TWO*lambda*(F_calc(i) - F_exp(i))/(sigma(i)*sigma(i)*n_refl) 
            ints_ba = ints_ba +    fac*spin(i,:,:,3,1)
            ints_ba = ints_ba - ci*fac*spin(i,:,:,3,2)
            ints_aa = ints_aa -    fac*spin(i,:,:,1,1)
            ints_bb = ints_bb +    fac*spin(i,:,:,1,1)
            ints_aa = ints_aa -    fac*spin(i,:,:,2,2)
            ints_bb = ints_bb +    fac*spin(i,:,:,2,2)
         end
         spin.destroy
         nabla.create(n_refl,shell%a%n_comp,shell%b%n_comp,3)
         nabla_archive%file.read(nabla)
         do i = 1,n_refl
            fac = TWO*lambda*(F_calc(i) - F_exp(i))/(sigma(i)*sigma(i)*n_refl) 
            ints_aa = ints_aa + fac*nabla(i,:,:,3)
            ints_bb = ints_bb + fac*nabla(i,:,:,3)
         end
         nabla.destroy
         r.create(n_refl,shell%a%n_comp,shell%b%n_comp,3)
         r_archive%file.read(r)
         do i = 1,n_refl
            fac = TWO*lambda*(F_calc(i) - F_exp(i))/(sigma(i)*sigma(i)*n_refl) 
            ints_aa = ints_aa + fac*r(i,:,:,3)
            ints_bb = ints_bb + fac*r(i,:,:,3)
         end
         r.destroy
         shell.destroy_ptr_part
      end
      shell.destroy
      ints.hermitian_reflect
      r_archive.close
      nabla_archive.close
      spin_archive.close
   end

!  ****************
!  Symmetry methods
!  ****************

   symmetrise(mat,kind)
   ! Symmetrise an opmat matrix "mat" of spinorbital_kind "kind" (if specified)
      OPMAT :: mat
      STR, optional :: kind
      STR :: itemkind
      itemkind = mat.spinorbital_kind
      if (present(kind)) itemkind = kind
      select case (itemkind)
         case ("restricted");           .symmetrise_r( mat%restricted)
         case ("unrestricted");         .symmetrise_r( mat%alpha)
                                        .symmetrise_r( mat%beta)
         case ("general");              .symmetrise_r( mat%general.alpha_alpha)
                                        .symmetrise_r( mat%general.beta_beta)
                                        .symmetrise_r( mat%general.alpha_beta)
                                        .symmetrise_r( mat%general.beta_alpha)
         case ("restricted_complex");   .symmetrise_c( mat%restricted_complex)
         case ("unrestricted_complex"); .symmetrise_c( mat%alpha_complex)
                                        .symmetrise_c( mat%beta_complex)
         case ("general_complex");      .symmetrise_c( mat%general_complex.alpha_alpha)
                                        .symmetrise_c( mat%general_complex.beta_beta)
                                        .symmetrise_c( mat%general_complex.alpha_beta)
                                        .symmetrise_c( mat%general_complex.beta_alpha)
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   symmetrise_r(mat)
   ! Symmetrise a real restricted basis kind matrix
      MAT :: mat
      MAT, PTR :: sym,w
      MAT,  PTR :: tra,trb
      SHELL, PTR :: sh
      INT :: n_bf,dim1,dim2,n,a,b,i,j,na,nb
      INT :: fa,fb,fi,fj,la,lb,li,lj
      IVEC, PTR :: first,last
      IMAT, PTR :: image
      DBL :: diff
      dim1 = size(mat,1)
      dim2 = size(mat,2)
      n_bf = .n_bf
      ENSURE( .atom.created,"no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( dim1==dim2,"non-square matrix")
      ENSURE( dim1==n_bf,"incorrectly dimensioned matrix")
      first => .first_basis_fn_for_shell
      last  => .last_basis_fn_for_shell
      image.create( .n_shell, .pointgroup%order)
      .make_image_of_shell(image)
      sym.create(n_bf,n_bf)
      sym = ZERO
      sh.create
      do n = 1,.pointgroup%order
         do a = 1,.n_shell
            .get_shell(a,sh); na = sh%n_comp; la = sh%l; sh.destroy_ptr_part
            tra => .pointgroup.xyz_matrix(n,la)
            i = image(a,n)
            fa = first(a);  la = last(a); fi = first(i);  li = last(i)
            do b = 1,.n_shell
               .get_shell(b,sh); nb = sh%n_comp; lb = sh%l; sh.destroy_ptr_part
               trb => .pointgroup.xyz_matrix(n,lb)
               j = image(b,n)
               fb = first(b);  lb = last(b); fj = first(j);  lj = last(j)
               w.create(na,nb)
               w = matmul(tra, mat(fa:la,fb:lb) )
               sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + matmul(w,transpose(trb))
               w.destroy
               trb.destroy
            end
            tra.destroy
         end
      end
      sh.destroy
      sym = sym/.pointgroup%order
      mat = sym
      sym.destroy
      image.destroy
   end

   symmetrise_c(mat)
   ! Symmetrise a complex restricted basis kind matrix
      CMAT :: mat
      CMAT, PTR :: sym,w
      MAT,  PTR :: tra,trb
      SHELL, PTR :: sh
      INT :: n_bf,dim1,dim2,n,a,b,i,j,na,nb
      INT :: fa,fb,fi,fj,la,lb,li,lj
      IVEC, PTR :: first,last
      IMAT, PTR :: image
      DBL :: diff
      dim1 = size(mat,1)
      dim2 = size(mat,2)
      n_bf = .n_bf
      ENSURE( .atom.created,"no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( dim1==dim2,"non-square matrix")
      ENSURE( dim1==n_bf,"incorrectly dimensioned matrix")
      first => .first_basis_fn_for_shell
      last  => .last_basis_fn_for_shell
      image.create( .n_shell, .pointgroup%order)
      .make_image_of_shell(image)
      sym.create(n_bf,n_bf)
      sym = ZERO
      sh.create
      do n = 1,.pointgroup%order
         do a = 1,.n_shell
            .get_shell(a,sh); na = sh%n_comp; la = sh%l; sh.destroy_ptr_part
            tra => .pointgroup.xyz_matrix(n,la)
            i = image(a,n)
            fa = first(a);  la = last(a); fi = first(i);  li = last(i)
            do b = 1,.n_shell
               .get_shell(b,sh); nb = sh%n_comp; lb = sh%l; sh.destroy_ptr_part
               trb => .pointgroup.xyz_matrix(n,lb)
               j = image(b,n)
               fb = first(b);  lb = last(b); fj = first(j);  lj = last(j)
               w.create(na,nb)
               w = matmul(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + matmul(w,transpose(trb))
               w.destroy
               trb.destroy
            end
            tra.destroy
         end
      end
      sh.destroy
      sym = sym/.pointgroup%order
      mat = sym
      sym.destroy
      image.destroy
   end

   make_image_of_shell(res)
   ! Return an array "res(a,n)" which is the image of shell "a" under pointgroup
   ! operation "n"
   ! Size of "res" is [.n_shell,.pointgroup%order]
      IMAT, OUT :: res
      VEC(3) :: new_pos
      INT :: n,a,aa,as,new_atom,fs
      ENSURE(size(res,1) == .n_shell, "dimension of matrix incorrect")
      ENSURE(size(res,2) == .pointgroup%order, "dimension of matrix incorrect")
      do n = 1,.pointgroup%order
         do a = 1,.n_shell
            aa = .atom_for_shell(a)
            as = .atom_shell_for_shell(a)
            new_pos = matmul( .pointgroup%mat(:,:,n), .atom(aa)%pos)
            new_atom = .atom_index_from_pos(new_pos) 
            fs = .first_shell_for_atom(new_atom)
            res(a,n) = fs+as-1
         end
      end
   end

end 
