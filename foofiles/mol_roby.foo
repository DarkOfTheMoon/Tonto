!-------------------------------------------------------------------------------
!
! MOL: roby population analysis routines.
!
! $Id$
!
! (c) chris taylor, uwa, 1999.
!-------------------------------------------------------------------------------
module MOL_ROBY

   use TYPES
   use SYSTEM
   use TIME

   use STR
   use INT
   use DBL
   use BUFFER

   use IVEC
   use IVECVEC
   use VEC
   use VECVEC
   use MAT
   use MATVEC
   use OPVEC
   use OPMAT

   use INPUT
   use OUTPUT
   use ARCHIVE

   use ATOM
   use ATOMVEC

   use SCFDATA

   use MOL_COMMON
   use MOL_INTEGRALS
   use MOL_XTAL
   use MOL_IO
   use MOL_SCF
   use MOL_PLOT

   implicit none         

#  include "macros"
#  include "mol_roby.int"

contains

!--------------------------------------------!
! Prepare spherically averaged Roby atoms    !
!--------------------------------------------!

   prepare_roby_atoms  [leaky]
   ! Provides the preliminary data required to do the Roby population analysis
      if ( .mult /= 1) then; .make_ANSO_data
      else;                  .make_ANO_data
      end
   end

   make_ANO_data [leaky]
   ! Prepare the restricted atomic natural orbital (ANO) data 
      INT :: k,u,n_no, j
      MOL, PTR :: mol
      BIN :: output
      output = TRUE
      do k = 1,.n_atom_kind ! Do an SCF for every different kind of atom
         mol.create
         u = .unique_atom(k)
         .make_molecule_from_atom(u,mol)
         mol%scfdata%output = FALSE
         mol.scf
         mol.make_ao_density_matrix
         mol%pointgroup.create("oh")
         mol.symmetrise(mol%density_matrix)
         mol.make_natural_orbitals
         .atom(u)%natural_orbitals => mol%natural_orbitals
         .atom(u)%occupation       => mol%occupation
         do j = u+1,.n_atom
            if (.atom_kind(j)/=k) cycle
            .atom(j)%natural_orbitals => .atom(u)%natural_orbitals
            .atom(j)%occupation       => .atom(u)%occupation
         end
         mol%atom.nullify_ptr_part     ! do not destroy these
         nullify(mol%natural_orbitals) ! do not destroy this
         nullify(mol%occupation)       ! do not destroy this
         nullify(mol%basis)            ! do not destroy this
         mol.destroy
         if (NOT output) cycle
         n_no = .atom(u)%occupation%restricted.no_of_elements_larger_than(0.05d0)
         .out.show("n_no=",n_no)
         .atom(u).put_natural_orbitals(.out)
      end
   end

   make_ANSO_data [leaky]
   ! Prepare the unrestricted atomic natural spin orbital (ASNO) data 
      INT :: k,u,a
      MOL, PTR :: mol
      BIN :: output
      output = TRUE
      do k = 1,.n_atom_kind ! Do an SCF for every different kind of atom
         mol.create
         u = .unique_atom(k)
         .make_molecule_from_atom(u,mol)
         mol%scfdata%output = FALSE
         mol.scf
         mol%density_matrix.convert_to("unrestricted",factor=HALF)
         mol%density_matrix%restricted.destroy
         mol%pointgroup.create("oh")
         mol.symmetrise(mol%density_matrix)
         mol.make_natural_orbitals
         .atom(u)%natural_orbitals => mol%natural_orbitals
         .atom(u)%occupation       => mol%occupation
         do a = u+1,.n_atom
            if (.atom_kind(a)/=k) cycle
            .atom(a)%natural_orbitals => .atom(u)%natural_orbitals
            .atom(a)%occupation       => .atom(u)%occupation
         end
         mol%atom.nullify_ptr_part     ! do not destroy these
         nullify(mol%natural_orbitals) ! do not destroy this
         nullify(mol%occupation)       ! do not destroy this
         nullify(mol%basis)            ! do not destroy this
         mol.destroy
         if (NOT output) cycle
         .atom(u).put_natural_orbitals(.out)
      end
   end

!----------------------------------------------------------!
! Roby population analysis - general analysis procedure    !
!----------------------------------------------------------!
   roby_population_analysis [leaky]
   ! Do a Roby population analysis of a molecule
   VEC, PTR :: n1
   MAT, PTR :: n2
   INT :: n_atom, i, j
   MAT, PTR :: index, cov
      .prepare_roby_atoms
      n_atom = .n_atom
      n1.create(n_atom)           ! Roby populations
      n2.create(n_atom,n_atom)    ! Roby pair populations
      index.create(n_atom,n_atom) ! Bond indices between pairs of atoms
      cov.create(n_atom,n_atom)   ! Covalency of each two atom bond
      do i = 1,n_atom
         n1(i) = .roby_population((/i/)) 
      end
      do i = 2,n_atom
      do j = 1,i-1
         n2(i,j) = .roby_population((/i,j/)) 
         if (.mult /= 1) then 
           .unrestricted_roby_gould_index((/i,j/), index(i,j), cov(i,j))
         else
           .roby_gould_bond_index((/i,j/), index(i,j), cov(i,j)) 
         end
      end
      end
      .put_roby_populations( n1, n2, index, cov)
      n1.destroy; n2.destroy
      cov.destroy; index.destroy
   end

   put_roby_populations(n1, n2, index, covalency)
   ! Put .out the Roby population analysis data
      VEC  :: n1
      MAT, PTR :: index, covalency
      MAT  :: n2
      INT :: a,b
      STR :: symbol_a,symbol_b
      .out.flush
      .out.text("Roby populations:",flush=2)
      .out.dash(int_fields=1,dbl_fields=1)
      .out.put("Atom",int_width=TRUE)
      .out.put("Population")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=1)
      do a = 1,.n_atom
         symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
         .out.put( symbol_a,int_width=TRUE)
         .out.put( n1(a))
         .out.flush
      end
      .out.dash(int_fields=1,dbl_fields=1)
      .out.flush
      .out.text("Roby pair populations:",flush=2)
      .out.dash(int_fields=2,dbl_fields=4)
      .out.put("Atom_a",int_width=TRUE)
      .out.put("Atom_b",int_width=TRUE)
      .out.put("n_ab")
      .out.put("s_ab")
      .out.put("Bond Index")
      .out.put("% Covalency")
      .out.flush
      .out.dash(int_fields=2,dbl_fields=4)
      do a = 1,.n_atom
      do b = 1,a-1
         symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
         symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
         .out.put(symbol_a,int_width=TRUE)
         .out.put(symbol_b,int_width=TRUE)
         .out.put(n2(a,b))
         .out.put(n1(a)+n1(b)-n2(a,b))
         .out.put(index(a,b))
         .out.put(covalency(a,b))
         .out.flush
      end
      end
      .out.dash(int_fields=2,dbl_fields=4)
   end


!------------------------------------------!
! Routines to get Roby Shared Populations  !
!------------------------------------------!

   get_roby_shared_populations(roby_atom, pop_groups) result (sp)
   ! returns the Roby shared population of "roby_atom"
   ! as well as the calculated sub-group populations "pop_groups"
   IVEC :: roby_atom
   VEC :: pop_groups
   DBL :: sp 
   INT :: m, k, n_k, n_roby_atom
   IMAT, PTR :: comb_mat
      n_roby_atom = size(roby_atom)
      sp = 0
      do k = 1,n_roby_atom
         n_k = n_roby_atom.choose(k)
         comb_mat.create(k,n_k)
         comb_mat = roby_atom.get_combination_matrix_from(k)
         ! comb_mat is the matrix of all combinations of groups
         ! of size k atoms taken from the atoms listed in roby_atom
         pop_groups(k) = 0
         do m = 1,n_k
            pop_groups(k) = pop_groups(k) + .roby_population(comb_mat(:,m))
         end      
         comb_mat.destroy
         sp = sp - ((-1)**k)*pop_groups(k)
      end
   end

   put_roby_shared_population
   ! Evaluate and put the Roby shared population for any group of atoms
   DBL :: shared_population
   INT :: n_roby_atom,a,k
   IVEC, PTR :: roby_atom
   VEC, PTR :: pop_groups
      .read_roby_atom(roby_atom)
      n_roby_atom = size(roby_atom)
      pop_groups.create(n_roby_atom)
      shared_population = .get_roby_shared_populations(roby_atom, pop_groups)
      .out.flush
      .out.text("Roby multi-atom shared population analysis:")
      .out.flush
      .out.put_text("Atom list         =")
      do k = 1,n_roby_atom
         a = roby_atom(k)
         .out.put_text( " " )
         .out.put_text( .atom(a).chemical_symbol.trim)
         .out.put_text( "(" )
         .out.put_text( a.to_str.trim )
         .out.put_text( ")" )
      end
      .out.flush
      .out.show("Shared population =",shared_population)
      .out.flush
      .out.text("Shared populations by group order:")
      .out.dash(int_fields=1,dbl_fields=1)
      .out.put("Order",int_width=TRUE)
      .out.put("Population")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=1)
      do k = 1,n_roby_atom
         .out.put(k)
         .out.put(pop_groups(k))
         .out.flush
      end
      .out.dash(int_fields=1,dbl_fields=1)
      pop_groups.destroy
      roby_atom.destroy
   end

!---------------------------------------------!
! Roby Energy and Shared Energy calculations  !
!---------------------------------------------!

   roby_energy(roby_atom) result(energy)
   ! Return the (total) Roby energy for the group of atoms whose
   ! indices are given in "roby_atom".
      IVEC :: roby_atom
      DBL :: energy
      OPMAT, PTR :: D,D_save
      MAT, PTR :: P
      P.create(.n_bf, .n_bf)
      .make_roby_projected_density(P,roby_atom)
      D_save => .density_matrix
      D.create(.n_bf,"restricted")
      D%restricted = P ! P is projected density
      .density_matrix => D
      .make_fock_matrix
      energy = .scf_electronic_energy(D)
      .density_matrix => D_save
      D.destroy
      P.destroy
   end

   get_roby_shared_energy(roby_atom, en_groups) result(se)
   ! returns the shared energy of the atoms given in "roby_atom"
   ! as well as the energy of all sub-groups of atoms "en_groups"
   IVEC :: roby_atom
   VEC :: en_groups
   DBL :: se 
   INT :: m,k, n_k, n_roby_atom
   IMAT, PTR :: comb_mat
      n_roby_atom = size(roby_atom)
      se = 0
      do k = 1,n_roby_atom
         n_k = n_roby_atom.choose(k)
         comb_mat.create(k,n_k)
         comb_mat = roby_atom.get_combination_matrix_from(k)
         en_groups(k) = 0
         do m = 1,n_k
            en_groups(k) = en_groups(k) + .roby_energy(comb_mat(:,m))
         end      
         comb_mat.destroy
         se = se - ((-1)**k)*en_groups(k)
      end
   end

   put_roby_shared_energy
   ! Evaluate and put the Roby shared energy for a group of atoms
      DBL :: shared_energy
      INT :: n_roby_atom,k,n_k,total_combs,count,m,a
      IVEC, PTR :: roby_atom
      VEC, PTR :: energy,en_groups
      IMAT, PTR :: comb_mat
      .read_roby_atom(roby_atom)
      n_roby_atom = size(roby_atom)
      en_groups.create(n_roby_atom)
      shared_energy = .get_roby_shared_energy(roby_atom, en_groups)
      .out.flush
      .out.text("Roby multi-atom shared energy analysis:")
      .out.flush
      .out.put_text("Atom list         =")
      do k = 1,n_roby_atom
         a = roby_atom(k)
         .out.put_text( " " )
         .out.put_text( .atom(a).chemical_symbol.trim)
         .out.put_text( "(" )
         .out.put_text( a.to_str.trim )
         .out.put_text( ")" )
      end
      .out.flush
      .out.show("Shared energy =",shared_energy)
      .out.flush
      .out.text("Shared energies by group order:")
      .out.dash(int_fields=1,dbl_fields=1)
      .out.put("Order",int_width=TRUE)
      .out.put("Population")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=1)
      do k = 1,n_roby_atom
         .out.put(k)
         .out.put(en_groups(k))
         .out.flush
      end
      .out.dash(int_fields=1,dbl_fields=1)
      en_groups.destroy
      energy.destroy
      roby_atom.destroy
   end


!-----------------------------------------!
! Plot covalent and ionic theta orbitals  !
!-----------------------------------------!

   plot_covalent_orbitals
   ! creates the covalent operator for the roby_atom
   ! and plots the theta orbitals
   IVEC, PTR :: roby_atom
   INT :: n_bf
   MAT, PTR :: R
      .read_roby_atom(roby_atom)
      ENSURE(size(roby_atom)==2,"must specify a diatomic")
      n_bf= .atom(roby_atom).n_bf
      R.create(n_bf,n_bf)
      .make_roby_shared_operator(R,roby_atom)
      .plot_theta_orbitals(roby_atom,R)
      roby_atom.destroy
      R.destroy
   end

   plot_covalent_density_orbitals
   ! creates the covalent operator for the roby_atom
   ! and plots the theta density orbitals
   IVEC, PTR :: roby_atom
   INT :: n_bf
   MAT, PTR :: R
      .read_roby_atom(roby_atom)
      ENSURE(size(roby_atom)==2,"must specify a diatomic")
      n_bf = .atom(roby_atom).n_bf
      R.create(n_bf,n_bf)
      .make_roby_shared_operator(R,roby_atom)
      .plot_theta_orbitals(roby_atom,R,density=TRUE)
      roby_atom.destroy
      R.destroy
   end

   plot_ionic_orbitals
   ! creates the covalent operator for the roby_atom
   ! and plots the thetaorbitals
   IVEC, PTR :: roby_atom
   INT :: n_bf
   MAT, PTR :: I
      .read_roby_atom(roby_atom)
      ENSURE(size(roby_atom)==2,"must specify a diatomic")
      n_bf= .atom(roby_atom).n_bf
      I.create(n_bf,n_bf)
      .make_roby_ionic_operator(I,roby_atom)
      .plot_theta_orbitals(roby_atom,I)
      roby_atom.destroy
      I.destroy
   end

   plot_ionic_density_orbitals
   ! creates the covalent operator for the roby_atom
   ! and plots the theta density orbitals
   IVEC, PTR :: roby_atom
   INT :: n_bf
   MAT, PTR :: I
      .read_roby_atom(roby_atom)
      ENSURE(size(roby_atom)==2,"must specify a diatomic")
      n_bf = .atom(roby_atom).n_bf
      I.create(n_bf,n_bf)
      .make_roby_ionic_operator(I,roby_atom)
      .plot_theta_orbitals(roby_atom,I,density=TRUE)
      roby_atom.destroy
      I.destroy
   end

   plot_theta_orbitals(roby_atom,operator, density)
   ! plots all the theta orbitals involving the diatomic specified
   ! "operator" is the matrix of either the cosine or sine operator
   ! which determines whether covalent or ionic orbitals are produced
   ! "density" is present and TRUE gives orbital density plots.
      IVEC, PTR :: roby_atom
      MAT :: operator
      BIN, optional :: density
      BIN :: make_density
      INT :: i, size_theta
      VEC,PTR :: eigenval
      OPMAT, PTR :: proj_NOs
      MAT, PTR :: theta, saved_NO_matrix
      .grid.put( .out)
      make_density = FALSE
      if (present(DENSITY)) make_density = density 
      size_theta = .atom(roby_atom).n_bf
      theta.create(size_theta,size_theta)
      eigenval.create(size_theta)
      .make_gould_theta_orbitals(operator,roby_atom,theta,eigenval)
      saved_NO_matrix.create( .n_bf, .n_bf)
      saved_NO_matrix = .natural_orbitals%restricted
      do i = 1, size_theta
        if (abs(eigenval(i))<1.0d-05) cycle 
        proj_NOs.create( .n_bf, "restricted")
        .make_roby_projected_NOs(proj_NOs, roby_atom, theta(:,i:i))
        .natural_orbitals%restricted = proj_NOs%restricted
        if (make_density) then
           .make_orbital_density_grid(i,make_NOs=FALSE)
        else
           .make_orbital_grid(i,make_NOs=FALSE)
        end
        !----------------------------------------------------!
        ! WARNING: These will be written to either:          !
        ! ?name?:orbital_grid?orb?,gnuplot,ascii             !
        ! ?name?:orbital_density_grid?orb?,gnuplot,ascii     !
        ! regardless of being covalent or ionic orbitals.    !
        !----------------------------------------------------!
        .natural_orbitals%restricted = saved_NO_matrix
        proj_NOs.destroy
      end 
      eigenval.destroy
      theta.destroy
      saved_NO_matrix.destroy
   end

!-----------------------------------------!
! Routines to calculate Roby populations  !
!-----------------------------------------!
 
   roby_population(roby_atom) result (population) 
   ! Return the (total) Roby population for the group of atoms whose
   ! indices are given in "roby_atom".
      IVEC :: roby_atom
      DBL :: population
      STR :: spin
      MAT, PTR :: X,Y, Y_A,Y_B,X_A,X_B
      INT :: n_bf,i
      n_bf = .atom(roby_atom).no_of_basis_functions
      if (.mult /= 1) then
         ! Unrestricted Roby procedure
         X_A.create( n_bf,  n_bf)
         Y_A.create(.n_bf, .n_bf)
         X_B.create( n_bf,  n_bf)
         Y_B.create(.n_bf, .n_bf)
         spin="alpha"
         .make_roby_projection_matrix(X_A,spin,roby_atom)
         spin="beta"
         .make_roby_projection_matrix(X_B,spin,roby_atom)
         .roby_overlap_transform(X_A,Y_A,roby_atom)
         .roby_overlap_transform(X_B,Y_B,roby_atom)
         population = HALF * ( Y_A.trace_product_with( .density_matrix%alpha) &
              + Y_A.trace_product_with( .density_matrix%beta) &
              + Y_B.trace_product_with( .density_matrix%alpha) &
              + Y_B.trace_product_with( .density_matrix%beta) )
      else
         ! Restricted Roby procedure
         X.create( n_bf,  n_bf)
         Y.create(.n_bf, .n_bf)
         .make_roby_projection_matrix(X,roby_atom)
         .roby_overlap_transform(X,Y,roby_atom)
         population = Y.trace_product_with( .density_matrix%restricted)
         Y.destroy
         X.destroy
      end
   end

   roby_population_from_rho(roby_atom,rho) result (population) 
   ! Return the (total) Roby population for the group of atoms whose
   ! indices are given in "roby_atom" and for which the density matrix
   ! used for projection is given by rho 
      IVEC :: roby_atom
      MAT, PTR :: rho 
      DBL :: population
      MAT, PTR :: X,Y
      INT :: n_bf
      ENSURE(size(rho,1)==.n_bf, "supplied density is of wrong order")
      ENSURE(size(rho,2)==.n_bf, "supplied density is of wrong order")
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      Y.create(.n_bf, .n_bf)
      .make_roby_projection_matrix(X,roby_atom)
      .roby_overlap_transform(X,Y,roby_atom)
      population = Y.trace_product_with( rho)
      Y.destroy
      X.destroy
   end

   roby_population(roby_atom,ANO) result (population) 
   ! Return the (total) Roby population for the group of atoms whose
   ! indices are given in "roby_atom" and for which the roby projection
   ! operator orbitals are defined by columns of "ANO"
      IVEC :: roby_atom
      MAT :: ANO
      DBL :: population
      MAT, PTR :: X,Y
      INT :: n_bf
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      Y.create(.n_bf, .n_bf)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      .roby_overlap_transform(X,Y,roby_atom)
      if (.mult /= 1) then
         population = Y.trace_product_with( .density_matrix%alpha + .density_matrix%beta)
      else
         population = Y.trace_product_with( .density_matrix%restricted)
      end
      Y.destroy
      X.destroy
   end

   roby_population(roby_atom,ANO,atom) result (population) 
   ! Return the (total) Roby population for atom "atom" of the group of atoms whose
   ! indices are given in "roby_atom" and for which the roby projection operator 
   ! orbitals are defined by columns of "ANO"
      IVEC :: roby_atom
      MAT :: ANO
      INT :: atom
      DBL :: population
      MAT, PTR :: X,Y,PA,Z,W, PT
      INT :: n_bf,n_af
      n_bf = .atom(roby_atom).no_of_basis_functions
      n_af = .atom(roby_atom(atom)).no_of_basis_functions
      X.create(n_bf, n_bf)
      Y.create(n_af, n_af)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      .roby_overlap_transform(X,Y,roby_atom,roby_atom(atom:atom))
      PA.create(n_af,n_af)
      .make_roby_projection_matrix(PA,roby_atom(atom:atom))
      Z.create(n_af,n_af)
      .roby_project(Y,Z,PA)
      W.create(.n_bf,.n_bf) 
      .roby_overlap_transform(Z,W,roby_atom(atom:atom)) 
      population = W.trace_product_with( .density_matrix%restricted)
      W.destroy 
      Z.destroy 
      PA.destroy 
      Y.destroy
      X.destroy
   end

!------------------------------------------!
! Routines to get Roby-Gould bond indices  !
!------------------------------------------!

   roby_gould_bond_index(roby_atom, bond_index, pcc)
   ! Calculates the Roby-Gould bond index for two atoms
   ! for singlet state (restricted) molecules
      IVEC :: roby_atom
      DBL :: pcc, bond_index
      MAT, PTR :: C, theta_c, S, theta_s
      VEC, PTR :: cval, c_p, sval, s_p 
      VEC, PTR :: c_a, c_b, s_a, s_b
      VEC, PTR :: covalency,ionicity
      VEC, PTR :: R_AB, I_AB
      IVEC, PTR :: c_pair, s_pair
      INT :: n_a, n_b, n_ab, i, j, a, b
      DBL :: total_i,total_c
      BIN :: output
      ENSURE(size(roby_atom)==2,"roby_atom has wrong size")
      ENSURE( .mult==1, "restricted molecules only")
      output = TRUE
      a = roby_atom(1)
      b = roby_atom(2)
      n_a = .atom(a).no_of_basis_functions
      n_b = .atom(b).no_of_basis_functions
      n_ab = n_a + n_b
      C.create(n_ab,n_ab); theta_c.create(n_ab, n_ab); cval.create(n_ab)
      S.create(n_ab,n_ab); theta_s.create(n_ab, n_ab); sval.create(n_ab)
      c_p.create(n_ab); s_p.create(n_ab)
      c_a.create(n_ab); c_b.create(n_ab)
      s_a.create(n_ab); s_b.create(n_ab)
      .make_roby_shared_operator(C,roby_atom)
      .make_roby_ionic_operator(S,roby_atom)
      .make_gould_theta_orbitals(C,roby_atom,theta_c,cval)
      .make_gould_theta_orbitals(S,roby_atom,theta_s,sval)
      .get_theta_populations(roby_atom, theta_c, c_p, c_a, c_b)
      .get_theta_populations(roby_atom, theta_s, s_p, s_a, s_b)
      c_pair.create(n_ab); s_pair.create(n_ab)
      cval.find_opposite_pairs(c_pair,TOL(5),ONE-TOL(5))
      sval.find_opposite_pairs(s_pair,TOL(5),ONE-TOL(5))
      covalency.create(n_ab); ionicity.create(n_ab)
      total_c = .get_roby_gould_index(c_pair,c_p,covalency)
      total_i = .get_roby_gould_index(s_pair,s_p,ionicity)
      bond_index = sqrt( total_c**2 + total_i **2)
      pcc = (total_c/bond_index)**2
      if (output) then
        .put_roby_gould_data(roby_atom,bond_index,pcc,1-pcc)
        .put_roby_gould_c_data(covalency,ionicity,cval,c_p,c_pair,c_a,c_b)
        .put_roby_gould_s_data(covalency,ionicity,sval,s_p,s_pair,s_a,s_b)
           ! the following directs the partitioning verification ...
        R_AB.create(size(c_p)); I_AB.create(size(s_p))
        .make_roby_gould_superoperators(roby_atom,R_AB,I_AB,theta_c)
        .put_roby_gould_superoperators(R_AB,I_AB,c_p,c_pair,cval)
        R_AB.destroy; I_AB.destroy
        .roby_gould_partitioning(cval,c_p,c_pair,sval,s_p,s_pair)
      end
      covalency.destroy
      ionicity.destroy
      C.destroy; theta_c.destroy; cval.destroy
      S.destroy; theta_s.destroy; sval.destroy
      c_p.destroy; c_pair.destroy; c_b.destroy; s_b.destroy
      s_p.destroy; s_pair.destroy; c_a.destroy; s_a.destroy
   end   

   unrestricted_roby_gould_index(roby_atom, bond_index,pcc)
   ! calculates the roby_gould_index for diatomics in unrestricted molecules
     IVEC :: roby_atom
     DBL :: bond_index, pcc
     DBL :: cov_a, ion_a, cov_b, ion_b
     STR :: alpha, beta
     alpha = "alpha"; beta="beta"
     .get_unres_roby_gould_data(roby_atom, cov_a, ion_a, alpha)
     .get_unres_roby_gould_data(roby_atom, cov_b, ion_b, beta)
     bond_index = sqrt( ((cov_a + cov_b)/2)**2 + ((ion_a + ion_b)/2)**2)
     pcc = (HALF*(cov_a + cov_b)/bond_index)**2
     .put_roby_gould_data( roby_atom, bond_index, pcc, 1-pcc)
   end
     
   get_roby_gould_index(pair,population,orbital_strength) result (index)
   ! calculates the index "ind" from the theta "population" data
   ! NOTE : returns only the ionic or covalent index !!!!!!
   ! "orbital_strength" = (#bonding - #anti-bonding) / 2
   ! "pair" is the anti-bonding/bonding pair list
      IVEC :: pair
      VEC :: population, orbital_strength 
      INT :: j, n_ab
      DBL :: index
      n_ab = size(population)
      orbital_strength.zero
      do j = 1, n_ab
         if (pair(j) <= 0) cycle 
         orbital_strength(j) = (population(j) - population(pair(j)))/2
      end
      index = sum(orbital_strength) 
   end

   get_theta_populations(roby_atom, theta, p, a, b)
   ! returns the theta population information
   ! of the "theta" orbitals from "roby_atom"
   ! including the population, "p", and the population 
   ! belonging to atoms "a" and "b" if present.
     VEC :: p
     VEC, OPTIONAL :: a, b
     IVEC :: roby_atom
     MAT :: theta
     INT :: i
     do i = 1, size(p)
       p(i) = .roby_population(roby_atom,theta(:,i:i)) 
       if (.mult /= 1) cycle
       a(i) = .roby_population(roby_atom,theta(:,i:i),1) 
       b(i) = .roby_population(roby_atom,theta(:,i:i),2) 
     end
   end

   get_unres_roby_gould_data(roby_atom, total_c, total_i, spin_case) 
   ! provides the covalency and ionicity of orbitals for the roby_gould
   ! bond index calculation required in the unrestricted case
   ! spin_case is a STR describing whether alpha or beta orbitals
   ! are required.
      IVEC :: roby_atom
      MAT, PTR :: C, theta_c, S, theta_s
      VEC, PTR :: cval, c_p, sval, s_p
      VEC, PTR :: covalency,ionicity
      VEC, PTR :: R_AB, I_AB
      STR :: spin_case
      IVEC, PTR :: c_pair, s_pair
      INT :: n_a, n_b, n_ab, i, j, a, b
      DBL :: total_i,total_c
      ENSURE(size(roby_atom)==2,"roby_atom has wrong size")
      a = roby_atom(1)
      b = roby_atom(2)
      n_a = .atom(a).no_of_basis_functions
      n_b = .atom(b).no_of_basis_functions
      n_ab = n_a + n_b
      C.create(n_ab,n_ab); theta_c.create(n_ab, n_ab); cval.create(n_ab)
      S.create(n_ab,n_ab); theta_s.create(n_ab, n_ab); sval.create(n_ab)
      c_p.create(n_ab); s_p.create(n_ab)
      .make_roby_shared_operator(C,roby_atom,spin_case)
      .make_roby_ionic_operator(S,roby_atom,spin_case)
      .make_gould_theta_orbitals(C,roby_atom,theta_c,cval)
      .make_gould_theta_orbitals(S,roby_atom,theta_s,sval)
      .get_theta_populations(roby_atom, theta_c, c_p)
      .get_theta_populations(roby_atom, theta_s, s_p)
      c_pair.create(n_ab); s_pair.create(n_ab)
      cval.find_opposite_pairs(c_pair,TOL(5),ONE-TOL(5))
      sval.find_opposite_pairs(s_pair,TOL(5),ONE-TOL(5))
      covalency.create(n_ab)
      ionicity.create(n_ab)
      total_c = .get_roby_gould_index(c_pair,c_p,covalency)
      total_i = .get_roby_gould_index(s_pair,s_p,ionicity)
      covalency.destroy   ! may want to use later ...
      ionicity.destroy    ! .. ditto ..
      C.destroy; theta_c.destroy; cval.destroy
      S.destroy; theta_s.destroy; sval.destroy
      c_p.destroy; c_pair.destroy
      s_p.destroy; s_pair.destroy
   end   

   put_roby_gould_data(roby_atom,bond_index,pc_covalency,pc_ionicity)
   ! Output detailed Roby-Gould bond index information
      IVEC :: roby_atom
      DBL :: bond_index,pc_covalency,pc_ionicity
      INT :: a,b
      STR :: symbol_a,symbol_b
      .out.flush
      a = roby_atom(1)
      b = roby_atom(2)
      symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
      symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
      .out.text("Gould bond index data:",flush=2)
      .out.show("Atom_a           =",symbol_a)
      .out.show("Atom_b           =",symbol_b)
      .out.show("Total bond_index =",bond_index)
      .out.show("% Covalency      =",pc_covalency)
      .out.show("% Ionicity       =",pc_ionicity)
   end

   put_roby_gould_c_data(covalency,ionicity,cos_theta,c_p,c_pair,c_a,c_b)
   ! Output detailed Roby-Gould bond index information
      VEC :: covalency,ionicity,cos_theta,c_p,c_a,c_b
      IVEC :: c_pair
      INT :: i, n_ab
      .out.flush
      n_ab =size(c_p)
      .out.flush
      .out.text("Cos(theta) subspace data:")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=5)
      .out.put("Theta/dg",int_width=TRUE)
      .out.put("Theta(+) pop")
      .out.put("Theta(a+) pop")
      .out.put("Theta(b+) pop")
      .out.put("Covalent Index")
      .out.put("Ionic Index")
      .out.flush
      .out.tab(int_fields=1)
      .out.put("Theta(-) pop")
      .out.put("Theta(a-) pop")
      .out.put("Theta(b-) pop")
      .out.flush
      .out.tab(int_fields=1)
      .out.put("Theta    pop")
      .out.put("Theta(a ) pop")
      .out.put("Theta(b ) pop")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=5)
      do i = 1, n_ab
         if (c_pair(i) <= 0) cycle
         .out.put(nint(180* cos_theta(i).arccos/ PI))
         .out.put(c_p(i))
         .out.put(c_a(i))
         .out.put(c_b(i))
         .out.put(covalency(i))
         .out.put(ionicity(i))
         .out.flush
         .out.tab(int_fields=1)
         .out.put(c_p(c_pair(i)))
         .out.put(c_a(c_pair(i)))
         .out.put(c_b(c_pair(i)))
         .out.flush
         .out.tab(int_fields=1)
         .out.put(c_p(i)+c_p(c_pair(i)))
         .out.put(c_a(i)+c_a(c_pair(i)))
         .out.put(c_b(i)+c_b(c_pair(i)))
         .out.flush
      end
      .out.dash(int_fields=1,dbl_fields=5)
   end

   put_roby_gould_s_data(covalency,ionicity,sin_theta,s_p,s_pair,s_a,s_b)
   ! Output detailed Roby-Gould bond index information
      VEC :: covalency,ionicity,sin_theta,s_p,s_a,s_b
      IVEC :: s_pair
      INT :: i, n_ab, theta
      .out.flush
      n_ab =size(s_p)
      .out.flush
      .out.text("Sin(theta) subspace data:")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=5)
      .out.put("Theta/dg",int_width=TRUE)
      .out.put("Theta(+) pop")
      .out.put("Theta(a+) pop")
      .out.put("Theta(b+) pop")
      .out.put("Covalent Index")
      .out.put("Ionic Index")
      .out.flush
      .out.tab(int_fields=1)
      .out.put("Theta(-) pop")
      .out.put("Theta(a-) pop")
      .out.put("Theta(b-) pop")
      .out.flush
      .out.tab(int_fields=1)
      .out.put("Theta    pop")
      .out.put("Theta(a ) pop")
      .out.put("Theta(b ) pop")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=5)
      do i = 1, n_ab
         theta = nint(180* sin_theta(i).arcsin/ PI)
         if (s_pair(i) > 0 OR abs(theta)==90) then
            .out.put(theta)
            .out.put(s_p(i))
            .out.put(s_a(i))
            .out.put(s_b(i))
            .out.put(covalency(i))
            .out.put(ionicity(i))
            .out.flush
         end
         if (s_pair(i) > 0) then
            .out.tab(int_fields=1)
            .out.put(s_p(s_pair(i)))
            .out.put(s_a(s_pair(i)))
            .out.put(s_b(s_pair(i)))
            .out.flush
            .out.tab(int_fields=1)
            .out.put(s_p(i)+s_p(s_pair(i)))
            .out.put(s_a(i)+s_a(s_pair(i)))
            .out.put(s_b(i)+s_b(s_pair(i)))
            .out.flush
         end
      end
      .out.dash(int_fields=1,dbl_fields=5)
   end

!---------------------------------------------------!
! Roby-Gould partitioning information               !
! Used to verify the additivity of the operators    !
!---------------------------------------------------!

   roby_gould_partitioning(cval,c_p,c_pair,sval,s_p,s_pair)
   ! calculates the roby_gould partitioning data
   ! where the ionic and shared components are extracted
   ! from the eigenvector populations and gives this as output.
      IVEC, PTR :: c_pair, s_pair, angle_c, angle_s, angle_pairs
      VEC, PTR :: cval, c_p, s_p, sval
      VEC, PTR :: s_ab, i_ab 
      VEC, PTR :: s_total, i_total
      VEC, PTR :: n2
      INT :: i, j
      s_ab.create(size(c_p))
      s_ab = abs(cval) * c_p
      ! make the |I_AB| data for each theta orbital = i_ab
      i_ab.create(size(c_p))
      i_ab = abs(sval) * s_p
      .out.dash(dbl_fields=4,int_fields=1)
      .out.put("Roby Gould Partitioning.");.out.flush
      .out.dash(dbl_fields=4,int_fields=1)
      .out.flush
      .out.put("Theta (dg)", int_width=TRUE)
      .out.put("Covalent")
      .out.put("Ionic")
      .out.put("Sum Weighted")
      .out.put("Total")
      .out.flush
      .out.tab(int_fields=1)
      .out.put("Population")
      .out.put("Population")
      .out.put("Squares")
      .out.put("Population")
      .out.flush
      .out.dash(dbl_fields=4,int_fields=1)
      angle_c.create(size(c_p)) 
      angle_s.create(size(s_p))
      s_total.create(size(c_p)); s_total.zero
      i_total.create(size(s_p)); i_total.zero
      do i = 1, size(c_p)
        angle_c(i) = nint(180*cval(i).arccos/PI)
        angle_s(i) = nint(180*sval(i).arcsin/PI)
         if (c_pair(i) <= 0) cycle
         s_total(i) = s_ab(i) + s_ab(c_pair(i))
         if (s_pair(i) == 0) cycle
         if (s_pair(i) == -1) then
            i_total(i) = i_ab(i)
         else
            i_total(i) = i_ab(i) + i_ab(s_pair(i))
         end
      end
      angle_pairs.create(size(c_p))
      angle_pairs.pair_vec_from(angle_c,angle_s)
      n2.create(size(c_p)); n2.zero
      do i = 1, size(c_p)
        if (angle_pairs(i)==0) cycle
        n2(i) = sqrt(i_total(angle_pairs(i))**2 + s_total(i)**2)
        .out.put(angle_c(i))
        .out.put(s_total(i))
        .out.put(i_total(i))
        .out.put(n2(i))
        .out.put(c_p(i) + c_p(c_pair(i)))
        .out.flush
      end
      .out.dash(int_fields=1,dbl_fields=4)
      angle_c.destroy; angle_s.destroy
      s_total.destroy; i_total.destroy
      i_ab.destroy; s_ab.destroy
      angle_pairs.destroy
      n2.destroy
   end

   make_roby_gould_superoperators(roby_atom,R_AB,I_AB,theta_c)
   ! Makes the superoperators R_AB^2 and calculates the expectation value
   ! of this over each theta orbital. Similarly for I_AB^2.
   ! R_AB^2 = -P_A - P_B +P_AB + P_A.P_B + P_B.P_A
   ! I_AB^2 = P_A + P_B - P_A.P_B - P_B.P_A
   VEC, PTR :: R_AB, I_AB, p_a, p_b, p_ab, bp_a, ap_b
   IVEC :: roby_atom
   MAT, PTR :: theta_c, rho_A, rho_B, rho_t
   INT :: i, n_theta
    rho_A.create( .n_bf, .n_bf)
    rho_B.create( .n_bf, .n_bf)
    rho_t.create( .n_bf, .n_bf)
    n_theta = size(theta_c,1)
    p_a.create( n_theta)
    p_b.create( n_theta)
    p_ab.create( n_theta)
    bp_a.create( n_theta)
    ap_b.create( n_theta)
    do i = 1, size(theta_c,1)
      p_a(i)  = .roby_population(roby_atom,theta_c(:,i:i),1)  ! P_A  rho_theta
      p_b(i)  = .roby_population(roby_atom,theta_c(:,i:i),2)  ! P_B  rho_theta
      p_ab(i) = .roby_population(roby_atom,theta_c(:,i:i))    ! P_AB rho_theta
      .make_roby_projected_density(rho_t,roby_atom,theta_c(:,i:i))
      .make_roby_projected_density(rho_A,rho_t,roby_atom(1:1))
      .make_roby_projected_density(rho_B,rho_t,roby_atom(2:2))
      bp_a(i) = .roby_population_from_rho(roby_atom(2:2),rho_A) ! P_B.P_A rho_t
      ap_b(i) = .roby_population_from_rho(roby_atom(1:1),rho_B) ! P_A.P_B rho_t 
    end
    R_AB = -p_a - p_b + p_ab + bp_a + ap_b
    I_AB = p_a + p_b - ap_b - bp_a
    rho_A.destroy; rho_B.destroy; rho_t.destroy
    p_a.destroy; p_b.destroy; p_ab.destroy; bp_a.destroy; ap_b.destroy
   end

   put_roby_gould_superoperators(R_AB,I_AB,c_p,c_pair, cval)
   ! outputs the Roby_gould superoperator relationships for the bond
   VEC, PTR :: R_AB, I_AB, c_p, cval
   IVEC, PTR :: c_pair
   INT :: i
     .out.dash(int_fields=1,dbl_fields=4)
     .out.put("Roby-Gould super operator relationships.")
     .out.flush
     .out.dash(int_fields=1,dbl_fields=4)
     .out.put("Theta (dg)",int_width=TRUE)
     .out.put("R_AB^2")
     .out.put("I_AB^2")
     .out.put("I_AB^2 + R_AB^2")
     .out.put("n_theta"); .out.flush
     .out.dash(int_fields=1,dbl_fields=4)
     do i = 1, size(c_p)
      if (c_pair(i)<=0) cycle
      .out.put(nint(180*cval(i).arccos/PI))
      .out.put(R_AB(i) + R_AB(c_pair(i)))
      .out.put(I_AB(i) + I_AB(c_pair(i)))
      .out.put(R_AB(i) + I_AB(i) + R_AB(c_pair(i)) + I_AB(c_pair(i)))
      .out.put(c_p(i) + c_p(c_pair(i))); .out.flush
     end
     .out.dash(int_fields=1,dbl_fields=4)
   end

!---------------------!
! Make Roby operators !
!---------------------!

   make_roby_projection_matrix(P,roby_atom)
   ! Make the Roby projection matrix in the AO basis made from the concatenated 
   ! basis sets for each atom in "roby_atom"
      MAT :: P
      IVEC :: roby_atom
      STR :: kind
      MAT, PTR :: W,X,Y
      INT :: n_roby_atom, n_occ,n_bf
      n_bf  = .atom(roby_atom).no_of_basis_functions
      ENSURE(size(P,1)==n_bf,"P is incorrectly dimensioned")
      ENSURE(size(P,2)==n_bf,"P is incorrectly dimensioned")
      n_occ = .atom(roby_atom).no_of_occupied_ANOs(tol=0.05d0)
      n_roby_atom = size(roby_atom)
      W.create(n_bf,n_occ)                   ! W = columns of ANO's
      .make_ANO_matrix(W, roby_atom)
      Y.create(n_bf,n_bf)                    ! Y = overlap matrix for roby_atoms(:) basis
      .make_roby_overlap_matrix(Y,roby_atom,roby_atom) 
      X.create(n_occ,n_occ)
      Y.change_basis(X,W)                    ! X = S in the ANO basis
      Y.destroy
      Y.create(n_occ,n_occ)
      Y.to_inverse_of(X)                     ! Y = (ANO overlap matrix)^{-1}
      X.destroy
      Y.back_transform(P,W)                  ! P = Y in the roby_atom(:) AO basis
      Y.destroy
      W.destroy
   end

   make_roby_projection_matrix(P,spin_case,roby_atom)
   ! Make the Roby projection matrix in the AO basis made from the concatenated 
   ! basis sets for each atom in "roby_atom"
      MAT :: P
      IVEC :: roby_atom
      STR :: spin_case, alpha
      MAT, PTR :: W,X,Y
      INT :: n_roby_atom, n_occ,n_bf
      n_bf  = .atom(roby_atom).no_of_basis_functions
      alpha="alpha"
      ENSURE(size(P,1)==n_bf,"P is incorrectly dimensioned")
      ENSURE(size(P,2)==n_bf,"P is incorrectly dimensioned")
      ENSURE((spin_case=="alpha") OR (spin_case=="beta"), "must specify spin of projector")
      n_occ = .atom(roby_atom).no_of_occupied_ANOs(spin_case,tol=0.05d0) !need number of "spinkind" NOs
      n_roby_atom = size(roby_atom)
      if (n_occ == 0) then 
         n_occ = .atom(roby_atom).no_of_occupied_ANOs(alpha,tol=0.05d0) !need number of "spinkind" NOs
         spin_case="alpha"
      end
       W.create(n_bf,n_occ)                   ! W = columns of ANO's
       .make_ANO_matrix(W, spin_case, roby_atom)
       Y.create(n_bf,n_bf)                    ! Y = overlap matrix for roby_atoms(:) basis
       .make_roby_overlap_matrix(Y,roby_atom,roby_atom) 
       X.create(n_occ,n_occ)
       Y.change_basis(X,W)                    ! X = S in the ANO basis
       Y.destroy
       Y.create(n_occ,n_occ)
       Y.to_inverse_of(X)                     ! Y = (ANO overlap matrix)^{-1}
       X.destroy
       Y.back_transform(P,W)                  ! P = Y in the roby_atom(:) AO basis
       Y.destroy
       W.destroy
   end

   make_roby_projection_matrix(P,roby_atom,ANO)
   ! Make the Roby projection matrix in the AO basis made from the concatenated 
   ! basis sets for each atom in "roby_atom" using the columns of "ANO" as 
   ! orbital coefficients to form the projection operator.
      MAT :: P
      IVEC :: roby_atom
      MAT :: ANO
      STR :: kind
      MAT, PTR :: W,X,Y
      INT :: n_roby_atom, n_occ,n_bf
      n_bf  = .atom(roby_atom).no_of_basis_functions
      ENSURE(size(P,1)==n_bf,  "P is incorrectly dimensioned")
      ENSURE(size(P,2)==n_bf,  "P is incorrectly dimensioned")
      ENSURE(size(ANO,1)==n_bf,"ANO is incorrectly dimensioned")
      n_occ = size(ANO,2)
      n_roby_atom = size(roby_atom)
      W.create(n_bf,n_occ)                   ! W = columns of ANO's
      W = ANO                                
      Y.create(n_bf,n_bf)                    ! Y = overlap matrix for roby_atoms(:) basis
      .make_roby_overlap_matrix(Y,roby_atom,roby_atom) 
      X.create(n_occ,n_occ)
      Y.change_basis(X,W)                    ! X = S in the ANO basis
      Y.destroy
      Y.create(n_occ,n_occ)
      Y.to_inverse_of(X)                     ! Y = (ANO overlap matrix)^{-1}
      X.destroy
      Y.back_transform(P,W)                  ! P = Y in the roby_atom(:) AO basis
      Y.destroy
      W.destroy
   end

   make_roby_shared_operator(R,roby_atom,spin_case)
   ! constructs the roby_shared_operator R_AB = P_A + P_B - P_AB
   ! if spin_case is supplied then either the alpha or beta
   ! operator is constructed, depending on the value of spin_case
   IVEC :: roby_atom
   MAT, PTR :: P_A,P_B,P_AB
   MAT :: R
   STR,optional :: spin_case
   INT :: a, b, n_a, n_b, n_ab
      a = roby_atom(1)
      b = roby_atom(2)
      n_a = .atom(a).no_of_basis_functions
      n_b = .atom(b).no_of_basis_functions
      n_ab = n_a + n_b
      P_A.create(n_a,n_a)
      P_B.create(n_b,n_b)
      P_AB.create(n_ab,n_ab)
      if ( .mult /= 1) then
         .make_roby_projection_matrix(P_A , spin_case,(/a/)  )
         .make_roby_projection_matrix(P_B , spin_case,(/b/)  )
         .make_roby_projection_matrix(P_AB, spin_case,(/a,b/))
      else
         .make_roby_projection_matrix(P_A , (/a/)  )
         .make_roby_projection_matrix(P_B , (/b/)  )
         .make_roby_projection_matrix(P_AB, (/a,b/))
      end
      R = ZERO
      R(    1:n_a ,     1:n_a ) =  P_A
      R(n_a+1:n_ab, n_a+1:n_ab) =  P_B
      R = R - P_AB
      P_AB.destroy
      P_B.destroy
      P_A.destroy
   end

   make_roby_ionic_operator(I,roby_atom,spin_case)
   ! constructs the roby/gould ionic operator I_AB = P_A - P_B
   IVEC :: roby_atom
   MAT, PTR :: P_B,P_A
   STR, optional :: spin_case
   MAT :: I
   INT :: a, b, n_a, n_b, n_ab
      a = roby_atom(1)
      b = roby_atom(2)
      n_a = .atom(a).no_of_basis_functions
      n_b = .atom(b).no_of_basis_functions
      n_ab = n_a + n_b
      P_A.create(n_a,n_a)
      P_B.create(n_b,n_b)
      if ( .mult /= 1) then
         .make_roby_projection_matrix(P_A , spin_case,(/a/)  )
         .make_roby_projection_matrix(P_B , spin_case,(/b/)  )
      else
         .make_roby_projection_matrix(P_A , (/a/)  )
         .make_roby_projection_matrix(P_B , (/b/)  )
      end
      I = ZERO
      I(    1:n_a ,     1:n_a ) =  P_A
      I(n_a+1:n_ab, n_a+1:n_ab) = -P_B
      P_A.destroy; P_B.destroy
   end

!-----------------------------------------------!
! Make theta bonding and anti-bonding orbitals  !
!-----------------------------------------------!

   make_gould_theta_orbitals(X,roby_atom,theta,eigenvalues)
   ! For a given operator "X" (either cos theta or sin theta) in the concatenated
   ! AO basis of the atoms in "roby_atom", make the Gould "theta" bonding orbitals 
   ! and corresponding "eigenvalues"
      MAT :: X,theta
      IVEC :: roby_atom
      VEC :: eigenvalues
      MAT, PTR :: XX,XV, SS,SI,SH
      INT :: a,b,n_a,n_b, n_ab
      a = roby_atom(1)
      b = roby_atom(2)
      n_a = .atom(a).no_of_basis_functions
      n_b = .atom(b).no_of_basis_functions
      n_ab = n_a + n_b
      XX.create(n_ab,n_ab); XV.create(n_ab,n_ab)
      SS.create(n_ab,n_ab); SI.create(n_ab,n_ab); SH.create(n_ab,n_ab)
      .make_roby_overlap_matrix(SS,(/a,b/),(/a,b/))
      SH.to_sqrt(SS)
      SI.to_inverse_of(SH)
      X.back_transform(XX,SH)
      XX.solve_eigenproblem(eigenvalues,XV)
      theta.to_product(SI,XV)
      SH.destroy; SI.destroy; SS.destroy
      XV.destroy; XX.destroy
   end

!---------------------------------------!
! Make roby projected densities and NOs !
!---------------------------------------!

   make_roby_projected_density(rho,roby_atom)
   ! Make the Roby-projected density matrix in the concatenated basis 
   ! of AO functions of the atoms in "roby_atoms" and copy it into
   ! a matrix .n_bf x .n_bf, where all other matrix elements not 
   ! corresponding to basis functions in "roby_atoms" are made zero.
      MAT :: rho
      IVEC :: roby_atom
      MAT, PTR :: D,P,rho_W
      INT :: n_bf
      ENSURE(size(rho,1)==.n_bf,"rho has wrong shape")
      ENSURE(size(rho,2)==.n_bf,"rho has wrong shape")
      n_bf = .atom(roby_atom).no_of_basis_functions
      D.create(n_bf,n_bf)
      .roby_overlap_transform( .density_matrix%restricted,D,col_atom=roby_atom)
      P.create(n_bf,n_bf)
      .make_roby_projection_matrix(P,roby_atom)
      rho_W.create(n_bf,n_bf)
      .roby_project(D,rho_W,P) ! rho_W(small) = P_W(small) D(small) P_W(small)
      .AO_subspace_set(rho,rho_W,A_row_atom=roby_atom,A_col_atom=roby_atom)
      rho_W.destroy
      P.destroy
      D.destroy
   end

   make_roby_projected_density(rho,rho_old,roby_atom)
   ! Make the Roby-projected density matrix in the concatenated basis 
   ! of AO functions of the atoms in "roby_atoms" and copy it into
   ! a matrix .n_bf x .n_bf, where all other matrix elements not 
   ! corresponding to basis functions in "roby_atoms" are made zero.
   ! rho_old specifies that the density_matrix to be used is supplied
      MAT :: rho
      IVEC :: roby_atom
      MAT, PTR :: D,P,rho_W, rho_old
      INT :: n_bf
      ENSURE(size(rho,1)==.n_bf,"rho has wrong shape")
      ENSURE(size(rho,2)==.n_bf,"rho has wrong shape")
      n_bf = .atom(roby_atom).no_of_basis_functions
      D.create(n_bf,n_bf)
      .roby_overlap_transform( rho_old,D,col_atom=roby_atom)
      P.create(n_bf,n_bf)
      .make_roby_projection_matrix(P,roby_atom)
      rho_W.create(n_bf,n_bf)
      .roby_project(D,rho_W,P) ! rho_W(small) = P_W(small) D(small) P_W(small)
      .AO_subspace_set(rho,rho_W,A_row_atom=roby_atom,A_col_atom=roby_atom)
      rho_W.destroy
      P.destroy
      D.destroy
   end

   make_roby_projected_density(rho,roby_atom,ANO) 
   ! Make the Roby-projected density matrix in the concatenated basis 
   ! of AO functions of the atoms in "roby_atoms" and copy it into
   ! a matrix .n_bf x .n_bf, where all other matrix elements not 
   ! corresponding to basis functions in "roby_atoms" are made zero.
   ! The orbitals for roby projection are supplied in the ANO matrix
      IVEC :: roby_atom
      MAT :: ANO
      DBL :: pop
      MAT, PTR :: X, D, rho_W, rho
      INT :: n_bf
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      D.create(n_bf,n_bf) 
      .roby_overlap_transform( .density_matrix%restricted,D,col_atom=roby_atom)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      rho_W.create(n_bf,n_bf)
      .roby_project(D,rho_W,X)
      .AO_subspace_set(rho,rho_W,A_row_atom=roby_atom, A_col_atom=roby_atom) 
      rho_W.destroy; D.destroy
      X.destroy
   end

   make_roby_projected_NOs(NOs,roby_atom,ANO) 
   ! Make the Roby-projected natural orbitals.
   ! The orbitals for roby projection are supplied in the ANO matrix
      IVEC :: roby_atom
      MAT :: ANO
      DBL :: pop
      MAT, PTR :: X, D
      OPMAT, PTR :: NOs
      INT :: n_bf
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      D.create( .n_bf, .n_bf)
      .AO_subspace_set(D,X,A_row_atom=roby_atom, A_col_atom=roby_atom)
      NOs%restricted = matmul(D,.natural_orbitals%restricted)
      D.destroy
      X.destroy
   end

!--------------------------------------------!
! Low level routines used all over the place !
!--------------------------------------------!

   read_roby_atom(roby_atom) [leaky]
   ! Reads from the .in file the roby_atom for consideration
      IVEC, PTR :: roby_atom
      INT :: k, n_roby_atom
      n_roby_atom = .in%buffer%n_items - 1
      roby_atom.create(n_roby_atom)
      do k = 1,n_roby_atom
         roby_atom(k) = .in.next_int
      end
   end


   make_roby_overlap_matrix(SS,row_atom,col_atom)
   ! Make an overlap section "SS" from the basis functions of the atoms
   ! specified in "row_atom" and "col_atom".
      MAT :: SS
      IVEC, optional :: row_atom,col_atom
      MAT, PTR :: S
      S.create(.n_bf,.n_bf)
      .get_overlap_matrix(S)
      .AO_subspace_set(SS,S,B_row_atom=row_atom,B_col_atom=col_atom)
      S.destroy
   end

   make_ANO_matrix(ANO,roby_atom)
   ! Make the ANO matrix "ANO" comprised of columns of the occupied atomic natural orbitals,
   ! for each atom whose index appears in "roby_atom".
      MAT :: ANO
      IVEC :: roby_atom
      INT :: n_roby_atom,a, n_bf,n_occ,B,N
      n_roby_atom = size(roby_atom)
      ANO = ZERO
      b = 0; n = 0
      do a = 1,n_roby_atom
         n_bf  = .atom(roby_atom(a)).no_of_basis_functions
         n_occ = .atom(roby_atom(a)).no_of_occupied_NOs(tol=0.05d0)
         ANO(b+1:b+n_bf,n+1:n+n_occ) &
          = .atom(roby_atom(a))%natural_orbitals%restricted(:,1:n_occ)
         b = b + n_bf
         n = n + n_occ
      end      
   end

   make_ANO_matrix(ANO,spin_case,roby_atom)
   ! Make the ANO matrix "ANO" comprised of columns of the occupied atomic natural orbitals,
   ! for each atom whose index appears in "roby_atom".
      MAT :: ANO
      IVEC :: roby_atom
      STR(*) :: spin_case
      INT :: n_roby_atom,a, n_bf,n_occ,B,N
      n_roby_atom = size(roby_atom)
      ANO = ZERO
      b = 0; n = 0
      do a = 1,n_roby_atom
         n_bf  = .atom(roby_atom(a)).no_of_basis_functions
         n_occ = .atom(roby_atom(a)).no_of_occupied_NOs(spin_case,tol=0.05d0)
         select case(spin_case)
            case("alpha"); 
              ANO(b+1:b+n_bf,n+1:n+n_occ) &
                = .atom(roby_atom(a))%natural_orbitals%alpha(:,1:n_occ)
            case("beta");
              ANO(b+1:b+n_bf,n+1:n+n_occ) &
                = .atom(roby_atom(a))%natural_orbitals%beta(:,1:n_occ)
         end 
         b = b + n_bf
         n = n + n_occ
      end      
   end

   roby_project(X,Y,P)
   ! Do: Y = P X P
      MAT :: X,Y,P
      X.change_basis(Y,P)
   end

   roby_overlap_transform(X,Y,row_atom,col_atom)
   ! Do: Y = S(col_atom,row_atom) X S(row_atom,col_atom)
   ! where S(col_atom,row_atom) is the AO subspace section of the full
   ! overlap matrix specified by the basis functions on the atom indices
   ! in "row_atom" and "col_atom".
      MAT :: X,Y
      IVEC, optional :: row_atom, col_atom
      MAT, PTR :: S,SS
      INT :: n_row,n_col
      n_row = .n_bf
      if (present(row_atom)) then
      n_row = .atom(row_atom).no_of_basis_functions
      end
      n_col = .n_bf
      if (present(col_atom)) then
      n_col = .atom(col_atom).no_of_basis_functions
      end
      S.create(.n_bf,.n_bf)
      SS.create(n_row,n_col)
      .get_overlap_matrix(S)
      .AO_subspace_set(SS,S,B_row_atom=row_atom,B_col_atom=col_atom)
      X.change_basis(Y,SS) 
      SS.destroy
      S.destroy
   end

   AO_subspace_set(A,B,A_row_atom,A_col_atom,B_row_atom,B_col_atom)
   ! If either "B_row_atom" or "B_col_atom" is present, then:
   ! Set "A" equal to the AO subspace blocks of "B" specified by the atom 
   ! indices in "B_row_atom" and "B_col_atom". If either is missing,
   ! then copy the entire row. (i.e. A(small) = B(big))
   ! If either "A_row_atom" or "A_col_atom" is present, then:
   ! Set the AO subspace blocks of "A" specified by the atom 
   ! indices in "A_row_atom" and "A_col_atom" equal to "B". If either
   ! "A_row_atom" and "A_col_atom" is missing then copy the entire row.
   ! Uncopied blocks are set to zero. (i.e. A(big) = B(small))
      MAT :: A,B
      IVEC, optional :: A_row_atom,A_col_atom
      IVEC, optional :: B_row_atom,B_col_atom
      INT :: n_row_atoms,n_col_atoms, a1,a2, b1,b2 
      INT :: i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j
      if (present(B_row_atom) OR present(B_col_atom)) then
         ENSURE(size(B,1)==.n_bf,"B has wrong shape")
         ENSURE(size(B,2)==.n_bf,"B has wrong shape")
         if (present(B_row_atom) AND present(B_col_atom)) then
            n_row_atoms = size(B_row_atom)
            n_col_atoms = size(B_col_atom)
            a1 = .atom(B_row_atom).no_of_basis_functions
            a2 = .atom(B_col_atom).no_of_basis_functions
            ENSURE(size(A,1)==a1,   "A has wrong shape")
            ENSURE(size(A,2)==a2,   "A has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(B_row_atom(i))
               l_i = .last_basis_fn_for_atom( B_row_atom(i))
               n_i = .atom(B_row_atom(i)).no_of_basis_functions
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = .first_basis_fn_for_atom(B_col_atom(j))
                  l_j = .last_basis_fn_for_atom( B_col_atom(j))
                  n_j = .atom(B_col_atom(j)).no_of_basis_functions
                  A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)
                  b_j = b_j + n_j
               end 
               b_i = b_i + n_i
            end
         else if (present(B_row_atom)) then
            n_row_atoms = size(B_row_atom)
            a1 = .atom(B_row_atom).no_of_basis_functions
            a2 = .n_bf
            ENSURE(size(A,1)==a1,"A has wrong shape")
            ENSURE(size(A,2)==a2,"A has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(B_row_atom(i));
               l_i = .last_basis_fn_for_atom( B_row_atom(i))
               n_i = .atom(B_row_atom(i)).no_of_basis_functions
               A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)
               b_i = b_i + n_i
            end
         else if (present(B_col_atom)) then
            n_col_atoms = size(B_col_atom)
            a1 = .n_bf
            a2 = .atom(B_col_atom).no_of_basis_functions
            ENSURE(size(A,1)==a1,"A has wrong shape")
            ENSURE(size(A,2)==a2,"A has wrong shape")
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(B_col_atom(j));
               l_j = .last_basis_fn_for_atom( B_col_atom(j))
               n_j = .atom(B_col_atom(j)).no_of_basis_functions
               A(:,b_j+1:b_j+n_j) = B(:,f_j:l_j)
               b_j = b_j + n_j
            end
         end
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      else if (present(A_row_atom) OR present(A_col_atom)) then
         ENSURE(size(A,1)==.n_bf,"A has wrong shape")
         ENSURE(size(A,2)==.n_bf,"A has wrong shape")
         A = ZERO
         if (present(A_row_atom) AND present(A_col_atom)) then
            n_row_atoms = size(A_row_atom)
            n_col_atoms = size(A_col_atom)
            b1 = .atom(A_row_atom).no_of_basis_functions
            b2 = .atom(A_col_atom).no_of_basis_functions
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(A_row_atom(i))
               l_i = .last_basis_fn_for_atom( A_row_atom(i))
               n_i = .atom(A_row_atom(i)).no_of_basis_functions
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = .first_basis_fn_for_atom(A_col_atom(j))
                  l_j = .last_basis_fn_for_atom( A_col_atom(j))
                  n_j = .atom(A_col_atom(j)).no_of_basis_functions
                  A(f_i:l_i,f_j:l_j) = B(b_i+1:b_i+n_i,b_j+1:b_j+n_j) 
                  b_j = b_j + n_j
               end 
               b_i = b_i + n_i
            end
         else if (present(A_row_atom)) then
            n_row_atoms = size(A_row_atom)
            b1 = .atom(A_row_atom).no_of_basis_functions
            b2 = .n_bf
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(A_row_atom(i));
               l_i = .last_basis_fn_for_atom( A_row_atom(i))
               n_i = .atom(A_row_atom(i)).no_of_basis_functions
               A(f_i:l_i,:) = B(b_i+1:b_i+n_i,:)
               b_i = b_i + n_i
            end
         else if (present(A_col_atom)) then
            n_col_atoms = size(A_col_atom)
            b1 = .atom(A_col_atom).no_of_basis_functions
            b2 = .n_bf
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(A_col_atom(j));
               l_j = .last_basis_fn_for_atom( A_col_atom(j))
               n_j = .atom(A_col_atom(j)).no_of_basis_functions
               A(:,f_j:l_j) = B(:,b_j+1:b_j+n_j)
               b_j = b_j + n_j
            end
         end
      else
         DIE("must specify A or B row atoms")
      end
   end

!---------------!
! Dylan's stuff !
!---------------!

!!    dylans_population_analysis
!!    ! Analyse the SCF orbitals into dylans populations
!!       INT :: n_k
!!       MAT, PTR  :: p
!!       VEC, PTR  :: n1
!!       MAT, PTR  :: n2
!!       MAT3, PTR :: n3
!!       TIME :: timer
!!       ENSURE( .density_matrix.created,"need a density matrix")
!!       .out.flush
!!       .out.text("Starting dylans_population_analysis ...")
!!       timer.start
!!       .density_matrix.convert_to("unrestricted",factor=HALF)
!!       .density_matrix%restricted.destroy
!!       .make_natural_orbitals
!!       .atom.make_atom_kind_list( .atom_kind)
!!       .atom.make_atom_kind_map( .atom_kind_map)
!!       n_k = size( .atom_kind)
!!       p.create(.n_atom+1,.n_atom+1)
!!       n1.create(.n_atom)
!!       n2.create(.n_atom,.n_atom)
!!       n3.create(.n_atom,.n_atom,.n_atom)
!!       .make_ANSO_data
!!       .make_dylans_populations(p,n1)
!!       .put_dylans_populations(p,n1)
!! !      .make_dylans_populations(p,n1,n2,n3)
!! !      .put_dylans_populations(p,n1,n2,n3)
!!       n3.destroy; n2.destroy; n1.destroy; p.destroy
!!       .out.put( timer.time_taken("dylans_population_analysis"))
!!    end
!! 
!!    make_dylans_populations(p,n1)
!! !   make_dylans_populations(p,n1,n2,n3,atom_kind_map,NOa,NOb,occa,occb)
!!    ! Make dylans populations, for closed shells only
!!       MAT :: p
!!       VEC  :: n1
!! !      MAT  :: n2
!! !      MAT3 :: n3
!!       INT :: k,a,fa,la,n,na
!!       DBL :: pop
!!       MAT, PTR :: S,D,W,X
!! !     MAT, PTR :: Y
!! !     INT :: b,c,fb,lb,fc,lc,l,m,mm,nb,nc,nabc,nk,nl,nm,nkl,nklm
!! !     DBL :: bot
!! !     VEC, PTR :: lambda
!!       .atom.make_atom_basis_fn_limits( .first, .last)
!!       S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
!!       D.create(.n_bf,.n_bf)
!!       D.from_diagonal(sqrt(.occupation%alpha))
!!       D.back_transform(.natural_orbitals%alpha)
!!       p = ZERO
!!       n = .n_atom+1
!!       p(n,n) = .n_e
!!       n1 = ZERO
!!       do a = 1,.n_atom
!!          k = .atom_kind_map(a)
!!          .out.show("a=",a)
!!          .out.show("k=",k)
!!          fa = .first(a); la = .last(a); na = la-fa+1
!!          X.create(na,na)
!!          X.from_diagonal(sqrt( .atom(a)%occupations%alpha))
!!          X.back_transform( .atom(a)%natural_orbitals%alpha)
!!          W.create(.n_bf,.n_bf)
!!          X.change_basis(W,S(fa:la,:))
!!          pop = W.trace_product_with(D)
!!          X.from_diagonal(sqrt( .atom(a)%occupations%beta))
!!          X.back_transform( .atom(a)%natural_orbitals%beta)
!!          X.change_basis(W,S(fa:la,:))
!!          pop = pop + W.trace_product_with(D)
!!          p(a,a) = .atom(a)%atomic_number
!!          p(a,n) = pop
!!          p(n,a) = pop
!!          n1(a) = pop*pop/p(a,a)
!!          W.destroy
!!          X.destroy
!!       end
!! !     n2 = ZERO
!! !     do k = 1,n_k
!! !     do kk = 1,size(atom_kind(k)%vec) 
!! !     do l = 1,n_k
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        if (a<=b) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !        fa = first(a); la = last(a); na = la-fa+1
!! !        fb = first(b); lb = last(b); nb = lb-fb+1
!! !        nk = size(NO(k)%mat,2)
!! !        nl = size(NO(l)%mat,2)
!! !        nab = na + nb
!! !        nkl = nk + nl
!! !        lambda.create(nkl)
!! !        lambda(   1:nk ) = sqrt(occ(k)%vec)
!! !        lambda(nk+1:nkl) = sqrt(occ(l)%vec)
!! !        W.create(nab,nkl)
!! !        W = ZERO
!! !        W(   1:na ,   1:nk ) = NO(k)%mat
!! !        W(na+1:nab,nk+1:nkl) = NO(l)%mat
!! !        Y.create(nab,nab)
!! !        Y(   1:na ,   1:na ) = S(fa:la,fa:la)
!! !        Y(na+1:nab,na+1:nab) = S(fb:lb,fb:lb)
!! !        Y(na+1:nab,   1:na ) = S(fb:lb,fa:la)
!! !        Y(   1:na ,na+1:nab) = S(fa:la,fb:lb)
!! !        X.create(nkl,nkl)
!! !        Y.change_basis(X,W)
!! !        Y.destroy
!! !        Y.create(nkl,nkl)
!! !        Y.to_inverse_of(X)  ! Y = S^-1
!! !        X.destroy
!! !        X.create(nkl,nkl)
!! !        X.to_product_with_diagonal(lambda,Y)
!! !        Y.destroy
!! !        Y.create(nab,nab)
!! !        X.back_transform(Y,W)
!! !        X.destroy
!! !        W.destroy
!! !        W.create(.n_bf,.n_bf)
!! !        X.create(nab,.n_bf)
!! !        X(   1:na ,:) = S(fa:la,:)
!! !        X(na+1:nab,:) = S(fb:lb,:)
!! !        Y.change_basis(W,X)
!! !        W = transpose(W)
!! !        pop = W.trace_product_with(.density_matrix%restricted)
!! !        bot = W.trace_product_with(X)
!! !        pop = pop*pop/bot
!! !        n2(a,b) = pop
!! !        n2(b,a) = pop
!! !        X.destroy
!! !        W.destroy
!! !        Y.destroy
!! !        lambda.destroy
!! !     end
!! !     end
!! !     end
!! !     end
!! !     n3 = ZERO
!! !     do k = 1,n_k
!! !     do kk = 1,size(atom_kind(k)%vec) 
!! !     do l = 1,n_k
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !     do m = 1,n_k
!! !     do mm = 1,size(atom_kind(m)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        c = atom_kind(m)%vec(mm)
!! !        if (a<=b OR b<=c) cycle
!! !      ! if (a==b OR b==c OR c==a) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !      ! if ( .atom.not_bonded(b,c)) cycle
!! !        fa = first(a); la = last(a); na = la-fa+1
!! !        fb = first(b); lb = last(b); nb = lb-fb+1
!! !        fc = first(c); lc = last(c); nc = lc-fc+1
!! !        nk = size(NO(k)%mat,2)
!! !        nl = size(NO(l)%mat,2)
!! !        nm = size(NO(m)%mat,2)
!! !        nabc = na + nb + nc
!! !        nklm = nk + nl + nm
!! !        lambda.create(nkl)
!! !        lambda(      1:nk   ) = sqrt(occ(k)%vec)
!! !        lambda(nk   +1:nk+nl) = sqrt(occ(l)%vec)
!! !        lambda(nk+nl+1:nklm ) = sqrt(occ(m)%vec)
!! !        W.create(nabc,nklm)
!! !        W = ZERO
!! !        W(      1:na   ,      1:nk   ) = NO(k)%mat
!! !        W(na   +1:na+nb,nk   +1:nk+nl) = NO(l)%mat
!! !        W(na+nb+1:nabc ,nk+nl+1:nklm ) = NO(m)%mat
!! !        Y.create(nabc,nabc)
!! !        Y(      1:na   ,      1:na   ) = S(fa:la,fa:la)
!! !        Y(na   +1:na+nb,na   +1:na+nb) = S(fb:lb,fb:lb)
!! !        Y(na+nb+1:nabc ,na+nb+1:nabc ) = S(fc:lc,fc:lc)
!! !        Y(na+1:nab,   1:na ) = S(fb:lb,fa:la)
!! !        Y(   1:na ,na+1:nab) = S(fa:la,fb:lb)
!! !        Y(na+nb+1:nabc,      1:na  ) = S(fc:lc,fa:la)
!! !        Y(      1:na  ,na+nb+1:nabc) = S(fa:la,fc:lc)
!! !        Y(na+nb+1:nabc ,na   +1:na+nb) = S(fc:lc,fb:lb)
!! !        Y(na   +1:na+nb,na+nb+1:nabc ) = S(fb:lb,fc:lc)
!! !        X.create(nklm,nklm)
!! !        Y.change_basis(X,W)
!! !        Y.destroy
!! !        Y.create(nklm,nklm)
!! !        Y.to_inverse_of(X)  ! Y = S^-1
!! !        X.destroy
!! !        X.create(nklm,nklm)
!! !        X.to_product_with_diagonal(lambda,Y)
!! !        Y.destroy
!! !        Y.create(nabc,nabc)
!! !        X.back_transform(Y,W)
!! !        X.destroy
!! !        W.destroy
!! !        W.create(.n_bf,.n_bf)
!! !        X.create(nabc,.n_bf)
!! !        X(      1:na   ,:) = S(fa:la,:)
!! !        X(na   +1:na+nb,:) = S(fb:lb,:)
!! !        X(na+nb+1:nabc ,:) = S(fc:lc,:)
!! !        Y.change_basis(W,X)
!! !        W = transpose(W)
!! !        pop = W.trace_product_with(.density_matrix%restricted)
!! !        bot = W.trace_product_with(X)
!! !        pop = pop*pop/bot
!! !        n3(a,b,c) = pop
!! !        n3(a,c,b) = pop
!! !        n3(b,a,c) = pop
!! !        n3(b,c,a) = pop
!! !        n3(c,a,b) = pop
!! !        n3(c,b,a) = pop
!! !        X.destroy
!! !        W.destroy
!! !        Y.destroy
!! !        lambda.destroy
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!!       D.destroy
!!       S.destroy
!!    end
!! 
!!    put_dylans_populations(p,n1)
!! !   put_dylans_populations(p,n1,n2,n3,atom_kind)
!!    ! Put .out the roby populations
!!       MAT :: p
!!       VEC  :: n1
!! !      MAT  :: n2
!! !      MAT3 :: n3
!!       INT :: k,kk,a,b
!!       STR :: symbol_a,symbol_b
!! !     INT :: l,m,ll,mm,c
!! !     STR :: symbol_c
!!       .out.flush
!!       .out.text("Dylan's population analysis",flush=2)
!!       .out.text("Pair overlaps (last atom is the molecule itself):",flush=2)
!!       .out.dash(int_fields=2,dbl_fields=1)
!!       .out.put("Atom_a",int_width=TRUE)
!!       .out.put("Atom_b",int_width=TRUE)
!!       .out.put("p_ab",flush=1)
!!       .out.dash(int_fields=2,dbl_fields=1)
!!       do a = 1,.n_atom+1
!!       do b = 1,a-1
!!        ! if ( .atom.not_bonded(a,b)) cycle
!!          if (a==.n_atom+1) then; symbol_a = "M"
!!          else; symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!!          end
!!          symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
!!          .out.put(symbol_a,int_width=TRUE)
!!          .out.put(symbol_b,int_width=TRUE)
!!          .out.put(p(a,b))
!!          .out.flush
!!       end
!!       end
!!       .out.dash(int_fields=2,dbl_fields=1)
!!       .out.text("Dylan's atomic populations",flush=2)
!!       .out.dash(int_fields=1,dbl_fields=1)
!!       .out.put("Atom",int_width=TRUE)
!!       .out.put("Population",flush=1)
!!       .out.dash(int_fields=1,dbl_fields=1)
!!       do k = 1,size( .atom_kind)
!!       do kk = 1,size( .atom_kind(k)%vec)
!!          a = .atom_kind(k)%vec(kk)
!!          symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!!          .out.put(symbol_a,int_width=TRUE)
!!          .out.put(n1(a))
!!          .out.flush
!!       end
!!       end
!!       .out.dash(int_fields=1,dbl_fields=1)
!! !     .out.flush
!! !     .out.text("Pair populations:",flush=2)
!! !     .out.dash(int_fields=2,dbl_fields=2)
!! !     .out.put("Atom_a",int_width=TRUE)
!! !     .out.put("Atom_b",int_width=TRUE)
!! !     .out.put("n_ab")
!! !     .out.put("s_ab",flush=1)
!! !     .out.dash(int_fields=2,dbl_fields=2)
!! !     do k = 1,size(atom_kind)
!! !     do kk = 1,size(atom_kind(k)%vec)
!! !     do l = 1,size(atom_kind)
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        if (a==b) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !        symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!! !        symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
!! !        .out.put(symbol_a,int_width=TRUE)
!! !        .out.put(symbol_b,int_width=TRUE)
!! !        .out.put(n2(a,b))
!! !        .out.put(n1(a)+n1(b)-n2(a,b))
!! !        .out.flush
!! !     end
!! !     end
!! !     end
!! !     end
!! !     .out.dash(int_fields=2,dbl_fields=2)
!! !     .out.flush
!! !     .out.text("Triple populations:",flush=2)
!! !     .out.dash(int_fields=3,dbl_fields=2)
!! !     .out.put("Atom_a",int_width=TRUE)
!! !     .out.put("Atom_b",int_width=TRUE)
!! !     .out.put("Atom_c",int_width=TRUE)
!! !     .out.put("n_abc")
!! !     .out.put("s_abc",flush=1)
!! !     .out.dash(int_fields=3,dbl_fields=2)
!! !     do k = 1,size(atom_kind)
!! !     do kk = 1,size(atom_kind(k)%vec)
!! !     do l = 1,size(atom_kind)
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !     do m = 1,size(atom_kind)
!! !     do mm = 1,size(atom_kind(m)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        c = atom_kind(m)%vec(mm)
!! !        if (a==b OR b==c OR c==a) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !      ! if ( .atom.not_bonded(b,c)) cycle
!! !        symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!! !        symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
!! !        symbol_c = .atom(c).chemical_symbol.trim // " (" // c.to_str.trim // ")"
!! !        .out.put(symbol_a,int_width=TRUE)
!! !        .out.put(symbol_b,int_width=TRUE)
!! !        .out.put(symbol_c,int_width=TRUE)
!! !        .out.put(n3(a,b,c))
!! !        .out.put(n1(a)+n1(b)+n1(c)-n2(a,b)-n2(b,c)-n2(c,a)+n3(a,b,c))
!! !        .out.flush
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!! !     .out.dash(int_fields=3,dbl_fields=2)
!!    end

end 

