!-------------------------------------------------------------------------------
!
! MOL: roby population analysis routines.
!
! $Id$
!
! (c) chris taylor, uwa, 1999.
!-------------------------------------------------------------------------------
module MOL_ROBY

   use TYPES
   use ERROR
   use MM
   use TIME

   use STR
   use INT
   use DBL
   use BUFFER

   use IVEC
   use IVECVEC
   use VEC
   use VECVEC
   use MAT
   use MATVEC
   use OPVEC
   use OPMAT

   use INPUT
   use OUTPUT
   use ARCHIVE

   use ATOM
   use ATOMVEC

   use SCFDATA

   use MOL_COMMON
   use MOL_INTEGRALS
   use MOL_XTAL
   use MOL_IO
   use MOL_SCF
   use MOL_PLOT

   implicit none         

#  include "macros"
#  include "mol_roby.int"

contains

   prepare_roby_data  [leaky]
   ! Provides the preliminary data required to do the Roby population analysis
      if ( .mult /= 1) then; .make_ANSO_data
      else;                  .make_ANO_data
      end
   end

   make_ANO_data [leaky]
   ! Prepare the restricted atomic natural orbital (ANO) data 
      INT :: k,u,n_no, j
      MOL, PTR :: mol
      BIN :: output
      output = TRUE
      do k = 1,.n_atom_kind ! Do an SCF for every different kind of atom
         mol.create
         u = .unique_atom(k)
         .make_molecule_from_atom(u,mol)
         mol%scfdata%output = FALSE
         mol.scf
         mol.make_ao_density_matrix
         mol%pointgroup.create("oh")
         mol.symmetrise(mol%density_matrix)
         mol.make_natural_orbitals
         .atom(u)%natural_orbitals => mol%natural_orbitals
         .atom(u)%occupation       => mol%occupation
         do j = u+1,.n_atom
            if (.atom_kind(j)/=k) cycle
            .atom(j)%natural_orbitals => .atom(u)%natural_orbitals
            .atom(j)%occupation       => .atom(u)%occupation
         end
         mol%atom.nullify_ptr_part     ! do not destroy these
         nullify(mol%natural_orbitals) ! do not destroy this
         nullify(mol%occupation)       ! do not destroy this
         nullify(mol%basis)            ! do not destroy this
         mol.destroy
         if (NOT output) cycle
         n_no = .atom(u)%occupation%restricted.no_of_elements_larger_than(0.05d0)
         .out.show("n_no=",n_no)
         .atom(u).put_natural_orbitals(.out)
      end
   end

   make_ANSO_data [leaky]
   ! Prepare the unrestricted atomic natural spin orbital (ASNO) data 
      INT :: k,u,a
      MOL, PTR :: mol
      BIN :: output
      output = TRUE
      do k = 1,.n_atom_kind ! Do an SCF for every different kind of atom
         mol.create
         u = .unique_atom(k)
         .make_molecule_from_atom(u,mol)
         mol%scfdata%output = FALSE
         mol.scf
         mol%density_matrix.convert_to("unrestricted",factor=HALF)
         mol%density_matrix%restricted.destroy
         mol%pointgroup.create("oh")
         mol.symmetrise(mol%density_matrix)
         mol.make_natural_orbitals
         .atom(u)%natural_orbitals => mol%natural_orbitals
         .atom(u)%occupation       => mol%occupation
         do a = u+1,.n_atom
            if (.atom_kind(a)/=k) cycle
            .atom(a)%natural_orbitals => .atom(u)%natural_orbitals
            .atom(a)%occupation       => .atom(u)%occupation
         end
         mol%atom.nullify_ptr_part     ! do not destroy these
         nullify(mol%natural_orbitals) ! do not destroy this
         nullify(mol%occupation)       ! do not destroy this
         nullify(mol%basis)            ! do not destroy this
         mol.destroy
         if (NOT output) cycle
         .atom(u).put_natural_orbitals(.out)
      end
   end
   
   roby_population_analysis
   ! Do a Roby population analysis of a molecule
   VEC, PTR :: n1, less
   MAT, PTR :: n2
   INT :: n_atom, n_bf, i, j, o_no
   MAT, PTR :: index, cov
   DBL :: bi, c, d1, d2
   STR :: word
      .prepare_roby_data
      n_atom = .n_atom
      n1.create(n_atom)           ! Roby populations
      less.create(n_atom)         ! ?
      less = ZERO
      n2.create(n_atom,n_atom)    ! Roby pair populations
      index.create(n_atom,n_atom) !
      cov.create(n_atom,n_atom)   !
      do i = 1,n_atom
         n1(i) = .roby_population((/i/)) 
      end
      do i = 1,n_atom
      do j = 1,i-1
         n2(i,j) = .roby_population((/i,j/)) 
         index(i,j) = .roby_gould_bond_index((/i,j/), d1, d2, cov(i,j)) 

         less(i) = (n1(i) + n1(j) - n2(i,j))*(d2/(d1+d2)) + less(i)
         less(j) = less(j) + (n1(i) + n1(j) -n2(i,j))*(d1/(d1+d2))

      end
      end

      .put_roby_populations( n1, n2, index, cov)
!
!      read_loop: do
!         .in.read(word)
!         select case(word)
!            case("end");        exit read_loop
!            case("bond");       .read_atoms_to_bond(i, j)
!                bi = .roby_gould_bond_index((/i,j/), d1,d2, c)
!                .out.put("Atoms"// trim( i.to_str) // "and" // trim( j.to_str))
!                .out.flush
!                .out.put("Bond index:"); .out.put(bi); .out.flush
!                .out.put("%Covalency:"); .out.put(c); .out.flush
!            case("plot_theta_c"); 
!                o_no = .in%buffer.get_item.to_int
!                .plot_theta_orbitals( orb_type="covalent_orbitals", orb_no=o_no)
!            case("plot_theta_i");
!                o_no = .in%buffer.get_item.to_int
!                .plot_theta_orbitals( orb_type="ionic_orbitals", orb_no=o_no)
!            case("shared");     .read_atoms_to_share( S)
!            case("plot_density"); .plot_subspace_density( S)
!            case("plot_diff");    .plot_density_difference( S)
!            case("energy");     
!               .read_shared_energy_atoms( S)
!         end
!      end do read_loop
      n1.destroy; n2.destroy; less.destroy 
      cov.destroy; index.destroy
   end

   put_roby_populations(n1, n2, index, covalency)
   ! Put .out the Roby population analysis data
      VEC  :: n1
      ! charge = fitted excess charge
      ! charge2 =  roby_gould charge
      ! charge3 = equally distributed charge
      ! charge4 = fitted equally distributed charge
      ! charge5 = proportionate fitin gto Roby Gould charge
      VEC, PTR :: charge, charge2, charge3, charge4, charge5
      MAT, PTR :: index, covalency
      DBL :: polarization, polarization2, sum_n
      MAT  :: n2
      INT :: k,l,kk,ll,a,b
      STR :: symbol_a,symbol_b
      .out.flush
      .out.text("Roby populations:",flush=2)
      .out.dash(int_fields=1,dbl_fields=1)
      .out.put("Atom",int_width=TRUE)
      .out.put("Population")
      .out.dash(int_fields=1,dbl_fields=1)
      do a = 1,.n_atom
         symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
         .out.put( symbol_a,int_width=TRUE)
         .out.put( n1(a))
         .out.flush
      end
      .out.dash(int_fields=1,dbl_fields=1)
      !
      .out.flush
      .out.text("Roby pair populations:",flush=2)
      .out.dash(int_fields=1,dbl_fields=3)
      .out.flush
      .out.dash(int_fields=2,dbl_fields=4)
      .out.put("Atom_a",int_width=TRUE)
      .out.put("Atom_b",int_width=TRUE)
      .out.put("n_ab")
      .out.put("s_ab")
      .out.put("Bond Index")
      .out.put("% Covalency",flush=1)
      .out.dash(int_fields=2,dbl_fields=4)
      do a = 1,.n_atom
      do b = 1,a-1
         symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
         symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
         .out.put(symbol_a,int_width=TRUE)
         .out.put(symbol_b,int_width=TRUE)
         .out.put(n2(a,b))
         .out.put(n1(a)+n1(b)-n2(a,b))
         .out.put(index(a,b))
         .out.put(covalency(a,b))
         .out.flush
      end
      end
      .out.dash(int_fields=2,dbl_fields=4)
   end

   roby_population(roby_atom) result (pop) 
   ! Return the (total) Roby population for the group of atoms whose
   ! indices are given in "roby_atom".
      IVEC :: roby_atom
      DBL :: pop
      MAT, PTR :: X,Y
      INT :: n_bf,i
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      Y.create(.n_bf, .n_bf)
      .make_roby_projection_matrix(X,roby_atom)
      .roby_overlap_transform(X,Y,roby_atom)
      pop = Y.trace_product_with( .density_matrix%restricted)
      Y.destroy
      X.destroy
   end

   roby_population(roby_atom,ANO) result (pop) 
   ! Return the (total) Roby population for the group of atoms whose
   ! indices are given in "roby_atom" and for which the roby projection
   ! operator orbitals are defined by columns of "ANO"
      IVEC :: roby_atom
      MAT :: ANO
      DBL :: pop
      MAT, PTR :: X,Y
      INT :: n_bf
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      Y.create(.n_bf, .n_bf)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      .roby_overlap_transform(X,Y,roby_atom)
      pop = Y.trace_product_with( .density_matrix%restricted)
      Y.destroy
      X.destroy
   end

   roby_population(roby_atom,ANO,atom) result (pop) 
   ! Return the (total) Roby population for atom "atom" of the group of atoms whose
   ! indices are given in "roby_atom" and for which the roby projection operator 
   ! orbitals are defined by columns of "ANO"
      IVEC :: roby_atom
      MAT :: ANO
      INT :: atom
      DBL :: pop
      MAT, PTR :: X,Y,PA,Z,W
      INT :: n_bf,n_af
      n_bf = .atom(roby_atom).no_of_basis_functions
      n_af = .atom(roby_atom(atom)).no_of_basis_functions
      X.create(n_bf, n_bf)
      Y.create(n_af, n_af)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      .roby_overlap_transform(X,Y,roby_atom,roby_atom(atom:atom))
      PA.create(n_af,n_af)
      .make_roby_projection_matrix(PA,roby_atom(atom:atom))
      Z.create(n_af,n_af)
      .roby_project(Y,Z,PA)
      W.create(.n_bf,.n_bf)
      .roby_overlap_transform(Z,W,roby_atom(atom:atom))
      pop = W.trace_product_with( .density_matrix%restricted)
      W.destroy
      Z.destroy
      PA.destroy
      Y.destroy
      X.destroy
   end

   make_roby_projection_matrix(P,roby_atom)
   ! Make the Roby projection matrix in the AO basis made from the concatenated 
   ! basis sets for each atom in "roby_atom"
      MAT :: P
      IVEC :: roby_atom
      STR :: kind
      MAT, PTR :: W,X,Y
      INT :: n_roby_atom, n_occ,n_bf
      n_bf  = .atom(roby_atom).no_of_basis_functions
      ENSURE(size(P,1)==n_bf,"P is incorrectly dimensioned")
      ENSURE(size(P,2)==n_bf,"P is incorrectly dimensioned")
      n_occ = .atom(roby_atom).no_of_occupied_ANOs(tol=0.05d0)
      n_roby_atom = size(roby_atom)
      W.create(n_bf,n_occ)                   ! W = columns of ANO's
      .make_ANO_matrix(W,roby_atom)          
      Y.create(n_bf,n_bf)                    ! Y = overlap matrix for roby_atoms(:) basis
      .make_roby_overlap_matrix(Y,roby_atom,roby_atom) 
      X.create(n_occ,n_occ)
      Y.change_basis(X,W)                    ! X = S in the ANO basis
      Y.destroy
      Y.create(n_occ,n_occ)
      Y.to_inverse_of(X)                     ! Y = (ANO overlap matrix)^{-1}
      X.destroy
      Y.back_transform(P,W)                  ! P = Y in the roby_atom(:) AO basis
      Y.destroy
      W.destroy
   end

   make_roby_projection_matrix(P,roby_atom,ANO)
   ! Make the Roby projection matrix in the AO basis made from the concatenated 
   ! basis sets for each atom in "roby_atom" using the columns of "ANO" as 
   ! orbital coefficients to form the projection operator.
      MAT :: P
      IVEC :: roby_atom
      MAT :: ANO
      STR :: kind
      MAT, PTR :: W,X,Y
      INT :: n_roby_atom, n_occ,n_bf
      n_bf  = .atom(roby_atom).no_of_basis_functions
      ENSURE(size(P,1)==n_bf,  "P is incorrectly dimensioned")
      ENSURE(size(P,2)==n_bf,  "P is incorrectly dimensioned")
      ENSURE(size(ANO,1)==n_bf,"ANO is incorrectly dimensioned")
      n_occ = size(ANO,2)
      n_roby_atom = size(roby_atom)
      W.create(n_bf,n_occ)                   ! W = columns of ANO's
      W = ANO                                
      Y.create(n_bf,n_bf)                    ! Y = overlap matrix for roby_atoms(:) basis
      .make_roby_overlap_matrix(Y,roby_atom,roby_atom) 
      X.create(n_occ,n_occ)
      Y.change_basis(X,W)                    ! X = S in the ANO basis
      Y.destroy
      Y.create(n_occ,n_occ)
      Y.to_inverse_of(X)                     ! Y = (ANO overlap matrix)^{-1}
      X.destroy
      Y.back_transform(P,W)                  ! P = Y in the roby_atom(:) AO basis
      Y.destroy
      W.destroy
   end

   make_roby_overlap_matrix(SS,row_atom,col_atom)
   ! Make an overlap section "SS" from the basis functions of the atoms
   ! specified in "row_atom" and "col_atom".
      MAT :: SS
      IVEC, optional :: row_atom,col_atom
      MAT, PTR :: S
      S.create(.n_bf,.n_bf)
      .get_overlap_matrix(S)
      .AO_subspace_set(SS,S,B_row_atom=row_atom,B_col_atom=col_atom)
      S.destroy
   end

   make_ANO_matrix(ANO,roby_atom)
   ! Make the ANO matrix "ANO" comprised of columns of the occupied atomic natural orbitals,
   ! for each atom whose index appears in "roby_atom".
      MAT :: ANO
      IVEC :: roby_atom
      INT :: n_roby_atom,a, n_bf,n_occ,B,N
      n_roby_atom = size(roby_atom)
      b = 0; n = 0
      do a = 1,n_roby_atom
         n_bf  = .atom(roby_atom(a)).no_of_basis_functions
         n_occ = .atom(roby_atom(a)).no_of_occupied_NOs(tol=0.05d0)
         ANO(b+1:b+n_bf,n+1:n+n_occ) &
          = .atom(roby_atom(a))%natural_orbitals%restricted(:,1:n_occ)
         b = b + n_bf
         n = n + n_occ
      end      
   end

   roby_gould_bond_index(roby_atom, d1, d2, covalent_index) result(bond_index)
   ! Calculates the Roby-Gould bond index for two atoms
      IVEC :: roby_atom
      DBL :: d1,d2,covalent_index,bond_index
      MAT, PTR :: P_A, P_B, P_AB
      MAT, PTR :: C, theta_c, S, theta_s
      VEC, PTR :: cos_eigenvalue, c_m, sin_eigenvalue, s_m
      VEC, PTR :: covalency, ionicity, c_a, c_b
      IVEC, PTR :: c_pair, s_pair
      DBL :: total_c, total_i
      INT :: n_a, n_b, n_ab, i, j, a, b
      ENSURE(size(roby_atom)==2,"roby_atom has wrong size")
      a = roby_atom(1)
      b = roby_atom(2)
      n_a = .atom(a).no_of_basis_functions
      n_b = .atom(b).no_of_basis_functions
      n_ab = n_a + n_b
      C.create(n_ab,n_ab); theta_c.create(n_ab, n_ab); cos_eigenvalue.create(n_ab)
      S.create(n_ab, n_ab); theta_s.create(n_ab, n_ab); sin_eigenvalue.create(n_ab)
      P_A.create(n_a,n_a); P_B.create(n_b,n_b); P_AB.create(n_ab,n_ab)
      .make_roby_projection_matrix(P_A ,(/a/)  )
      .make_roby_projection_matrix(P_B ,(/b/)  )
      .make_roby_projection_matrix(P_AB,(/a,b/))
      C = ZERO
      C(    1:n_a ,     1:n_a ) =  P_A
      C(n_a+1:n_ab, n_a+1:n_ab) =  P_B
      C = C - P_AB
      P_AB.destroy
      .make_gould_theta_orbitals(C,roby_atom,theta_c,cos_eigenvalue)
      S = ZERO
      S(    1:n_a ,     1:n_a ) =  P_A
      S(n_a+1:n_ab, n_a+1:n_ab) = -P_B
      .make_gould_theta_orbitals(S,roby_atom,theta_s,sin_eigenvalue)
      P_A.destroy
      P_B.destroy
    ! .archive_orbitals( theta_c, theta_s, a, b)
      c_pair.create(n_ab); s_pair.create(n_ab)
      cos_eigenvalue.find_opposite_pairs(c_pair,TOL(5),ONE-TOL(5))
      sin_eigenvalue.find_opposite_pairs(s_pair,TOL(5),ONE-TOL(5))
      c_m.create(n_ab); s_m.create(n_ab)
      c_a.create(n_ab); c_b.create(n_ab)
      do i = 1, n_ab 
        c_m(i) = .roby_population(roby_atom,theta_c(:,i:i)) 
        s_m(i) = .roby_population(roby_atom,theta_s(:,i:i)) 
        c_a(i) = .roby_population(roby_atom,theta_c(:,i:i),1) 
        c_b(i) = .roby_population(roby_atom,theta_c(:,i:i),2) 
      end
      covalency.create(n_ab); ionicity.create( n_ab)
      d1 = 0; d2 = 0
      .out.flush
      .out.dash(int_fields=1, dbl_fields=3)
      .out.put("Bond Index Data: "); .out.flush
      .out.put( .atom(a)%label.trim // " and " // .atom(b)%label.trim ); .out.flush
      .out.dash(int_fields=1, dbl_fields=3)
      .out.put("Orbital Angles")
      .out.put("Theta+ Popn")
      .out.put("Theta- Popn")
      .out.flush
      .out.dash(int_fields=1, dbl_fields=3)
      do i = 1, n_ab
         if (c_pair(i) <= 0) then
           covalency(i) = 0
         else
           covalency(i) = (c_m(i) - c_m(c_pair(i)))/2
           d1 = d1 + c_a(i) + c_a(c_pair(i))
           d2 = d2 + c_b(i) + c_b(c_pair(i))
           .out.put_int( i)
           .out.put_dbl( 180 * cos_eigenvalue(i).arccos / PI)
           .out.put( c_m(i)); .out.put( c_m(c_pair(i)))
           .out.flush
         end
      end
      .out.dash(int_fields = 1, dbl_fields = 3)
      do i = 1, n_ab
         if (s_pair(i) == 0) then
           ionicity(i) = 0
         else if (s_pair(i) < 0) then
           ionicity(i) = 0
         else
           ionicity(i) = (s_m(i) - s_m(s_pair(i)))/2
         end
      end      
      total_i = sum(ionicity) 
      total_c = sum(covalency)
      bond_index = sqrt(total_i**2 + total_c**2)
      covalent_index = (total_c/bond_index)**2
      ionicity.destroy; covalency.destroy
      C.destroy; theta_c.destroy; cos_eigenvalue.destroy; 
      S.destroy; theta_s.destroy; sin_eigenvalue.destroy
      c_m.destroy; c_pair.destroy; c_b.destroy
      s_m.destroy; s_pair.destroy; c_a.destroy; 
   end   

   make_gould_theta_orbitals(X,roby_atom,theta,eigenvalues)
   ! For a given operator "X" (either cos theta or sin theta) in the concatenated
   ! AO basis of the atoms in "roby_atom", make the Gould "theta" bonding orbitals 
   ! and corresponding "eigenvalues"
      MAT :: X,theta
      IVEC :: roby_atom
      VEC :: eigenvalues
      MAT, PTR :: XX,XV, SS,SI,SH
      INT :: a,b,n_a,n_b, n_ab
      a = roby_atom(1)
      b = roby_atom(2)
      n_a = .atom(a).no_of_basis_functions
      n_b = .atom(b).no_of_basis_functions
      n_ab = n_a + n_b
      XX.create(n_ab,n_ab); XV.create(n_ab,n_ab)
      SS.create(n_ab,n_ab); SI.create(n_ab,n_ab); SH.create(n_ab,n_ab)
      .make_roby_overlap_matrix(SS,(/a,b/),(/a,b/))
      SH.to_sqrt(SS)
      SI.to_inverse_of(SH)
      X.back_transform(XX,SH)
      XX.solve_eigenproblem(eigenvalues,XV)
      theta.to_product(SI,XV)
      SH.destroy; SI.destroy; SS.destroy
      XV.destroy; XX.destroy
   end

   roby_project(X,Y,P)
   ! Do: Y = P X P
      MAT :: X,Y,P
      X.change_basis(Y,P)
   end

   roby_overlap_transform(X,Y,row_atom,col_atom)
   ! Do: Y = S(col_atom,row_atom) X S(row_atom,col_atom)
   ! where S(col_atom,row_atom) is the AO subspace section of the full
   ! overlap matrix specified by the basis functions on the atom indices
   ! in "row_atom" and "col_atom".
      MAT :: X,Y
      IVEC, optional :: row_atom, col_atom
      MAT, PTR :: S,SS
      INT :: n_row,n_col
      n_row = .n_bf
      if (present(row_atom)) then
      n_row = .atom(row_atom).no_of_basis_functions
      end
      n_col = .n_bf
      if (present(col_atom)) then
      n_col = .atom(col_atom).no_of_basis_functions
      end
      S.create(.n_bf,.n_bf)
      SS.create(n_row,n_col)
      .get_overlap_matrix(S)
      .AO_subspace_set(SS,S,B_row_atom=row_atom,B_col_atom=col_atom)
      X.change_basis(Y,SS) 
      SS.destroy
      S.destroy
   end

   AO_subspace_set(A,B,A_row_atom,A_col_atom,B_row_atom,B_col_atom)
   ! If either "B_row_atom" or "B_col_atom" is present, then:
   ! Set "A" equal to the AO subspace blocks of "B" specified by the atom 
   ! indices in "B_row_atom" and "B_col_atom". If either is missing,
   ! then copy the entire row. (i.e. A(small) = B(big))
   ! If either "A_row_atom" or "A_col_atom" is present, then:
   ! Set the AO subspace blocks of "A" specified by the atom 
   ! indices in "A_row_atom" and "A_col_atom" equal to "B". If either
   ! "A_row_atom" and "A_col_atom" is missing then copy the entire row.
   ! Uncopied blocks are set to zero. (i.e. A(big) = B(small))
      MAT :: A,B
      IVEC, optional :: A_row_atom,A_col_atom
      IVEC, optional :: B_row_atom,B_col_atom
      INT :: n_row_atoms,n_col_atoms, a1,a2, b1,b2 
      INT :: i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j
      if (present(B_row_atom) OR present(B_col_atom)) then
         ENSURE(size(B,1)==.n_bf,"B has wrong shape")
         ENSURE(size(B,2)==.n_bf,"B has wrong shape")
         if (present(B_row_atom) AND present(B_col_atom)) then
            n_row_atoms = size(B_row_atom)
            n_col_atoms = size(B_col_atom)
            a1 = .atom(B_row_atom).no_of_basis_functions
            a2 = .atom(B_col_atom).no_of_basis_functions
            ENSURE(size(A,1)==a1,   "A has wrong shape")
            ENSURE(size(A,2)==a2,   "A has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(B_row_atom(i))
               l_i = .last_basis_fn_for_atom( B_row_atom(i))
               n_i = .atom(B_row_atom(i)).no_of_basis_functions
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = .first_basis_fn_for_atom(B_col_atom(j))
                  l_j = .last_basis_fn_for_atom( B_col_atom(j))
                  n_j = .atom(B_col_atom(j)).no_of_basis_functions
                  A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)
                  b_j = b_j + n_j
               end 
               b_i = b_i + n_i
            end
         else if (present(B_row_atom)) then
            n_row_atoms = size(B_row_atom)
            a1 = .atom(B_row_atom).no_of_basis_functions
            a2 = .n_bf
            ENSURE(size(A,1)==a1,"A has wrong shape")
            ENSURE(size(A,2)==a2,"A has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(B_row_atom(i));
               l_i = .last_basis_fn_for_atom( B_row_atom(i))
               n_i = .atom(B_row_atom(i)).no_of_basis_functions
               A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)
               b_i = b_i + n_i
            end
         else if (present(B_col_atom)) then
            DIE("not implemented yet")
         end
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      else if (present(A_row_atom) OR present(A_col_atom)) then
         ENSURE(size(A,1)==.n_bf,"A has wrong shape")
         ENSURE(size(A,2)==.n_bf,"A has wrong shape")
         A = ZERO
         if (present(A_row_atom) AND present(A_col_atom)) then
            n_row_atoms = size(A_row_atom)
            n_col_atoms = size(A_col_atom)
            b1 = .atom(A_row_atom).no_of_basis_functions
            b2 = .atom(A_col_atom).no_of_basis_functions
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(A_row_atom(i))
               l_i = .last_basis_fn_for_atom( A_row_atom(i))
               n_i = .atom(A_row_atom(i)).no_of_basis_functions
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = .first_basis_fn_for_atom(A_col_atom(j))
                  l_j = .last_basis_fn_for_atom( A_col_atom(j))
                  n_j = .atom(A_col_atom(j)).no_of_basis_functions
                  A(f_i:l_i,f_j:l_j) = B(b_i+1:b_i+n_i,b_j+1:b_j+n_j) 
                  b_j = b_j + n_j
               end 
               b_i = b_i + n_i
            end
         else if (present(A_row_atom)) then
            n_row_atoms = size(A_row_atom)
            b1 = .atom(A_row_atom).no_of_basis_functions
            b2 = .n_bf
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(A_row_atom(i));
               l_i = .last_basis_fn_for_atom( A_row_atom(i))
               n_i = .atom(A_row_atom(i)).no_of_basis_functions
               A(f_i:l_i,:) = B(b_i+1:b_i+n_i,:)
               b_i = b_i + n_i
            end
         else if (present(A_col_atom)) then
            n_col_atoms = size(A_col_atom)
            b1 = .atom(A_col_atom).no_of_basis_functions
            b2 = .n_bf
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(A_col_atom(j));
               l_j = .last_basis_fn_for_atom( A_col_atom(j))
               n_j = .atom(A_col_atom(j)).no_of_basis_functions
               A(:,f_j:l_j) = B(:,b_j+1:b_j+n_j)
               b_j = b_j + n_j
            end
         end
      else
         DIE("must specify A or B row atoms")
      end
   end

!!!   make_roby_projected_density(rho,roby_atom,shape)
!!!   ! If "shape" is not present, or is present and has value "small":
!!!   ! Make the small Roby-projected density matrix in the concatenated basis 
!!!   ! of AO functions of the atoms in "roby_atoms".
!!!   ! If "shape" is present and has value "big" (this is the default):
!!!   ! The small Roby-projected density matrix operator is copied into 
!!!   ! a matrix .n_bf x .n_bf, where all other matrix elements not 
!!!   ! corresponding to basis functions in "roby_atoms" are made zero.
!!!      MAT :: rho
!!!      IVEC :: roby_atom
!!!      STR(*), optional :: shape
!!!      STR :: kind
!!!      INT :: n_roby_atom, n_bf, a,b_a,f_a,l_a,n_a, b,b_b,f_b,l_b,n_b
!!!      MAT, PTR :: S
!!!      n_roby_atom = size(roby_atom)
!!!      n_bf = .atom(roby_atom).no_of_basis_functions
!!!      kind = "big"
!!!      if (present(shape)) kind = shape
!!!      S.create(n_bf,.n_bf)
!!!      .make_roby_overlap_matrix(S,roby_atom,shape="rectangle")
!!!      rho_W.create(n_bf,n_bf)
!!!      .density_matrix%restricted.back_transform(rho_W,S)
!!!      P.create(n_bf,n_bf)
!!!      .make_roby_projection_matrix(P,roby_atom)
!!!      rho_W.change_basis(P)            ! rho_W(small) = P_W(small) D(small) P_W(small)
!!!    ! rhoW.zero_small_values(TOL(10))
!!!      P.destroy
!!!      S.destroy
!!!      select case (kind)
!!!         case ("small")
!!!            ENSURE(size(rho,1)==n_bf,"rho has wrong shape")
!!!            ENSURE(size(rho,2)==n_bf,"rho has wrong shape")
!!!            rho = rho_W
!!!         case ("big")
!!!            ENSURE(size(rho,1)==.n_bf,"rho has wrong shape")
!!!            ENSURE(size(rho,2)==.n_bf,"rho has wrong shape")
!!!            rho = ZERO
!!!            b_a = 0
!!!            do a = 1,n_roby_atom
!!!               f_a = .first_basis_fn_for_atom(roby_atom(a));
!!!               l_a = .last_basis_fn_for_atom(roby_atom(a))
!!!               n_a = .atom(roby_atom(a)).n_bf
!!!               b_b = 0
!!!               do b = 1,n_roby_atom
!!!                  f_b = .first_basis_fn_for_atom(roby_atom(b))
!!!                  l_b = .last_basis_fn_for_atom(roby_atom(b))
!!!                  n_b = .atom(roby_atom(b)).n_bf
!!!                  rho(f_a:l_a,f_b:l_b) = rho_W(b_a+1:b_a+n_a,b_b+1:b_b+n_b)
!!!                  b_b = b_b + n_b
!!!               end
!!!               b_a = b_a + n_a
!!!            end
!!!      end
!!!   end
!!!
!!!   archive_orbitals( mat1, mat2, a, b)
!!!   ! archives the orbitals created in the previous routine
!!!   MAT, PTR :: mat1, mat2
!!!   OPMAT, PTR :: tmp_mat1, tmp_mat2
!!!   INT :: a, b, j, count
!!!   ARCHIVE :: archive
!!!      tmp_mat1.create(.n_bf, "restricted")
!!!      tmp_mat2.create( .n_bf, "restricted")
!!!      tmp_mat1%restricted.zero; tmp_mat2%restricted.zero
!!!      count = 0
!!!      tmp_mat1%restricted( 1:size(mat1,1), .first(a) : .last(a)) & 
!!!         = mat1(:, 1 : .atom(a)%basis%n_bf)
!!!      tmp_mat2%restricted( 1:size(mat2,1), .first(a) : .last(a)) &
!!!         = mat2(:, 1 : .atom(a)%basis%n_bf)
!!!      count = count + .atom(a)%basis%n_bf
!!!      tmp_mat1%restricted( 1:size(mat1,1), count + 1 : count + .atom(b)%basis%n_bf) &
!!!          = mat1(: , .atom(a)%basis%n_bf + 1 : size(mat1, 2))
!!!      tmp_mat2%restricted(1:size(mat2,1), count + 1 : count + .atom(b)%basis%n_bf) &
!!!          = mat2(:, .atom(a)%basis%n_bf + 1 : size(mat2, 2))
!!!      archive.set( .name, "covalent_orbitals", "restricted")
!!!      archive.write( tmp_mat1)
!!!      archive.set( .name, "ionic_orbitals", "restricted")
!!!      archive.write( tmp_mat2)
!!!      tmp_mat1.destroy; tmp_mat2.destroy   
!!!    end  
!!!
!!!   plot_theta_orbitals( orb_type, orb_no)
!!!   ARCHIVE :: archive
!!!   STR(*) :: orb_type
!!!   OPMAT, PTR :: temp_NOs
!!!   INT :: orb_no
!!!      .grid.put( .out)
!!!      print *, orb_type
!!!      archive.set( .name, orb_type.trim, "restricted")
!!!      temp_NOs.create( .n_bf, "restricted")
!!!      temp_NOs = .natural_orbitals
!!!      archive.read( .natural_orbitals)
!!!      archive.close
!!!      .make_orbital_density_grid( orb_no, make_NOs=FALSE)
!!!      .natural_orbitals = temp_NOs; temp_NOs.destroy
!!!   end
!!!
!!!   get_shared_energy( sel, e, c_l, S) result(se)
!!!   ! calculates the shared population of "atoms"
!!!      IVEC, PTR :: sel
!!!      IVEC, PTR :: comb
!!!      STRVEC :: c_l
!!!      IMAT, PTR :: comb_mat
!!!      MAT, PTR :: S, rho_W, P, overlap
!!!      DBL :: se, population
!!!      VEC, PTR :: energy, e
!!!      INT :: k, m, count, i, size_P
!!!      energy.create( size(sel))
!!!      se = 0
!!!      count = 0
!!!      do k = 1, size(sel)
!!!         energy(k) = 0
!!!         comb_mat => sel.get_combination_matrix_from(k)
!!!         comb.create(k)
!!!         do m = 1, nint( size(sel).choose(k))
!!!            count = count + 1
!!!            comb = comb_mat(:, m); size_P = 0
!!!            do i = 1, size( comb)
!!!               size_P = size_P + .atom(comb(i)).n_bf
!!!            end
!!!            P.create( size_P, size_P); overlap.create( size_P, .n_bf)
!!!            rho_W.create( .n_bf, .n_bf)
!!!            population = .roby_population( comb, S, P, rho_W, overlap)
!!!            e(count) = .calculate_subspace_energy( rho_W, P, overlap)
!!!            .out.put(e(count))        ! just for testing purposes
!!!            rho_W.destroy
!!!            c_l(count) = comb.to_str
!!!            energy(k) = energy(k) + e(count)
!!!            P.destroy; overlap.destroy
!!!         end      
!!!         comb.destroy
!!!         se = se - ((-1)**k)*energy(k)
!!!      end
!!!      comb_mat.destroy; energy.destroy
!!!   end
!!!
!!!   calculate_subspace_energy( rho, P, O) result(energy)
!!!   ! calculates the energy of the subspace defined by P_W
!!!   MAT, PTR :: rho, O, rho_save, F, H, I, P, R
!!!   ARCHIVE :: archive
!!!   DBL :: energy
!!!      rho_save.create( .n_bf, .n_bf)
!!!      rho_save = .density_matrix%restricted
!!!      .density_matrix%restricted = rho ! rho is project density
!!!      .make_fock_matrix
!!!      F => .fock_matrix%restricted
!!!      .add_core_hamiltonian(F)
!!!      energy = HALF * F.trace_product_with(rho)
!!!      .density_matrix%restricted = rho_save
!!!      rho_save.destroy
!!!   end
!!!
!!!   plot_subspace_density( S)
!!!   ! plots the density of the subspace given in the mol.in file
!!!   MAT, PTR :: S   ! The overlap matrix
!!!   MAT, PTR :: sub_NOs, saved_NOs, sub_density, saved_rho
!!!   VEC, PTR :: proj_grid
!!!   IVEC, PTR :: comb
!!!   INT :: i
!!!   DBL ::pop
!!!   ARCHIVE :: archive
!!!      comb.create( .in%buffer%n_items - 1)
!!!      print *, 1
!!!      do i = 1, .in%buffer%n_items - 1
!!!         comb(i) = .in%buffer.get_item.to_int
!!!      end
!!!      print *, comb
!!!      sub_density.create( .n_bf, .n_bf)
!!!      sub_NOs.create( .n_bf, .n_bf)
!!!      pop = .roby_population( comb, S, rho=sub_density, proj_NOs=sub_NOs)
!!!      saved_NOs.create( .n_bf, .n_bf)
!!!      saved_rho.create( .n_bf, .n_bf)
!!!      saved_NOs = .natural_orbitals%restricted
!!!      saved_rho = .density_matrix%restricted
!!!      .natural_orbitals%restricted = sub_NOs
!!!      .density_matrix%restricted = sub_density
!!!      proj_grid.create( .grid%n_pt)
!!!      print *, 2
!!!      .make_density_grid(proj_grid, make_NOs=FALSE)
!!!      print *, 3
!!!      archive.set(.name,"proj_density_grid,gnuplot",format="ascii")
!!!      archive.write_gnuplot(proj_grid, .grid%n_x, .grid%n_y, .grid%n_z)
!!!      .natural_orbitals%restricted = saved_NOs
!!!      .density_matrix%restricted = saved_rho
!!!      saved_rho.destroy; saved_NOs.destroy
!!!      comb.destroy; sub_NOs.destroy; sub_density.destroy
!!!   end
!!!   
!!!   plot_density_difference( S)
!!!   ! plots the difference density map for the molecule
!!!   ARCHIVE  :: archive
!!!   MAT, PTR :: S
!!!   MAT, PTR :: sub_NOs, saved_NOs, sub_density, saved_rho
!!!   VEC, PTR :: density_grid, proj_grid, grid
!!!   IVEC, PTR :: comb
!!!   INT :: i
!!!   DBL :: pop
!!!      density_grid.create( .grid%n_pt)
!!!      .make_density_grid(density_grid)
!!!      comb.create( .n_atom)
!!!      do i = 1, .n_atom
!!!       comb(i) = i
!!!      end
!!!      sub_NOs.create( .n_bf, .n_bf)
!!!      sub_density.create( .n_bf, .n_bf)
!!!      pop = .roby_population( comb, S, rho=sub_density, proj_NOs=sub_NOs)
!!!      comb.destroy
!!!      saved_NOs.create( .n_bf, .n_bf)
!!!      saved_rho.create( .n_bf, .n_bf)
!!!      saved_NOs = .natural_orbitals%restricted
!!!      saved_rho = .density_matrix%restricted
!!!      .natural_orbitals%restricted = sub_NOs
!!!      .density_matrix%restricted = sub_density
!!!      proj_grid.create( .grid%n_pt)
!!!      .make_density_grid(proj_grid, make_NOs=FALSE)
!!!      grid.create( .grid%n_pt)
!!!      grid = density_grid - proj_grid
!!!      archive.set(.name,"diff_proj_density_grid,gnuplot",format="ascii")
!!!      archive.write_gnuplot(grid, .grid%n_x, .grid%n_y, .grid%n_z)
!!!      .natural_orbitals%restricted = saved_NOs
!!!      .density_matrix%restricted = saved_rho
!!!      saved_NOs.destroy; saved_rho.destroy
!!!      grid.destroy; proj_grid.destroy; density_grid.destroy
!!!   end      
!!!         
!!!
!!!
!!!  
!!!   read_atoms_to_bond( a, b)
!!!   ! reads in from the buffer the two atoms for the bond_index routine
!!!      INT :: a, b
!!!      ENSURE(.in%buffer%n_items==3, "Two atoms required for bond index calculation.")
!!!      a = .in%buffer.get_item.to_int      
!!!      b = .in%buffer.get_item.to_int
!!!   end
!!!   
!!!   read_atoms_to_share( S)
!!!   ! runs the get_shared_population procedure
!!!   ! after reading in the atom list
!!!      DBL :: shared
!!!      IVEC, PTR :: sel
!!!      MAT, PTR :: S
!!!      STRVEC, PTR :: comb_list
!!!      VEC, PTR :: population 
!!!      INT :: i, total_combs
!!!      sel.create( .in%buffer%n_items - 1)
!!!      do i = 1, .in%buffer%n_items
!!!         sel(i) = .in%buffer.get_item.to_int
!!!      end
!!!      do i = 1, size(sel)
!!!         total_combs = total_combs + size(sel).choose(i)   ! gets number of combinations
!!!      end
!!!      population.create( total_combs)
!!!      comb_list.create( total_combs)
!!!      shared = .get_shared_population( sel, population, comb_list, S)
!!!      .out.dash(dbl_fields = 3)
!!!      .out.text("Shared Population analysis")
!!!      .out.flush
!!!      .out.dash(dbl_fields = 3)
!!!      do i = 1, size( sel)
!!!         .out.put( .atom(sel(i))%label, int_width=TRUE, flush=1)
!!!      end
!!!      .out.flush
!!!      .out.put(shared)
!!!      .out.flush
!!!      .out.dash(dbl_fields = 3)
!!!      sel.destroy
!!!      comb_list.destroy
!!!      population.destroy
!!!   end
!!!
!!!   get_shared_population( sel, p, c_l, S) result(sp)
!!!   ! calculates the shared population of "atoms"
!!!      IVEC, PTR :: sel
!!!      IVEC, PTR :: comb
!!!      STRVEC :: c_l
!!!      IMAT, PTR :: comb_mat
!!!      MAT, PTR :: S
!!!      DBL :: sp
!!!      VEC, PTR :: pop, p
!!!      INT :: k, m, count
!!!      sp = 0
!!!      pop.create( size(sel))
!!!      count = 0
!!!      do k = 1, size(sel)
!!!         pop(k) = 0
!!!         comb_mat => sel.get_combination_matrix_from(k)
!!!         comb.create(k)
!!!         do m = 1, nint( size(sel).choose(k))
!!!            count = count + 1
!!!            comb = comb_mat(:, m)
!!!            p(count) = .roby_population(comb)
!!!            c_l(count) = comb.to_str
!!!            pop(k) = pop(k) + p(count)
!!!         end      
!!!         comb.destroy
!!!         sp = sp - ((-1)**k)*pop(k)
!!!      end
!!!      comb_mat.destroy; pop.destroy
!!!   end
!!!
!!!   read_shared_energy_atoms( S)
!!!   ! runs the shared_energy calculations
!!!   ! after reading in the atom list
!!!      DBL :: shared
!!!      IVEC, PTR :: sel
!!!      MAT, PTR :: S
!!!      STRVEC, PTR :: comb_list
!!!      VEC, PTR :: energy 
!!!      INT :: i, total_combs
!!!      sel.create( .in%buffer%n_items - 1)
!!!      do i = 1, .in%buffer%n_items
!!!         sel(i) = .in%buffer.get_item.to_int
!!!      end
!!!      do i = 1, size(sel)
!!!         total_combs = total_combs + size(sel).choose(i)   ! gets number of combinations
!!!      end
!!!      energy.create( total_combs)
!!!      comb_list.create( total_combs)
!!!      shared = .get_shared_energy( sel, energy, comb_list, S)
!!!      .out.dash(dbl_fields = 3)
!!!      .out.text("Shared Energy analysis")
!!!      .out.flush
!!!      .out.dash(dbl_fields = 3)
!!!      do i = 1, size( sel)
!!!         .out.put( trim( .atom(sel(i))%label), int_width=TRUE, flush=1)
!!!      end
!!!      .out.flush
!!!      .out.put(shared)
!!!      .out.flush
!!!      .out.dash(dbl_fields = 3)
!!!      sel.destroy
!!!      comb_list.destroy
!!!      energy.destroy
!!!   end

!!    dylans_population_analysis
!!    ! Analyse the SCF orbitals into dylans populations
!!       INT :: n_k
!!       MAT, PTR  :: p
!!       VEC, PTR  :: n1
!!       MAT, PTR  :: n2
!!       MAT3, PTR :: n3
!!       TIME :: timer
!!       ENSURE( .density_matrix.created,"need a density matrix")
!!       .out.flush
!!       .out.text("Starting dylans_population_analysis ...")
!!       timer.start
!!       .density_matrix.convert_to("unrestricted",factor=HALF)
!!       .density_matrix%restricted.destroy
!!       .make_natural_orbitals
!!       .atom.make_atom_kind_list( .atom_kind)
!!       .atom.make_atom_kind_map( .atom_kind_map)
!!       n_k = size( .atom_kind)
!!       p.create(.n_atom+1,.n_atom+1)
!!       n1.create(.n_atom)
!!       n2.create(.n_atom,.n_atom)
!!       n3.create(.n_atom,.n_atom,.n_atom)
!!       .make_ANSO_data
!!       .make_dylans_populations(p,n1)
!!       .put_dylans_populations(p,n1)
!! !      .make_dylans_populations(p,n1,n2,n3)
!! !      .put_dylans_populations(p,n1,n2,n3)
!!       n3.destroy; n2.destroy; n1.destroy; p.destroy
!!       .out.put( timer.time_taken("dylans_population_analysis"))
!!    end
!! 
!!    make_dylans_populations(p,n1)
!! !   make_dylans_populations(p,n1,n2,n3,atom_kind_map,NOa,NOb,occa,occb)
!!    ! Make dylans populations, for closed shells only
!!       MAT :: p
!!       VEC  :: n1
!! !      MAT  :: n2
!! !      MAT3 :: n3
!!       INT :: k,a,fa,la,n,na
!!       DBL :: pop
!!       MAT, PTR :: S,D,W,X
!! !     MAT, PTR :: Y
!! !     INT :: b,c,fb,lb,fc,lc,l,m,mm,nb,nc,nabc,nk,nl,nm,nkl,nklm
!! !     DBL :: bot
!! !     VEC, PTR :: lambda
!!       .atom.make_atom_basis_fn_limits( .first, .last)
!!       S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
!!       D.create(.n_bf,.n_bf)
!!       D.from_diagonal(sqrt(.occupation%alpha))
!!       D.back_transform(.natural_orbitals%alpha)
!!       p = ZERO
!!       n = .n_atom+1
!!       p(n,n) = .n_e
!!       n1 = ZERO
!!       do a = 1,.n_atom
!!          k = .atom_kind_map(a)
!!          .out.show("a=",a)
!!          .out.show("k=",k)
!!          fa = .first(a); la = .last(a); na = la-fa+1
!!          X.create(na,na)
!!          X.from_diagonal(sqrt( .atom(a)%occupations%alpha))
!!          X.back_transform( .atom(a)%natural_orbitals%alpha)
!!          W.create(.n_bf,.n_bf)
!!          X.change_basis(W,S(fa:la,:))
!!          pop = W.trace_product_with(D)
!!          X.from_diagonal(sqrt( .atom(a)%occupations%beta))
!!          X.back_transform( .atom(a)%natural_orbitals%beta)
!!          X.change_basis(W,S(fa:la,:))
!!          pop = pop + W.trace_product_with(D)
!!          p(a,a) = .atom(a)%atomic_number
!!          p(a,n) = pop
!!          p(n,a) = pop
!!          n1(a) = pop*pop/p(a,a)
!!          W.destroy
!!          X.destroy
!!       end
!! !     n2 = ZERO
!! !     do k = 1,n_k
!! !     do kk = 1,size(atom_kind(k)%vec) 
!! !     do l = 1,n_k
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        if (a<=b) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !        fa = first(a); la = last(a); na = la-fa+1
!! !        fb = first(b); lb = last(b); nb = lb-fb+1
!! !        nk = size(NO(k)%mat,2)
!! !        nl = size(NO(l)%mat,2)
!! !        nab = na + nb
!! !        nkl = nk + nl
!! !        lambda.create(nkl)
!! !        lambda(   1:nk ) = sqrt(occ(k)%vec)
!! !        lambda(nk+1:nkl) = sqrt(occ(l)%vec)
!! !        W.create(nab,nkl)
!! !        W = ZERO
!! !        W(   1:na ,   1:nk ) = NO(k)%mat
!! !        W(na+1:nab,nk+1:nkl) = NO(l)%mat
!! !        Y.create(nab,nab)
!! !        Y(   1:na ,   1:na ) = S(fa:la,fa:la)
!! !        Y(na+1:nab,na+1:nab) = S(fb:lb,fb:lb)
!! !        Y(na+1:nab,   1:na ) = S(fb:lb,fa:la)
!! !        Y(   1:na ,na+1:nab) = S(fa:la,fb:lb)
!! !        X.create(nkl,nkl)
!! !        Y.change_basis(X,W)
!! !        Y.destroy
!! !        Y.create(nkl,nkl)
!! !        Y.to_inverse_of(X)  ! Y = S^-1
!! !        X.destroy
!! !        X.create(nkl,nkl)
!! !        X.to_product_with_diagonal(lambda,Y)
!! !        Y.destroy
!! !        Y.create(nab,nab)
!! !        X.back_transform(Y,W)
!! !        X.destroy
!! !        W.destroy
!! !        W.create(.n_bf,.n_bf)
!! !        X.create(nab,.n_bf)
!! !        X(   1:na ,:) = S(fa:la,:)
!! !        X(na+1:nab,:) = S(fb:lb,:)
!! !        Y.change_basis(W,X)
!! !        W = transpose(W)
!! !        pop = W.trace_product_with(.density_matrix%restricted)
!! !        bot = W.trace_product_with(X)
!! !        pop = pop*pop/bot
!! !        n2(a,b) = pop
!! !        n2(b,a) = pop
!! !        X.destroy
!! !        W.destroy
!! !        Y.destroy
!! !        lambda.destroy
!! !     end
!! !     end
!! !     end
!! !     end
!! !     n3 = ZERO
!! !     do k = 1,n_k
!! !     do kk = 1,size(atom_kind(k)%vec) 
!! !     do l = 1,n_k
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !     do m = 1,n_k
!! !     do mm = 1,size(atom_kind(m)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        c = atom_kind(m)%vec(mm)
!! !        if (a<=b OR b<=c) cycle
!! !      ! if (a==b OR b==c OR c==a) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !      ! if ( .atom.not_bonded(b,c)) cycle
!! !        fa = first(a); la = last(a); na = la-fa+1
!! !        fb = first(b); lb = last(b); nb = lb-fb+1
!! !        fc = first(c); lc = last(c); nc = lc-fc+1
!! !        nk = size(NO(k)%mat,2)
!! !        nl = size(NO(l)%mat,2)
!! !        nm = size(NO(m)%mat,2)
!! !        nabc = na + nb + nc
!! !        nklm = nk + nl + nm
!! !        lambda.create(nkl)
!! !        lambda(      1:nk   ) = sqrt(occ(k)%vec)
!! !        lambda(nk   +1:nk+nl) = sqrt(occ(l)%vec)
!! !        lambda(nk+nl+1:nklm ) = sqrt(occ(m)%vec)
!! !        W.create(nabc,nklm)
!! !        W = ZERO
!! !        W(      1:na   ,      1:nk   ) = NO(k)%mat
!! !        W(na   +1:na+nb,nk   +1:nk+nl) = NO(l)%mat
!! !        W(na+nb+1:nabc ,nk+nl+1:nklm ) = NO(m)%mat
!! !        Y.create(nabc,nabc)
!! !        Y(      1:na   ,      1:na   ) = S(fa:la,fa:la)
!! !        Y(na   +1:na+nb,na   +1:na+nb) = S(fb:lb,fb:lb)
!! !        Y(na+nb+1:nabc ,na+nb+1:nabc ) = S(fc:lc,fc:lc)
!! !        Y(na+1:nab,   1:na ) = S(fb:lb,fa:la)
!! !        Y(   1:na ,na+1:nab) = S(fa:la,fb:lb)
!! !        Y(na+nb+1:nabc,      1:na  ) = S(fc:lc,fa:la)
!! !        Y(      1:na  ,na+nb+1:nabc) = S(fa:la,fc:lc)
!! !        Y(na+nb+1:nabc ,na   +1:na+nb) = S(fc:lc,fb:lb)
!! !        Y(na   +1:na+nb,na+nb+1:nabc ) = S(fb:lb,fc:lc)
!! !        X.create(nklm,nklm)
!! !        Y.change_basis(X,W)
!! !        Y.destroy
!! !        Y.create(nklm,nklm)
!! !        Y.to_inverse_of(X)  ! Y = S^-1
!! !        X.destroy
!! !        X.create(nklm,nklm)
!! !        X.to_product_with_diagonal(lambda,Y)
!! !        Y.destroy
!! !        Y.create(nabc,nabc)
!! !        X.back_transform(Y,W)
!! !        X.destroy
!! !        W.destroy
!! !        W.create(.n_bf,.n_bf)
!! !        X.create(nabc,.n_bf)
!! !        X(      1:na   ,:) = S(fa:la,:)
!! !        X(na   +1:na+nb,:) = S(fb:lb,:)
!! !        X(na+nb+1:nabc ,:) = S(fc:lc,:)
!! !        Y.change_basis(W,X)
!! !        W = transpose(W)
!! !        pop = W.trace_product_with(.density_matrix%restricted)
!! !        bot = W.trace_product_with(X)
!! !        pop = pop*pop/bot
!! !        n3(a,b,c) = pop
!! !        n3(a,c,b) = pop
!! !        n3(b,a,c) = pop
!! !        n3(b,c,a) = pop
!! !        n3(c,a,b) = pop
!! !        n3(c,b,a) = pop
!! !        X.destroy
!! !        W.destroy
!! !        Y.destroy
!! !        lambda.destroy
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!!       D.destroy
!!       S.destroy
!!    end
!! 
!!    put_dylans_populations(p,n1)
!! !   put_dylans_populations(p,n1,n2,n3,atom_kind)
!!    ! Put .out the roby populations
!!       MAT :: p
!!       VEC  :: n1
!! !      MAT  :: n2
!! !      MAT3 :: n3
!!       INT :: k,kk,a,b
!!       STR :: symbol_a,symbol_b
!! !     INT :: l,m,ll,mm,c
!! !     STR :: symbol_c
!!       .out.flush
!!       .out.text("Dylan's population analysis",flush=2)
!!       .out.text("Pair overlaps (last atom is the molecule itself):",flush=2)
!!       .out.dash(int_fields=2,dbl_fields=1)
!!       .out.put("Atom_a",int_width=TRUE)
!!       .out.put("Atom_b",int_width=TRUE)
!!       .out.put("p_ab",flush=1)
!!       .out.dash(int_fields=2,dbl_fields=1)
!!       do a = 1,.n_atom+1
!!       do b = 1,a-1
!!        ! if ( .atom.not_bonded(a,b)) cycle
!!          if (a==.n_atom+1) then; symbol_a = "M"
!!          else; symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!!          end
!!          symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
!!          .out.put(symbol_a,int_width=TRUE)
!!          .out.put(symbol_b,int_width=TRUE)
!!          .out.put(p(a,b))
!!          .out.flush
!!       end
!!       end
!!       .out.dash(int_fields=2,dbl_fields=1)
!!       .out.text("Dylan's atomic populations",flush=2)
!!       .out.dash(int_fields=1,dbl_fields=1)
!!       .out.put("Atom",int_width=TRUE)
!!       .out.put("Population",flush=1)
!!       .out.dash(int_fields=1,dbl_fields=1)
!!       do k = 1,size( .atom_kind)
!!       do kk = 1,size( .atom_kind(k)%vec)
!!          a = .atom_kind(k)%vec(kk)
!!          symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!!          .out.put(symbol_a,int_width=TRUE)
!!          .out.put(n1(a))
!!          .out.flush
!!       end
!!       end
!!       .out.dash(int_fields=1,dbl_fields=1)
!! !     .out.flush
!! !     .out.text("Pair populations:",flush=2)
!! !     .out.dash(int_fields=2,dbl_fields=2)
!! !     .out.put("Atom_a",int_width=TRUE)
!! !     .out.put("Atom_b",int_width=TRUE)
!! !     .out.put("n_ab")
!! !     .out.put("s_ab",flush=1)
!! !     .out.dash(int_fields=2,dbl_fields=2)
!! !     do k = 1,size(atom_kind)
!! !     do kk = 1,size(atom_kind(k)%vec)
!! !     do l = 1,size(atom_kind)
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        if (a==b) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !        symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!! !        symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
!! !        .out.put(symbol_a,int_width=TRUE)
!! !        .out.put(symbol_b,int_width=TRUE)
!! !        .out.put(n2(a,b))
!! !        .out.put(n1(a)+n1(b)-n2(a,b))
!! !        .out.flush
!! !     end
!! !     end
!! !     end
!! !     end
!! !     .out.dash(int_fields=2,dbl_fields=2)
!! !     .out.flush
!! !     .out.text("Triple populations:",flush=2)
!! !     .out.dash(int_fields=3,dbl_fields=2)
!! !     .out.put("Atom_a",int_width=TRUE)
!! !     .out.put("Atom_b",int_width=TRUE)
!! !     .out.put("Atom_c",int_width=TRUE)
!! !     .out.put("n_abc")
!! !     .out.put("s_abc",flush=1)
!! !     .out.dash(int_fields=3,dbl_fields=2)
!! !     do k = 1,size(atom_kind)
!! !     do kk = 1,size(atom_kind(k)%vec)
!! !     do l = 1,size(atom_kind)
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !     do m = 1,size(atom_kind)
!! !     do mm = 1,size(atom_kind(m)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        c = atom_kind(m)%vec(mm)
!! !        if (a==b OR b==c OR c==a) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !      ! if ( .atom.not_bonded(b,c)) cycle
!! !        symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!! !        symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
!! !        symbol_c = .atom(c).chemical_symbol.trim // " (" // c.to_str.trim // ")"
!! !        .out.put(symbol_a,int_width=TRUE)
!! !        .out.put(symbol_b,int_width=TRUE)
!! !        .out.put(symbol_c,int_width=TRUE)
!! !        .out.put(n3(a,b,c))
!! !        .out.put(n1(a)+n1(b)+n1(c)-n2(a,b)-n2(b,c)-n2(c,a)+n3(a,b,c))
!! !        .out.flush
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!! !     .out.dash(int_fields=3,dbl_fields=2)
!!    end

end 

