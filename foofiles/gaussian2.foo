!---------------------------------------------------------------------------
!
!  GAUSSIAN2 : Pairs of gaussian functions
!
!  (c) dylan jayatilaka, 1998
!
! $Id$
!---------------------------------------------------------------------------
module GAUSSIAN2

   use TYPES
   use SYSTEM
   use INT
   use IVEC
   use IMAT
   use VEC
   use MAT
   use MAT3
   use CVEC
   use CMAT3
   use CMAT4
   use TEXTFILE
   use RYS
   use GAUSSIAN

   implicit none         

#  include "macros"
#  include "gaussian2.int"

!   type gaussian2_type
!
!   INT :: l_a
!   ! l quantum number for gaussian "a" of the gaussian pair
!
!   INT :: l_b
!   ! l quantum number for gaussian "b" of the gaussian pair
!
!   DBL :: ex_a
!   ! Exponent for gaussian "a" of the gaussian pair
!
!   DBL :: ex_b
!   ! Exponent for gaussian "b" of the gaussian pair
!
!   VEC(3) :: pos_a
!   ! Position for gaussian "a" of the gaussian pair
!
!   VEC(3) :: pos_b
!   ! Position for gaussian "b" of the gaussian pair
!   end

   DBL, private :: pi212  = 1.1283791670955d+0

!  The i-th point and weight for n-point Gauss-Hermite quadrature

   IVEC(9), private :: first_pt = (/1,2,4, 7,11,16,22,29,37/)
   IVEC(9), private :: last_pt  = (/1,3,6,10,15,21,28,36,45/)

   VEC(45), private :: gauss_hermite_pt = (/                                                   &
       0.000000000000000e+0,                                                                   & ! H_11
      -0.707106781186548e+0, 0.707106781186548e+0,                                             & ! H_12 H_22
      -1.224744871391590e+0, 0.000000000000000e+0, 1.224744871391590e+0,                       & ! H_13 H_23 H_33
      -1.650680123885780e+0,-0.524647623275290e+0, 0.524647623275290e+0, 1.650680123885780e+0, & ! H_*4
      -2.020182870456090e+0,-0.958572464613819e+0, 0.000000000000000e+0, 0.958572464613819e+0, & ! H_*5
       2.020182870456090e+0,                                                                   &
      -2.350604973674000e+0,-1.335849074014000e+0,-0.436077411928000e+0, 0.436077411928000e+0, & ! H_*6
       1.335849074014000e+0, 2.350604973674000e+0,                                             &
      -2.651961356835233e+0,-1.673551628767471e+0,-0.816287882858965e+0, 0.000000000000000e+0, & ! H_*7
       0.816287882858965e+0, 1.673551628767471e+0, 2.651961356835233e+0,                       &
      -2.930637420257244e+0,-1.981656756695843e+0,-1.157193712446780e+0,-0.381186990207322e+0, & ! H_*8
       0.381186990207322e+0, 1.157193712446780e+0, 1.981656756695843e+0, 2.930637420257244e+0, &
      -3.190993201781528e+0,-2.266580584531843e+0,-1.468553289216668e+0,-0.723551018752838e+0, & ! H_*9
       0.000000000000000e+0, 0.723551018752838e+0, 1.468553289216668e+0, 2.266580584531843e+0, &
       3.190993201781528e+0  /)

   VEC(45), private :: gauss_hermite_wt = (/                                                   &
       1.772453850905520e+0,                                                                   & ! W_11
       0.886226925452800e+0, 0.886226925452800e+0,                                             & ! W_12 W_22
       0.295408975150900e+0, 1.181635900604000e+0, 0.295408975150900e+0,                       & ! W_13 W_23 W_33
       8.131283544725000e-2, 8.049140900055000e-1, 8.049140900055000e-1, 8.131283544725000e-2, & ! W_*4
       1.995324205905000e-2, 3.936193231522000e-1, 9.453087204829000e-1, 3.936193231522000e-1, & ! W_*5
       1.995324205905000e-2,                                                                   &
       4.530009905509000e-3, 1.570673203229000e-1, 7.246295952244000e-1, 7.246295952244000e-1, & ! W_*6
       1.570673203229000e-1, 4.530009905509000e-3,                                             &
       9.717812450995000e-4, 5.451558281913000e-2, 4.256072526101000e-1, 8.102646175568000e-1, & ! W_*7
       4.256072526101000e-1, 5.451558281913000e-2, 9.717812450995000e-4,                       &
       1.996040722114000e-4, 1.707798300741000e-2, 2.078023258149000e-1, 6.611470125582000e-1, & ! W_*8
       6.611470125582000e-1, 2.078023258149000e-1, 1.707798300741000e-2, 1.996040722114000e-4, &
       3.960697726326000e-5, 4.943624275537000e-3, 8.847452739438000e-2, 4.326515590026000e-1, & ! W_*9
       7.202352156061000e-1, 4.326515590026000e-1, 8.847452739438000e-2, 4.943624275537000e-3, &
       3.960697726326000e-5  /)

contains

   create
   ! Create a gaussian pair
      PTR :: self
      nullify(self)
      allocate(self)
      ADD_MEM(GAUSSIAN2_SIZE)
   end

   create(Ga,Gb)
   ! Create a gaussian pair and set it to "Ga" and "Gb"
      PTR :: self
      GAUSSIAN :: Ga,Gb 
      nullify(self)
      allocate(self)
      ADD_MEM(GAUSSIAN2_SIZE)
      .set(Ga,Gb)
   end

   destroy
   ! Destroy a guassian pair
      PTR :: self
      if (.destroyed) return
      DELETE_MEM(GAUSSIAN2_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set(Ga,Gb) 
   ! Set the gaissian pair object to "Ga" and "Gb"
      GAUSSIAN :: Ga,Gb 
      .l_a   = Ga.l
      .pos_a = Ga.pos
      .ex_a  = Ga.ex
      .l_b   = Gb.l
      .pos_b = Gb.pos
      .ex_a  = Gb.ex
   end

   set(l_a,pos_a,ex_a,l_b,pos_b,ex_b) 
   ! Set a gaussian object
      INT :: l_a,l_b
      VEC(3) :: pos_a,pos_b
      DBL :: ex_a,ex_b
      .l_a   = l_a
      .pos_a = pos_a
      .ex_a  = ex_a
      .l_b   = l_b
      .pos_b = pos_b
      .ex_b  = ex_b
   end

   set(ex_a,ex_b) 
   ! Set the exponents of the pair
      DBL, optional :: ex_a,ex_b
      if (present(ex_a)) .ex_a = ex_a
      if (present(ex_b)) .ex_b = ex_b
   end

   make_e_coeff(e,comp)
   ! Return the McMurchie-Davidson "e" coefficients for component "comp"
   ! (c) dylan jayatilaka, april 1995
   ! Checked using mathematica, may 1995
      INT, IN :: comp
      MAT3(0:,0:,0:) :: e ! Generic e coefficient table
      INT :: t,a,b,ap,am,bp,bm,abp,ab,abm,max,l_a,l_b
      DBL :: R,gamma,g1,g2,a1,b1,e000
      l_a = .l_a
      l_b = .l_b
      max = l_a+l_b
      R = .pos_a(comp)-.pos_b(comp)
      gamma = .ex_a + .ex_b
      g1 = 1/gamma
      b1 = .ex_b*g1*R
      e000 = exp(-.ex_a*b1*R)  
      e(0,0,0) = e000  
      RETURN_IF(max==0)                ! Return for e000
      g2 = HALF*g1 
      a1 = .ex_a*g1*R
      if (l_a>=1) then    
         e(1,1,0) =  g2*e000  
         e(0,1,0) = -b1*e000  
      end
      if (l_b>=1) then    
         e(1,0,1) =  g2*e000  
         e(0,0,1) =  a1*e000  
      end
      RETURN_IF(max==1)                ! Return for eXX1
      do a = 1,l_a-1                   ! Consider case b=0  
         ap = a + 1
         am = a - 1
         e(ap,ap,0) =  g2*e( a,a,0) 
         e( a,ap,0) =  g2*e(am,a,0) - b1*e(a,a,0) 
         e( 0,ap,0) = -b1*e( 0,a,0) +    e(1,a,0) 
         do t = 1,am
            e(t,ap,0) = g2*e(t-1,a,0) - b1*e(t,a,0) + (t+1)*e(t+1,a,0)
         end
      end
      do b = 1,l_b-1                   ! Consider case a=0  
         bp = b + 1
         bm = b - 1
         e(bp,0,bp) =  g2*e( b,0,b) 
         e( b,0,bp) =  g2*e(bm,0,b) + a1*e(b,0,b) 
         e( 0,0,bp) =  a1*e( 0,0,b) +    e(1,0,b) 
         do t = 1,bm
            e(t,0,bp) = g2*e(t-1,0,b) + a1*e(t,0,b) + (t+1)*e(t+1,0,b)
         end
      end
      do b = 1,l_b                     ! Now do the rest, a/=0 & b/=0
         do a = 0,l_a-1
            ab  = a + b
            ap  = a + 1
            abp = ab + 1
            abm = ab - 1
            e(abp,ap,b) =  g2*e( ab,a,b) 
            e( ab,ap,b) =  g2*e(abm,a,b) - b1*e(ab,a,b) 
            e(  0,ap,b) = -b1*e(  0,a,b) +    e( 1,a,b) 
            do t = 1,abm
               e(t,ap,b) = g2*e(t-1,a,b) - b1*e(t,a,b) + (t+1)*e(t+1,a,b)
            end
         end
      end
   end 

   make_e_coeff_derivative(e1,comp,e0)
   ! Return the derivative McMurchie-Davidson "e1" coefficients for 
   ! component "comp" with repect to R = .pos_a - .pos_b. The zero order 
   ! derivative E coefficients "e0" for the same component must be supplied.
   ! This routine is based on Helgaker & Taylor, TCA 83, p. 177 (1992)
   ! (c) dylan jayatilaka, may 1998
      INT, IN :: comp
      MAT3(0:,0:,0:), IN :: e0
      MAT3(0:,0:,0:) :: e1 ! Generic e coefficient table
      INT :: t,a,b,ap,am,bp,bm,abp,ab,abm,max
      DBL :: R,gamma,g1,g2,a0,a1,b0,b1,e0000,e1000
      max = .l_a+.l_b
      R = .pos_a(comp)-.pos_b(comp)
      gamma = .ex_a + .ex_b
      g1 = 1/gamma
      b0 = .ex_b*g1
      b1 = b0*R
      e0000  = e0(0,0,0)
      e1000 = -2*.ex_a*b1*e0000
      e1(0,0,0) = e1000  
      RETURN_IF(max==0)                 ! Return for e000
      a0 = .ex_a*g1
      a1 = a0*R
      g2 = HALF*g1 
      if (.l_a>=1) then    
         e1(1,1,0) =  g2*e1000 
         e1(0,1,0) = -b1*e1000 - b0*e0000
      end
      if (.l_b>=1) then    
         e1(1,0,1) =  g2*e1000 
         e1(0,0,1) =  a1*e1000 + a0*e0000
      end
      RETURN_IF(max==1)                 ! Return for eXX1
      do a = 1,.l_a-1                   ! Consider case b=0  
         ap = a + 1
         am = a - 1
         e1(ap,ap,0) =  g2*e1( a,a,0) 
         e1( a,ap,0) =  g2*e1(am,a,0) - b1*e1(a,a,0) - b0*e0(a,a,0)
         e1( 0,ap,0) = -b1*e1( 0,a,0) - b0*e0(0,a,0) +    e1(1,a,0) 
         do t = 1,am
            e1(t,ap,0) = g2*e1(t-1,a,0) - b1*e1(t,a,0) - b0*e0(t,a,0) + (t+1)*e1(t+1,a,0)
         end
      end
      do b = 1,.l_b-1                   ! Consider case a=0  
         bp = b + 1
         bm = b - 1
         e1(bp,0,bp) =  g2*e1( b,0,b) 
         e1( b,0,bp) =  g2*e1(bm,0,b) + a1*e1(b,0,b) + a0*e0(b,0,b)
         e1( 0,0,bp) =  a1*e1( 0,0,b) + a0*e0(0,0,b) +    e1(1,0,b) 
         do t = 1,bm
            e1(t,0,bp) = g2*e1(t-1,0,b) + a1*e1(t,0,b) + a0*e0(t,0,b) + (t+1)*e1(t+1,0,b)
         end
      end
      do b = 1,.l_b                     ! Now do the rest, a/=0 & b/=0
         do a = 0,.l_a-1
            ab  = a + b
            ap  = a + 1
            abp = ab + 1
            abm = ab - 1
            e1(abp,ap,b) =  g2*e1( ab,a,b) 
            e1( ab,ap,b) =  g2*e1(abm,a,b) - b1*e1(ab,a,b) - b0*e0(ab,a,b)
            e1(  0,ap,b) = -b1*e1(  0,a,b) - b0*e0( 0,a,b) +    e1( 1,a,b) 
            do t = 1,abm
               e1(t,ap,b) = g2*e1(t-1,a,b) - b1*e1(t,a,b) - b0*e0(t,a,b) + (t+1)*e1(t+1,a,b)
            end
         end
      end
   end 

   make_ft_component(res,comp,k_pts,k_max)
   ! Do the Fourier transform of component "comp" of the guassian pair 
   ! evaluated at the points "k_pts"
      INT, IN :: comp,k_max
      VEC, IN :: k_pts
      CMAT3(1:,0:,0:) :: res
      DBL :: kn,kn_t
      INT :: a,b,t,t_max,n
      MAT3* :: e
      VEC* :: val1,val2                    ! Local variables
      MAT* :: k1
      t_max = .l_a+.l_b
      e.create((/0,t_max/),(/0,.l_a/),(/0,.l_b/))
      .make_e_coeff(e,comp)
      select case (t_max)
        case (0)
          res(:,0,0) = cmplx(e(0,0,0),ZERO)
        case (1)
          if (.l_a==1) then
            res(:,0,0) = cmplx(e(0,0,0),ZERO)
            res(:,1,0) = cmplx(e(0,1,0),e(1,1,0)*k_pts(:))
          else
            res(:,0,0) = cmplx(e(0,0,0),ZERO)
            res(:,0,1) = cmplx(e(0,0,1),e(1,0,1)*k_pts(:))
          end
        case default                            ! general routine
          k1.create((/1,k_max/),(/0,t_max/))    ! Define k1 array containing
          do n = 1,k_max                        ! powers k^n of k_pts
            kn = k_pts(n)
            kn_t = kn          ! t=0 is 1, has been optimised out below.
            do t = 2,t_max     ! t=1 is k_pts(n), explicity written below.
              kn_t = kn_t * kn
              k1(n,t) = kn_t
            end
          end
          val1.create(k_max)   ! val1 is real part
          val2.create(k_max)   ! val2 is imaginary part
          do a = 0,.l_a
            do b = 0,.l_b
              t_max = a+b
              select case (t_max)
                case (0)
                  res(:,0,0) = cmplx(e(0,0,0),ZERO)
                case (1)
                  res(:,a,b) = cmplx(e(0,a,b),e(1,a,b)*k_pts(:))
                case (2)
                  val1(:) = e(0,a,b) - e(2,a,b)*k1(:,2)
                  val2(:) = e(1,a,b)*k_pts(:)
                  res(:,a,b) = cmplx(val1(:),val2(:))
                case default
                  val1(:) = e(0,a,b)          - e(2,a,b)*k1(:,2)
                  val2(:) = e(1,a,b)*k_pts(:) - e(3,a,b)*k1(:,3)
                  do t = 3,t_max-3,4
                    val1(:) = val1(:) + e(t,a,b)  *k1(:,t)  - e(t+2,a,b)*k1(:,t+2)
                    val2(:) = val2(:) + e(t+1,a,b)*k1(:,t+1)- e(t+3,a,b)*k1(:,t+3)
                  end
                  select case (mod(t_max+1,4))
                    case (0)
                    case (1)
                      val1(:) = val1(:) + e(t_max,a,b)*k1(:,t_max)
                    case (2)
                      val1(:) = val1(:) + e(t_max-1,a,b)*k1(:,t_max-1)
                      val2(:) = val2(:) + e(t_max,a,b)  *k1(:,t_max)
                    case (3)
                      val1(:) = val1(:) + e(t_max-2,a,b)*k1(:,t_max-2) - &
                                          e(t_max,a,b)  *k1(:,t_max)
                      val2(:) = val2(:) + e(t_max-1,a,b)*k1(:,t_max-1)
                  end
                  res(:,a,b) = cmplx(val1(:),val2(:))
              end
            end
          end
          val2.destroy
          val1.destroy
          k1.destroy
      end
      e.destroy
   end

   make_ft_dab_component(res,comp,k_pts,k_max)
   ! Do the Fourier transform of the derivative of component a minus b 
   ! of a a pair of gaussians, for component "comp" of the guassian 
   ! product pair, evaliated for the points "k_pts".
   ! Dimensions of res are [[1,size(k_pts)],[0,.l_a],[0,.l_b]].
      INT, IN :: comp,k_max
      VEC, IN :: k_pts
      CMAT3(1:,0:,0:) :: res
      DBL :: kn,fac
      INT :: a,b,t,t_max,n
      MAT3* :: e0,e1
      VEC* :: val                      ! Local variables
      MAT* :: k1
      t_max = .l_a+.l_b
      k1.create((/1,k_max/),(/0,t_max+1/)) ! Define k1 array containing
      do n = 1,k_max                       ! powers k^n of k_pts
         k1(n,0) = ONE  
         kn = k_pts(n)
         do t = 1,t_max+1
            k1(n,t) = k1(n,t-1)*kn
         end
      end
      val.create(k_max)       ! Now evaluate; use real arithmetic where possible
      e0.create((/0,.l_a+.l_b/),(/0,.l_a/),(/0,.l_b/))
      .make_e_coeff(e0,comp)
      e1.create((/0, .l_a+.l_b /),(/0, .l_a /),(/0, .l_b /))
      .make_e_coeff_derivative(e1,comp,e0)
      do a = 0,.l_a
         do b = 0,.l_b
            t_max = a+b
            val = ZERO                         ! Do the real part first ...
            do t = 0,t_max,4
               val(:) = val(:) + e1(t,a,b)*k1(:,t)
            end
            do t = 2,t_max,4
               val(:) = val(:) - e1(t,a,b)*k1(:,t)
            end
            val = TWO*val
            res(:,a,b) = cmplx(val(:),ZERO)
            val = ZERO                         ! Now do imaginary part ...
            do t = 1,t_max,4
               val(:) = val(:) + e1(t,a,b)*k1(:,t)
            end
            do t = 3,t_max,4
               val(:) = val(:) - e1(t,a,b)*k1(:,t)
            end
            val = TWO*val
            res(:,a,b) = res(:,a,b) + cmplx(ZERO,val(:))
         end
      end
      fac = (.ex_a-.ex_b)/(.ex_a+.ex_b)
      do a = 0,.l_a
         do b = 0,.l_b
            t_max = a+b
            val = ZERO                         ! Do the imaginary part first ...
            do t = 0,t_max,4
               val(:) = val(:) + e0(t,a,b)*k1(:,t+1)
            end
            do t = 2,t_max,4
               val(:) = val(:) - e0(t,a,b)*k1(:,t+1)
            end
            val = fac*val
            res(:,a,b) = res(:,a,b) + cmplx(ZERO,val(:))
            val = ZERO                         ! Now do real part ...
            do t = 1,t_max,4
               val(:) = val(:) - e0(t,a,b)*k1(:,t+1)
            end
            do t = 3,t_max,4
               val(:) = val(:) + e0(t,a,b)*k1(:,t+1)
            end
            val = fac*val
            res(:,a,b) = res(:,a,b) + cmplx(val(:),ZERO)
         end
      end
      e1.destroy
      e0.destroy
      val.destroy
      k1.destroy
   end

   make_ft_dab(res,ft)
   ! Form the Fourier transform of the derivative of the product
   ! of two gaussians w.r.t. coordinates in shell b, from the zeroth
   ! derivative Fourier transform.  Dimensions of res are
   ! [[1,size(k_pts)],[0,l_a],[0,l_b]].
      CMAT3(1:,0:,0:), IN :: ft
      CMAT3(1:,0:,0:) :: res
      INT :: a,b,l_a,l_b
      l_a = ubound(ft,2)-1
      l_b = ubound(ft,3)-1
      res = ZERO
      do a = 0,l_a
         do b = 0,l_b
            res(:,a,b) = res(:,a,b) - TWO*.ex_b*ft(:,a,b+1) 
            res(:,a,b) = res(:,a,b) + TWO*.ex_a*ft(:,a+1,b) 
            if (b>0) res(:,a,b) = res(:,a,b) + b*ft(:,a,b-1) 
            if (a>0) res(:,a,b) = res(:,a,b) - a*ft(:,a-1,b) 
         end
      end
   end

   make_ft(ft,k_pts)
   ! Calculates the Fourier transform for a product of two primitive 
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
      MAT, target :: k_pts
      CMAT3 :: ft
      DBL  :: pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3,PI_on_gamma
      INT  :: k_max,n_a,n_b,a,b,k,ax,ay,az,bx,by,bz
      IMAT* :: la,lb
      CMAT3* :: ft_x,ft_y,ft_z
      CVEC* :: prefac
      VEC* :: k_x,k_y,k_z
      DBL :: g1_exa,g1_exb
      k_max = size(k_pts,1)
      n_a = .l_a.n_comp
      n_b = .l_b.n_comp
      gamma = .ex_a+.ex_b
      g1 = ONE/gamma
      g4 = 0.25d0*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma
      g1_exa = g1*.ex_a
      g1_exb = g1*.ex_b
      P1 = g1_exa*.pos_a(1) + g1_exb*.pos_b(1)
      P2 = g1_exa*.pos_a(2) + g1_exb*.pos_b(2)
      P3 = g1_exa*.pos_a(3) + g1_exb*.pos_b(3)
      la.create(3,n_a);   .l_a.make_gaussian_xyz_powers(la)
      lb.create(3,n_b);   .l_b.make_gaussian_xyz_powers(lb)
      ft_x.create((/1,k_max/),(/0,.l_a/),(/0,.l_b/))
      ft_y.create((/1,k_max/),(/0,.l_a/),(/0,.l_b/))
      ft_z.create((/1,k_max/),(/0,.l_a/),(/0,.l_b/))
      k_x => k_pts(:,1)
      k_y => k_pts(:,2)
      k_z => k_pts(:,3)
      .make_ft_component(ft_x,1,k_x,k_max)        ! Get the Fourier transforms
      .make_ft_component(ft_y,2,k_y,k_max)        ! of each component.
      .make_ft_component(ft_z,3,k_z,k_max)
      prefac.create(k_max)
      do k = 1,k_max
        k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
        dot1 = k1*P1+k2*P2+k3*P3
        dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
        prefac(k) = pifac*exp(cmplx(dot2,dot1))
      end
      do b = 1,n_b               ! Loop over all elements and multiply prefactor
         bx = lb(1,b)
         by = lb(2,b)
         bz = lb(3,b)
         do a = 1,n_a
            ax = la(1,a)
            ay = la(2,a)
            az = la(3,a)
            ft(:,a,b) = prefac(:)*ft_x(:,ax,bx)*ft_y(:,ay,by)*ft_z(:,az,bz)
         end
      end
      prefac.destroy
      lb.destroy
      la.destroy
      ft_z.destroy
      ft_y.destroy
      ft_x.destroy
   end

   make_ft_nabla(ft,k_pts)
   ! Calculates the Fourier transform of the current integrals for the product
   ! of two primitive gaussian functions, evaluated at a series of points
   ! "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! size of "ft" is [k_max],[.l_a.n_comp],[.l_b.n_comp],[3]
      MAT, IN :: k_pts
      CMAT4 :: ft
      CDBL :: ci,prefac
      DBL  :: pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3
      INT  :: k_max,n_a,n_b,a,b,k,ax,ay,az,bx,by,bz
      IMAT* :: la,lb
      CMAT3* :: ft_x,ft_y,ft_z,ft_dx,ft_dy,ft_dz
      ci = (ZERO,ONE)                         ! A few useful constants ...
      k_max = size(k_pts,1)
      n_a = size(ft,2)
      n_b = size(ft,3)
      gamma = .ex_a+.ex_b
      g1 = 1/gamma
      g4 = 0.25d0*g1
      pifac = (PI/gamma)**(1.5)
      P1 = g1*(.ex_a*.pos_a(1)+.ex_b*.pos_b(1))
      P2 = g1*(.ex_a*.pos_a(2)+.ex_b*.pos_b(2))
      P3 = g1*(.ex_a*.pos_a(3)+.ex_b*.pos_b(3))
      la.create(3, .l_a.n_comp );   .l_a.make_gaussian_xyz_powers(la)
      lb.create(3, .l_b.n_comp );   .l_b.make_gaussian_xyz_powers(lb)

      ft_x.create((/1,k_max/),(/0,.l_a/),(/0,.l_b/))
      ft_y.create((/1,k_max/),(/0,.l_a/),(/0,.l_b/))
      ft_z.create((/1,k_max/),(/0,.l_a/),(/0,.l_b/))
      .make_ft_component(ft_x,1,k_pts(:,1),k_max)        ! Get the Fourier transforms
      .make_ft_component(ft_y,2,k_pts(:,2),k_max)        ! of each component.
      .make_ft_component(ft_z,3,k_pts(:,3),k_max)
      ft_dx.create((/1,k_max/),(/0,.l_a/),(/0,.l_b/))
      ft_dy.create((/1,k_max/),(/0,.l_a/),(/0,.l_b/))
      ft_dz.create((/1,k_max/),(/0,.l_a/),(/0,.l_b/))
      .make_ft_dab_component(ft_dx,1,k_pts(:,1),k_max)   ! Get the Fourier transforms
      .make_ft_dab_component(ft_dy,2,k_pts(:,2),k_max)   ! of the derivative of each
      .make_ft_dab_component(ft_dz,3,k_pts(:,3),k_max)   ! component.

      do a = 1,n_a               ! Loop over all elements and multiply prefactor
         ax = la(1,a)
         ay = la(2,a)
         az = la(3,a)
         do b = 1,n_b
            bx = lb(1,b)
            by = lb(2,b)
            bz = lb(3,b)
            do k = 1,k_max
               k1 = k_pts(k,1)
               k2 = k_pts(k,2)
               k3 = k_pts(k,3)
               dot1 = k1*P1+k2*P2+k3*P3
               dot2 = k1*k1+k2*k2+k3*k3
               dot2 = -dot2*g4
               prefac = pifac*exp(ci*dot1)*exp(dot2)
               ft(k,a,b,1) = prefac*ft_dx(k,ax,bx)*ft_y(k,ay,by) *ft_z(k,az,bz)
               ft(k,a,b,2) = prefac*ft_x(k,ax,bx) *ft_dy(k,ay,by)*ft_z(k,az,bz)
               ft(k,a,b,3) = prefac*ft_x(k,ax,bx) *ft_y(k,ay,by) *ft_dz(k,az,bz)
            end
         end
      end
      lb.destroy
      la.destroy
      ft_dz.destroy
      ft_dy.destroy
      ft_dx.destroy
      ft_z.destroy
      ft_y.destroy
      ft_x.destroy
   end

   make_ft_r(ft,k_pts)
   ! Calculates the Fourier transform of the derivative of a product of two
   ! primitive gaussian functions, times vector r, evaluated at a series of
   ! points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! size of "ft" is [k_max],[.l_a.n_comp],[.l_b.n_comp],[3]
      MAT :: k_pts
      CMAT4 :: ft
      CDBL :: ci,prefac
      DBL  :: pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3
      INT  :: k_max,n_a,n_b,a,b,k,ax,ay,az,bx,by,bz
      IMAT* :: la,lb
      CMAT3* :: ft_x,ft_y,ft_z
      ci = (ZERO,ONE)                         ! A few useful constants ...
      k_max = size(k_pts,1)
      n_a = size(ft,2)
      n_b = size(ft,3)
      gamma = .ex_a+.ex_b
      g1 = 1/gamma
      g4 = 0.25d0*g1
      pifac = (PI/gamma)**(1.5)
      P1 = g1*(.ex_a*.pos_a(1)+.ex_b*.pos_b(1))
      P2 = g1*(.ex_a*.pos_a(2)+.ex_b*.pos_b(2))
      P3 = g1*(.ex_a*.pos_a(3)+.ex_b*.pos_b(3))
      la.create(3, .l_a.n_comp );   .l_a.make_gaussian_xyz_powers(la)
      lb.create(3, .l_b.n_comp );   .l_b.make_gaussian_xyz_powers(lb)

      ft_x.create((/1,k_max/),(/0,.l_a/),(/0,.l_b+1/))
      ft_y.create((/1,k_max/),(/0,.l_a/),(/0,.l_b+1/))
      ft_z.create((/1,k_max/),(/0,.l_a/),(/0,.l_b+1/))
      .make_ft_component(ft_x,1,k_pts(:,1),k_max)        ! Get the Fourier transforms
      .make_ft_component(ft_y,2,k_pts(:,2),k_max)        ! of each component.
      .make_ft_component(ft_z,3,k_pts(:,3),k_max)

      do a = 1,n_a               ! Loop over all elements and multiply prefactor
         ax = la(1,a)
         ay = la(2,a)
         az = la(3,a)
         do b = 1,n_b
            bx = lb(1,b)
            by = lb(2,b)
            bz = lb(3,b)
            do k = 1,k_max
               k1 = k_pts(k,1)
               k2 = k_pts(k,2)
               k3 = k_pts(k,3)
               dot1 = k1*P1+k2*P2+k3*P3
               dot2 = k1*k1+k2*k2+k3*k3
               dot2 = -dot2*g4
               prefac = pifac*exp(ci*dot1)*exp(dot2)
               ft(k,a,b,1) = prefac*(ft_x(k,ax,bx+1)+.pos_b(1)*ft_x(k,ax,bx))*ft_y(k,ay,by)*ft_z(k,az,bz)
               ft(k,a,b,2) = prefac*ft_x(k,ax,bx)*(ft_y(k,ay,by+1)+.pos_b(2)*ft_y(k,ay,by))*ft_z(k,az,bz)
               ft(k,a,b,3) = prefac*ft_x(k,ax,bx)*ft_y(k,ay,by)*(ft_z(k,az,bz+1)+.pos_b(3)*ft_z(k,az,bz))
            end
         end
      end
      lb.destroy
      la.destroy
      ft_z.destroy
      ft_y.destroy
      ft_x.destroy
   end

   put_e_coeff(out)
   ! Put the McMurchie Davidson E coefficients to file "out"
      TEXTFILE :: out
      INT ::  a,b,t
      MAT3* :: Ex 
      MAT3* :: Ey 
      MAT3* :: Ez 
      out.flush
      out.put_text("GAUSSIAN2 output:\n\n")
      out.put_text("Dylan Jayatilaka, University of Western Australia, March 1998\n\n")
      out.show("l_a   =",.l_a,dbl_width=TRUE)
      out.show("l_b   =",.l_a,dbl_width=TRUE)
      out.show("Ra    =",.pos_a)
      out.show("Rb    =",.pos_b)
      out.show("R     =",.pos_a-.pos_b)
      out.show("alpha =",.ex_a)
      out.show("beta  =",.ex_b)
      out.flush
      out.put_dash(int_fields=3,dbl_fields=3,flush=1)
      out.put("a",int_width=TRUE)
      out.put("b",int_width=TRUE)
      out.put("t",int_width=TRUE)
      out.put("Ex(t,a,b)")
      out.put("Ey(t,a,b)")
      out.put("Ez(t,a,b)",flush=1)
      Ex.create((/0,.l_a+.l_b/),(/0,.l_a/),(/0,.l_b/))
      .make_e_coeff(Ex,1)
      Ey.create((/0,.l_a+.l_b/),(/0,.l_a/),(/0,.l_b/))
      .make_e_coeff(Ey,2)
      Ez.create((/0,.l_a+.l_b/),(/0,.l_a/),(/0,.l_b/))
      .make_e_coeff(Ez,3)
      out.put_dash(int_fields=3,dbl_fields=3,flush=1)
      do a = 0,.l_a
      do b = 0,.l_b
      do t = 0,a+b
         out.put(a)
         out.put(b)
         out.put(t)
         out.put(Ex(t,a,b))
         out.put(Ey(t,a,b))
         out.put(Ez(t,a,b),flush=1)
      end 
      end 
      end 
      Ez.destroy
      Ey.destroy
      Ex.destroy
   end

!  **********************
!  CADPAC-style integrals
!  **********************

   make_overlap_ints(S)
   ! Make the overlap integral matrix "S". Uses Gauss-Hermite quadrature.
      MAT :: S
      MAT* :: Sx,Sy,Sz
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rab
      DBL :: p,prefac
      INT :: n_a,n_b
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx.create(.l_a+1,.l_b+1); Sy.create(.l_a+1,.l_b+1); Sz.create(.l_a+1,.l_b+1)
      .make_overlap_ints(Sx,1)
      .make_overlap_ints(Sy,2)
      .make_overlap_ints(Sz,3)
      S = Sx(ax,bx)*Sy(ay,by)*Sz(az,bz)
      Sz.destroy; Sy.destroy; Sx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      p = .ex_a + .ex_b
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)/(p*sqrt(p))
      S = prefac*S
   end

   make_overlap_ints(Sx,x)
   ! Make the 1-D overlap xyz integral matrix "Sx" for component "x". 
   ! Uses Gauss-Hermite quadrature.
      MAT :: Sx
      INT :: x
      DBL :: p,t,rp,ax,bx,wt,pt,ra,rb
      INT :: a,b,i,k
      p = .ex_a + .ex_b
      t = sqrt(p)
      ax = .pos_a(x)
      bx = .pos_b(x)
      rp = (.ex_a*ax + .ex_b*bx)/p
      Sx = ZERO
      do a = 1,.l_a+1
      do b = 1,.l_b+1
         i = (a+b)/2 
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
         end
      end
      end
   end

   make_dipole_ints(Dx,Dy,Dz,origin)
   ! Make the dipole integral matrices "Dx", "Dy", and "Dz". 
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      MAT :: Dx,Dy,Dz
      VEC(3) :: origin
      MAT* :: Sx,Sy,Sz,Rx,Ry,Rz
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rab
      DBL :: p,prefac
      INT :: n_a,n_b
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx.create(.l_a+1,.l_b+1); Sy.create(.l_a+1,.l_b+1); Sz.create(.l_a+1,.l_b+1)
      Rx.create(.l_a+1,.l_b+1); Ry.create(.l_a+1,.l_b+1); Rz.create(.l_a+1,.l_b+1)
      .make_dipole_ints(Sx,Rx,1,origin(1))
      .make_dipole_ints(Sy,Ry,2,origin(2))
      .make_dipole_ints(Sz,Rz,3,origin(3))
      Dx = Rx(ax,bx)*Sy(ay,by)*Sz(az,bz)
      Dy = Sx(ax,bx)*Ry(ay,by)*Sz(az,bz)
      Dz = Sx(ax,bx)*Sy(ay,by)*Rz(az,bz)
      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      p = .ex_a + .ex_b
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)/(p*sqrt(p))
      Dx = prefac*Dx
      Dy = prefac*Dy
      Dz = prefac*Dz
   end

   make_dipole_ints(Sx,Dx,x,ox,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx" and dipole integrals "Dx" for component "x". 
   ! "ox" is the origin for the dipole terms. If present, "max_a" and "max_b" override
   ! the l value for gaussian a or b. Uses Gauss-Hermite quadrature.
      MAT :: Sx,Dx
      INT :: x
      DBL :: ox
      INT, optional :: max_a,max_b
      DBL :: p,t,ax,bx,rp,wt,pt,ra,rb,rd
      INT :: l_a,l_b,a,b,i,k
      l_a = .l_a; if (present(max_a)) l_a = max_a
      l_b = .l_b; if (present(max_b)) l_b = max_b
      p = .ex_a + .ex_b
      t = sqrt(p)
      ax = .pos_a(x)
      bx = .pos_b(x)
      rp = (.ex_a*ax + .ex_b*bx)/p
      Sx = ZERO
      Dx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b-1)/2 + 1 ! 
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            rd = pt - ox
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
         end
      end
      end
   end

   make_quadrupole_ints(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz,origin)
   ! Make the qudrupole integral matrices "Qxx", ..., "Qyz". 
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      MAT :: Qxx,Qyy,Qzz,Qxy,Qxz,Qyz
      VEC(3) :: origin
      MAT* :: Sx,Sy,Sz,Rx,Ry,Rz,Qx,Qy,Qz
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rab
      DBL :: p,prefac
      INT :: n_a,n_b
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx.create(.l_a+1,.l_b+1); Sy.create(.l_a+1,.l_b+1); Sz.create(.l_a+1,.l_b+1)
      Rx.create(.l_a+1,.l_b+1); Ry.create(.l_a+1,.l_b+1); Rz.create(.l_a+1,.l_b+1)
      Qx.create(.l_a+1,.l_b+1); Qy.create(.l_a+1,.l_b+1); Qz.create(.l_a+1,.l_b+1)
      .make_quadrupole_ints(Sx,Rx,Qx,1,origin(1))
      .make_quadrupole_ints(Sy,Ry,Qy,2,origin(2))
      .make_quadrupole_ints(Sz,Rz,Qz,3,origin(3))
      Qxx = Qx(ax,bx)*Sy(ay,by)*Sz(az,bz)
      Qyy = Sx(ax,bx)*Qy(ay,by)*Sz(az,bz)
      Qzz = Sx(ax,bx)*Sy(ay,by)*Qz(az,bz)
      Qxy = Rx(ax,bx)*Ry(ay,by)*Qz(az,bz)
      Qxz = Rx(ax,bx)*Sy(ay,by)*Rz(az,bz)
      Qyz = Sx(ax,bx)*Ry(ay,by)*Rz(az,bz)
      Qz.destroy; Qy.destroy; Qx.destroy
      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      p = .ex_a + .ex_b
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)/(p*sqrt(p))
      Qxx = prefac*Qxx
      Qyy = prefac*Qyy
      Qzz = prefac*Qzz
      Qxy = prefac*Qxy
      Qxz = prefac*Qxz
      Qyz = prefac*Qyz
   end

   make_quadrupole_ints(Sx,Dx,Qx,x,ox,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx", dipole integrals "Dx" and quadruple integrals "Qx" 
   ! for component "x". "ox" is the origin for the dipole terms. 
   ! If present, "max_a" and "max_b" override the l value for gaussian a or b. 
   ! Uses Gauss-Hermite quadrature.
      MAT :: Sx,Dx,Qx
      INT :: x
      DBL :: ox
      INT, optional :: max_a,max_b
      DBL :: p,t,ax,bx,rp,wt,pt,ra,rb,rd
      INT :: l_a,l_b,a,b,i,k
      l_a = .l_a; if (present(max_a)) l_a = max_a
      l_b = .l_b; if (present(max_b)) l_b = max_b
      p = .ex_a + .ex_b
      t = sqrt(p)
      ax = .pos_a(x)
      bx = .pos_b(x)
      rp = (.ex_a*ax + .ex_b*bx)/p
      Sx = ZERO
      Dx = ZERO
      Qx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+2)/2 
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            rd = pt - ox
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
            Qx(a,b) = Qx(a,b) + rd*rd*wt
         end
      end
      end
   end

   make_octupole_ints(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz,origin)
   ! Make the octupole integral matrices "Oxxx", ..., "Oxyz". 
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      MAT :: Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz
      VEC(3) :: origin
      MAT* :: Sx,Sy,Sz,Rx,Ry,Rz,Qx,Qy,Qz,Ox,Oy,Oz
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rab
      DBL :: p,prefac
      INT :: n_a,n_b
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx.create(.l_a+1,.l_b+1); Sy.create(.l_a+1,.l_b+1); Sz.create(.l_a+1,.l_b+1)
      Rx.create(.l_a+1,.l_b+1); Ry.create(.l_a+1,.l_b+1); Rz.create(.l_a+1,.l_b+1)
      Qx.create(.l_a+1,.l_b+1); Qy.create(.l_a+1,.l_b+1); Qz.create(.l_a+1,.l_b+1)
      Ox.create(.l_a+1,.l_b+1); Oy.create(.l_a+1,.l_b+1); Oz.create(.l_a+1,.l_b+1)
      .make_octupole_ints(Sx,Rx,Qx,Ox,1,origin(1))
      .make_octupole_ints(Sy,Ry,Qy,Oy,2,origin(2))
      .make_octupole_ints(Sz,Rz,Qz,Oz,3,origin(3))
      Oxxx = Ox(ax,bx)*Sy(ay,by)*Sz(az,bz)
      Oyyy = Oy(ax,bx)*Sy(ay,by)*Sz(az,bz)
      Ozzz = Oz(ax,bx)*Sy(ay,by)*Sz(az,bz)
      Oxxy = Qx(ax,bx)*Ry(ay,by)*Sz(az,bz)
      Oxxz = Qx(ax,bx)*Sy(ay,by)*Rz(az,bz)
      Oyyx = Rx(ax,bx)*Qy(ay,by)*Sz(az,bz)
      Oyyz = Sx(ax,bx)*Qy(ay,by)*Rz(az,bz)
      Ozzx = Rx(ax,bx)*Sy(ay,by)*Qz(az,bz)
      Ozzy = Sx(ax,bx)*Ry(ay,by)*Qz(az,bz)
      Oxyz = Rx(ax,bx)*Ry(ay,by)*Rz(az,bz)
      Oz.destroy; Oy.destroy; Ox.destroy
      Qz.destroy; Qy.destroy; Qx.destroy
      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      p = .ex_a + .ex_b
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)/(p*sqrt(p))
      Oxxx = prefac*Oxxx
      Oyyy = prefac*Oyyy
      Ozzz = prefac*Ozzz
      Oxxy = prefac*Oxxy
      Oxxz = prefac*Oxxz
      Oyyx = prefac*Oyyx
      Oyyz = prefac*Oyyz
      Ozzx = prefac*Ozzx
      Ozzy = prefac*Ozzy
      Oxyz = prefac*Oxyz
   end

   make_octupole_ints(Sx,Dx,Qx,Ox,x,og,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx", dipole integrals "Dx", quadruple integrals "Qx",
   ! and the ocupole integrals "Ox", for component "x". "og" is the origin for the dipole terms. 
   ! If present, "max_a" and "max_b" override the l value for gaussian a or b. 
   ! Uses Gauss-Hermite quadrature.
      MAT :: Sx,Dx,Qx,Ox
      INT :: x
      DBL :: og
      INT, optional :: max_a,max_b
      DBL :: p,t,ax,bx,rp,wt,pt,ra,rb,rd,rd2
      INT :: l_a,l_b,a,b,i,k
      l_a = .l_a; if (present(max_a)) l_a = max_a
      l_b = .l_b; if (present(max_b)) l_b = max_b
      p = .ex_a + .ex_b
      t = sqrt(p)
      ax = .pos_a(x)
      bx = .pos_b(x)
      rp = (.ex_a*ax + .ex_b*bx)/p
      Sx = ZERO
      Dx = ZERO
      Qx = ZERO
      Ox = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+3)/2 
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            rd = pt - og
            rd2 = rd*rd
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
            Qx(a,b) = Qx(a,b) + rd2*wt
            Ox(a,b) = Qx(a,b) + rd2*rd*wt
         end
      end
      end
   end

   make_nuclear_attraction_ints(N,c)
   ! Make the nuclear attraction integral matrix "N" for a nucleus at position "c". 
   ! Uses Rys decomposition of 1/r_c and Gauss-Hermite quadrature.
      MAT :: N
      VEC(3) :: c
      MAT* :: Nx,Ny,Nz
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rpc,rab
      DBL :: p,xx,uu,wt,prefac
      INT :: n_a,n_b,n_roots,k
      RYS* :: rys
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Nx.create(.l_a+1,.l_b+1); Ny.create(.l_a+1,.l_b+1); Nz.create(.l_a+1,.l_b+1)
      n_roots = (.l_a+.l_b+2)/2
      p = .ex_a + .ex_b
      rpc = (.ex_a*.pos_a + .ex_b*.pos_b)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      N = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_nuclear_attraction_ints(Nx,1,uu,c(1))
         .make_nuclear_attraction_ints(Ny,2,uu,c(2))
         .make_nuclear_attraction_ints(Nz,3,uu,c(3))
         Nz = Nz*wt
         N = N + Nx(ax,bx)*Ny(ay,by)*Nz(az,bz)
      end
      rys.destroy
      Nz.destroy; Ny.destroy; Nx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)*pi212/p
      N = prefac*N
   end

   make_nuclear_attraction_ints(Nx,x,uu,cx,max_a,max_b)
   ! Make the 1-D nuclear attraction xyz integrals "Nx", for component "x", for a particular 
   ! Rys-gaussian with exponent "uu", used in the decomposition of 1/r_c centred at 
   ! position "cx". If present, "max_a" and "max_b" override the l value for gaussian a or b. 
   ! Uses Gauss-Hermite quadrature.
      MAT :: Nx
      INT :: x
      DBL :: uu,cx
      INT, optional :: max_a,max_b
      DBL :: p,t,ax,bx,r0,wt,pt,ra,rb
      INT :: l_a,l_b,a,b,i,k
      l_a = .l_a; if (present(max_a)) l_a = max_a
      l_b = .l_b; if (present(max_b)) l_b = max_b
      p = .ex_a + .ex_b + uu
      t = sqrt(p)
      ax = .pos_a(x)
      bx = .pos_b(x)
      r0 = (.ex_a*ax + .ex_b*bx + uu*cx)/p
      Nx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b)/2 ! should be max((a+b-1)/2,1) ?
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + r0
            ra = pt - ax
            rb = pt - bx
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Nx(a,b) = Nx(a,b) + wt
         end
      end
      end
   end

   make_spin_orbit_ints(Lx,Ly,Lz,c)
   ! Make the spin orbit integral matrices "Lx", "Ly", and "Lz" around nucleus "c".
   ! This integrals is for: (r - r_c) x nabla / |r - r_c|^3, with no minus sign on nabla.
   ! Uses Rys decomposition of 1/r_c and Gauss-Hermite quadrature.
      MAT :: Lx,Ly,Lz
      VEC(3) :: c
      MAT* :: NAx,NAy,NAz,AAx,AAy,AAz,BBx,BBy,BBz
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rpc,rab
      DBL :: p,xx,uu,wt,prefac
      INT :: n_a,n_b,n_roots,k
      RYS* :: rys
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      NAx.create(.l_a+2,.l_b+2); NAy.create(.l_a+2,.l_b+2); NAz.create(.l_a+2,.l_b+2)
      AAx.create(.l_a+1,.l_b+1); AAy.create(.l_a+1,.l_b+1); AAz.create(.l_a+1,.l_b+1)
      BBx.create(.l_a+1,.l_b+1); BBy.create(.l_a+1,.l_b+1); BBz.create(.l_a+1,.l_b+1)
      n_roots = (.l_a+.l_b+3)/2
      p = .ex_a + .ex_b
      rpc = (.ex_a*.pos_a + .ex_b*.pos_b)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Lx = ZERO
      Ly = ZERO
      Lz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k) 
         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.l_a+1,.l_b+1)
         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.l_a+1,.l_b+1)
         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.l_a+1,.l_b+1)
         NAz = NAz*wt
         .differentiate(NAx,"right",BBx) ! with respect to electron coordinates !
         .differentiate(NAy,"right",BBy) 
         .differentiate(NAz,"right",BBz) 
         .differentiate(NAx,"left ",AAx) ! with respect to electron coordinates !
         .differentiate(NAy,"left ",AAy) 
         .differentiate(NAz,"left ",AAz) 
         Lx = Lx + NAx(ax,bx)*(AAy(ay,by)*BBz(az,bz)-BBy(ay,by)*AAz(az,bz))
         Ly = Ly + NAy(ay,by)*(AAz(az,bz)*BBx(ax,bx)-BBz(az,bz)*AAx(ax,bx))
         Lz = Lz + NAz(az,bz)*(AAx(ax,bx)*BBy(ay,by)-BBx(ax,bx)*AAy(ay,by))
      end
      rys.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)*pi212/p
      Lx = prefac*Lx
      Ly = prefac*Ly
      Lz = prefac*Lz
   end

   make_e_field_ints(Ex,Ey,Ez,c,max_a,max_b)
   ! Make the electric field integral matrices "Ei" at position "c". If present, 
   ! "max_a" and "max_b" indicate the l value to be used for gaussian a or b, 
   ! respectively. Uses Rys decomposition of 1/r_c and Gauss-Hermite quadrature.
      MAT :: Ex,Ey,Ez
      VEC(3) :: c
      INT, optional :: max_a,max_b
      MAT* :: Sx,Sy,Sz,Fx,Fy,Fz
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rpc,rab
      DBL :: p,xx,uu,wt,prefac
      INT :: l_a,l_b,n_a,n_b,n_roots,k
      RYS* :: rys
      l_a = .l_a; if (present(max_a)) l_a = max_a
      l_b = .l_b; if (present(max_b)) l_b = max_b
      n_a = (l_a+1)*(l_a+2)/2
      n_b = (l_b+1)*(l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx.create(l_a+1,l_b+1); Sy.create(l_a+1,l_b+1); Sz.create(l_a+1,l_b+1)
      Fx.create(l_a+1,l_b+1); Fy.create(l_a+1,l_b+1); Fz.create(l_a+1,l_b+1)
      n_roots = (l_a+l_b+1)/2 + 1
      p = .ex_a + .ex_b
      rpc = (.ex_a*.pos_a + .ex_b*.pos_b)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Ex = ZERO; Ey = ZERO; Ez = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_e_field_ints(Sx,Fx,1,uu,c(1),l_a,l_b)
         .make_e_field_ints(Sy,Fy,2,uu,c(2),l_a,l_b)
         .make_e_field_ints(Sz,Fz,3,uu,c(3),l_a,l_b)
         Sz = Sz*wt
         Fz = Fz*wt
         Ex = Ex + Fx(ax,bx)*Sy(ay,by)*Sz(az,bz)
         Ey = Ey + Sx(ax,bx)*Fy(ay,by)*Sz(az,bz)
         Ez = Ez + Sx(ax,bx)*Sy(ay,by)*Fz(az,bz)
      end
      rys.destroy
      Fz.destroy; Fy.destroy; Fx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)*pi212/p
      Ex = prefac*Ex
      Ey = prefac*Ey
      Ez = prefac*Ez
   end

   make_e_field_ints(Sx,Fx,x,uu,cx,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx", and the electric field integrals "Fx" 
   ! for component "x", for a particular Rys-gaussian with exponent "uu", used in the 
   ! decomposition of (c-r)/|c-r|^3 centred at position "cx". Uses Gauss-Hermite quadrature.
   ! If present, "max_a" and "max_b" indicate the l value to be used for gaussian a or b, 
      MAT :: Sx,Fx
      INT :: x
      DBL :: uu,cx
      INT, optional :: max_a,max_b
      DBL :: p,t,ax,bx,r0,ff,pt,wt,ra,rb,ru
      INT :: l_a,l_b,a,b,i,k
      l_a = .l_a; if (present(max_a)) l_a = max_a
      l_b = .l_b; if (present(max_b)) l_b = max_b
      p = .ex_a + .ex_b + uu
      t = sqrt(p)
      ax = .pos_a(x)
      bx = .pos_b(x)
      r0 = (.ex_a*ax + .ex_b*bx + uu*cx)/p
      Sx = ZERO; Fx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+1)/2 ! should be max((a+b)/2,1) ?
         do k = first_pt(i),last_pt(i)
            pt = gauss_hermite_pt(k)/t + r0
            ra = pt - ax
            rb = pt - bx
            ru = TWO*uu*(cx-pt)
            ff = ONE
            if(a>1) ff = ff*ra**(a-1)
            if(b>1) ff = ff*rb**(b-1)
            wt = gauss_hermite_wt(k)
            Sx(a,b) = Sx(a,b) + ff*wt
            Fx(a,b) = Fx(a,b) + ru*ff*wt
         end
      end
      end
   end

   make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,c,origin)
   ! Make gauge modified (B field) spin orbit integral matrices "Qij" around nucleus "c".
   ! using gauge origin "origin".  The integrals are:
   !    Qij(a,b) = <a| (r-o)_i (r-c)_j / |r-c|^3 |b>
   ! Uses Rys decomposition of 1/|r-c| and Gauss-Hermite quadrature.
      MAT :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
      VEC(3) :: c,origin
      MAT* :: Sx,Sy,Sz,Dx,Dy,Dz,Fx,Fy,Fz,Qx,Qy,Qz
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rpc,rab
      DBL :: p,xx,uu,wt,prefac
      INT :: n_a,n_b,n_roots,k
      RYS* :: rys
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx.create(.l_a+1,.l_b+1); Sy.create(.l_a+1,.l_b+1); Sz.create(.l_a+1,.l_b+1)
      Dx.create(.l_a+1,.l_b+1); Dy.create(.l_a+1,.l_b+1); Dz.create(.l_a+1,.l_b+1)
      Fx.create(.l_a+1,.l_b+1); Fy.create(.l_a+1,.l_b+1); Fz.create(.l_a+1,.l_b+1)
      Qx.create(.l_a+1,.l_b+1); Qy.create(.l_a+1,.l_b+1); Qz.create(.l_a+1,.l_b+1)
      n_roots = (.l_a+.l_b+3)/2
      p = .ex_a + .ex_b
      rpc = (.ex_a*.pos_a + .ex_b*.pos_b)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Qxx = ZERO; Qyx = ZERO; Qzx = ZERO
      Qxy = ZERO; Qyy = ZERO; Qzy = ZERO
      Qxz = ZERO; Qyz = ZERO; Qzz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k) 
         .make_q_field_ints(Sx,Dx,Fx,Qx,1,uu,c(1),origin(1))
         .make_q_field_ints(Sy,Dy,Fy,Qy,2,uu,c(2),origin(2))
         .make_q_field_ints(Sz,Dz,Fz,Qz,3,uu,c(3),origin(3))
         Sz = Sz*wt; Dz = Dz*wt; Fz = Fz*wt; Qz = Qz*wt
         Qxx = Qxx + Qx(ax,bx)*Sy(ay,by)*Sz(az,bz)
         Qyx = Qyx + Fx(ax,bx)*Dy(ay,by)*Sz(az,bz)
         Qzx = Qzx + Fx(ax,bx)*Sy(ay,by)*Dz(az,bz)
         Qxy = Qxy + Dx(ax,bx)*Fy(ay,by)*Sz(az,bz)
         Qyy = Qyy + Sx(ax,bx)*Qy(ay,by)*Sz(az,bz)
         Qzy = Qzy + Sx(ax,bx)*Fy(ay,by)*Dz(az,bz)
         Qxz = Qxz + Dx(ax,bx)*Sy(ay,by)*Fz(az,bz)
         Qyz = Qyz + Sx(ax,bx)*Dy(ay,by)*Fz(az,bz)
         Qzz = Qzz + Sx(ax,bx)*Sy(ay,by)*Qz(az,bz)
      end
      rys.destroy
      Qz.destroy; Qy.destroy; Qx.destroy
      Fz.destroy; Fy.destroy; Fx.destroy
      Dz.destroy; Dy.destroy; Dx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)*pi212/p
      Qxx = prefac*Qxx; Qyx = prefac*Qyx; Qzx = prefac*Qzx
      Qxy = prefac*Qxy; Qyy = prefac*Qyy; Qzy = prefac*Qzy
      Qxz = prefac*Qxz; Qyz = prefac*Qyz; Qzz = prefac*Qzz
   end

   make_q_field_ints(Sx,Dx,Fx,Qx,x,uu,cx,ox,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx", dipole integrals "Dx", electric field integrals "Fx",
   ! and the dipole-electric field integrals "Qx" for component "x". "uu" is the Rys-gaussian 
   ! exponent used in the decomposition of (c-r)/|c-r|^3 centred at position "cx". 
   ! "ox" is the origin for the dipole terms. If present, "max_a" and "max_b" override
   ! the l value for gaussian a or b. Uses Gauss-Hermite quadrature.
      MAT :: Sx,Dx,Fx,Qx
      INT :: x
      DBL :: uu,cx,ox
      INT, optional :: max_a,max_b
      DBL :: p,t,ax,bx,r0,wt,pt,ra,rb,ru,rd
      INT :: l_a,l_b,a,b,i,k
      l_a = .l_a; if (present(max_a)) l_a = max_a
      l_b = .l_b; if (present(max_b)) l_b = max_b
      p = .ex_a + .ex_b + uu
      t = sqrt(p)
      ax = .pos_a(x)
      bx = .pos_b(x)
      r0 = (.ex_a*ax + .ex_b*bx + uu*cx)/p
      Sx = ZERO; Dx = ZERO; Fx = ZERO; Qx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+2)/2 ! should be max((a+b+1)/2,1) ?
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + r0
            ra = pt - ax
            rb = pt - bx
            ru = TWO*uu*(cx-pt)
            rd = pt - ox
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
            Fx(a,b) = Fx(a,b) + ru*wt
            Qx(a,b) = Qx(a,b) + ru*rd*wt
         end
      end
      end
   end

   make_L_ints(Lx,Ly,Lz,origin)
   ! Make the angular momentum integral matrices "Lx", "Ly", and "Lz". 
   ! The integrals are for (r x nabla) with *no* minus sign on nabla.
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      MAT :: Lx,Ly,Lz
      VEC(3) :: origin
      MAT* :: Sx,Sy,Sz,Rx,Ry,Rz,Dx,Dy,Dz
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rab
      DBL :: p,prefac
      INT :: n_a,n_b
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx.create(.l_a+1,.l_b+2); Sy.create(.l_a+1,.l_b+2); Sz.create(.l_a+1,.l_b+2)
      Rx.create(.l_a+1,.l_b+2); Ry.create(.l_a+1,.l_b+2); Rz.create(.l_a+1,.l_b+2)
      Dx.create(.l_a+1,.l_b+1); Dy.create(.l_a+1,.l_b+1); Dz.create(.l_a+1,.l_b+1)
      .make_dipole_ints(Sx,Rx,1,origin(1),max_b=.l_b+1)
      .make_dipole_ints(Sy,Ry,2,origin(2),max_b=.l_b+1)
      .make_dipole_ints(Sz,Rz,3,origin(3),max_b=.l_b+1)
      .differentiate(Sx,"right",Dx) 
      .differentiate(Sy,"right",Dy) 
      .differentiate(Sz,"right",Dz) 
      Lx = Sx(ax,bx)*(Ry(ay,by)*Dz(az,bz)-Dy(ay,by)*Rz(az,bz))
      Ly = Sy(ay,by)*(Rz(az,bz)*Dx(ax,bx)-Dz(az,bz)*Rx(ax,bx))
      Lz = Sz(az,bz)*(Rx(ax,bx)*Dy(ay,by)-Dx(ax,bx)*Ry(ay,by))
      Dz.destroy; Dy.destroy; Dx.destroy
      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      p = .ex_a + .ex_b
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)/(p*sqrt(p))
      Lx = prefac*Lx 
      Ly = prefac*Ly
      Lz = prefac*Lz
   end

   differentiate(I,index,D) 
   ! Differentiate a gaussian-integral matrix "I" with respect to the
   ! *electron* coordinate on basis function "index", which can be "left" 
   ! or "right". Place the result in "D".
      MAT :: I,D
      STR(*) :: index
      INT :: i_a,i_b,d_a,d_b,a,b
      DBL :: a2,b2
      i_a = ubound(I,1); i_b = ubound(I,2)
      d_a = ubound(D,1); d_b = ubound(D,2)
      D = ZERO
      select case (index)
         case("l","left")
            ENSURE(i_a>1,   "I array too small to differentiate")
            ENSURE(i_a>d_a, "I and D arrays are incompatible")
            ENSURE(i_b>=d_b,"I and D arrays are incompatible")
            a2 = TWO*.ex_a
            D(1,:) = -a2*I(2  ,1:d_b) 
            do a = 2,d_a
            D(a,:) = -a2*I(a+1,1:d_b) + (a-1)*I(a-1,1:d_b) 
            end
         case("r","right")
            ENSURE(i_b>1,   "I array too small to differentiate")
            ENSURE(i_b>d_b, "I and D arrays are incompatible")
            ENSURE(i_a>=d_a,"I and D arrays are incompatible")
            b2 = TWO*.ex_b
            D(:,1) = -b2*I(1:d_a,2  ) 
            do b = 2,d_b
            D(:,b) = -b2*I(1:d_a,b+1) + (b-1)*I(1:d_a,b-1)
            end
      end
   end

   make_magnetic_jp_ints(Jx,Jy,Jz,c)
   ! Make the magnetic Jp integrals "Ji", evaluated at point "c",
   !    <a|J(c)|b> = \int dr [g_a grad g_b - g_b grad g_a] x (c - r)/ |c - r|^3
   ! These are used to get the magnetic field from the paramegnetic current density,
   !      B(c) = ( mu_o / 4 pi ) \int dr J(r) x (c - r)/|c - r|^3 
   ! Note: in atomic units mu_o = 4 pi / c^2. 
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      MAT :: Jx,Jy,Jz
      VEC(3) :: c
      MAT* :: Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxmm,Symm,Szmm
      MAT* :: Fx00,Fy00,Fz00
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rpc,rab
      DBL :: p,xx,uu,wt,prefac
      INT :: n_a,n_b,n_roots,k
      RYS* :: rys
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx00.create(.l_a+2,.l_b+2); Sy00.create(.l_a+2,.l_b+2); Sz00.create(.l_a+2,.l_b+2)
      Sx10.create(.l_a+1,.l_b+1); Sy10.create(.l_a+1,.l_b+1); Sz10.create(.l_a+1,.l_b+1)
      Sx01.create(.l_a+1,.l_b+1); Sy01.create(.l_a+1,.l_b+1); Sz01.create(.l_a+1,.l_b+1)
      Sxmm.create(.l_a+1,.l_b+1); Symm.create(.l_a+1,.l_b+1); Szmm.create(.l_a+1,.l_b+1)
      Fx00.create(.l_a+2,.l_b+2); Fy00.create(.l_a+2,.l_b+2); Fz00.create(.l_a+2,.l_b+2)
      p = .ex_a + .ex_b
      rpc = (.ex_a*.pos_a + .ex_b*.pos_b)/p - c
      n_roots = (.l_a+.l_b+1)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_e_field_ints(Sx00,Fx00,1,uu,c(1),.l_a+1,.l_b+1)
         .make_e_field_ints(Sy00,Fy00,2,uu,c(2),.l_a+1,.l_b+1)
         .make_e_field_ints(Sz00,Fz00,3,uu,c(3),.l_a+1,.l_b+1)
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01) 
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01) 
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01) 
         Sxmm = Sx01 - Sx10
         Symm = Sy01 - Sy10
         Szmm = Sz01 - Sz10
         Jx = Jx + Sx00(ax,bx)*Symm(ay,by)*Fz00(az,bz) &
                 - Sx00(ax,bx)*Fy00(ay,by)*Szmm(az,bz)
         Jy = Jy + Fx00(ax,bx)*Sy00(ay,by)*Szmm(az,bz) &
                 - Sxmm(ax,bx)*Sy00(ay,by)*Fz00(az,bz)
         Jz = Jz + Sxmm(ax,bx)*Fy00(ay,by)*Sz00(az,bz) &
                 - Fx00(ax,bx)*Symm(ay,by)*Sz00(az,bz)
      end
      rys.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szmm.destroy; Symm.destroy; Sxmm.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)*pi212/p
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz
   end

   make_magnetic_S_ints(Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz,c)
   ! Make the magnetic spin density integrals "Mij", evaluated at point "c",
   !    <a|Mij(c)|b> = \int dr [curl( g_a(r) g_b(r) S_j ) x (c - r)]_i/ |c - r|^3
   ! These are used to get the magnetic field from the spin density,
   !      B(c) = -(g mu_b mu_o / 4 pi) 
   !             \int dr curl rho_spin(r) x (c - r)/|c - r|3 
   ! Note: in atomic units mu_o = 4 pi / c^2. 
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      MAT :: Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz
      VEC(3) :: c
      MAT* :: Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxpp,Sypp,Szpp
      MAT* :: Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxpp,Fypp,Fzpp
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rpc,rab
      DBL :: p,xx,uu,wt,prefac
      INT :: n_a,n_b,n_roots,k
      RYS* :: rys
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx00.create(.l_a+2,.l_b+2); Sy00.create(.l_a+2,.l_b+2); Sz00.create(.l_a+2,.l_b+2)
      Sx10.create(.l_a+1,.l_b+1); Sy10.create(.l_a+1,.l_b+1); Sz10.create(.l_a+1,.l_b+1)
      Sx01.create(.l_a+1,.l_b+1); Sy01.create(.l_a+1,.l_b+1); Sz01.create(.l_a+1,.l_b+1)
      Sxpp.create(.l_a+1,.l_b+1); Sypp.create(.l_a+1,.l_b+1); Szpp.create(.l_a+1,.l_b+1)
      Fx00.create(.l_a+2,.l_b+2); Fy00.create(.l_a+2,.l_b+2); Fz00.create(.l_a+2,.l_b+2)
      Fx10.create(.l_a+1,.l_b+1); Fy10.create(.l_a+1,.l_b+1); Fz10.create(.l_a+1,.l_b+1)
      Fx01.create(.l_a+1,.l_b+1); Fy01.create(.l_a+1,.l_b+1); Fz01.create(.l_a+1,.l_b+1)
      Fxpp.create(.l_a+1,.l_b+1); Fypp.create(.l_a+1,.l_b+1); Fzpp.create(.l_a+1,.l_b+1)
      p = .ex_a + .ex_b
      rpc = (.ex_a*.pos_a + .ex_b*.pos_b)/p - c
      n_roots = (.l_a+.l_b+2)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Mxx = ZERO; Mxy = ZERO; Mxz = ZERO
      Myx = ZERO; Myy = ZERO; Myz = ZERO
      Mzx = ZERO; Mzy = ZERO; Mzz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_e_field_ints(Sx00,Fx00,1,uu,c(1),.l_a+1,.l_b+1)
         .make_e_field_ints(Sy00,Fy00,2,uu,c(2),.l_a+1,.l_b+1)
         .make_e_field_ints(Sz00,Fz00,3,uu,c(3),.l_a+1,.l_b+1)
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01) 
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01) 
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01) 
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01) 
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01) 
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01) 
         Sxpp = Sx01 + Sx10
         Sypp = Sy01 + Sy10
         Szpp = Sz01 + Sz10
         Fxpp = Fx01 + Fx10
         Fypp = Fy01 + Fy10
         Fzpp = Fz01 + Fz10
         Mxx = Mxx + Sx00(ax,bx)*Sy00(ay,by)*Fzpp(az,bz) & 
                   + Sx00(ax,bx)*Fypp(ay,by)*Sz00(az,bz)
         Mxz = Mxz - Sxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)  
         Mxy = Mxy - Sxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz)  
         Myy = Myy + Fxpp(ax,bx)*Sy00(ay,by)*Sz00(az,bz) &
                   + Sx00(ax,bx)*Sy00(ay,by)*Fzpp(az,bz)
         Myx = Myx - Fx00(ax,bx)*Sypp(ay,by)*Sz00(az,bz)  
         Myz = Myz - Sx00(ax,bx)*Sypp(ay,by)*Fz00(az,bz)  
         Mzz = Mzz + Sx00(ax,bx)*Fypp(ay,by)*Sz00(az,bz) &
                   + Fxpp(ax,bx)*Sy00(ay,by)*Sz00(az,bz)
         Mzy = Mzy - Sx00(ax,bx)*Fy00(ay,by)*Szpp(az,bz)  
         Mzx = Mzx - Fx00(ax,bx)*Sy00(ay,by)*Szpp(az,bz)  
      end
      rys.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)*pi212/p
      Mxx = prefac*Mxx; Mxy = prefac*Mxy; Mxz = prefac*Mxz
      Myx = prefac*Myx; Myy = prefac*Myy; Myz = prefac*Myz
      Mzx = prefac*Mzx; Mzy = prefac*Mzy; Mzz = prefac*Mzz
   end

   make_solenoidal_jp_ints(Jx,Jy,Jz,c)
   ! Make the solenoidal Jp integrals "Ji", evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr curl [g_a grad g_b - g_b grad g_a] x (c - r)/ |c - r|^3
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      MAT :: Jx,Jy,Jz
      VEC(3) :: c
      MAT* :: Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxpp,Sypp,Szpp,Sxmm,Symm,Szmm
      MAT* :: Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxpp,Fypp,Fzpp,Fxmm,Fymm,Fzmm
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rpc,rab
      DBL :: p,xx,uu,wt,prefac
      INT :: n_a,n_b,n_roots,k
      RYS* :: rys
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx00.create(.l_a+2,.l_b+2); Sy00.create(.l_a+2,.l_b+2); Sz00.create(.l_a+2,.l_b+2)
      Sx10.create(.l_a+1,.l_b+1); Sy10.create(.l_a+1,.l_b+1); Sz10.create(.l_a+1,.l_b+1)
      Sx01.create(.l_a+1,.l_b+1); Sy01.create(.l_a+1,.l_b+1); Sz01.create(.l_a+1,.l_b+1)
      Sxpp.create(.l_a+1,.l_b+1); Sypp.create(.l_a+1,.l_b+1); Szpp.create(.l_a+1,.l_b+1)
      Sxmm.create(.l_a+1,.l_b+1); Symm.create(.l_a+1,.l_b+1); Szmm.create(.l_a+1,.l_b+1)
      Fx00.create(.l_a+2,.l_b+2); Fy00.create(.l_a+2,.l_b+2); Fz00.create(.l_a+2,.l_b+2)
      Fx10.create(.l_a+1,.l_b+1); Fy10.create(.l_a+1,.l_b+1); Fz10.create(.l_a+1,.l_b+1)
      Fx01.create(.l_a+1,.l_b+1); Fy01.create(.l_a+1,.l_b+1); Fz01.create(.l_a+1,.l_b+1)
      Fxpp.create(.l_a+1,.l_b+1); Fypp.create(.l_a+1,.l_b+1); Fzpp.create(.l_a+1,.l_b+1)
      Fxmm.create(.l_a+1,.l_b+1); Fymm.create(.l_a+1,.l_b+1); Fzmm.create(.l_a+1,.l_b+1)
      p = .ex_a + .ex_b
      rpc = (.ex_a*.pos_a + .ex_b*.pos_b)/p - c
      n_roots = (.l_a+.l_b+2)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_e_field_ints(Sx00,Fx00,1,uu,c(1),.l_a+1,.l_b+1)
         .make_e_field_ints(Sy00,Fy00,2,uu,c(2),.l_a+1,.l_b+1)
         .make_e_field_ints(Sz00,Fz00,3,uu,c(3),.l_a+1,.l_b+1)
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01) 
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01) 
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01) 
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01) 
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01) 
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01) 
         Sxpp = Sx01 + Sx10; Sxmm = Sx01 - Sx10
         Sypp = Sy01 + Sy10; Symm = Sy01 - Sy10
         Szpp = Sz01 + Sz10; Szmm = Sz01 - Sz10
         Fxpp = Fx01 + Fx10; Fxmm = Fx01 - Fx10
         Fypp = Fy01 + Fy10; Fymm = Fy01 - Fy10
         Fzpp = Fz01 + Fz10; Fzmm = Fz01 - Fz10
         Jx = Jx &
            + Sxmm(ax,bx)*Sy00(ay,by)*Fzpp(az,bz) &
            - Sxpp(ax,bx)*Sy00(ay,by)*Fzmm(az,bz) &
            - Sxpp(ax,bx)*Fymm(ay,by)*Sz00(az,bz) &
            + Sxmm(ax,bx)*Fypp(ay,by)*Sz00(az,bz)
         Jy = Jy &
            + Fxpp(ax,bx)*Symm(ay,by)*Sz00(az,bz) &
            - Fxmm(ax,bx)*Sypp(ay,by)*Sz00(az,bz) &
            - Sx00(ax,bx)*Sypp(ay,by)*Fzmm(az,bz) &
            + Sx00(ax,bx)*Symm(ay,by)*Fzpp(az,bz)
         Jz = Jz &
            + Sx00(ax,bx)*Fypp(ay,by)*Szmm(az,bz) &
            - Sx00(ax,bx)*Fymm(ay,by)*Szpp(az,bz) &
            - Fxmm(ax,bx)*Sy00(ay,by)*Szpp(az,bz) &
            + Fxpp(ax,bx)*Sy00(ay,by)*Szmm(az,bz)
      end
      rys.destroy
      Fzmm.destroy; Fymm.destroy; Fxmm.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szmm.destroy; Symm.destroy; Sxmm.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz
   end

   make_solenoidal_jd_ints(Jx,Jy,Jz,B_field,origin,c)
   ! Make the solenoidal Jd integrals "Ji", with external magnetic field "B_field",
   ! gauge origin "origin",evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr (curl J^d_ab(r)) x (c - r)/ |c - r|^3
   !     curl J^d_ab(r) = B (2 g_a(r)g_b(r) + (r-r_o).grad g_a(r)g_b(r)) 
   !                      - (r-r_o)(B.grad g_a(r)g_b(r))
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      MAT :: Jx,Jy,Jz
      VEC(3) :: B_field,origin,c
      MAT* :: Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxpp,Sypp,Szpp
      MAT* :: Dx00,Dy00,Dz00,Dx10,Dy10,Dz10,Dx01,Dy01,Dz01,Dxpp,Dypp,Dzpp
      MAT* :: Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxpp,Fypp,Fzpp
      MAT* :: Qx00,Qy00,Qz00,Qx10,Qy10,Qz10,Qx01,Qy01,Qz01,Qxpp,Qypp,Qzpp
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rpc,rab
      DBL :: p,xx,uu,wt,prefac
      INT :: n_a,n_b,n_roots,k
      RYS* :: rys
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx00.create(.l_a+2,.l_b+2); Sy00.create(.l_a+2,.l_b+2); Sz00.create(.l_a+2,.l_b+2)
      Sx10.create(.l_a+1,.l_b+1); Sy10.create(.l_a+1,.l_b+1); Sz10.create(.l_a+1,.l_b+1)
      Sx01.create(.l_a+1,.l_b+1); Sy01.create(.l_a+1,.l_b+1); Sz01.create(.l_a+1,.l_b+1)
      Sxpp.create(.l_a+1,.l_b+1); Sypp.create(.l_a+1,.l_b+1); Szpp.create(.l_a+1,.l_b+1)
      Dx00.create(.l_a+2,.l_b+2); Dy00.create(.l_a+2,.l_b+2); Dz00.create(.l_a+2,.l_b+2)
      Dx10.create(.l_a+1,.l_b+1); Dy10.create(.l_a+1,.l_b+1); Dz10.create(.l_a+1,.l_b+1)
      Dx01.create(.l_a+1,.l_b+1); Dy01.create(.l_a+1,.l_b+1); Dz01.create(.l_a+1,.l_b+1)
      Dxpp.create(.l_a+1,.l_b+1); Dypp.create(.l_a+1,.l_b+1); Dzpp.create(.l_a+1,.l_b+1)
      Fx00.create(.l_a+2,.l_b+2); Fy00.create(.l_a+2,.l_b+2); Fz00.create(.l_a+2,.l_b+2)
      Fx10.create(.l_a+1,.l_b+1); Fy10.create(.l_a+1,.l_b+1); Fz10.create(.l_a+1,.l_b+1)
      Fx01.create(.l_a+1,.l_b+1); Fy01.create(.l_a+1,.l_b+1); Fz01.create(.l_a+1,.l_b+1)
      Fxpp.create(.l_a+1,.l_b+1); Fypp.create(.l_a+1,.l_b+1); Fzpp.create(.l_a+1,.l_b+1)
      Qx00.create(.l_a+2,.l_b+2); Qy00.create(.l_a+2,.l_b+2); Qz00.create(.l_a+2,.l_b+2)
      Qx10.create(.l_a+1,.l_b+1); Qy10.create(.l_a+1,.l_b+1); Qz10.create(.l_a+1,.l_b+1)
      Qx01.create(.l_a+1,.l_b+1); Qy01.create(.l_a+1,.l_b+1); Qz01.create(.l_a+1,.l_b+1)
      Qxpp.create(.l_a+1,.l_b+1); Qypp.create(.l_a+1,.l_b+1); Qzpp.create(.l_a+1,.l_b+1)
      p = .ex_a + .ex_b
      rpc = (.ex_a*.pos_a + .ex_b*.pos_b)/p - c
      n_roots = (.l_a+.l_b+3)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_q_field_ints(Sx00,Dx00,Fx00,Qx00,1,uu,c(1),origin(1),.l_a+1,.l_b+1)
         .make_q_field_ints(Sy00,Dy00,Fy00,Qy00,2,uu,c(2),origin(2),.l_a+1,.l_b+1)
         .make_q_field_ints(Sz00,Dz00,Fz00,Qz00,3,uu,c(3),origin(3),.l_a+1,.l_b+1)
         Sz00 =  Sz00*wt
         Dz00 =  Dz00*wt
         Fx00 = -Fx00     ! minus sign to give (c-r) instead of (r-c)
         Fy00 = -Fy00
         Fz00 = -Fz00*wt
         Qx00 = -Qx00     
         Qy00 = -Qy00
         Qz00 = -Qz00*wt
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01) 
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01) 
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01) 
         .differentiate(Dx00,"left",Dx10); .differentiate(Dx00,"right",Dx01) 
         .differentiate(Dy00,"left",Dy10); .differentiate(Dy00,"right",Dy01) 
         .differentiate(Dz00,"left",Dz10); .differentiate(Dz00,"right",Dz01) 
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01) 
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01) 
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01) 
         .differentiate(Qx00,"left",Qx10); .differentiate(Qx00,"right",Qx01) 
         .differentiate(Qy00,"left",Qy10); .differentiate(Qy00,"right",Qy01) 
         .differentiate(Qz00,"left",Qz10); .differentiate(Qz00,"right",Qz01) 
         Sxpp = Sx01 + Sx10
         Sypp = Sy01 + Sy10
         Szpp = Sz01 + Sz10
         Dxpp = Dx01 + Dx10
         Dypp = Dy01 + Dy10
         Dzpp = Dz01 + Dz10
         Fxpp = Fx01 + Fx10
         Fypp = Fy01 + Fy10
         Fzpp = Fz01 + Fz10
         Qxpp = Qx01 + Qx10
         Qypp = Qy01 + Qy10
         Qzpp = Qz01 + Qz10
         Jx = Jx &
          + B_field(2)*( TWO*Sx00(ax,bx)*Sy00(ay,by)*Fz00(az,bz) &
          + Dxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)  &
          + Sx00(ax,bx)*Dypp(ay,by)*Fz00(az,bz)  &
          + Sx00(ax,bx)*Sy00(ay,by)*Qzpp(az,bz)) &
          - B_field(3)*( TWO*Sx00(ax,bx)*Fy00(ay,by)*Sz00(az,bz) &
          + Dxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz)  &
          + Sx00(ax,bx)*Qypp(ay,by)*Sz00(az,bz)  &
          + Sx00(ax,bx)*Fy00(ay,by)*Dzpp(az,bz)) &
          - B_field(1)*(Sxpp(ax,bx)*Dy00(ay,by)*Fz00(az,bz) - Sxpp(ax,bx)*Fy00(ay,by)*Dz00(az,bz)) &
          - B_field(2)*(Sx00(ax,bx)*Dypp(ay,by)*Fz00(az,bz) - Sx00(ax,bx)*Fypp(ay,by)*Dz00(az,bz)) &
          - B_field(3)*(Sx00(ax,bx)*Dy00(ay,by)*Fzpp(az,bz) - Sx00(ax,bx)*Fy00(ay,by)*Dzpp(az,bz))
         Jy = Jy &
          + B_field(3)*( TWO*Fx00(ax,bx)*Sy00(ay,by)*Sz00(az,bz) &
          + Qxpp(ax,bx)*Sy00(ay,by)*Sz00(az,bz)  &
          + Fx00(ax,bx)*Dypp(ay,by)*Sz00(az,bz)  &
          + Fx00(ax,bx)*Sy00(ay,by)*Dzpp(az,bz)) &
          - B_field(1)*( TWO*Sx00(ax,bx)*Sy00(ay,by)*Fz00(az,bz) &
          + Dxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)  &
          + Sx00(ax,bx)*Dypp(ay,by)*Fz00(az,bz)  &
          + Sx00(ax,bx)*Sy00(ay,by)*Qzpp(az,bz)) &
          - B_field(1)*(Fxpp(ax,bx)*Sy00(ay,by)*Dz00(az,bz) - Dxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)) &
          - B_field(2)*(Fx00(ax,bx)*Sypp(ay,by)*Dz00(az,bz) - Dx00(ax,bx)*Sypp(ay,by)*Fz00(az,bz)) &
          - B_field(3)*(Fx00(ax,bx)*Sy00(ay,by)*Dzpp(az,bz) - Dx00(ax,bx)*Sy00(ay,by)*Fzpp(az,bz))
         Jz = Jz &
          + B_field(1)*( TWO*Sx00(ax,bx)*Fy00(ay,by)*Sz00(az,bz) &
          + Dxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz)  &
          + Sx00(ax,bx)*Qypp(ay,by)*Sz00(az,bz)  &
          + Sx00(ax,bx)*Fy00(ay,by)*Dzpp(az,bz)) &
          - B_field(2)*( TWO*Fx00(ax,bx)*Sy00(ay,by)*Sz00(az,bz) &
          + Qxpp(ax,bx)*Sy00(ay,by)*Sz00(az,bz)  &
          + Fx00(ax,bx)*Dypp(ay,by)*Sz00(az,bz)  &
          + Fx00(ax,bx)*Sy00(ay,by)*Dzpp(az,bz)) &
          - B_field(1)*(Dxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz) - Fxpp(ax,bx)*Dy00(ay,by)*Sz00(az,bz)) &
          - B_field(2)*(Dx00(ax,bx)*Fypp(ay,by)*Sz00(az,bz) - Fx00(ax,bx)*Dypp(ay,by)*Sz00(az,bz)) &
          - B_field(3)*(Dx00(ax,bx)*Fy00(ay,by)*Szpp(az,bz) - Fx00(ax,bx)*Dy00(ay,by)*Szpp(az,bz))
      end
      rys.destroy
      Qzpp.destroy; Qypp.destroy; Qxpp.destroy
      Qz01.destroy; Qy01.destroy; Qx01.destroy
      Qz10.destroy; Qy10.destroy; Qx10.destroy
      Qz00.destroy; Qy00.destroy; Qx00.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Qzpp.destroy; Qypp.destroy; Qxpp.destroy
      Qz01.destroy; Qy01.destroy; Qx01.destroy
      Qz10.destroy; Qy10.destroy; Qx10.destroy
      Qz00.destroy; Qy00.destroy; Qx00.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz
   end

   make_irrotational_jp_ints(Jx,Jy,Jz,c)
   ! Make the solenoidal Jp integrals "Ji", evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr curl [g_a grad g_b - g_b grad g_a] x (c - r)/ |c - r|^3
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      MAT :: Jx,Jy,Jz
      VEC(3) :: c
      MAT* :: Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxmm,Symm,Szmm
      MAT* :: Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxmm,Fymm,Fzmm
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rpc,rab
      DBL :: p,xx,uu,wt,prefac
      INT :: n_a,n_b,n_roots,k
      RYS* :: rys
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx00.create(.l_a+3,.l_b+3); Sy00.create(.l_a+3,.l_b+3); Sz00.create(.l_a+3,.l_b+3)
      Sx10.create(.l_a+2,.l_b+2); Sy10.create(.l_a+2,.l_b+2); Sz10.create(.l_a+2,.l_b+2)
      Sx01.create(.l_a+2,.l_b+2); Sy01.create(.l_a+2,.l_b+2); Sz01.create(.l_a+2,.l_b+2)
      Sxmm.create(.l_a+2,.l_b+2); Symm.create(.l_a+2,.l_b+2); Szmm.create(.l_a+2,.l_b+2)
      Fx00.create(.l_a+3,.l_b+3); Fy00.create(.l_a+3,.l_b+3); Fz00.create(.l_a+3,.l_b+3)
      Fx10.create(.l_a+2,.l_b+2); Fy10.create(.l_a+2,.l_b+2); Fz10.create(.l_a+2,.l_b+2)
      Fx01.create(.l_a+2,.l_b+2); Fy01.create(.l_a+2,.l_b+2); Fz01.create(.l_a+2,.l_b+2)
      Fxmm.create(.l_a+2,.l_b+2); Fymm.create(.l_a+2,.l_b+2); Fzmm.create(.l_a+2,.l_b+2)
      p = .ex_a + .ex_b
      rpc = (.ex_a*.pos_a + .ex_b*.pos_b)/p - c
      n_roots = (.l_a+.l_b+3)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_e_field_ints(Sx00,Fx00,1,uu,c(1),.l_a+2,.l_b+2)
         .make_e_field_ints(Sy00,Fy00,2,uu,c(2),.l_a+2,.l_b+2)
         .make_e_field_ints(Sz00,Fz00,3,uu,c(3),.l_a+2,.l_b+2)
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt
         .differentiate(Sx00,"right",Sx01); .differentiate(Sx01,"right",Sxmm)
         .differentiate(Sx00,"left" ,Sx10); .differentiate(Sx10,"left" ,Sx01)
         .differentiate(Sy00,"right",Sy01); .differentiate(Sy01,"right",Symm)
         .differentiate(Sy00,"left" ,Sy10); .differentiate(Sy10,"left" ,Sy01)
         .differentiate(Sz00,"right",Sz01); .differentiate(Sz01,"right",Szmm)
         .differentiate(Sz00,"left" ,Sz10); .differentiate(Sz10,"left" ,Sz01)
         .differentiate(Fx00,"right",Fx01); .differentiate(Fx01,"right",Fxmm)
         .differentiate(Fx00,"left" ,Fx10); .differentiate(Fx10,"left" ,Fx01)
         .differentiate(Fy00,"right",Fy01); .differentiate(Fy01,"right",Fymm)
         .differentiate(Fy00,"left" ,Fy10); .differentiate(Fy10,"left" ,Fy01)
         .differentiate(Fz00,"right",Fz01); .differentiate(Fz01,"right",Fzmm)
         .differentiate(Fz00,"left" ,Fz10); .differentiate(Fz10,"left" ,Fz01)
         Sxmm = Sxmm - Sx01
         Symm = Symm - Sy01
         Szmm = Szmm - Sz01
         Fxmm = Fxmm - Fx01
         Fymm = Fymm - Fy01
         Fzmm = Fzmm - Fz01
         Jx = Jx + Fxmm(ax,bx)*Sy00(ay,by)*Sz00(az,bz) &
                 + Fx00(ax,bx)*Symm(ay,by)*Sz00(az,bz) &
                 + Fx00(ax,bx)*Sy00(ay,by)*Szmm(az,bz)  
         Jy = Jy + Sxmm(ax,bx)*Fy00(ay,by)*Sz00(az,bz) &
                 + Sx00(ax,bx)*Fymm(ay,by)*Sz00(az,bz) &
                 + Sx00(ax,bx)*Fy00(ay,by)*Szmm(az,bz)  
         Jz = Jz + Sxmm(ax,bx)*Sy00(ay,by)*Fz00(az,bz) &
                 + Sx00(ax,bx)*Symm(ay,by)*Fz00(az,bz) &
                 + Sx00(ax,bx)*Sy00(ay,by)*Fzmm(az,bz)  
      end
      rys.destroy
      Fzmm.destroy; Fymm.destroy; Fxmm.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szmm.destroy; Symm.destroy; Sxmm.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz
   end

   make_irrotational_jd_ints(Jx,Jy,Jz,B_field,origin,c)
   ! Make the solenoidal Jd integrals "Ji", with external magnetic field "B_field",
   ! gauge origin at "origin", and evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr (div J^d_ab(r)) (c - r)/|c - r|3 
   !     J^d_ab(r) = B (2 g_a(r)g_b(r) + (r-r_o).grad g_a(r)g_b(r)) 
   !                 - (r-r_o)(B.grad g_a(r)g_b(r))
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      MAT :: Jx,Jy,Jz
      VEC(3) :: B_field,origin,c
      MAT* :: Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxpp,Sypp,Szpp,Dx00,Dy00,Dz00
      MAT* :: Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxpp,Fypp,Fzpp,Qx00,Qy00,Qz00
      IVEC* :: ax,ay,az,bx,by,bz
      VEC(3) :: rpc,rab
      DBL :: p,xx,uu,wt,prefac
      INT :: n_a,n_b,n_roots,k
      RYS* :: rys
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_indices(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_indices(bx,by,bz)
      Sx00.create(.l_a+2,.l_b+2); Sy00.create(.l_a+2,.l_b+2); Sz00.create(.l_a+2,.l_b+2)
      Sx10.create(.l_a+1,.l_b+1); Sy10.create(.l_a+1,.l_b+1); Sz10.create(.l_a+1,.l_b+1)
      Sx01.create(.l_a+1,.l_b+1); Sy01.create(.l_a+1,.l_b+1); Sz01.create(.l_a+1,.l_b+1)
      Sxpp.create(.l_a+1,.l_b+1); Sypp.create(.l_a+1,.l_b+1); Szpp.create(.l_a+1,.l_b+1)
      Dx00.create(.l_a+2,.l_b+2); Dy00.create(.l_a+2,.l_b+2); Dz00.create(.l_a+2,.l_b+2)
      Fx00.create(.l_a+2,.l_b+2); Fy00.create(.l_a+2,.l_b+2); Fz00.create(.l_a+2,.l_b+2)
      Fx10.create(.l_a+1,.l_b+1); Fy10.create(.l_a+1,.l_b+1); Fz10.create(.l_a+1,.l_b+1)
      Fx01.create(.l_a+1,.l_b+1); Fy01.create(.l_a+1,.l_b+1); Fz01.create(.l_a+1,.l_b+1)
      Fxpp.create(.l_a+1,.l_b+1); Fypp.create(.l_a+1,.l_b+1); Fzpp.create(.l_a+1,.l_b+1)
      Qx00.create(.l_a+2,.l_b+2); Qy00.create(.l_a+2,.l_b+2); Qz00.create(.l_a+2,.l_b+2)
      p = .ex_a + .ex_b
      rpc = (.ex_a*.pos_a + .ex_b*.pos_b)/p - c
      n_roots = (.l_a+.l_b+2)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_q_field_ints(Sx00,Dx00,Fx00,Qx00,1,uu,c(1),origin(1),.l_a+1,.l_b+1)
         .make_q_field_ints(Sy00,Dy00,Fy00,Qy00,2,uu,c(2),origin(2),.l_a+1,.l_b+1)
         .make_q_field_ints(Sz00,Dz00,Fz00,Qz00,3,uu,c(3),origin(3),.l_a+1,.l_b+1)
         Sz00 =  Sz00*wt
         Dz00 =  Dz00*wt
         Fz00 =  Fz00*wt
         Qz00 =  Qz00*wt
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01) 
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01) 
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01) 
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01) 
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01) 
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01) 
         Sxpp = Sx01 + Sx10
         Sypp = Sy01 + Sy10
         Szpp = Sz01 + Sz10
         Fxpp = Fx01 + Fx10
         Fypp = Fy01 + Fy10
         Fzpp = Fz01 + Fz10
         Jx = Jx + B_field(2)*Fxpp(ax,bx)*Sy00(ay,by)*Dz00(az,bz) - B_field(3)*Fxpp(ax,bx)*Dy00(ay,by)*Sz00(az,bz) &
                 + B_field(3)*Qx00(ax,bx)*Sypp(ay,by)*Sz00(az,bz) - B_field(1)*Fx00(ax,bx)*Sypp(ay,by)*Dz00(az,bz) &
                 + B_field(1)*Fx00(ax,bx)*Dy00(ay,by)*Szpp(az,bz) - B_field(2)*Qx00(ax,bx)*Sy00(ay,by)*Szpp(az,bz)
         Jy = Jy + B_field(2)*Sxpp(ax,bx)*Fy00(ay,by)*Dz00(az,bz) - B_field(3)*Sxpp(ax,bx)*Qy00(ay,by)*Sz00(az,bz) &
                 + B_field(3)*Dx00(ax,bx)*Fypp(ay,by)*Sz00(az,bz) - B_field(1)*Sx00(ax,bx)*Fypp(ay,by)*Dz00(az,bz) &
                 + B_field(1)*Sx00(ax,bx)*Qy00(ay,by)*Szpp(az,bz) - B_field(2)*Dx00(ax,bx)*Fy00(ay,by)*Szpp(az,bz)
         Jz = Jz + B_field(2)*Sxpp(ax,bx)*Sy00(ay,by)*Qz00(az,bz) - B_field(3)*Sxpp(ax,bx)*Dy00(ay,by)*Fz00(az,bz) &
                 + B_field(3)*Dx00(ax,bx)*Sypp(ay,by)*Fz00(az,bz) - B_field(1)*Sx00(ax,bx)*Sypp(ay,by)*Qz00(az,bz) &
                 + B_field(1)*Sx00(ax,bx)*Dy00(ay,by)*Fzpp(az,bz) - B_field(2)*Dx00(ax,bx)*Sy00(ay,by)*Fzpp(az,bz)
      end
      rys.destroy
      Qz00.destroy; Qy00.destroy; Qx00.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Dz00.destroy; Dy00.destroy; Dx00.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      rab = .pos_a - .pos_b
      prefac = exp(-.ex_a*.ex_b*sum(rab*rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz
   end

end
