!---------------------------------------------------------------------------
!
!  VEC: Vector operations ...
!
!  (c) dylan jayatilaka, 1997
!
! $Id$
!---------------------------------------------------------------------------
module VEC

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL

   implicit none

#include "macros"
#include "vec.int"

   public test

contains

   create(dim)
   ! Create the vector with dimension "dim"
      PTR :: self
      INT, IN :: dim
      nullify(self)
      allocate(self(dim))
      ADD_MEM(dim*DBL_SIZE)
   end

   create(lb,ub)
   ! Create the vector with lower bound "lb", upper bound "ub"
      PTR :: self
      INT, IN :: lb,ub
      nullify(self)
      allocate(self(lb:ub))
      ADD_MEM((ub-lb+1)*DBL_SIZE)
   end

   create(bounds)
   ! Create the vector with "bounds"
      PTR :: self
      IVEC(2), IN :: bounds
      .create(bounds(1),bounds(2))
   end

   destroy
   ! Destroy the vector
      PTR :: self
      if (.destroyed) return
      DELETE_MEM(size(self)*DBL_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

  shrink(dim) [leaky]
  ! Shrinks self to dimension dim.  Contents are retained.
    PTR :: self
    VEC, PTR :: old
    INT, IN :: dim
    old => self
    nullify(self)
    self.create(dim)
    self=old(1:dim)
    old.destroy
  end

  expand(dim) [leaky]
  ! Expands self to dimension dim.  Contents are retained.
  ! Elements added are set to zero.
    PTR :: self
    VEC, PTR :: old
    INT, IN :: dim
    INT :: old_size
    old => self
    old_size=size(old)
    nullify(self)
    self.create(dim)
    self(1:old_size)=old
    self(old_size+1:dim)=0
    old.destroy
  end

   to_product(mat,vec,transpose)
   ! Set "self" to the product of the matrix and vector. If present,
   ! "transpose" can be set to TRUE if the matrix needs to be transposed.
      MAT, IN :: mat
      VEC, IN :: vec
      BIN, optional :: transpose
      INT :: dim_a1,dim_a2,dim_b1,dim1,i,k
      BIN :: trans
      DBL :: temp

      trans = FALSE
      if (present(transpose)) trans = transpose

      dim_a1 = size(mat,1);           dim_a2 = size(mat,2)
      dim_b1 = size(vec,1)
      dim1   = size(self)

      if (trans) then
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        ENSURE(dim_b1==dim_a1,"array dimensions do not agree")
        do i=1,dim1
          temp = mat(1,i) * vec(1)
          do k=2,dim_b1
            temp = temp + mat(k,i) * vec(k)
          end
          self(i) = temp
        end
      else
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        ENSURE(dim_b1==dim_a2,"array dimensions do not agree")
        do i=1,dim1
          temp = mat(i,1) * vec(1)
          do k=2,dim_b1
            temp = temp + mat(i,k) * vec(k)
          end
          self(i) = temp
        end
      end
   end

  to_product(mat_a,mat_b,transpose_a,transpose_b)
  ! Set "self" to the matrix product of "mat_a" and "mat_b". If present,
  ! "transpose_a" and "transpose_b" can be set to TRUE if "mat_a" and "mat_b"
  ! neeb to be transposed.
    MAT :: mat_a, mat_b
    BIN, optional :: transpose_a, transpose_b
    INT :: dim_a1,dim_a2,dim_b1,dim_b2,dim1,i,j,k,opt
    BIN :: trans_a,trans_b
    DBL :: temp

    trans_a = FALSE;       trans_b = FALSE
    if (present(transpose_a)) trans_a = transpose_a
    if (present(transpose_b)) trans_b = transpose_b

    dim_a1 = size(mat_a,1);           dim_a2 = size(mat_a,2)
    dim_b1 = size(mat_b,1);           dim_b2 = size(mat_b,2)
    dim1   = size(self,1)

    opt = 0
    if (trans_a) opt = opt + 1
    if (trans_b) opt = opt + 2

    select case (opt)
      case (0)
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        ENSURE(dim_a2==dim_b1,"array dimensions do not agree")
        ENSURE(dim_b2==1,"b array dimensions incorrect")
        do i=1,dim1
          temp = ZERO
          do k=1,dim_a2
            temp = temp + mat_a(i,k) * mat_b(k,1)
          end
          self(i) = temp
        end
      case (1)
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        ENSURE(dim_a1==dim_b1,"array dimensions do not agree")
        ENSURE(dim_b2==1,"b array dimension incorrect")
        do i=1,dim1
          temp = ZERO
          do k=1,dim_a1
            temp = temp + mat_a(k,i) * mat_b(k,1)
          end
          self(i) = temp
        end
      case (2)
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        ENSURE(dim_a2==dim_b2,"array dimensions do not agree")
        ENSURE(dim_b1==1,"b array dimension incorrect")
        do i=1,dim1
          temp = ZERO
          do k=1,dim_a2
            temp = temp + mat_a(i,k) * mat_b(1,k)
          end
          self(i) = temp
        end
      case (3)
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        ENSURE(dim_a1==dim_b2,"array dimensions do not agree")
        ENSURE(dim_b1==1,"b array dimension incorrect")
        do i=1,dim1
          temp = ZERO
          do k=1,dim_a1
            temp = temp + mat_a(k,i) * mat_b(1,k)
          end
          self(i) = temp
        end
    end
  end

   plus_product(mat,vec,transpose)
   ! Add to "self" the product of the matrix and vector. If present,
   ! "transpose" can be set to TRUE if the matrix needs to be transposed.
      MAT, IN :: mat
      VEC, IN :: vec
      BIN, optional :: transpose
      INT :: dim_a1,dim_a2,dim_b1,dim1,i,k
      BIN :: trans
      DBL :: temp

      trans = FALSE
      if (present(transpose)) trans = transpose

      dim_a1 = size(mat,1);           dim_a2 = size(mat,2)
      dim_b1 = size(vec,1)
      dim1   = size(self)

      if (trans) then
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        ENSURE(dim_b1==dim_a1,"array dimensions do not agree")
        do i=1,dim1
          temp = mat(1,i) * vec(1)
          do k=2,dim_b1
            temp = temp + mat(k,i) * vec(k)
          end
          self(i) = self(i) + temp
        end
      else
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        ENSURE(dim_b1==dim_a2,"array dimensions do not agree")
        do i=1,dim1
          temp = mat(i,1) * vec(1)
          do k=2,dim_b1
            temp = temp + mat(i,k) * vec(k)
          end
          self(i) = self(i) + temp
        end
      end
   end

   sum_elements result (res) [pure]
   ! Return the suym of the elements in the vector
      IN :: self
      DBL :: res
      res = sum(self)
   end

   dot(b) result (res) [pure]
   ! Return the dot product with "b"
      IN :: self
      VEC, IN :: b
      DBL :: res
      res = dot_product(self,b)
   end

   cross(b) result(res) [pure]
   ! Return the cross product of "self" and "b".
      IN :: self
      VEC, IN :: b
      VEC(3) :: res
      res(1) = self(2)*b(3) - b(2)*self(3)
      res(2) = self(3)*b(1) - b(3)*self(1)
      res(3) = self(1)*b(2) - b(1)*self(2)
   end

   to_cross_product(a,b) [pure]
   ! Set the vector to the cross product of "a" and "b".
      INOUT :: self
      VEC, IN :: a,b
      self(1) = a(2)*b(3) - b(2)*a(3)
      self(2) = a(3)*b(1) - b(3)*a(1)
      self(3) = a(1)*b(2) - b(1)*a(2)
   end

   norm result (val) [pure]
   ! Return the norm of the vector
      IN :: self
      DBL :: val
      val = sum(self*self)
      val = sqrt(val)
   end

   normalise
   ! Normalise the vector
      INOUT :: self
      self = self/.norm
   end

   normalize
   ! Normalise the vector
      INOUT :: self
      self = self/.norm
   end

   distance_to(b) result(res)
   ! Return the distance to "b"
   ! if supplied
      VEC, IN :: b
      DBL :: res,temp
      INT :: s1,b1,i
      s1 = size(self)
      b1 = size(b)
      DIE_IF(s1/=b1,"incompatible dimensions")
      res = ZERO
      do i = 1,s1
         temp = self(i)-b(i)
         res = res + temp*temp
      end
      res = sqrt(res)
   end

   equals(b, tol) result(res)
   ! Return true if "self" is the same as "b", within range "tol"
   ! if supplied
      VEC, IN :: b
      DBL, optional, IN :: tol
      BIN :: res
      DBL :: tolerance
      INT :: s1,b1
      s1 = size(self)
      b1 = size(b)
      if (s1/=b1) then; res = FALSE; RETURN
      end
      tolerance = DBL_EPSILON
      if (present(tol)) tolerance = tol
      res = .distance_to(b)<tolerance
   end

   same_as(b, tol) result(res)
   ! Return true if "self" is the same as "b", within range "tol"
   ! if supplied
      VEC, IN :: b
      DBL, optional, IN :: tol
      BIN :: res
      DBL :: tolerance
      INT :: s1,b1
      s1 = size(self)
      b1 = size(b)
      if (s1/=b1) then; res = FALSE; RETURN
      end
      tolerance = DBL_EPSILON
      if (present(tol)) tolerance = tol
      res = .distance_to(b)<tolerance
   end

   to_scaled_vec(fac,b) [pure]
   ! Set the vector to "b" scaled by "fac"
      INOUT :: self
      VEC, IN :: b
      DBL, IN :: fac
      self = fac*b
   end

   plus_scaled_vec(fac,b) [pure]
   ! Add a vector "b" scaled by "fac" to "self"
      INOUT :: self
      VEC, IN :: b
      DBL, IN :: fac
      self = self + fac*b
   end

   minus_vec(b) [pure]
   ! Subtract vector "b" from "self"
      INOUT :: self
      VEC, IN :: b
      self = self-b
   end

   plus_vec(b) [pure]
   ! Add vector "b" to "self"
      INOUT :: self
      VEC, IN :: b
      self = self+b
   end

   set_to(b) [pure]
   ! Set the vector to "b"
      INOUT :: self
      VEC, IN :: b
      self = b
   end

   zero [pure]
   ! Zero the vector
      INOUT :: self
      self = ZERO
   end

   zero_small_values(tol) [pure]
   ! Zero elements of the vector which are less than "tol" in magnitude
      INOUT :: self
      DBL, IN :: tol
      where (abs(self)<tol)
        self = ZERO
      end
   end

   swap_elements(e1,e2)
   ! Swap elements "e1" and "e2" in "self".
      INT :: e1,e2
      INT :: a1
      DBL :: val
      a1 = size(self,1)
      ENSURE(e1<=a1 AND e2<=a1,"element exceeds dimesion")
      val = self(e1)
      self(e1) = self(e2)
      self(e2) = val
   end

   chop_large_values(maxval) [pure]
   ! Truncate all values in the vector whose absolute value is larger than
   ! "maxval".
      INOUT :: self
      DBL, IN :: maxval
      INT :: dim,i
      DBL :: bb,ba,sign
      dim = size(self)
      do i = 1,dim
         bb = self(i)
         if (bb==ZERO) then
            self(i) = ZERO
         else
            ba = abs(bb)
            sign = bb/ba
            self(i) = sign*min(maxval,ba)
         end
     end
   end

   maximum result (val) [pure]
   ! Return the maximum value in the vector
      IN :: self
      DBL :: val
      INT :: i
      val = self(1)
      do i=2,size(self)
        if (self(i) > val) val = self(i)
      end
   end

   minimum result (val) [pure]
   ! Return the minimum value in the vector
      IN :: self
      DBL :: val
      INT :: i
      val = self(1)
      do i=2,size(self)
        if (self(i) < val) val = self(i)
      end
   end

   index_of_maximum result (ind) [pure]
   ! Return the index of the maximum in the vector
      IN :: self
      INT :: ind,i
      DBL :: maxval
      maxval = abs(self(1))
      ind = 1
      do i = 2,size(self)
        if (self(i) > maxval) then
          maxval = self(i)
          ind = i
        end
      end
   end

   index_of_minimum result (ind) [pure]
   ! Return the index of the minimum in the vector
      IN :: self
      INT :: ind,i
      DBL :: minval
      minval = abs(self(1))
      do i = 2,size(self)
        if (self(i) < minval) then
          minval = self(i)
          ind = i
        end
      end
   end

   is_zero(eps) result(res)
   ! Return true if the vector is zero (within "eps", if supplied)
      DBL, optional :: eps
      BIN :: res
      res = .norm.is_zero(eps)
   end

   is_not_zero(eps) result(res)
   ! Return true if the vector is not zero (within "eps", if supplied)
      DBL, optional :: eps
      BIN :: res
      res = .norm.is_not_zero(eps)
   end

   is_z_axis(eps) result(res)
   ! Return true if the vector is set to the z-axis (within "eps", if
   ! supplied)
      DBL, optional :: eps
      BIN :: res
      ENSURE(size(self)==3,"must supply a 3 dimensional vector!")
      res = self(1).is_zero(eps)
      res = self(2).is_zero(eps) AND res
      res = (ONE-self(3)).is_zero(eps) AND res
   end

   is_not_z_axis(eps) result(res)
   ! Return true if the vector is NOT set to the z-axis (within "eps", if
   ! supplied)
      DBL, optional :: eps
      BIN :: res
      res = NOT .is_z_axis(eps)
   end

   largest_value result (maxval) [pure]
   ! Return the maximum absolute value in the vector
      IN :: self
      DBL :: maxval,bb
      INT :: i
      maxval = abs(self(1))
      do i = 2,size(self)
        bb = abs(self(i))
        if (bb > maxval) maxval = bb
      end
   end

   smallest_value result (minval)  [pure]
   ! Return minimum absolute value in the vector
      IN :: self
      DBL :: minval,bb
      INT :: i
      minval = abs(self(1))
      do i = 2,size(self)
        bb = abs(self(i))
        if (bb < minval) minval = bb
      end
   end

   index_of_largest_value result (ind) [pure]
   ! Return the index of the largest value in the vector
      IN :: self
      INT :: ind,i
      DBL :: maxval,bb
      maxval = abs(self(1))
      ind = 1
      do i = 2,size(self)
        bb = abs(self(i))
        if (bb > maxval) then
          maxval = bb
          ind = i
        end
      end
   end

   index_of_smallest_value result (ind) [pure]
   ! Return the index of the smallest value in the vector
      IN :: self
      INT :: ind,i
      DBL :: minval,bb
      minval = abs(self(1))
      ind = 1
      do i = 2,size(self)
        bb = abs(self(i))
        if (bb < minval) then
          minval = bb
          ind = i
        end
      end
   end

   no_of_elements_larger_than(tol) result(res) [pure]
   ! Return the number of elements larger than "tol"
      IN :: self
      DBL, IN :: tol
      INT :: res
      INT :: i
      res = 0
      do i = 1,size(self)
         if (self(i)>tol) res = res+1
      end
   end

  normalizing_factors(l) [pure]
  ! Size of self is l.n_comp.
    INT, IN :: l
    OUT :: self
    IMAT, allocatable :: xyz_momenta
    DBL :: fac
    INT :: i

    if (l<2) then
      self = ONE
    else
      allocate(xyz_momenta(3, l.n_comp ))
      l.make_gaussian_xyz_powers(xyz_momenta)
      do i=1,size(xyz_momenta,2)
        fac = l.double_factorial / &
                (xyz_momenta(1,i).double_factorial   &
                *xyz_momenta(2,i).double_factorial   &
                *xyz_momenta(3,i).double_factorial)
        self(i)=sqrt(fac)
      end
      deallocate(xyz_momenta)
    end
  end

   alpha result(res)
   ! return the alpha sector of the vector
      TARGET :: self
      VEC, PTR :: res
      INT :: n
      n = size(self)
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      res => self(1:n)
   end

   beta result(res)
   ! return the beta sector of the vector
      TARGET :: self
      VEC, PTR :: res
      INT :: n
      n = size(self)
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      res => self(n+1:2*n)
   end

   set_alpha(X)
   ! Set the alpha sector of the vector
      VEC :: X
      INT :: n
      n = size(self)
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n) = X
   end

   set_beta(X)
   ! Set the beta sector of the vector
      VEC :: X
      INT :: n
      n = size(self)
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n) = X
   end

   integrate(a,b,accuracy) result(res) [recursive] [functional]
   ! Integrate the vector valued scalar function "self" between the limits
   ! "a" and "b" using adaptive trapezoidal rule with Simpsons approximation.
   ! If present, "accuracy" is the required accuracy of the integral.
      interface
         self(x) result(res)
            DBL :: x
            VEC, PTR :: res
         end
      end
      DBL :: a,b
      DBL, optional :: accuracy
      VEC, PTR :: res
      INT :: n
      BIN :: same
      DBL :: tol,h,m
      VEC,PTR :: fa,fb,fm,one_trap,two_trap,left,right
      tol = TOL(6)
      if (present(accuracy)) tol = accuracy
      h  = b-a
      m  = (a+b)/TWO
      fa => self(a)
      fb => self(b)
      fm => self(m)
      n = size(fa)
      one_trap.create(n)
      two_trap.create(n)
      one_trap = h*(fa+fb)/TWO
      two_trap = h*(fa+TWO*fm+fb)/FOUR
      fm.destroy
      fb.destroy
      fa.destroy
      res.create(n)
      res = abs(one_trap-two_trap)
      same = maxval(res) < THREE*tol
      if (same) then
         res = (FOUR*two_trap - one_trap)/THREE
         two_trap.destroy
         one_trap.destroy
      else
         two_trap.destroy
         one_trap.destroy
         left  => .integrate(a,m,tol/TWO)
         right => .integrate(m,b,tol/TWO)
         res = left + right
         right.destroy
         left.destroy
      end
   end

  seitz_multiply(seitz)
  ! Self is operated on by the seitz matrix.  Self must be in fractional
  !  coordinates.
    INOUT :: self
    MAT, IN :: seitz
    ENSURE(size(seitz,1)==4,"seitz matrix must be 4x4")
    ENSURE(size(seitz,2)==4,"seitz matrix must be 4x4")
    ENSURE(size(self)==3,"vector not of dimension 3")
    .rotate(seitz(1:3,1:3))
    .translate(seitz(4,1:3))
  end

  translate(vector)
  ! Translate self by vector.
    INOUT :: self
    VEC, IN :: vector
    ENSURE(size(self)==size(vector),"vectors not of same dimension")
    self = self + vector
  end

  rotate(matrix)
  ! Rotate self by the rotation matrix
    INOUT :: self
    MAT, IN :: matrix
    ENSURE(size(matrix,1)==size(matrix,2),"matrix must be square")
    ENSURE(size(matrix,2)==size(self),"matrix and vector dimensions inconsistent")
    self = matmul(matrix,self)
  end

  rotate_by(matrix)
  ! Rotate self by the rotation matrix
    INOUT :: self
    MAT, IN :: matrix
    ENSURE(size(matrix,1)==size(matrix,2),"matrix must be square")
    ENSURE(size(matrix,2)==size(self),"matrix and vector dimensions inconsistent")
    self = matmul(matrix,self)
  end

  outer_product(b) result(res)
  ! Returns the outer product of self with b.
    IN :: self
    VEC, IN :: b
    MAT(size(b),size(self)) :: res
    res = spread(self,2,size(b)) * spread(b,1,size(self))
  end

  sort(reverse_order)
  ! Sort the array from lowest to highest.
  ! Optional reverse_order.
    INOUT :: self
    BIN, optional :: reverse_order
    BIN :: lowest_first
    INT :: i,j,n
    DBL :: temp
    n = size(self)
    lowest_first = TRUE
    if (present(reverse_order)) lowest_first = NOT reverse_order
    if (lowest_first) then
      do i=1,n-1
        do j=i+1,n
          if (self(j) < self(i)) then
            temp = self(i)
            self(i) = self(j)
            self(j) = temp
          end
        end
      end
    else
      do i=1,n-1
        do j=i+1,n
          if (self(j) > self(i)) then
            temp = self(i)
            self(i) = self(j)
            self(j) = temp
          end
        end
      end
    end
  end

  find_opposite_pairs(pair,min,max)
  ! "pair(i)" returns the location of the element which has the opposite
  ! value to self(i) *and* is also negative. Otherwise, O is returned,
  ! unless self(i) is greater than max, in which case pair(i) is set to -1.
     IVEC :: pair
     DBL :: min,max
     INT :: i,j
     pair = 0
     do i = 1,size(self)
        if      (abs(self(i))<min) then; pair(i) =  0
        else if (abs(self(i))>max) then
            if (self(i)<0)  pair(i) = -1
            if (self(i)>0)  pair(i) = -2
        else
           do j = 1,i-1
              if (any(pair==j)) cycle
              if (abs(self(j)+self(i))<min) then
                 if (self(i)>0) then; pair(i)=j
                 else;                pair(i)=0
                 end
              end
           end
        end
     end
   end

  convert_to(units)
  ! Convert the number "self" in atomic units or generic units to a
  ! new number in "units".  
     INOUT :: self
     STR(*), IN :: units
     DBL :: factor
     ENSURE(units.is_known_unit,"unknown units, " // units)
     factor = units.conversion_factor
     self = self * factor
  end

  convert_from(units)
  ! Convert the number "self" from "units" system to a new number
  ! in atomic units or generic units.  Returns "err" whether it was successful.
     INOUT :: self
     STR(*), IN :: units
     DBL :: factor
     ENSURE(units.is_known_unit,"unknown units, " // units)
     factor = ONE/(units.conversion_factor)
     self = self * factor
  end


  to_str result(string)
  ! Change self to a "string" using default format.
    STR :: string,str1,str2
    INT :: n,str_len
    string = ""
    str_len = len(string)
    do n=1,size(self)
      str1 = self(n).to_str
      ENSURE(len_trim(string) + len_trim(str1) < str_len, "string too long")
      str2 = trim(string) // " " // trim(str1)
      string = str2
    end
  end

  to_str(form) result(string)
  ! Change self to a "string" using specified format "form"
    STR(*) :: form
    STR :: string,str1,str2
    INT :: n,str_len
    string = ""
    str_len = len(string)
    do n=1,size(self)
      str1 = self(n).to_str(form)
      ENSURE(len_trim(string) + len_trim(str1) < str_len, "string too long")
      str2 = trim(string) // " " // trim(str1)
      string = str2
    end
  end

! *********************
! Minimisation routines
! *********************

  minimise(new_direction,gradient,old_val,old_gradient,hessian)
  ! Move the vector "self" to a position closer to the minimum, based on the
  ! gradient.  Uses the BFGS scheme.  Doesn't check for convergence, just does
  ! one iteration.
    VEC, OUT :: new_direction
    VEC, IN :: gradient
    VEC, INOUT :: old_val, old_gradient
    MAT, INOUT :: hessian
    VEC, PTR :: dx,dg,hdg,u
    DBL :: dxdg,dghdg,dghdg_inv
    INT :: dim
    dim = size(self)
    dx.create(dim); dg.create(dim); hdg.create(dim); u.create(dim)
    ENSURE(dim==size(new_direction), "vector size mismatch")
    ENSURE(dim==size(gradient), "vector size mismatch")
    ENSURE(dim==size(old_val), "vector size mismatch")
    ENSURE(dim==size(old_gradient), "vector size mismatch")
    ENSURE(dim==size(hessian,1), "incorrect dimension for hessian matrix")
    ENSURE(dim==size(hessian,2), "incorrect dimension for hessian matrix")
    dg = gradient - old_gradient
    dx = self - old_val
    hdg.to_product(hessian,dg)
    dxdg = ONE / dot_product(dx,dg)
    dghdg = dot_product(dg,hdg)
    dghdg_inv = ONE / dghdg
    u  = dxdg * dx - dghdg_inv * hdg
    hessian = hessian + dxdg * dx.outer_product(dx) - &
              dghdg_inv * hdg.outer_product(hdg) + dghdg * u.outer_product(u)
    dx.to_product(hessian,gradient)
    old_val = self
    old_gradient = gradient
    new_direction = - dx
    dx.destroy; dg.destroy; hdg.destroy; u.destroy
  end

   minimise_powell(p,directions,fret,tol,ftol) [routinal]
   ! Use Powell's method to minimise a vector function self(p) starting from 
   ! an initial point "p" along the initial (columns of) "directions", returning
   ! the minimum point in "p", the minimum function value in "fret" to a
   ! tolerance "ftol", and "tol" in the vector coordinates "p".
      interface
         self(p) result(res)
            VEC :: p
            DBL :: res
         end
      end
      VEC :: p
      MAT :: directions
      DBL :: fret,tol,ftol
      INT :: itmax = 200
      INT :: n,iter,i,ibig
      DBL :: del,fp,fptt,t
      VEC, PTR :: pt,ptt,xit
      BIN :: fail
      ENSURE(size(p)==size(directions,1),"incompatible initial data")
      ENSURE(size(p)==size(directions,2),"incompatible initial data")
      n = size(p)
      pt.create(n)
      ptt.create(n)
      xit.create(n)
      fret = self(p)
      pt = p                                    ! Save initial point
      iter = 0
      do                                        ! Iteration loop
         iter = iter + 1
         fp = fret
         ibig = 0
         del = 0
         do i = 1,n                             ! Loop over all directions in set
            xit = directions(:,i)               ! Get direction
            fptt = fret
            .line_minimise_from(p,xit,fret,tol) ! Minimize along direction
            if (abs(fptt-fret)>del) then        ! Save if largest decrease so far
               del = abs(fptt-fret)
               ibig = i
            end
         end
         if (TWO*abs(fp-fret)<=ftol*(abs(fp)+abs(fret))) exit
         fail = iter>=itmax
         if (fail) exit
         ptt = TWO*p - pt                       ! Construct extrapolated point and the
         xit = p - pt                           ! average direction moved; save old
         pt = p                                 ! starting point
         fptt = self(ptt)
         if (fptt>=fp) cycle
         t = TWO*(fp-TWO*fret+fptt)*(fp-fret-del)**2-del*(fp-fptt)**2
         if (t>=0) cycle
         .line_minimise_from(p,xit,fret,tol)    ! Move to minimum of the new direction
         directions(:,ibig) = directions(:,n)
         directions(:,n) = xit
      end
      DIE_IF(fail,"exceeded allowed iterations")
      xit.destroy
      ptt.destroy
      pt.destroy
   end

   line_minimise_from(p,direction,fret,tol) [routinal]
   ! Given a vector function self(x), minimise from point "p" along "direction".
   ! Return the minimum point in "p" and the minimum value "fret", with an
   ! accuracy "tol"
      interface
         self(p) result(res)
            VEC :: p
            DBL :: res
         end
      end
      VEC :: p,direction
      DBL :: fret,tol
      DBL :: a,x,b,fa,fx,fb,xmin
      ENSURE(size(p)==size(direction),"incompatible vectors")
      a = ZERO
      x = ONE
      .find_initial_bracket(p,direction,a,x,b,fa,fx,fb)
      .minimise_brent(p,direction,a,x,b,xmin,fret,tol) 
   end

   find_initial_bracket(p,direction,a,b,c,fa,fb,fc) [routinal]
   ! Given a vector function self(p), an initial point "p" and a "direction",
   ! and initial distances "a" and "b" along "direction" from "p", search in
   ! the downhill direction and return new distances "a", "b" and "c" along
   ! "direction" from "p" that bracket a minimum of the function self, and 
   ! return the values of the function "fa", "fb", and "fc" at these points. 
   ! NOTE: "c" is not used initially.
      interface
         self(p) result(res)
            VEC :: p
            DBL :: res
         end
      end
      VEC :: p,direction
      DBL :: a,b,c,fa,fb,fc
      DBL :: gold = 1.618034
      DBL :: glimit = 100
      DBL :: tiny = 1.0d-20
      DBL :: dum,fu,q,r,u,ulim
      ENSURE(size(p)==size(direction),"incompatible vectors")
      fa = self(p + a*direction)
      fb = self(p + b*direction)
      if (fb>fa) then
        a.swap_with(b)
        fa.swap_with(fb)
      end
      c  = b + gold*(b-a)
      fc = self(p + c*direction)
      do
         if (fb<fc) exit                  ! bracket found
         r = (b-a)*(fb-fa)                ! get u by parabolic extrapolation
         q = (b-c)*(fb-fa)
         u = b - ((b-c)*q-(b-a)*r)/(TWO*sign(max(abs(q-r),tiny),q-r))
         ulim = b + glimit*(c-b)
         if ((b-u)*(u-c)>ZERO) then       ! Parabolic u lies between b and c
            fu = self(p + u*direction)
            if (fu<fc) then               ! got a minimum between b and c
               a = b; fa = fb
               b = u; fb = fu
               exit
            else if (fu>fb) then          ! got a minimum between a and u
               c = u; fc = fu
               exit
            end
            u = c + gold*(c-b)            ! parabolic fit no use, so magnify 
            fu = self(p + u*direction)
         else if ((c-u)*(u-ulim)>0) then ! Fit is between c and its allowed limit
            fu = self(p + u*direction)
            if (fu<fc) then
               b = c; fb = fc
               c = u; fc = fu
               u = c + gold*(c-b)
               fu = self(p + u*direction)
            end 
         else if ((u-ulim)*(ulim-c)>0) then
            u = ulim
            fu = self(p + u*direction)
         else
            u = c + gold*(c-b)            ! magnify 
            fu = self(p + u*direction)
         end
         a = b; fa = fb
         b = c; fb = fc
         c = u; fc = fu
      end
      if (a>c) then
         a.swap_with(c)
         fa.swap_with(fc)
      end
   end

   minimise_golden(p,direction,a,b,c,xmin,f,tol) [routinal]
   ! Given a vector function self(p), an initial point "p" and a "direction",
   ! and initial distances "a", "b" and "c" along "direction" from "p" which 
   ! bracket a minimum in function self, return the minimum point "p" and its
   ! distance "xmin" along the "direction" from "p", and also the value "f" at 
   ! the minimum to a precision "tol", using the golden section search method.
      interface
         self(p) result(res)
            VEC :: p
            DBL :: res
         end
      end
      VEC :: p,direction
      DBL :: a,b,c,xmin,f,tol
      DBL :: r = 0.618033399
      DBL :: s,f1,f2,x0,x1,x2,x3
      ENSURE(size(p)==size(direction),"incompatible vectors")
      s = ONE - r
      x0 = a
      x3 = c
      if (abs(c-b)>abs(b-a)) then
         x1 = b; x2 = b + s*(c-b)
      else
         x2 = b; x1 = b - s*(b-a)
      end
      f1 = self(p + x1*direction)
      f2 = self(p + x2*direction)
      do 
         if (abs(x3-x0)<=tol*(abs(x1)+abs(x2))) exit
         if (f2<f1) then
            x0 = x1
            x1 = x2
            x2 = r*x1 + s*x3
            f1 = f2
            f2 = self(p + x2*direction)
         else
            x3 = x2
            x2 = x1
            x1 = r*x2 + s*x0
            f2 = f1
            f1 = self(p + x1*direction)
         end
      end
      if (f1<f2) then; f = f1; xmin = x1; p = p + x1*direction
      else;            f = f2; xmin = x2; p = p + x2*direction
      end
   end

   minimise_brent(p,direction,a,b,c,xmin,f,tol) [routinal]
   ! Given a vector function self(p), an initial point "p" and a "direction",
   ! and initial distances "a", "b" and "c" along "direction" from "p" which 
   ! bracket a minimum in function self, return the minimum point "p" and its
   ! distance "xmin" along the "direction" from "p", and also the value "f" at 
   ! the minimum to a precision "tol", using Brent's search method.
      interface
         self(p) result(res)
            VEC :: p
            DBL :: res
         end
      end
      VEC :: p,direction
      DBL :: a,b,c,xmin,f,tol
      INT :: itmax = 100
      DBL :: cgold = 0.3819660
      DBL :: zeps = TOL(10)
      DBL :: d,e,etemp,fu,fv,fw,fx,pp,qq,r,tol1,tol2,u,v,w,x,xm
      INT :: iter
      BIN :: fail
      ENSURE(size(p)==size(direction),"incompatible vectors")
      if (a>c) a.swap_with(c)
      v = b
      b = c
      w = v
      x = v
      fx = self(p + x*direction)
      fv = fx
      fw = fx
      e = ZERO
      fail = TRUE
      do iter = 1,itmax
         xm = HALF*(a+b)
         tol1 = tol*abs(x) + zeps
         tol2 = TWO*tol1
         if (abs(x-xm)<(tol2-HALF*(b-a))) then
            fail = FALSE
            exit
         end
         if (abs(e)>tol1) then
            r = (x-w)*(fx-fv)
            qq = (x-v)*(fx-fw)
            pp = (x-v)*qq - (x-w)*r
            qq = TWO*(qq-r)
            if (qq>ZERO) pp = -pp
            qq = abs(qq)
            etemp = e
            e = d
            if (abs(pp)>=abs(HALF*qq*etemp) OR pp<=qq*(a-x) OR pp>=qq*(b-x)) goto 1
            d = pp/qq
            u = x + d
            if ((u-a)<tol2 OR (b-u)<tol2) d = sign(tol1,xm-x)
            goto 2
         end
         1 continue
         if (x>=xm) then; e = a-x
         else;            e = b-x
         end
         d = cgold*e
         2 continue
         if (abs(d)>=tol1) then; u = x + d
         else;                   u = x + sign(tol1,d)
         end
         fu = self(p + u*direction)
         if (fu<=fx) then
            if (u>=x) then; a = x
            else;           b = x
            end
            v = w; fv = fw
            w = x; fw = fx
            x = u; fx = fu
         else
            if (u<x) then; a = u
            else;          b = u
            end
            if (fu<=fw OR w==x) then
               v = w; fv = fw
               w = u; fw = fu
            else if (fu<=fv OR v==x OR v==w) then
               v = u; fv = fu
            end
         end
      end
      DIE_IF(fail,"maximum iterations exceeded")
      f = fx
      xmin = x
      p = p + x*direction
   end

   test result (res) 
   ! Test routine
      DBL :: x,y,res
      x = self(1)
      y = self(2)
      res = (x-ONE)**2 + (y-TWO)**2
   end

end
