! $Id$
!---------------------------------------------------------------------------
!  STR: methods of dealing with arbitrary length character strings
!
!  Notes
!          
!  Normally, a STR variable means a character string of length STR_SIZE.
!  However, in this module we use arbitrary length character strings.
!
!  (c) dylan jayatilaka, 1998
!---------------------------------------------------------------------------
module STR

   use TYPES
   use ERROR
   use MM

   implicit none

#  include "macros"
#  define STR_SIZE  *
#  include "str.int"

   interface trim
      trim_blanks_from_end
   end

   interface scan
      index_of_character_in
   end

   interface verify
      index_of_character_not_in
   end

contains

   create
   ! Create space for a string variable
      PTR :: self
      nullify(self)
      allocate(self)
      std_mm.add(len(self)*CHR_SIZE)
      self = " "
   end

   destroy
   ! Destroy space for a string variable
      PTR :: self
      if (.destroyed) return
      std_mm.delete(len(self)*CHR_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   same_as(string) result (same)
   ! Test to see if the string is the same as another string
      STR, IN :: string
      BIN :: same
      same = self==string
   end
     
   get_item(n) result (word)
   ! Get the item no. "n" in the string
      INT :: n
      CHR(len(self)) :: word
      INT :: i,f,l
      f = 1
      do i = 1,n
         word = self(f:).get_next_item(last=l)
         if (word=="") exit
         f = f + l 
      end
   end

   get_next_item(first,last,comment_chars,quote_chars) result (word)
   ! Get the first sequence of non-blank characters in the string (i.e. a "word")
   ! and the first and last character positions of the word in the string.
   ! If the first character of the word is a double quote, then all text between
   ! it and the next double quote is treated as one word.
   ! If comment_chars is present, the rest of the string following these
   ! comment characters is ignored .
      INT, OUT, optional :: first,last
      STR, optional :: comment_chars,quote_chars
      STR(16) :: quotes
      CHR(len(self)) :: word
      CHR(len(comment_chars)) :: cc
      INT :: f,l
      quotes = '"'
      if (present(quote_chars)) quotes = quote_chars
      self.get_next_item_position(f,l) 
      cc = ""
      if (present(comment_chars)) cc = comment_chars    
      if (f==0) then                            ! all characters are blanks
         word = ""
      else if (scan(self(f:f),quotes) /= 0) then           ! quotes
         f = f+1
         l = self(f:).quote_position(trim(quotes))
         DIE_IF(l==0,"unclosed quotes")
         l = f+l-2
         word = self(f:l)
         l = l+1
      else if ( self(f:f).has_any_characters_in(cc) ) then   ! comments
         l = f-1
         word = ""
      else
         word = self(f:l)
      end
      if(present(first)) first = f 
      if(present(last))  last  = l
   end

   get_next_item_position(first,last) 
   ! Get the first and last character positions of the first sequence of 
   ! non-blank characters in the string (i.e. a "word")
      INT, OUT :: first,last
      first = verify(self," ")   
      last = scan(self(max(first,1):)//" "," ") - 1 
      last = last + max(first,1) - 1
      last = max(last,0)
   end 

   quote_position(quote_chars) result (pos)
   ! Find the position of the first double quote character.
     INT :: pos
     STR, optional :: quote_chars
     if (present(quote_chars)) then
       pos = scan(self,quote_chars)
     else
       pos = index(self,'"')
     end
   end

   insert(string,position)
   ! Insert "string" at "position" into the original string
      STR, IN :: string
      INT, IN :: position
      self(position:) = string
   end 

   left_justify
   ! Remove leftmost blank characters by shifting all characters to the left
      self = adjustl(self)
   end

   right_justify
   ! Remove rightmost blank characters by shifting all characters to the right
      self = adjustr(self)
   end

   index_of_substring(substring,backwards) result(ind)
   ! Return the starting index of a substring in the original string
      STR, IN :: substring
      BIN, optional:: backwards
      INT :: ind
      if (present(backwards)) then
         ind = index(self,substring,backwards)
      else
         ind = index(self,substring)
      end
   end

   is_included_in(string) result(res)
   ! Return true if self is included in string. Traling blanks in self are ignored
      STR, IN :: string
      BIN :: res
      INT :: ind
      ind = index(string,self(1:len_trim(self)))
      res = (ind/=0)
   end

   includes(string) result(res)
   ! Return true if self includes string. Traling blanks in self are ignored
      STR, IN :: string
      BIN :: res
      INT :: ind
      ind = index(self(1:len_trim(self)),string)
      res = (ind/=0)
   end

   does_not_include(string) result(res)
   ! Return true if self does not include string. Traling blanks in self are ignored
      STR, IN :: string
      BIN :: res
      INT :: ind
      ind = index(self(1:len_trim(self)),string)
      res = (ind==0)
   end

   trim_blanks_from_end result(res)
   ! Return a trimmed version of self
      STR(len_trim(self)) :: res
      res = trim(self)
   end

   has_any_characters_in(set) result(res)
   ! Return TRUE if self has any of the characters in "set".
      STR, IN :: set
      BIN :: res
      res = .scan(set)/=0
   end

   has_no_characters_in(set) result(res)
   ! Return TRUE if self has no characters in "set".
      STR, IN :: set
      BIN :: res
      res = .scan(set)==0
   end

   index_of_character_in(set,backwards) result(ind)
   ! In self, scan from left to right for the index of the character in "set".
   ! If backwards is present and true, scan from right to left
      STR, IN :: set
      BIN, optional:: backwards
      INT :: ind
      if (present(backwards)) then
         ind = scan(self,set,backwards)
      else
         ind = scan(self,set)
      end
   end

   index_of_character_not_in(set,backwards) result(ind)
   ! In self, scan from left to right for the index of the character *not* in "set".
   ! If backwards is present and true, scan from right to left
      STR, IN  :: set
      BIN, optional:: backwards
      INT :: ind
      if (present(backwards)) then
         ind = verify(self,set,backwards)
      else
         ind = verify(self,set)
      end
   end

   to_lower_case 
   ! Change upper case charaters to lower case in the original string
      INT :: i
      do i = 1,len(self)
         if("A"<=self(i:i) AND self(i:i)<="Z") then
            self(i:i) = achar(iachar(self(i:i))+32)
         end
      end
   end

   to_upper_case 
   ! Change lower case charaters to upper case in the original string
      INT :: i
      do i = 1,len(self)
         if("a"<=self(i:i) AND self(i:i)<="z") then
            self(i:i) = achar(iachar(self(i:i))-32)
         end
      end
   end

   append(string) result(res)
   ! Append "string" onto the end of self
      IN :: self
      STR, IN :: string
      STR(len(self)+len(string)) :: res
      res = trim(self) // string
   end

   prepend(string) result(res)
   ! Prepend "string" onto the start of self
      IN :: self
      STR, IN :: string
      STR(len(self)+len(string)) :: res
      res = trim(string) // self
   end

!  *****************
!  Inquiry functions
!  *****************
      
   is_dbl result(res)
   ! Returns true if the string can be interpred as a dbl number
      BIN :: res
      DBL :: value
      INT :: ios
      read(unit=self,fmt=*,iostat=ios) value
      res = ios==0
   end
      
   is_int result(res)
   ! Returns true if the string can be interpred as an integer number
      BIN :: res
      INT :: value,ios
      BIN :: char
      char = self(1:1).has_no_characters_in("0123456789")
      if (char) then 
         res = FALSE
      else
         read(unit=self,fmt=*,iostat=ios) value
         res = ios==0
      end
   end
      
   is_bin result(res)
   ! Returns true if the string can be interpred as a logical
      BIN :: res
      BIN :: value
      INT :: ios
      read(unit=self,fmt=*,iostat=ios) value
      res = ios==0
   end
      
   is_not_dbl result(res)
   ! Returns true if the string can't be interpred as a dbl number
      BIN :: res
      DBL :: value
      INT :: ios
      read(unit=self,fmt=*,iostat=ios) value
      res = ios/=0
   end
      
   is_not_int result(res)
   ! Returns true if the string can't be interpred as an integer number
      BIN :: res
      INT :: value
      INT :: ios
      read(unit=self,fmt=*,iostat=ios) value
      res = ios/=0
   end
      
   is_not_bin result(res)
   ! Returns true if the string can't be interpred as a logical
      BIN :: res
      BIN :: value
      INT :: ios
      read(unit=self,fmt=*,iostat=ios) value
      res = ios/=0
   end

!  **********************************
!  Conversion to value type variables
!  **********************************
      
   to_dbl result(value)
   ! Returns the dbl number corresponding to the first token string
      DBL :: value
      read(self,*) value
   end
      
   to_int result (value)
   ! Returns the integer number corresponding to the first token string
      INT :: value
      read(self,*) value
   end
      
   to_bin result(value)
   ! Returns the logical corresponding to the first token string
      BIN :: value
      read(self,*) value
   end

!  ******************************
!  Conversion to self variables
!  ******************************

   from_int(value)
   ! Set the original string to the result from changing integer "value" to a string
      INT :: value
      self = ""
      write(self,fmt=*) value
      self.left_justify
   end

   from_bin(value)
   ! Set the original string to the result from changing logical "value" to a string
      BIN :: value
      self = ""
      write(self,*) value
      self.left_justify
   end

   from_dbl(value)
   ! Set the original string to the result from changing dbl "value" to a string
      DBL :: value
      self = ""
      write(self,*) value
      self.left_justify
   end
      
end 
