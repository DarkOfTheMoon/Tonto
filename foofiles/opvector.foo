!-------------------------------------------------------------------------------
!
! OPVEC: Diagonals of operator matrices, e.g. eigenvalues an occupation numbers
!
! Provide a basis set (matrix) representation of the diagonal of a one-electron 
! quantum mechanical operator. Can cope with polymorphic types of basis 
! representations, including restricted, unrestricted, and general basis 
! orbitals. Complex types aren't needed sice operators are hermitian.
!
! (c) dylan jayatilaka 1998
!
! $Id$
!-------------------------------------------------------------------------------
module OPVEC

   use TYPES
   use ERROR
   use MM
   use STR

   use VEC

   implicit none         

#  include "macros"
#  include "opvec.int"

!  type opvec_type
!     INT        :: n_bf                   ! No of spatial basis functions (i.e. AO's)
!     VEC, PTR   :: restricted             ! Restricted spinorbital representation
!     VEC, PTR   :: alpha                  ! Alpha part of a DODS representation
!     VEC, PTR   :: beta                   ! Beta  part of a DODS representation
!     VEC, PTR   :: general                ! General mixed alpha-beta matrix representation
!  end 

contains

   create(n_bf,kind)
   ! Create an opmat object, in a basis set with "n_bf" spatial orbitals
      PTR :: self
      INT :: n_bf
      STR(*), optional :: kind
      nullify(self)
      allocate(self)
      std_mm.add(OPVEC_SIZE)
      .nullify_ptr_part
      .n_bf = n_bf
      if (present(kind)) .create(kind)
   end

   destroy 
   ! Destroy an opmat object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      std_mm.delete(OPVEC_SIZE)
      deallocate(self)
   end

   create(kind)
   ! Create the appropriate spinorbital kind of the opvec
      STR(*) :: kind
      INT :: n_bf
      n_bf = .n_bf
      select case (kind)
         case ("restricted","restricted_complex");     .restricted.create(n_bf)
         case ("unrestricted","unrestricted_complex"); .alpha.create(n_bf)
                                                       .beta.create(n_bf)
         case ("alpha","alpha_complex");               .alpha.create(n_bf)
         case ("beta","beta_complex");                 .beta.create(n_bf)
         case ("general","general_complex");           .general.create(2*n_bf)
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   destroy(kind)
   ! Destroy the appropriate spinorbital kind of the opmat
      STR(*) :: kind
      select case (kind)
         case ("restricted","restriced_complex");       .restricted.destroy
         case ("unrestricted","unrestricted_complex");  .alpha.destroy; .beta.destroy
         case ("alpha","alpha_complex");                .alpha.destroy
         case ("beta","beta_complex");                  .beta.destroy
         case ("general","general_complex");            .general.destroy
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the opmat object
      nullify(.restricted)
      nullify(.alpha)
      nullify(.beta)
      nullify(.general)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of the opmat object
      .restricted.destroy
      .alpha.destroy
      .beta.destroy
      .general.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   created(kind) result(res)
   ! Returns true if subkind "kind" of self has been created
      PTR :: self
      STR(*) :: kind
      BIN :: res
      if (NOT associated(self)) then;      res = FALSE; return
      else
         select case (kind)
            case ("restricted");           res = self%restricted.created
            case ("unrestricted");         res = self%alpha.created
            case ("general");              res = self%general.created
            case default; DIE("unknown spinorbital kind, " // kind.trim)
         end
      end
   end

  destroyed(kind) result(res)
  ! Returns true if subkind "kind" of self has *not* been created
    PTR :: self
    STR(*) :: kind
    BIN :: res
    if (NOT associated(self)) then;      res = TRUE; return
    else
      select case (kind)
        case ("restricted");           res = self%restricted.destroyed
        case ("unrestricted");         res = self%alpha.destroyed
        case ("general");              res = self%general.destroyed
        case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
    end
  end

   any_created result(res)
   ! Returns true if any component of self has been created
      BIN :: res
      BIN, dimension(3) :: c
      c(1) = .restricted.created
      c(2) = .alpha.created
      c(3) = .general.created
      res = any(c)
   end

   all_destroyed result(res)
   ! Returns true if all components of self have been destroyed
      BIN :: res
      BIN, dimension(3) :: d
      d(1) = .restricted.destroyed
      d(2) = .alpha.destroyed
      d(3) = .general.destroyed
      res = all(d)
   end

   set(n_bf)
   ! Set with "n_bf" spatial orbitals
      INT :: n_bf
      .n_bf = n_bf
   end

   set_to(v) [leaky]
   ! Set self to "v"
      OPVEC :: v
      .set(v%n_bf)
      if ( v.all_destroyed) return
      if ( v%restricted.created) then
         .destroy("restricted"); .create("restricted")
         self%restricted = v%restricted
      end
      if ( v%alpha.created) then
         .destroy("alpha"); .create("alpha")
          self%alpha = v%alpha
      end
      if ( v%beta.created) then
         .destroy("beta"); .create("beta")
         self%beta = v%beta
      end
      if ( v%general.created) then
         .destroy("general"); .create("general")
         self%general = v%general
      end
   end

   spinorbital_kind result(res)
   ! Return the kind of spinorbitals used in the representation.
   ! The simplest spinorbital kind in use is the one returned.
      STR :: res
      if      ( .restricted.created ) then; res = "restricted"
      else if ( .alpha.created )      then; res = "unrestricted"
      else if ( .general.created )    then; res = "general"
      else; DIE("no object created")
      end
   end

   zero
   ! Set self to zero
      STR :: kind
      kind = .spinorbital_kind
      select case(kind)
         case("restricted");      .restricted = ZERO
         case("unrestricted");    .alpha = ZERO; .beta = ZERO
         case("general");         .general = ZERO
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   convert_to(newkind) [leaky]
   ! Convert self to a new basis kind "newkind"
      STR(*) :: newkind
      STR :: oldkind
      oldkind = .spinorbital_kind
      if (newkind==oldkind) return
      .create(newkind)
      select case (oldkind)
         case("restricted")
            select case (newkind)
               case("unrestricted")
                  .alpha = .restricted
                  .beta  = .restricted
               case("general")
                  .general = ZERO
                  .general.set_alpha(.restricted)
                  .general.set_beta(.restricted)
               case default
                  DIE("cant convert kind " // oldkind.trim // " to kind " // newkind.trim)
            end
         case("unrestricted")
            select case (newkind)
               case("restricted")
                  .restricted = .alpha
               case("general")
                  .general.set_alpha(.alpha)
                  .general.set_beta(.beta)
               case default
                  DIE("cant convert kind " // oldkind.trim // " to kind " // newkind.trim)
            end
         case("general")
            select case (newkind)
               case("unrestricted")
                  .alpha = .general.alpha
                  .beta  = .general.beta
               case default
                  DIE("cant convert kind " // oldkind.trim // " to kind " // newkind.trim)
            end
         case default; DIE("cant convert old kind " // oldkind.trim)
      end
      .destroy(oldkind)
   end

end 
