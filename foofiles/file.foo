! $Id$
!---------------------------------------------------------------------------
!
!  FILE : Unformatted sequential advancing I/O, for fast mass data storage
!
!  NOTE: If ascii files are required consider using INPUT or OUTPUT.
!
!  A file is referred to only by a STR name. Unit numbers are not required.
!  Creation of a file object does not lead to creation of the actual file
!  on the computer, it merely creates the label for the file. 
!  The actual file may already exist. If it does not exist, then an 
!  FILE_open command will bring it into existence. Otherwise, FILE_open 
!  will open the existing file. Closing a file does not delete the actual
!  file unless specifically requested.
!
!  When reading or writing an object to the file, it is assumed that
!  each object occupied one abstract "record". After a recor5d is written,
!  it may not be overwritten without destroying all data objects in the
!  following records. It is recommended that multiple data objects which 
!  are logically related be stored in different files with appropriate names
!  for each file which indicate the relationship of the data objects
!  within them.
!
!  Strings are regarded as type STR for purposes of output to the file.
!
!  If the read or write statements give a segmentation fault for large
!  arrays or matrices, try increasing your stack size.
!  
!  (c) dylan jayatilaka, uwa, dec 1997
!---------------------------------------------------------------------------
module FILE

   use TYPES
   use ERROR
   use MM
   use STR
   use INT
   use IVEC
   use VEC
   use CVEC
   use UNITNUMBER

   implicit none         

#  include "macros"
#  include "file.int"

!  type file_type
!     INT :: unit
!     INT :: record
!     INT :: io_status
!     STR :: name
!     STR :: action
!     STR :: file_status
!     BIN :: buffered
!     INT :: dbl_buffer_pos,int_buffer_pos
!     VEC, PTR  :: dbl_buffer DEFAULT_NULL
!     IVEC, PTR :: int_buffer DEFAULT_NULL
!     CVEC, PTR :: cdbl_buffer DEFAULT_NULL
!  end 

   interface get
      read_str, read_dbl, read_cdbl, read_int, read_bin, 
      read_ivec, read_vec, read_cvec,
      read_mat, read_mat3, read_mat4, read_imat,
      read_cmat, read_cmat3, read_cmat4, read_cmat5
   end

   interface read
      read_str, read_dbl, read_cdbl, read_int, read_bin, 
      read_ivec, read_vec, read_cvec,
      read_mat, read_mat3, read_mat4, read_imat,
      read_cmat, read_cmat3, read_cmat4, read_cmat5
   end

   interface write
      write_int, write_dbl, write_cdbl, write_str, write_bin, 
      write_vec, write_ivec, write_cvec,
      write_mat, write_mat3, write_mat4, write_imat, 
      write_cmat, write_cmat3, write_cmat4, write_cmat5
   end

   interface put 
      write_int, write_dbl, write_cdbl, write_str, write_bin, 
      write_vec, write_ivec, write_cvec,
      write_mat, write_mat3, write_mat4, write_imat, 
      write_cmat, write_cmat3, write_cmat4, write_cmat5
   end
 
  interface write_buffered
    write_buffered_dbl, write_buffered_int, write_buffered_cdbl
    write_buffered_vec, write_buffered_ivec, write_buffered_cvec
    write_buffered_mat, write_buffered_imat, write_buffered_cmat
    write_buffered_mat3, write_buffered_cmat3, write_buffered_mat4
  end

  interface read_buffered
    read_buffered_dbl, read_buffered_int, read_buffered_cdbl
    read_buffered_vec, read_buffered_ivec, read_buffered_cvec
    read_buffered_mat, read_buffered_imat, read_buffered_cmat
    read_buffered_mat3, read_buffered_cmat3, read_buffered_mat4
  end

contains
      
!  *****************************
!  File creation type operations
!  *****************************

   create(name)  
   ! Create a file-label object. Does not open the file.
      PTR :: self
      UNITNUMBER :: unitnumber
      CHR(len=*) :: name
      nullify(self)
      allocate(self)
      std_mm.add(FILE_SIZE)
      .nullify_ptr_part
      .name = name
      .record = 1
      .io_status = 0
      .file_status = "unknown"
      .action      = "readwrite"
      .buffered    = FALSE
      .dbl_buffer_pos = 1
      .int_buffer_pos = 1
      .cdbl_buffer_pos = 1
      unitnumber.get( .unit)
   end

   destroy
   ! Destroy a file-label object
      PTR :: self
      UNITNUMBER :: unitnumber
      if (.destroyed) return
      if (.is_open AND .unit_used) .close
      unitnumber.free( .unit)
      .destroy_ptr_part
      std_mm.delete(FILE_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts
      nullify( .dbl_buffer )
      nullify( .int_buffer )
      nullify( .cdbl_buffer )
   end

   destroy_ptr_part
   ! Destroy pointer parts
      .dbl_buffer.destroy
      .int_buffer.destroy
      .cdbl_buffer.destroy
   end

   open(for,buffered,type) [leaky]
   ! Open the file. The file object must already be created.
   ! If present, "for" indicated whether the file is "read_write", "read-only" or "write-only"
   ! If present, "buffered" indicated whether the file is to be buffered, and the "type" of the 
   ! buffer must also be specified as "dbl" or "int"
     STR(*), optional :: for
     BIN,    optional :: buffered
     STR(*), optional :: type
     if (present(for)) then
        select case (for)
           case("readwrite","read-write","read-and-write","reading-and-writing"); .action = "readwrite"
           case("read","reading","read-only","reading-only");    .action = "read"
           case("write","writing","write-only","writing-only");  .action = "write"
           case default; DIE("unknown IO option, "//trim(for))
        end
     end
     .file_status = "new"
     if (.exists) .file_status = "old"
     open( unit   = .unit,         &
           file   = .name,         &
           status = .file_status,  &
           access = "sequential",  &
           form   = "unformatted", & ! <---------
           action = .action,       &
           iostat = .io_status)
     DIE_IF(.io_status>0,"error opening "//trim(.file_status)//" file "//.name)
     if (present(buffered)) .buffered = buffered
     if (.buffered) then
        ENSURE(present(type),"type of buffer must be specified")
        ENSURE(.action/="readwrite","buffer must be either read-only or write-only")
        select case (type)
           case("dbl")
             .dbl_buffer.create(FILE_BUFFER_LENGTH)
             if (.action == "read") .get_dbl_buffer
           case("int")
             .int_buffer.create(FILE_BUFFER_LENGTH)
             if (.action == "read") .get_int_buffer
           case("cdbl")
             .cdbl_buffer.create(FILE_BUFFER_LENGTH)
             if (.action == "read") .get_cdbl_buffer
           case default
             DIE("unknown buffer type, "//trim(type))
        end
     end
   end

   close [leaky]
   ! Close the file
      WARN_IF(.is_not_open,"file is not open")
      if (.dbl_buffer_pos > 1 AND .action=="write") then
        .flush_dbl_buffer
        .dbl_buffer_pos = 1
      end
      if (.int_buffer_pos > 1 AND .action=="write") then
        .flush_int_buffer
        .int_buffer_pos = 1
      end
      if (.cdbl_buffer_pos > 1 AND .action=="write") then
        .flush_cdbl_buffer
        .cdbl_buffer_pos = 1
      end
      .destroy_ptr_part
      close(unit=.unit)
   end

   close_and_delete [leaky]
   ! Close the file and delete it from the file system
      WARN_IF(.is_not_open,"file is not open")
      if (.dbl_buffer_pos > 1) then
        .flush_dbl_buffer
        .dbl_buffer.destroy
        .dbl_buffer_pos = 1
      end
      if (.int_buffer_pos > 1) then
        .flush_int_buffer
        .int_buffer.destroy
        .int_buffer_pos = 1
      end
      if (.cdbl_buffer_pos > 1) then
        .flush_cdbl_buffer
        .cdbl_buffer.destroy
        .cdbl_buffer_pos = 1
      end
      close(unit=.unit,status="delete")
   end

   delete
   ! Delete the file from the file system
      if (.is_not_open) .open
      .close_and_delete
   end

!  **************************
!  Data input type operations
!  **************************
      
   read_str(value)
   ! Read a default str from the file into variable "value"
      STR :: value
      read(unit=.unit,iostat=.io_status) value
      DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
      .record = .record + 1
   end
      
   read_int(value)
   ! Read an integer from the file into variable "value"
      INT :: value
      if (.buffered) then
         .read_buffered_int(value)
      else
         read(unit=.unit,iostat=.io_status) value
         DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end
      
   read_dbl(value)
   ! Read a dbl from the file into variable "value"
      DBL :: value
      if (.buffered) then
         .read_buffered_dbl(value)
      else
         read(unit=.unit,iostat=.io_status) value
         DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end
      
   read_cdbl(value)
   ! Read a complex dbl from the file into variable "value"
      CDBL :: value
      if (.buffered) then
         .read_buffered_cdbl(value)
      else
         read(unit=.unit,iostat=.io_status) value
         DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end
      
   read_bin(value)
   ! Read a logical from the file into variable "value"
      BIN :: value
      read(unit=.unit,iostat=.io_status) value
      DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
      .record = .record + 1
   end

   read_vec(vec)
   ! Read a vector from the file into variable "vec"
      VEC :: vec
      if (.buffered) then
         .read_buffered_vec(vec)
      else
         read(unit=.unit,iostat=.io_status) vec  
         DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   read_ivec(vec)
   ! Read a vector from the file into variable "vec"
      IVEC :: vec
      if (.buffered) then
         .read_buffered_ivec(vec)
      else
         read(unit=.unit,iostat=.io_status) vec  
         DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   read_cvec(vec)
   ! Read a vector from the file into variable "vec"
      CVEC :: vec
      if (.buffered) then
         .read_buffered_cvec(vec)
      else
         read(unit=.unit,iostat=.io_status) vec  
         DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   read_mat(mat)
   ! Read a matrix from the file into variable "mat"
      MAT :: mat
      if (.buffered) then
         .read_buffered_mat(mat)
      else
        read(unit=.unit,iostat=.io_status) mat  
        DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
        .record = .record + 1
      end
   end

   read_imat(mat)
   ! Read an integer matrix from the file into variable "mat"
      IMAT :: mat
      if (.buffered) then
         .read_buffered_imat(mat)
      else
         read(unit=.unit,iostat=.io_status) mat  
         DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   read_cmat(mat)
   ! Read a complex matrix from the file into variable "mat"
      CMAT :: mat
      if (.buffered) then
         .read_buffered_cmat(mat)
      else
         read(unit=.unit,iostat=.io_status) mat  
         DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   read_mat3(mat)
   ! Read a matrix from the file into variable "mat"
      MAT3 :: mat
      if (.buffered) then
         .read_buffered_mat3(mat)
      else
         read(unit=.unit,iostat=.io_status) mat  
         DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   read_cmat3(mat)
   ! Read a complex matrix from the file into variable "mat"
      CMAT3 :: mat
      if (.buffered) then
         .read_buffered_cmat3(mat)
      else
         read(unit=.unit,iostat=.io_status) mat  
         DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   read_mat4(mat)
   ! Read a matrix from the file into variable "mat"
      MAT4 :: mat
      if (.buffered) then
         .read_buffered_mat4(mat)
      else
         read(unit=.unit,iostat=.io_status) mat  
         DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   read_cmat4(mat)
   ! Read a complex matrix from the file into variable "mat"
      CMAT4 :: mat
      read(unit=.unit,iostat=.io_status) mat  
      DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
      .record = .record + 1
   end

   read_cmat5(mat)
   ! Read a complex matrix from the file into variable "mat"
      CMAT5 :: mat
      read(unit=.unit,iostat=.io_status) mat  
      DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
      .record = .record + 1
   end

!  ********************
!  Data output routines
!  ********************

   write_int(value)
   ! Write an integer to the file as a record
      INT :: value
      if (.buffered) then
         .write_buffered_int(value)
      else
         write(unit=.unit,iostat=.io_status) value
         DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end
      
   write_dbl(value)
   ! Write a dbl to the file as a record
      DBL :: value
      if (.buffered) then
         .write_buffered_dbl(value)
      else
         write(unit=.unit,iostat=.io_status) value
         DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end
      
   write_cdbl(value)
   ! Write a cdbl to the file as a record
      CDBL :: value
      if (.buffered) then
         .write_buffered_cdbl(value)
      else
         write(unit=.unit,iostat=.io_status) value
         DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end
      
   write_str(value)
   ! Write a str to the file as a record
      CHR(len=*) :: value
      STR :: str
      str = value
      write(unit=.unit,iostat=.io_status) str
      DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
      .record = .record + 1
   end
      
   write_bin(value)
   ! Write a bin to the file as a record
      BIN :: value
      write(unit=.unit,iostat=.io_status) value
      DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
      .record = .record + 1
   end

   write_vec(vec)
   ! Write a vector to the file as a single record
      VEC :: vec
      if (.buffered) then
         .write_buffered_vec(vec)
      else
         write(unit=.unit,iostat=.io_status) vec  
         DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   write_ivec(vec)
   ! Write a vector to the file as a single record
      IVEC, IN :: vec
      if (.buffered) then
         .write_buffered_ivec(vec)
      else
         write(unit=.unit,iostat=.io_status) vec  
         DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   write_cvec(vec)
   ! Write a vector to the file as a single record
      CVEC :: vec
      if (.buffered) then
         .write_buffered_cvec(vec)
      else
         write(unit=.unit,iostat=.io_status) vec  
         DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   write_mat(mat)
   ! Write a matrix to the file as a single record
      MAT :: mat
      if (.buffered) then
         .write_buffered_mat(mat)
      else
        write(unit=.unit,iostat=.io_status) mat  
        DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
        .record = .record + 1
      end
   end

   write_imat(mat)
   ! Write a matrix to the file as a single record
      IMAT :: mat
      if (.buffered) then
         .write_buffered_imat(mat)
      else
        write(unit=.unit,iostat=.io_status) mat  
        DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
        .record = .record + 1
      end
   end

   write_cmat(mat)
   ! Write a complex matrix to the file as a single record
      CMAT :: mat
      if (.buffered) then
         .write_buffered_cmat(mat)
      else
        write(unit=.unit,iostat=.io_status) mat  
        DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
        .record = .record + 1
      end
   end

   write_mat3(mat)
   ! Write a matrix to the file as a single record
      MAT3 :: mat
      if (.buffered) then
         .write_buffered_mat3(mat)
      else
         write(unit=.unit,iostat=.io_status) mat  
         DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   write_cmat3(mat)
   ! Write a complex 3d matrix to the file as a single record
      CMAT3 :: mat
      if (.buffered) then
         .write_buffered_cmat3(mat)
      else
         write(unit=.unit,iostat=.io_status) mat  
         DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   write_mat4(mat)
   ! Write a matrix to the file as a single record
      MAT4 :: mat
      if (.buffered) then
         .write_buffered_mat4(mat)
      else
         write(unit=.unit,iostat=.io_status) mat  
         DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
         .record = .record + 1
      end
   end

   write_cmat4(mat)
   ! Write a complex 4d matrix to the file as a single record
      CMAT4 :: mat
      write(unit=.unit,iostat=.io_status) mat  
      DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
      .record = .record + 1
   end

   write_cmat5(mat)
   ! Write a complex 5d matrix to the file as a single record
      CMAT5 :: mat
      write(unit=.unit,iostat=.io_status) mat  
      DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
      .record = .record + 1
   end

!  **********************************
!  File repositioning type operations
!  **********************************

   rewind
   ! Rewind the file
      rewind(unit=.unit,iostat=.io_status)
      DIE_IF(.io_status>0,"rewind error, error="// .io_status.to_str.trim)
      .record = 1
   end

   backspace
   ! Backspace the file one record of the file. Backspacing before record 1 has no effect.
      backspace(unit=.unit,iostat=.io_status)
      DIE_IF(.io_status>0,"backspace error, error="// .io_status.to_str.trim)
      .record = max(1,.record-1)
   end

   skip
   ! Skip over the next record of the file. An error is generated if at the end of the file
      read(unit=.unit,iostat=.io_status)
      DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
      .record = .record + 1
   end

   move_to_end
   ! Move to the end of the file, say for adding more data
      do
         read(unit=.unit,iostat=.io_status)
         if (.io_status/=0) exit
         .record = .record + 1
      end
   end

   move_to_position(pos) 
   ! Move to a particular record position in the file
      INT :: pos
      .move_to_record(pos) 
   end

   move_to_record(rec) 
   ! Move to a particular record position in the file
      INT :: rec
      DIE_IF(rec<1,"can't move to non-positive record")
      if (rec<.position) then
         do 
            .backspace
            if (.position==rec) exit
         end
      else if (rec>.position) then
         do 
            .skip
            if (.position==rec) exit
         end
      end
   end

!  ***************
!  Inquiry methods 
!  ***************

   exists result(res)
   ! Returns true if the file exists on the file system
      BIN :: res
      inquire(file=.name,exist=res)
   end

   exists(name) result(res)
   ! Returns true if the file exists on the file system
      BIN :: res
      STR, IN :: name
      inquire(file=name,exist=res)
   end

   does_not_exist result(res)
   ! Returns true if the file does *not* exist on the file system
      BIN :: res
      res = NOT (.exists)
   end

   does_not_exist(name) result(res)
   ! Returns true if the file does *not* exist on the file system
      BIN :: res
      STR, IN :: name
      res = NOT (.exists(name))
   end

   is_open result(res)
   ! Returns true if the file has been opened
      BIN :: res
      ! inquire(unit=.unit,opened=res)
      inquire(file=.name,opened=res)
   end

   is_not_open result(res)
   ! Returns true if the file has *not* been opened
      BIN :: res
      res = NOT (.is_open)
   end

   unit_used result(res)
   ! Returns true if the file unit is in use
      BIN :: res
      inquire(unit=.unit,opened=res)
   end

   unit_not_used result(res)
   ! Returns true if the file unit is *not* in use
      BIN :: res
      inquire(unit=.unit,opened=res)
      res = NOT res
   end

   created result(res)
   ! Returns true if the file object has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if the file object has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   position result(res) 
   ! Return record position of the file
      INT :: res
      res = .record
   end

   record result(res) 
   ! Return record position of the file
      INT :: res
      res = .record
   end

   io_status result(res) 
   ! Return the file unit number
      INT :: res
      res = .io_status
   end

   unit result(res) 
   ! Return the file unit number
      INT :: res
      res = .unit
   end

   name result(res) 
   ! Return the file name as a default str
      STR :: res
      res = .name
   end

   is_for_reading result(res)
   ! Return whether the file is opened for reading.
     BIN :: res
     STR :: reading
     inquire(unit=.unit,read=reading)
     if (reading.trim == "YES") then
       res = TRUE
     else
       res = FALSE
     end
   end

   is_dbl_buffered result(res)
   ! Returns true if the file is using DBL buffering
      BIN :: res
      res = associated(.dbl_buffer)
   end

   is_int_buffered result(res)
   ! Returns true if the file is using INT buffering
      BIN :: res
      res = associated(.int_buffer)
   end

!***************************************************
! Buffered routines
!***************************************************

  flush_dbl_buffer
  ! Writes the dbl_buffer to disk, and positions the pointer at the start of the buffer.
    write(unit=.unit,iostat=.io_status) .dbl_buffer
    DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
    .record = .record + 1
    .dbl_buffer_pos = 1
  end

  flush_int_buffer
  ! Writes the int_buffer to disk, and positions the pointer at the start of the buffer.
    write(unit=.unit,iostat=.io_status) .int_buffer
    DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
    .record = .record + 1
    .int_buffer_pos = 1
  end

  flush_cdbl_buffer
  ! Writes the cdbl_buffer to disk, and positions the pointer at the start of the buffer.
    write(unit=.unit,iostat=.io_status) .cdbl_buffer
    DIE_IF(.io_status>0,"write error, error="// .io_status.to_str.trim)
    .record = .record + 1
    .cdbl_buffer_pos = 1
  end

  get_dbl_buffer
  ! Reads the dbl_buffer from disk, and positions the pointer at the start of the buffer.
    read(unit=.unit,iostat=.io_status) .dbl_buffer
    DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
    .record = .record + 1
    .dbl_buffer_pos = 1
  end

  get_int_buffer
  ! Reads the int_buffer from disk, and positions the pointer at the start of the buffer.
    ENSURE( .int_buffer.created, "buffer not created")
    read(unit=.unit,iostat=.io_status) .int_buffer
    DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
    .record = .record + 1
    .int_buffer_pos = 1
  end

  get_cdbl_buffer
  ! Reads the cdbl_buffer from disk, and positions the pointer at the start of the buffer.
    read(unit=.unit,iostat=.io_status) .cdbl_buffer
    DIE_IF(.io_status>0,"read error, error="// .io_status.to_str.trim)
    .record = .record + 1
    .cdbl_buffer_pos = 1
  end

  write_buffered_dbl(the_dbl) 
  ! Writes "the_dbl" to the buffer, and writes buffer to disk when full.
    DBL, IN :: the_dbl
    ENSURE( .dbl_buffer.created, "buffer not created")
    .dbl_buffer( .dbl_buffer_pos ) = the_dbl
    .dbl_buffer_pos = .dbl_buffer_pos + 1
    if ( .dbl_buffer_pos > size( .dbl_buffer )) .flush_dbl_buffer
  end

  read_buffered_dbl(the_dbl) 
  ! Reads "the_dbl" from the buffer, and reads buffer from disk when empty.
    DBL, OUT :: the_dbl
    if ( .dbl_buffer_pos > size( .dbl_buffer )) .get_dbl_buffer
    the_dbl = .dbl_buffer( .dbl_buffer_pos )
    .dbl_buffer_pos = .dbl_buffer_pos + 1
  end

  write_buffered_int(the_int) 
  ! Writes "the_int" to the buffer, and writes buffer to disk when full.
    INT, IN :: the_int
    .int_buffer( .int_buffer_pos ) = the_int
    .int_buffer_pos = .int_buffer_pos + 1
    if ( .int_buffer_pos > size( .int_buffer )) .flush_int_buffer
  end

  read_buffered_int(the_int) 
  ! Reads the integer from the buffer, and reads buffer from disk when empty.
    INT, OUT :: the_int
    if ( .int_buffer_pos > size( .int_buffer )) .get_int_buffer
    the_int = .int_buffer( .int_buffer_pos )
    .int_buffer_pos = .int_buffer_pos + 1
  end

  write_buffered_cdbl(the_cdbl) 
  ! Writes "the_cdbl" to the buffer, and writes buffer to disk when full.
    CDBL, IN :: the_cdbl
    ENSURE( .cdbl_buffer.created, "buffer not created")
    .cdbl_buffer( .cdbl_buffer_pos ) = the_cdbl
    .cdbl_buffer_pos = .cdbl_buffer_pos + 1
    if ( .cdbl_buffer_pos > size( .cdbl_buffer )) .flush_cdbl_buffer
  end

  read_buffered_cdbl(the_cdbl) 
  ! Reads "the_cdbl" from the buffer, and reads buffer from disk when empty.
    CDBL, OUT :: the_cdbl
    if ( .cdbl_buffer_pos > size( .cdbl_buffer )) .get_cdbl_buffer
    the_cdbl = .cdbl_buffer( .cdbl_buffer_pos )
    .cdbl_buffer_pos = .cdbl_buffer_pos + 1
  end

  write_buffered_vec(the_vec) 
  ! Writes the vector to the buffer, and writes buffer to disk when full.
    VEC, IN :: the_vec
    INT :: buffer_length,vec_length,vec_pos,buffer_top,vec_top,put_length
    vec_length = size(the_vec)
    buffer_length = size( .dbl_buffer )
    vec_pos=1
    do
      put_length=min(buffer_length - .dbl_buffer_pos + 1,vec_length-vec_pos+1)
      buffer_top = .dbl_buffer_pos + put_length - 1
      vec_top = vec_pos + put_length - 1
      .dbl_buffer( .dbl_buffer_pos:buffer_top) = the_vec(vec_pos:vec_top)
      .dbl_buffer_pos = buffer_top + 1
      vec_pos = vec_top + 1
      if ( .dbl_buffer_pos > buffer_length) .flush_dbl_buffer
      if (vec_pos > vec_length) exit
    end
  end

  read_buffered_vec(the_vec) 
  ! Reads the vector from the buffer, and reads buffer from disk when empty.
    VEC, OUT :: the_vec
    INT :: buffer_length,vec_length,vec_pos,buffer_top,vec_top,get_length
    vec_length = size(the_vec)
    buffer_length = size( .dbl_buffer )
    vec_pos=1
    do
      if ( .dbl_buffer_pos > buffer_length) .get_dbl_buffer
      get_length=min(buffer_length - .dbl_buffer_pos + 1,vec_length-vec_pos+1)
      buffer_top = .dbl_buffer_pos + get_length - 1
      vec_top = vec_pos + get_length - 1
      the_vec(vec_pos:vec_top) = .dbl_buffer( .dbl_buffer_pos:buffer_top)
      .dbl_buffer_pos = buffer_top + 1
      vec_pos = vec_top + 1
      if (vec_pos > vec_length) exit
    end
  end

  write_buffered_ivec(the_ivec) 
  ! Writes the ivector to the buffer, and writes buffer to disk when full.
    IVEC, IN :: the_ivec
    INT :: buffer_length,ivec_length,ivec_pos,buffer_top,ivec_top,put_length
    ivec_length = size(the_ivec)
    buffer_length = size( .int_buffer )
    ivec_pos=1
    do
      put_length=min(buffer_length - .int_buffer_pos + 1,ivec_length-ivec_pos+1)
      buffer_top = .int_buffer_pos + put_length - 1
      ivec_top = ivec_pos + put_length - 1
      .int_buffer( .int_buffer_pos:buffer_top) = the_ivec(ivec_pos:ivec_top)
      .int_buffer_pos = buffer_top + 1
      ivec_pos = ivec_top + 1
      if ( .int_buffer_pos > buffer_length) .flush_int_buffer
      if (ivec_pos > ivec_length) exit
    end
  end

  read_buffered_ivec(the_ivec) 
  ! Reads the ivector from the buffer, and reads buffer from disk when empty.
    IVEC, OUT :: the_ivec
    INT :: buffer_length,ivec_length,ivec_pos,buffer_top,ivec_top,get_length
    ivec_length = size(the_ivec)
    buffer_length = size( .int_buffer )
    ivec_pos=1
    do
      if ( .int_buffer_pos > buffer_length) .get_int_buffer
      get_length=min(buffer_length - .int_buffer_pos + 1,ivec_length-ivec_pos+1)
      buffer_top = .int_buffer_pos + get_length - 1
      ivec_top = ivec_pos + get_length - 1
      the_ivec(ivec_pos:ivec_top) = .int_buffer( .int_buffer_pos:buffer_top)
      .int_buffer_pos = buffer_top + 1
      ivec_pos = ivec_top + 1
      if (ivec_pos > ivec_length) exit
    end
  end

  write_buffered_cvec(the_cvec) 
  ! Writes the cvector to the buffer, and writes buffer to disk when full.
    CVEC, IN :: the_cvec
    INT :: buffer_length,cvec_length,cvec_pos,buffer_top,cvec_top,put_length
    cvec_length = size(the_cvec)
    buffer_length = size( .cdbl_buffer )
    cvec_pos=1
    do
      put_length=min(buffer_length - .cdbl_buffer_pos + 1,cvec_length-cvec_pos+1)
      buffer_top = .cdbl_buffer_pos + put_length - 1
      cvec_top = cvec_pos + put_length - 1
      .cdbl_buffer( .cdbl_buffer_pos:buffer_top) = the_cvec(cvec_pos:cvec_top)
      .cdbl_buffer_pos = buffer_top + 1
      cvec_pos = cvec_top + 1
      if ( .cdbl_buffer_pos > buffer_length) .flush_cdbl_buffer
      if (cvec_pos > cvec_length) exit
    end
  end

  read_buffered_cvec(the_cvec) 
  ! Reads the cvector from the buffer, and reads buffer from disk when empty.
    CVEC, OUT :: the_cvec
    INT :: buffer_length,cvec_length,cvec_pos,buffer_top,cvec_top,get_length
    cvec_length = size(the_cvec)
    buffer_length = size( .cdbl_buffer )
    cvec_pos=1
    do
      if ( .cdbl_buffer_pos > buffer_length) .get_cdbl_buffer
      get_length=min(buffer_length - .cdbl_buffer_pos + 1,cvec_length-cvec_pos+1)
      buffer_top = .cdbl_buffer_pos + get_length - 1
      cvec_top = cvec_pos + get_length - 1
      the_cvec(cvec_pos:cvec_top) = .cdbl_buffer( .cdbl_buffer_pos:buffer_top)
      .cdbl_buffer_pos = buffer_top + 1
      cvec_pos = cvec_top + 1
      if (cvec_pos > cvec_length) exit
    end
  end

  write_buffered_mat(mat) 
  ! Writes the mat to the buffer, and writes buffer to disk when full.
    MAT, IN :: mat
    INT :: buffer_length,a,b,asize,bsize
    buffer_length = size( .dbl_buffer )
    asize=size(mat,1);    bsize=size(mat,2)
    do a=1,asize
      do b=1,bsize
        .dbl_buffer( .dbl_buffer_pos ) = mat(a,b)
        .dbl_buffer_pos = .dbl_buffer_pos + 1
        if ( .dbl_buffer_pos > buffer_length) .flush_dbl_buffer
      end
    end
  end

  read_buffered_mat(mat) 
  ! Reads the mat from the buffer.
    MAT, OUT :: mat
    INT :: buffer_length,a,b,asize,bsize
    buffer_length = size( .dbl_buffer )
    asize=size(mat,1);    bsize=size(mat,2)
    do a=1,asize
      do b=1,bsize
        if ( .dbl_buffer_pos > buffer_length) .get_dbl_buffer
        mat(a,b) = .dbl_buffer( .dbl_buffer_pos )
        .dbl_buffer_pos = .dbl_buffer_pos + 1
      end
    end
  end

  write_buffered_imat(imat) 
  ! Writes the imat to the buffer, and writes buffer to disk when full.
    IMAT, IN :: imat
    INT :: buffer_length,a,b,asize,bsize
    buffer_length = size( .int_buffer )
    asize=size(imat,1);    bsize=size(imat,2)
    do a=1,asize
      do b=1,bsize
        .int_buffer( .int_buffer_pos ) = imat(a,b)
        .int_buffer_pos = .int_buffer_pos + 1
        if ( .int_buffer_pos > buffer_length) .flush_int_buffer
      end
    end
  end

  read_buffered_imat(imat) 
  ! Reads the imat from the buffer.
    IMAT, OUT :: imat
    INT :: buffer_length,a,b,asize,bsize
    buffer_length = size( .int_buffer )
    asize=size(imat,1);    bsize=size(imat,2)
    do a=1,asize
      do b=1,bsize
        if ( .int_buffer_pos > buffer_length) .get_int_buffer
        imat(a,b) = .int_buffer( .int_buffer_pos )
        .int_buffer_pos = .int_buffer_pos + 1
      end
    end
  end

  write_buffered_cmat(mat) 
  ! Writes the cmat to the buffer, and writes buffer to disk when full.
    CMAT, IN :: mat
    INT :: buffer_length,a,b,asize,bsize
    buffer_length = size( .cdbl_buffer )
    asize=size(mat,1);    bsize=size(mat,2)
    do a=1,asize
      do b=1,bsize
        .cdbl_buffer( .cdbl_buffer_pos ) = mat(a,b)
        .cdbl_buffer_pos = .cdbl_buffer_pos + 1
        if ( .cdbl_buffer_pos > buffer_length) .flush_cdbl_buffer
      end
    end
  end

  read_buffered_cmat(mat) 
  ! Reads the cmat from the buffer.
    CMAT, OUT :: mat
    INT :: buffer_length,a,b,asize,bsize
    buffer_length = size( .cdbl_buffer )
    asize=size(mat,1);    bsize=size(mat,2)
    do a=1,asize
      do b=1,bsize
        if ( .cdbl_buffer_pos > buffer_length) .get_cdbl_buffer
        mat(a,b) = .cdbl_buffer( .cdbl_buffer_pos )
        .cdbl_buffer_pos = .cdbl_buffer_pos + 1
      end
    end
  end

  write_buffered_mat3(mat3) 
  ! Writes the mat3 to the buffer, and writes buffer to disk when full.
    MAT3, IN :: mat3
    INT :: buffer_length,a,b,c,asize,bsize,csize
    buffer_length = size( .dbl_buffer )
    asize=size(mat3,1);    bsize=size(mat3,2)
    csize=size(mat3,3)
    do a=1,asize
      do b=1,bsize
        do c=1,csize
          .dbl_buffer( .dbl_buffer_pos ) = mat3(a,b,c)
          .dbl_buffer_pos = .dbl_buffer_pos + 1
          if ( .dbl_buffer_pos > buffer_length) .flush_dbl_buffer
        end
      end
    end
  end

  read_buffered_mat3(mat3) 
  ! Reads the mat3 from the buffer.
    MAT3, OUT :: mat3
    INT :: buffer_length,a,b,c,asize,bsize,csize
    buffer_length = size( .dbl_buffer )
    asize=size(mat3,1);    bsize=size(mat3,2)
    csize=size(mat3,3)
    do a=1,asize
      do b=1,bsize
        do c=1,csize
          if ( .dbl_buffer_pos > buffer_length) .get_dbl_buffer
          mat3(a,b,c) = .dbl_buffer( .dbl_buffer_pos )
          .dbl_buffer_pos = .dbl_buffer_pos + 1
        end
      end
    end
  end

  write_buffered_cmat3(cmat3) 
  ! Writes the cmat3 to the buffer, and writes buffer to disk when full.
    CMAT3, IN :: cmat3
    INT :: buffer_length,a,b,c,asize,bsize,csize
    buffer_length = size( .cdbl_buffer )
    asize=size(cmat3,1);    bsize=size(cmat3,2)
    csize=size(cmat3,3)
    do a=1,asize
      do b=1,bsize
        do c=1,csize
          .cdbl_buffer( .cdbl_buffer_pos ) = cmat3(a,b,c)
          .cdbl_buffer_pos = .cdbl_buffer_pos + 1
          if ( .cdbl_buffer_pos > buffer_length) .flush_cdbl_buffer
        end
      end
    end
  end

  read_buffered_cmat3(cmat3) 
  ! Reads the cmat3 from the buffer.
    CMAT3, OUT :: cmat3
    INT :: buffer_length,a,b,c,asize,bsize,csize
    buffer_length = size( .cdbl_buffer )
    asize=size(cmat3,1);    bsize=size(cmat3,2)
    csize=size(cmat3,3)
    do a=1,asize
      do b=1,bsize
        do c=1,csize
          if ( .cdbl_buffer_pos > buffer_length) .get_cdbl_buffer
          cmat3(a,b,c) = .cdbl_buffer( .cdbl_buffer_pos )
          .cdbl_buffer_pos = .cdbl_buffer_pos + 1
        end
      end
    end
  end

  write_buffered_mat4(mat4) 
  ! Writes the mat4 to the buffer, and writes buffer to disk when full.
    MAT4, IN :: mat4
    INT :: buffer_length,a,b,c,d,asize,bsize,csize,dsize
    buffer_length = size( .dbl_buffer )
    asize=size(mat4,1);    bsize=size(mat4,2)
    csize=size(mat4,3);    dsize=size(mat4,4)
    do a=1,asize
      do b=1,bsize
        do c=1,csize
          do d=1,dsize
            .dbl_buffer( .dbl_buffer_pos ) = mat4(a,b,c,d)
            .dbl_buffer_pos = .dbl_buffer_pos + 1
            if ( .dbl_buffer_pos > buffer_length) .flush_dbl_buffer
          end
        end
      end
    end
  end

  read_buffered_mat4(mat4) 
  ! Reads the mat4 from the buffer.
    MAT4, OUT :: mat4
    INT :: buffer_length,a,b,c,d,asize,bsize,csize,dsize
    buffer_length = size( .dbl_buffer )
    asize=size(mat4,1);    bsize=size(mat4,2)
    csize=size(mat4,3);    dsize=size(mat4,4)
    do a=1,asize
      do b=1,bsize
        do c=1,csize
          do d=1,dsize
            if ( .dbl_buffer_pos > buffer_length) .get_dbl_buffer
            mat4(a,b,c,d) = .dbl_buffer( .dbl_buffer_pos )
            .dbl_buffer_pos = .dbl_buffer_pos + 1
          end
        end
      end
    end
  end

end 

