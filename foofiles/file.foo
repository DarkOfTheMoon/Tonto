!---------------------------------------------------------------------------
!
!  FILE : Unformatted sequential advancing I/O, for fast mass data storage
!
!  NOTE: If ascii files are required consider using INPUT or OUTPUT.
!
!  A file is referred to only by a STR name. Unit numbers are not required.
!  Creation of a file object does not lead to creation of the actual file
!  on the computer, it merely creates the label for the file.
!  The actual file may already exist. If it does not exist, then an
!  FILE_open command will bring it into existence. Otherwise, FILE_open
!  will open the existing file. Closing a file does not delete the actual
!  file unless specifically requested.
!
!  When reading or writing an object to the file, it is assumed that
!  each object occupied one abstract "record". After a recor5d is written,
!  it may not be overwritten without destroying all data objects in the
!  following records. It is recommended that multiple data objects which
!  are logically related be stored in different files with appropriate names
!  for each file which indicate the relationship of the data objects
!  within them.
!
!  Strings are regarded as type STR for purposes of output to the file.
!
!  If the read or write statements give a segmentation fault for large
!  arrays or matrices, try increasing your stack size.
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module FILE

   implicit none

   interface get
      read_str, read_dbl, read_cdbl, read_int, read_bin,
      read_ivec, read_vec, read_cvec,
      read_mat, read_mat3, read_mat4, read_imat,
      read_cmat, read_cmat3, read_cmat4, read_cmat5
   end

   interface read
      read_str, read_dbl, read_cdbl, read_int, read_bin,
      read_ivec, read_vec, read_cvec,
      read_mat, read_mat3, read_mat4, read_imat,
      read_cmat, read_cmat3, read_cmat4, read_cmat5
   end

   interface write
      write_int, write_dbl, write_cdbl, write_str, write_bin,
      write_vec, write_ivec, write_cvec,
      write_mat, write_mat3, write_mat4, write_imat,
      write_cmat, write_cmat3, write_cmat4, write_cmat5
   end

   interface put
      write_int, write_dbl, write_cdbl, write_str, write_bin,
      write_vec, write_ivec, write_cvec,
      write_mat, write_mat3, write_mat4, write_imat,
      write_cmat, write_cmat3, write_cmat4, write_cmat5
   end

  interface write_buffered
    write_buffered_dbl, write_buffered_int, write_buffered_cdbl
    write_buffered_vec, write_buffered_ivec, write_buffered_cvec
    write_buffered_mat, write_buffered_imat, write_buffered_cmat
    write_buffered_mat3, write_buffered_cmat3, write_buffered_mat4
    write_buffered_cmat4, write_buffered_cmat5
  end

  interface read_buffered
    read_buffered_dbl, read_buffered_int, read_buffered_cdbl
    read_buffered_vec, read_buffered_ivec, read_buffered_cvec
    read_buffered_mat, read_buffered_imat, read_buffered_cmat
    read_buffered_mat3, read_buffered_cmat3, read_buffered_mat4
    read_buffered_cmat4, read_buffered_cmat5
  end

contains

!  *****************************
!  File creation type operations
!  *****************************

   create(name)
   ! Create a file-label object. Does not open the file.  Sets the filename if
   ! present.
      self :: PTR
      unit :: UNITNUMBER
      name :: STR(*), optional
      nullify(self)
      allocate(self)
      ADD_MEMORY(FILE_SIZE)
      .nullify_ptr_part
      .set_defaults
      if (present(name)) then
        .name = name
        unit.get(.unit)
      end
   end

   destroy
   ! Destroy a file-label object
      self :: PTR
      unit :: UNITNUMBER
      if (.destroyed) return
      if (.is_open AND .unit_used) .close
      unit.free(.unit)
      .destroy_ptr_part
      DELETE_MEMORY(FILE_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts
      nullify( .dbl_buffer )
      nullify( .int_buffer )
      nullify( .cdbl_buffer )
   end

   destroy_ptr_part
   ! Destroy pointer parts
      .dbl_buffer.destroy
      .int_buffer.destroy
      .cdbl_buffer.destroy
   end

   create_copy(f)
   ! Create a copy a file "f"
      self :: PTR
       f :: FILE
      .create
      .copy(f)
   end

   copy(f) ::: leaky
   ! Copy a file "f"
      f :: FILE
      self = f
      if (f.int_buffer.created) &
         .int_buffer.create_copy(f.int_buffer)
      if (f.dbl_buffer.created) &
         .dbl_buffer.create_copy(f.dbl_buffer)
      if (f.cdbl_buffer.created) &
         .cdbl_buffer.create_copy(f.cdbl_buffer)
   end

   set_defaults
   ! Set up defaults
      .record = 1
      .io_status = 0
      .file_status = "unknown"
      .action      = "readwrite"
      .buffered    = FALSE
      .dbl_buffer_pos = 1
      .int_buffer_pos = 1
      .cdbl_buffer_pos = 1
   end

   open(for,buffered,type) ::: leaky
   ! Open the file. The file object must already be created.
   ! If present, "for" indicated whether the file is "read_write", "read-only"
   ! or "write-only"
   ! If present, "buffered" indicated whether the file is to be buffered, and
   ! the "type" of the buffer must also be specified as "dbl" or "int"
     for :: STR(*), optional
     buffered :: BIN,    optional
     type :: STR(*), optional
     if (present(for)) then
        select case (for)
           case("readwrite ","read-write") ;              .action = "readwrite"
           case("read      ","reading   ","read-only ") ; .action = "read"
           case("write     ","writing   ","write-only") ; .action = "write"
           case default; UNKNOWN(for)
        end
     end
     .file_status = "new"
     if (.exists) .file_status = "old"
     open( unit   = .unit,         &
           file   = .name,         &
           status = .file_status,  &
           access = "sequential",  &
           form   = "unformatted", & ! <---------
           action = .action,       &
           iostat = .io_status)
     ENSURE(.io_status==0,"error opening "//trim(.file_status)//" file "//.name)
     if (present(buffered)) .buffered = buffered
     if (.buffered) then
        ENSURE(present(type),"type of buffer must be specified")
        ENSURE(.action/="readwrite","buffer must be either read-only or write-only")
        select case (type)
           case("dbl")
             .dbl_buffer.create(FILE_BUFFER_LENGTH)
             if (.action == "read") .get_dbl_buffer
           case("int")
             .int_buffer.create(FILE_BUFFER_LENGTH)
             if (.action == "read") .get_int_buffer
           case("cdbl")
             .cdbl_buffer.create(FILE_BUFFER_LENGTH)
             if (.action == "read") .get_cdbl_buffer
           case default
             DIE("unknown buffer type, "//trim(type))
        end
     end
   end

   close ::: leaky
   ! Close the file
      WARN_IF(NOT .is_open,"file is not open")
      if (.action=="write") then
        if (.dbl_buffer_pos > 1) .flush_dbl_buffer
        if (.int_buffer_pos > 1) .flush_int_buffer
        if (.cdbl_buffer_pos > 1) .flush_cdbl_buffer
      end
      .destroy_ptr_part
      close(unit=.unit)
   end

   close_and_delete ::: leaky
   ! Close the file and delete it from the file system
      WARN_IF(NOT .is_open,"file is not open")
      if (.action=="write") then
        if (.dbl_buffer_pos > 1) .flush_dbl_buffer
        if (.int_buffer_pos > 1) .flush_int_buffer
        if (.cdbl_buffer_pos > 1) .flush_cdbl_buffer
      end
      .destroy_ptr_part
      close(unit=.unit,status="delete")
   end

   delete
   ! Delete the file from the file system
      if (NOT .is_open) .open
      .close_and_delete
   end

!  **************************
!  Data input type operations
!  **************************

   read_str(value)
   ! Read a default str from the file into variable "value"
     value :: STR(*)
     read(unit=.unit,iostat=.io_status) value
     ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
     .record = .record + 1
   end

   read_int(value)
   ! Read an integer from the file into variable "value"
     value :: INT
     if (.buffered) then
       .read_buffered_int(value)
     else
       read(unit=.unit,iostat=.io_status) value
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_dbl(value)
   ! Read a dbl from the file into variable "value"
     value :: REAL
     if (.buffered) then
       .read_buffered_dbl(value)
     else
       read(unit=.unit,iostat=.io_status) value
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_cdbl(value)
   ! Read a complex dbl from the file into variable "value"
     value :: CPX
     if (.buffered) then
       .read_buffered_cdbl(value)
     else
       read(unit=.unit,iostat=.io_status) value
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_bin(value)
   ! Read a logical from the file into variable "value"
     value :: BIN
     read(unit=.unit,iostat=.io_status) value
     ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
     .record = .record + 1
   end

   read_vec(vec)
   ! Read a vector from the file into variable "vec"
     vec :: REALVEC
     if (.buffered) then
       .read_buffered_vec(vec)
     else
       read(unit=.unit,iostat=.io_status) vec
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_ivec(vec)
   ! Read a vector from the file into variable "vec"
     vec :: INTVEC
     if (.buffered) then
       .read_buffered_ivec(vec)
     else
       read(unit=.unit,iostat=.io_status) vec
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_cvec(vec)
   ! Read a vector from the file into variable "vec"
     vec :: CPXVEC
     if (.buffered) then
       .read_buffered_cvec(vec)
     else
       read(unit=.unit,iostat=.io_status) vec
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_mat(mat)
   ! Read a matrix from the file into variable "mat"
     mat :: REALMAT
     if (.buffered) then
       .read_buffered_mat(mat)
     else
       read(unit=.unit,iostat=.io_status) mat
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_imat(mat)
   ! Read an integer matrix from the file into variable "mat"
     mat :: INTMAT
     if (.buffered) then
       .read_buffered_imat(mat)
     else
       read(unit=.unit,iostat=.io_status) mat
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_cmat(mat)
   ! Read a complex matrix from the file into variable "mat"
     mat :: CPXMAT
     if (.buffered) then
       .read_buffered_cmat(mat)
     else
       read(unit=.unit,iostat=.io_status) mat
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_mat3(mat)
   ! Read a matrix from the file into variable "mat"
     mat :: REALMAT3
     if (.buffered) then
       .read_buffered_mat3(mat)
     else
       read(unit=.unit,iostat=.io_status) mat
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_cmat3(mat)
   ! Read a complex matrix from the file into variable "mat"
     mat :: CPXMAT3
     if (.buffered) then
       .read_buffered_cmat3(mat)
     else
       read(unit=.unit,iostat=.io_status) mat
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_mat4(mat)
   ! Read a matrix from the file into variable "mat"
     mat :: REALMAT4
     if (.buffered) then
       .read_buffered_mat4(mat)
     else
       read(unit=.unit,iostat=.io_status) mat
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_cmat4(mat)
   ! Read a complex matrix from the file into variable "mat"
     mat :: CPXMAT4
     if (.buffered) then
       .read_buffered_cmat4(mat)
     else
       read(unit=.unit,iostat=.io_status) mat
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

   read_cmat5(mat)
   ! Read a complex matrix from the file into variable "mat"
     mat :: CPXMAT5
     if (.buffered) then
       .read_buffered_cmat5(mat)
     else
       read(unit=.unit,iostat=.io_status) mat
       ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
       .record = .record + 1
     end
   end

!  ********************
!  Data output routines
!  ********************

   write_int(value)
   ! Write an integer to the file as a record
      value :: INT
      if (.buffered) then
         .write_buffered_int(value)
      else
         write(unit=.unit,iostat=.io_status) value
         ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
         .record = .record + 1
      end
   end

   write_dbl(value)
   ! Write a dbl to the file as a record
      value :: REAL
      if (.buffered) then
         .write_buffered_dbl(value)
      else
         write(unit=.unit,iostat=.io_status) value
         ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
         .record = .record + 1
      end
   end

   write_cdbl(value)
   ! Write a cdbl to the file as a record
      value :: CPX
      if (.buffered) then
         .write_buffered_cdbl(value)
      else
         write(unit=.unit,iostat=.io_status) value
         ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
         .record = .record + 1
      end
   end

   write_str(value)
   ! Write a str to the file as a record
      value :: STR(*)
      str1 :: STR(len(value))
      str1 = value
      write(unit=.unit,iostat=.io_status) str1
      ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
      .record = .record + 1
   end

   write_bin(value)
   ! Write a bin to the file as a record
      value :: BIN
      write(unit=.unit,iostat=.io_status) value
      ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
      .record = .record + 1
   end

   write_vec(vec)
   ! Write a vector to the file as a single record
      vec :: REALVEC
      if (.buffered) then
         .write_buffered_vec(vec)
      else
         write(unit=.unit,iostat=.io_status) vec
         ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
         .record = .record + 1
      end
   end

   write_ivec(vec)
   ! Write a vector to the file as a single record
      vec :: INTVEC, IN
      if (.buffered) then
         .write_buffered_ivec(vec)
      else
         write(unit=.unit,iostat=.io_status) vec
         ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
         .record = .record + 1
      end
   end

   write_cvec(vec)
   ! Write a vector to the file as a single record
      vec :: CPXVEC
      if (.buffered) then
         .write_buffered_cvec(vec)
      else
         write(unit=.unit,iostat=.io_status) vec
         ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
         .record = .record + 1
      end
   end

   write_imat(mat)
   ! Write a matrix to the file as a single record
      mat :: INTMAT
      if (.buffered) then
         .write_buffered_imat(mat)
      else
        write(unit=.unit,iostat=.io_status) mat
        ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
        .record = .record + 1
      end
   end

   write_mat(mat)
   ! Write a matrix to the file as a single record
      mat :: REALMAT
      if (.buffered) then
         .write_buffered_mat(mat)
      else
        write(unit=.unit,iostat=.io_status) mat
        ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
        .record = .record + 1
      end
   end

   write_mat3(mat)
   ! Write a matrix to the file as a single record
      mat :: REALMAT3
      if (.buffered) then
         .write_buffered_mat3(mat)
      else
         write(unit=.unit,iostat=.io_status) mat
         ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
         .record = .record + 1
      end
   end

   write_mat4(mat)
   ! Write a matrix to the file as a single record
      mat :: REALMAT4
      if (.buffered) then
         .write_buffered_mat4(mat)
      else
         write(unit=.unit,iostat=.io_status) mat
         ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
         .record = .record + 1
      end
   end

   write_cmat(mat)
   ! Write a complex matrix to the file as a single record
      mat :: CPXMAT
      if (.buffered) then
         .write_buffered_cmat(mat)
      else
        write(unit=.unit,iostat=.io_status) mat
        ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
        .record = .record + 1
      end
   end

   write_cmat3(mat)
   ! Write a complex 3d matrix to the file as a single record
      mat :: CPXMAT3
      if (.buffered) then
         .write_buffered_cmat3(mat)
      else
         write(unit=.unit,iostat=.io_status) mat
         ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
         .record = .record + 1
      end
   end

   write_cmat4(mat)
   ! Write a complex 4d matrix to the file as a single record
      mat :: CPXMAT4
      if (.buffered) then
         .write_buffered_cmat4(mat)
      else
         write(unit=.unit,iostat=.io_status) mat
         ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
         .record = .record + 1
      end
   end

   write_cmat5(mat)
   ! Write a complex 5d matrix to the file as a single record
      mat :: CPXMAT5
      if (.buffered) then
         .write_buffered_cmat5(mat)
      else
         write(unit=.unit,iostat=.io_status) mat
         ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
         .record = .record + 1
      end
   end

!  **********************************
!  File repositioning type operations
!  **********************************

   rewind
   ! Rewind the file
      rewind(unit=.unit,iostat=.io_status)
      ENSURE(.io_status==0,"rewind error, error="// trim(.io_status.to_str))
      .record = 1
   end

   backspace
   ! Backspace the file one record of the file. Backspacing before record 1 has
   ! no effect.
      backspace(unit=.unit,iostat=.io_status)
      ENSURE(.io_status==0,"backspace error, error="// trim(.io_status.to_str))
      .record = max(1,.record-1)
   end

   skip
   ! Skip over the next record of the file. An error is generated if at the end
   ! of the file
      read(unit=.unit,iostat=.io_status)
      ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
      .record = .record + 1
   end

   move_to_end
   ! Move to the end of the file, say for adding more data
      do
         read(unit=.unit,iostat=.io_status)
         if (.io_status/=0) exit
         .record = .record + 1
      end
   end

   move_to_position(pos)
   ! Move to a particular record position in the file
      pos :: INT
      .move_to_record(pos)
   end

   move_to_record(rec)
   ! Move to a particular record position in the file
      rec :: INT
      ENSURE(rec>=1,"can't move to non-positive record")
      if (rec<.position) then
         do
            .backspace
            if (.position==rec) exit
         end
      else if (rec>.position) then
         do
            .skip
            if (.position==rec) exit
         end
      end
   end

!  ***************
!  Inquiry methods
!  ***************

   exists(name) result(res)
   ! Returns true if the file exists on the file system.  If present, "name" is
   ! used, otherwise .name is used.
      res :: BIN
      name :: STR(*), IN, optional
      if (present(name)) then
        inquire(file=name,exist=res)
      else
        inquire(file=.name,exist=res)
      end
   end

   is_open result(res)
   ! Returns true if the file has been opened
      res :: BIN
      ! inquire(unit=.unit,opened=res)
      inquire(file=.name,opened=res)
   end

   unit_used result(res)
   ! Returns true if the file unit is in use
      res :: BIN
      inquire(unit=.unit,opened=res)
   end

!   created result(res)
!   ! Returns true if the file object has been created
!      self :: PTR
!      res :: BIN
!      res = associated(self)
!   end

!   destroyed result(res)
!   ! Returns true if the file object has *not* been created
!      self :: PTR
!      res :: BIN
!      res = NOT associated(self)
!   end

   position result(res)
   ! Return record position of the file
      res :: INT
      res = .record
   end

   is_for_reading result(res)
   ! Return whether the file is opened for reading.
     res :: BIN
     reading :: STR(5)
     inquire(unit=.unit,read=reading)
     if (trim(reading) == "YES") then
       res = TRUE
     else
       res = FALSE
     end
   end

!   is_dbl_buffered result(res)
!   ! Returns true if the file is using REAL buffering
!      res :: BIN
!      res = associated(.dbl_buffer)
!   end

!   is_int_buffered result(res)
!   ! Returns true if the file is using INT buffering
!      res :: BIN
!      res = associated(.int_buffer)
!   end

!***************************************************
! Buffered routines
!***************************************************

   flush_dbl_buffer
   ! Writes the dbl_buffer to disk, and positions the pointer at the start of
   ! the buffer.
     write(unit=.unit,iostat=.io_status) .dbl_buffer
     ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
     .record = .record + 1
     .dbl_buffer_pos = 1
   end

   flush_int_buffer
   ! Writes the int_buffer to disk, and positions the pointer at the start of
   ! the buffer.
     write(unit=.unit,iostat=.io_status) .int_buffer
     ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
     .record = .record + 1
     .int_buffer_pos = 1
   end

   flush_cdbl_buffer
   ! Writes the cdbl_buffer to disk, and positions the pointer at the start of
   ! the buffer.
     write(unit=.unit,iostat=.io_status) .cdbl_buffer
     ENSURE(.io_status==0,"write error, error="// trim(.io_status.to_str))
     .record = .record + 1
     .cdbl_buffer_pos = 1
   end

   get_dbl_buffer
   ! Reads the dbl_buffer from disk, and positions the pointer at the start of
   ! the buffer.
     read(unit=.unit,iostat=.io_status) .dbl_buffer
     ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
     .record = .record + 1
     .dbl_buffer_pos = 1
   end

   get_int_buffer
   ! Reads the int_buffer from disk, and positions the pointer at the start of
   ! the buffer.
     ENSURE( .int_buffer.created, "buffer not created")
     read(unit=.unit,iostat=.io_status) .int_buffer
     ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
     .record = .record + 1
     .int_buffer_pos = 1
   end

   get_cdbl_buffer
   ! Reads the cdbl_buffer from disk, and positions the pointer at the start of
   ! the buffer.
     ENSURE( .cdbl_buffer.created, "buffer not created")
     read(unit=.unit,iostat=.io_status) .cdbl_buffer
     ENSURE(.io_status==0,"read error, error="// trim(.io_status.to_str))
     .record = .record + 1
     .cdbl_buffer_pos = 1
   end

   write_buffered_dbl(the_dbl)
   ! Writes "the_dbl" to the buffer, and writes buffer to disk when full.
     the_dbl :: REAL, IN
     ENSURE( .dbl_buffer.created, "buffer not created")
     .dbl_buffer( .dbl_buffer_pos ) = the_dbl
     .dbl_buffer_pos = .dbl_buffer_pos + 1
     if ( .dbl_buffer_pos > FILE_BUFFER_LENGTH) .flush_dbl_buffer
   end

   read_buffered_dbl(the_dbl)
   ! Reads "the_dbl" from the buffer, and reads buffer from disk when empty.
     the_dbl :: REAL, OUT
     if ( .dbl_buffer_pos > FILE_BUFFER_LENGTH) .get_dbl_buffer
     the_dbl = .dbl_buffer( .dbl_buffer_pos )
     .dbl_buffer_pos = .dbl_buffer_pos + 1
   end

   write_buffered_int(the_int)
   ! Writes "the_int" to the buffer, and writes buffer to disk when full.
     the_int :: INT, IN
     .int_buffer( .int_buffer_pos ) = the_int
     .int_buffer_pos = .int_buffer_pos + 1
     if ( .int_buffer_pos > FILE_BUFFER_LENGTH) .flush_int_buffer
   end

   read_buffered_int(the_int)
   ! Reads the integer from the buffer, and reads buffer from disk when empty.
     the_int :: INT, OUT
     if ( .int_buffer_pos > FILE_BUFFER_LENGTH) .get_int_buffer
     the_int = .int_buffer( .int_buffer_pos )
     .int_buffer_pos = .int_buffer_pos + 1
   end

   write_buffered_cdbl(the_cdbl)
   ! Writes "the_cdbl" to the buffer, and writes buffer to disk when full.
     the_cdbl :: CPX, IN
     ENSURE( .cdbl_buffer.created, "buffer not created")
     .cdbl_buffer( .cdbl_buffer_pos ) = the_cdbl
     .cdbl_buffer_pos = .cdbl_buffer_pos + 1
     if ( .cdbl_buffer_pos > FILE_BUFFER_LENGTH) .flush_cdbl_buffer
   end

   read_buffered_cdbl(the_cdbl)
   ! Reads "the_cdbl" from the buffer, and reads buffer from disk when empty.
     the_cdbl :: CPX, OUT
     if ( .cdbl_buffer_pos > FILE_BUFFER_LENGTH) .get_cdbl_buffer
     the_cdbl = .cdbl_buffer( .cdbl_buffer_pos )
     .cdbl_buffer_pos = .cdbl_buffer_pos + 1
   end

   write_buffered_vec(the_vec)
   ! Writes the vector to the buffer, and writes buffer to disk when full.
     the_vec :: REALVEC, IN
     vec_length,vec_pos,buffer_top,vec_top,put_length :: INT
     vec_length = size(the_vec)
     vec_pos=1
     do
       put_length=min(FILE_BUFFER_LENGTH - .dbl_buffer_pos + 1,vec_length-vec_pos+1)
       buffer_top = .dbl_buffer_pos + put_length - 1
       vec_top = vec_pos + put_length - 1
       .dbl_buffer( .dbl_buffer_pos:buffer_top) = the_vec(vec_pos:vec_top)
       .dbl_buffer_pos = buffer_top + 1
       vec_pos = vec_top + 1
       if ( .dbl_buffer_pos > FILE_BUFFER_LENGTH) .flush_dbl_buffer
       if (vec_pos > vec_length) exit
     end
   end

   read_buffered_vec(the_vec)
   ! Reads the vector from the buffer, and reads buffer from disk when empty.
     the_vec :: REALVEC, OUT
     vec_length,vec_pos,buffer_top,vec_top,get_length :: INT
     vec_length = size(the_vec)
     vec_pos=1
     do
       if ( .dbl_buffer_pos > FILE_BUFFER_LENGTH) .get_dbl_buffer
       get_length=min(FILE_BUFFER_LENGTH - .dbl_buffer_pos + 1,vec_length-vec_pos+1)
       buffer_top = .dbl_buffer_pos + get_length - 1
       vec_top = vec_pos + get_length - 1
       the_vec(vec_pos:vec_top) = .dbl_buffer( .dbl_buffer_pos:buffer_top)
       .dbl_buffer_pos = buffer_top + 1
       vec_pos = vec_top + 1
       if (vec_pos > vec_length) exit
     end
   end

   write_buffered_ivec(the_ivec)
   ! Writes the ivector to the buffer, and writes buffer to disk when full.
     the_ivec :: INTVEC, IN
     ivec_length,ivec_pos,buffer_top,ivec_top,put_length :: INT
     ivec_length = size(the_ivec)
     ivec_pos=1
     do
       put_length=min(FILE_BUFFER_LENGTH - .int_buffer_pos + 1,ivec_length-ivec_pos+1)
       buffer_top = .int_buffer_pos + put_length - 1
       ivec_top = ivec_pos + put_length - 1
       .int_buffer( .int_buffer_pos:buffer_top) = the_ivec(ivec_pos:ivec_top)
       .int_buffer_pos = buffer_top + 1
       ivec_pos = ivec_top + 1
       if ( .int_buffer_pos > FILE_BUFFER_LENGTH) .flush_int_buffer
       if (ivec_pos > ivec_length) exit
     end
   end

   read_buffered_ivec(the_ivec)
   ! Reads the ivector from the buffer, and reads buffer from disk when empty.
     the_ivec :: INTVEC, OUT
     ivec_length,ivec_pos,buffer_top,ivec_top,get_length :: INT
     ivec_length = size(the_ivec)
     ivec_pos=1
     do
       if ( .int_buffer_pos > FILE_BUFFER_LENGTH) .get_int_buffer
       get_length=min(FILE_BUFFER_LENGTH - .int_buffer_pos + 1,ivec_length-ivec_pos+1)
       buffer_top = .int_buffer_pos + get_length - 1
       ivec_top = ivec_pos + get_length - 1
       the_ivec(ivec_pos:ivec_top) = .int_buffer( .int_buffer_pos:buffer_top)
       .int_buffer_pos = buffer_top + 1
       ivec_pos = ivec_top + 1
       if (ivec_pos > ivec_length) exit
     end
   end

   write_buffered_cvec(the_cvec)
   ! Writes the cvector to the buffer, and writes buffer to disk when full.
     the_cvec :: CPXVEC, IN
     cvec_length,cvec_pos,buffer_top,cvec_top,put_length :: INT
     cvec_length = size(the_cvec)
     cvec_pos=1
     do
       put_length=min(FILE_BUFFER_LENGTH - .cdbl_buffer_pos + 1,cvec_length-cvec_pos+1)
       buffer_top = .cdbl_buffer_pos + put_length - 1
       cvec_top = cvec_pos + put_length - 1
       .cdbl_buffer( .cdbl_buffer_pos:buffer_top) = the_cvec(cvec_pos:cvec_top)
       .cdbl_buffer_pos = buffer_top + 1
       cvec_pos = cvec_top + 1
       if ( .cdbl_buffer_pos > FILE_BUFFER_LENGTH) .flush_cdbl_buffer
       if (cvec_pos > cvec_length) exit
     end
   end

   read_buffered_cvec(the_cvec)
   ! Reads the cvector from the buffer, and reads buffer from disk when empty.
     the_cvec :: CPXVEC, OUT
     cvec_length,cvec_pos,buffer_top,cvec_top,get_length :: INT
     cvec_length = size(the_cvec)
     cvec_pos=1
     do
       if ( .cdbl_buffer_pos > FILE_BUFFER_LENGTH) .get_cdbl_buffer
       get_length=min(FILE_BUFFER_LENGTH - .cdbl_buffer_pos + 1,cvec_length-cvec_pos+1)
       buffer_top = .cdbl_buffer_pos + get_length - 1
       cvec_top = cvec_pos + get_length - 1
       the_cvec(cvec_pos:cvec_top) = .cdbl_buffer( .cdbl_buffer_pos:buffer_top)
       .cdbl_buffer_pos = buffer_top + 1
       cvec_pos = cvec_top + 1
       if (cvec_pos > cvec_length) exit
     end
   end

   write_buffered_mat(mat)
   ! Writes the mat to the buffer, and writes buffer to disk when full.
     mat :: REALMAT, IN
     b,bsize :: INT
     bsize=size(mat,2)
     do b=1,bsize
       .write_buffered_vec(mat(:,b))
     end
   end

   read_buffered_mat(mat)
   ! Reads the mat from the buffer.
     mat :: REALMAT, OUT
     b,bsize :: INT
     bsize=size(mat,2)
     do b=1,bsize
       .read_buffered_vec(mat(:,b))
     end
   end

   write_buffered_imat(mat)
   ! Writes the imat to the buffer, and writes buffer to disk when full.
     mat :: INTMAT, IN
     a,b,asize,bsize :: INT
     asize=size(mat,1);    bsize=size(mat,2)
     do a=1,asize
       do b=1,bsize
         .write_buffered_int(mat(a,b))
       end
     end
   end

   read_buffered_imat(mat)
   ! Reads the imat from the buffer.
     mat :: INTMAT, OUT
     a,b,asize,bsize :: INT
     asize=size(mat,1);    bsize=size(mat,2)
     do a=1,asize
       do b=1,bsize
         .read_buffered_int(mat(a,b))
       end
     end
   end

   write_buffered_cmat(mat)
   ! Writes the cmat to the buffer, and writes buffer to disk when full.
     mat :: CPXMAT, IN
     b,bsize :: INT
     bsize=size(mat,2)
     do b=1,bsize
       .write_buffered_cvec(mat(:,b))
     end
   end

   read_buffered_cmat(mat)
   ! Reads the cmat from the buffer.
     mat :: CPXMAT, OUT
     b,bsize :: INT
     bsize=size(mat,2)
     do b=1,bsize
       .read_buffered_cvec(mat(:,b))
     end
   end

   write_buffered_mat3(mat)
   ! Writes the mat3 to the buffer, and writes buffer to disk when full.
     mat :: REALMAT3, IN
     b,c,bsize,csize :: INT
     bsize=size(mat,2);     csize=size(mat,3)
     do c=1,csize
       do b=1,bsize
         .write_buffered_vec(mat(:,b,c))
       end
     end
   end

   read_buffered_mat3(mat)
   ! Reads the mat3 from the buffer.
     mat :: REALMAT3, OUT
     b,c,bsize,csize :: INT
     bsize=size(mat,2);     csize=size(mat,3)
     do c=1,csize
       do b=1,bsize
         .read_buffered_vec(mat(:,b,c))
       end
     end
   end

   write_buffered_cmat3(mat)
   ! Writes the cmat3 to the buffer, and writes buffer to disk when full.
     mat :: CPXMAT3, IN
     b,c,bsize,csize :: INT
     bsize=size(mat,2);    csize=size(mat,3)
     do c=1,csize
       do b=1,bsize
         .write_buffered_cvec(mat(:,b,c))
       end
     end
   end

   read_buffered_cmat3(mat)
   ! Reads the cmat3 from the buffer.
     mat :: CPXMAT3, OUT
     b,c,bsize,csize :: INT
     bsize=size(mat,2);     csize=size(mat,3)
     do c=1,csize
       do b=1,bsize
         .read_buffered_cvec(mat(:,b,c))
       end
     end
   end

   write_buffered_mat4(mat)
   ! Writes the mat4 to the buffer, and writes buffer to disk when full.
     mat :: REALMAT4, IN
     b,c,d,bsize,csize,dsize :: INT
     bsize=size(mat,2);     csize=size(mat,3);    dsize=size(mat,4)
     do d=1,dsize
       do c=1,csize
         do b=1,bsize
           .write_buffered_vec(mat(:,b,c,d))
         end
       end
     end
   end

   read_buffered_mat4(mat)
   ! Reads the mat4 from the buffer.
     mat :: REALMAT4, OUT
     b,c,d,bsize,csize,dsize :: INT
     bsize=size(mat,2);     csize=size(mat,3);    dsize=size(mat,4)
     do d=1,dsize
       do c=1,csize
         do b=1,bsize
           .read_buffered_vec(mat(:,b,c,d))
         end
       end
     end
   end

   write_buffered_cmat4(mat)
   ! Writes the mat4 to the buffer, and writes buffer to disk when full.
     mat :: CPXMAT4, IN
     a,b,c,d,asize,bsize,csize,dsize :: INT
     asize=size(mat,1);    bsize=size(mat,2)
     csize=size(mat,3);    dsize=size(mat,4)
     do a=1,asize
       do b=1,bsize
         do c=1,csize
           do d=1,dsize
             .write_buffered_cdbl(mat(a,b,c,d))
           end
         end
       end
     end
   end

   read_buffered_cmat4(mat)
   ! Reads the mat4 from the buffer.
     mat :: CPXMAT4, OUT
     a,b,c,d,asize,bsize,csize,dsize :: INT
     asize=size(mat,1);    bsize=size(mat,2)
     csize=size(mat,3);    dsize=size(mat,4)
     do a=1,asize
       do b=1,bsize
         do c=1,csize
           do d=1,dsize
             .read_buffered_cdbl(mat(a,b,c,d))
           end
         end
       end
     end
   end

   write_buffered_cmat5(mat)
   ! Writes the mat5 to the buffer, and writes buffer to disk when full.
     mat :: CPXMAT5, IN
     a,b,c,d,e,asize,bsize,csize,dsize,esize :: INT
     asize=size(mat,1);    bsize=size(mat,2)
     csize=size(mat,3);    dsize=size(mat,4)
     esize=size(mat,5)
     do a=1,asize
       do b=1,bsize
         do c=1,csize
           do d=1,dsize
             do e=1,esize
               .write_buffered_cdbl(mat(a,b,c,d,e))
             end
           end
         end
       end
     end
   end

   read_buffered_cmat5(mat)
   ! Reads the mat5 from the buffer.
     mat :: CPXMAT5, OUT
     a,b,c,d,e,asize,bsize,csize,dsize,esize :: INT
     asize=size(mat,1);    bsize=size(mat,2)
     csize=size(mat,3);    dsize=size(mat,4)
     esize=size(mat,5)
     do a=1,asize
       do b=1,bsize
         do c=1,csize
           do d=1,dsize
             do e=1,esize
               .read_buffered_cdbl(mat(a,b,c,d,e))
             end
           end
         end
       end
     end
   end

end
