!-------------------------------------------------------------------------------
!
! GEMINAL_MF_SCHEME
!
! Copyright (C) Patrick Cassam-Chenai 2006
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: geminal_mf_spectrum.foo,v 1.15 2004/03/24 04:55:46 cassam Exp $
!
!-------------------------------------------------------------------------------

module GEMINAL_MF_SCHEME

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!*******************************************************************************
!                             Create and Destroy Routines
!*******************************************************************************

   create ::: leaky
   ! Create a contraction-truncation scheme 
      self :: PTR
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
   end

   create(name,nuc,n_geminals,n_bf,use_brillouin,orthogonality_type,guess_type,print_hamiltonian,convergence,n_step) ::: leaky
   ! Create the contraction-truncation scheme 
      self :: PTR
      name :: STR
      orthogonality_type :: STR
      guess_type :: STR
      nuc :: REAL
      n_geminals,n_bf :: INT
      convergence :: REAL
      use_brillouin,print_hamiltonian :: BIN
      n_step :: INT
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
      .set_defaults(n_geminals,n_bf,name,nuc,use_brillouin,orthogonality_type,guess_type,print_hamiltonian,convergence,n_step)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self  
     nullify(.spectrum)
     nullify(.ld_tol_scheme)
     nullify(.ig_tol_scheme)
     nullify(.tolerance_scheme)
     nullify(.do_triplet_energies)
     nullify(.do_electric_dipole)
     nullify(.truncation_scheme)
   end

   destroy_ptr_part  ::: leaky
   ! Destroy the pointer parts of self
     .spectrum.destroy
     .ld_tol_scheme.destroy
     .ig_tol_scheme.destroy
     .tolerance_scheme.destroy
     .do_triplet_energies.destroy
     .do_electric_dipole.destroy
     .truncation_scheme.destroy
   end

   create_copy(b) ::: leaky
   ! Create a copy of "b".
   ! Warning make_integrals, readin_mos, add_core, readin_scheme
   ! are not copied, they will be set to their default that is FALSE
     b :: GEMINAL_MF_SCHEME, IN
     n_step :: INT
     self :: PTR
     n_step=b.max_iterations
     .create(b.spectrum.name,b.spectrum.nuclear_energy,b.spectrum.n_geminals, &
     b.spectrum.n_bf,b.use_brillouin,b.orthogonality_type,b.guess_type, & 
     b.print_hamiltonian, b.convergence_threshold,n_step)
     .copy(b)
   end

   copy(b) ::: leaky
   ! Copy a GEMINAL_MF_SCHEME "b" to "self". Make sure pointer parts are first
   ! destroyed or nullified, as you want.
      b :: GEMINAL_MF_SCHEME, IN
      self = b
      if (b.spectrum.created) .spectrum.create_copy(b.spectrum)
      if (b.ld_tol_scheme.created) .ld_tol_scheme.create_copy(b.ld_tol_scheme)
      if (b.ig_tol_scheme.created) .ig_tol_scheme.create_copy(b.ig_tol_scheme)
      if (b.tolerance_scheme.created) .tolerance_scheme.create_copy(b.tolerance_scheme)
      if (b.truncation_scheme.created) .truncation_scheme.create_copy(b.truncation_scheme)
      if (b.do_triplet_energies.created) .do_triplet_energies.create_copy(b.do_triplet_energies)
      if (b.do_electric_dipole.created) .do_electric_dipole.create_copy(b.do_electric_dipole)
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

   set_defaults(n_geminals,n_bf,name,nuclear_energy,use_brillouin,orthogonality_type,guess_type,print_hamiltonian,convergence,max_it,make_integrals,readin_mos,add_core,make_singlet_extremals,readin_scheme) ::: leaky
   !set_defaults(n_geminals,n_bf,name,nuclear_energy,use_brillouin,orthogonality_type,print_hamiltonian,convergence,max_it,make_integrals,readin_mos,readin_gems,readin_scheme) ::: leaky
   ! Create a default object.
     n_geminals,n_bf :: INT
     name :: STR
     nuclear_energy :: REAL
     orthogonality_type :: STR, optional
     guess_type :: STR, optional
     use_brillouin,print_hamiltonian :: BIN, optional
     convergence :: REAL, optional
     max_it :: INT, optional
     readin_mos,make_integrals :: BIN, optional
     !readin_gems :: BIN, optional
     add_core :: BIN, optional
     make_singlet_extremals :: BIN, optional
     readin_scheme :: BIN, optional
     n_step :: INT
     .use_brillouin = FALSE
     if (present(use_brillouin)) .use_brillouin = use_brillouin
     .orthogonality_type = 'no_orthogonality'
     if (present(orthogonality_type)) .orthogonality_type = orthogonality_type
     .guess_type = 'hf'
     if (present(guess_type)) .guess_type = guess_type
     .print_hamiltonian = FALSE
     if (present(print_hamiltonian)) .print_hamiltonian = print_hamiltonian
     .convergence_threshold = TOL(10)
     if (present(convergence)) then
     if (convergence>.convergence_threshold) .convergence_threshold=convergence
     end
     .n_iterations=0
     .max_iterations=1001
     if (present(max_it)) .max_iterations = max_it
     n_step=.max_iterations-1
     .make_integrals = TRUE
     if (present(make_integrals)) .make_integrals = make_integrals
     .readin_mos = FALSE
     if (present(readin_mos)) .readin_mos = readin_mos
     .add_core = TRUE
     if (present(add_core)) .add_core= add_core
     .make_singlet_extremals = FALSE
     if (present(make_singlet_extremals)) .make_singlet_extremals= make_singlet_extremals
     .readin_scheme = FALSE
     if (present(readin_scheme)) .readin_scheme = readin_scheme
     .starting_group=0
     .n_orbitals=n_bf
     .spectrum.create(name,nuclear_energy,n_geminals,1,n_bf)
     .ld_tol_scheme.create(1,n_step)
     .ld_tol_scheme = LINEAR_DEPENDENCE_TOL
     .ig_tol_scheme.create(1,n_step)
     .ig_tol_scheme = INTERNAL_GEMINAL_TOL
     .tolerance_scheme.create(0,n_step)
     .tolerance_scheme  = 10
     .truncation_scheme.create(0,n_step)
     .truncation_scheme  = 0.0d0
     .do_triplet_energies.create(0,n_step)
     .do_triplet_energies = FALSE
     .do_electric_dipole.create(0,n_step)
     .do_electric_dipole = FALSE
   end

!  ************
!  I/O Routines
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
       case ("convergence_tolerance=  "); .read_convergence_tolerance
       case ("do_gmf_auto             "); .do_gmf_auto
       case ("do_triplet_energies=    "); .read_do_triplet_energies
       case ("do_electric_dipole=       "); .read_do_electric_dipole
       case ("ld_tol=                 "); .read_ld_tol
       case ("ig_tol=                 "); .read_ig_tol
       case ("tolerance=              "); .read_tolerance
       case ("truncation=             "); .read_truncation
     ! case ("do_gmf                  "); .do_gmf
     ! case ("restart_gmf             "); .restart_gmf
     ! case ("do_spectrum             "); .do_spectrum
     ! case ("do_restart              "); .do_restart
       case ("guess_type=             "); .read_guess_type
       case ("junk=                   "); .read_junk
       case ("make_integrals=         "); .read_make_integrals
       case ("make_singlet_extremals= "); .read_make_singlet_extremals
       case ("max_iterations=         "); .read_max_iterations
       case ("n_orbitals=             "); .read_n_orbitals
       case ("orthogonality_type=     "); .read_orthogonality_type
       case ("put                     "); .put
       case ("print_hamiltonian=      "); .read_print_hamiltonian
     !  case ("readin_gems=            "); .read_readin_gems
       case ("add_core=               "); .read_add_core
       case ("readin_mos=             "); .read_readin_mos
       case ("readin_scheme=          "); .read_readin_scheme
       case ("restart_gmf_auto        "); .restart_gmf_auto
       case ("starting_group=         "); .read_starting_group
       case ("units=                  "); .read_units
       case ("use_brillouin=          "); .read_use_brillouin
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_orthogonality_type
   ! Read  orthogonality type 
     stdin.read(.orthogonality_type)
     .orthogonality_type.to_lower_case
     select case (.orthogonality_type)
       case ("no_orthogonality    ")
       case ("one_orthogonality   ")
         DIE("one_orthogonality not yet implemented")
       case ("sp_two_orthogonality")
         stdout.text(" ")
         stdout.text("WARNING, two-orthogonality is used to reduce the size of the geminal basis set")
         stdout.text("but it is not yet taken advantage of to simplify matrix element calculations")
         stdout.text(" ")
       case ("sf_two_orthogonality")
         stdout.text(" ")
         stdout.text("WARNING, two-orthogonality is used to reduce the size of the geminal basis set")
         stdout.text("but it is not yet taken advantage of to simplify matrix element calculations")
         stdout.text(" ")
       case default
         DIE("unknown orthogonality option: "//trim(.orthogonality_type))
      end 
   end

   read_use_brillouin
   ! Read  use_brillouin flag
     stdin.read(.use_brillouin)
   end

   read_make_integrals
   ! Read  make_integrals flag
     stdin.read(.make_integrals)
   end

   read_guess_type
   ! Read  guess geminals type
     stdin.read(.guess_type)
     .guess_type.to_lower_case
     select case (.guess_type)
       case ("hf")
         stdout.text(" ")
         stdout.text("guess geminals will be singlet coupled canonical HF orbitals")
         stdout.text(" ")
       case ("agp")
         stdout.text(" ")
         stdout.text("guess geminals will be AGP from canonical HF orbitals")
         stdout.text(" ")
       case ("random")
         stdout.text(" ")
         stdout.text("guess geminals will be random")
         stdout.text(" ")
       case ("readin")
       !  .readin_gems= TRUE
         stdout.text(" ")
         stdout.text("guess geminals will be read in")
         stdout.text(" ")
       case default
         DIE("unknown guess option: "//trim(.guess_type))
     end 
   end

   read_add_core
   ! Read  add_core flag
     stdin.read(.add_core)
   end

   read_make_singlet_extremals
   ! Read  make_singlet_extremals flag
     stdin.read(.make_singlet_extremals)
   end

!pcc   read_readin_gems
!pcc   ! Read  readin_gems flag
!pcc     stdin.read(.readin_gems)
!pcc   end

   read_readin_mos
   ! Read  readin_mos flag
     stdin.read(.readin_mos)
   end

   read_readin_scheme
   ! Read  readin_scheme flag
     stdin.read(.readin_scheme)
   end

   read_scheme
   ! Read  readin_scheme 
     in :: TEXTFILE*
     i_step, n_step :: INT
     in.create("readin_scheme")
     in.open(for="read")
!steps from 0 to nstep
     in.read(.tolerance_scheme(0))
     if(.tolerance_scheme(0)<=ZERO) .tolerance_scheme(0)=10
     in.read(.do_triplet_energies(0))
     in.read(.do_electric_dipole(0))
     in.read(.truncation_scheme(0))
     n_step=.max_iterations-1
     do i_step=1,n_step
       in.read(.ld_tol_scheme(i_step))
       if(.ld_tol_scheme(i_step)<=ZERO) .ld_tol_scheme(i_step)=LINEAR_DEPENDENCE_TOL
       in.read(.ig_tol_scheme(i_step))
       if(.ig_tol_scheme(i_step)<=ZERO) .ig_tol_scheme(i_step)=INTERNAL_GEMINAL_TOL
       in.read(.tolerance_scheme(i_step))
       if(.tolerance_scheme(i_step)<=ZERO) .tolerance_scheme(i_step)=10
       in.read(.do_triplet_energies(i_step))
       in.read(.do_electric_dipole(i_step))
       in.read(.truncation_scheme(i_step))
     end
     in.close  
     in.destroy
   end

   read_n_orbitals
   ! Read a reduced number of molecular orbitals with respect to the
   ! size of the atomic orbitals 
     b :: GEMINAL_MF_SPECTRUM*
     stdin.read(.n_orbitals)
     DIE_IF(.n_orbitals>.spectrum.n_bf OR .n_orbitals<0,'invalid orbital number')
     b.create_copy(.spectrum)
     .spectrum.destroy
     .spectrum.create(b.name,b.nuclear_energy,b.n_geminals,b.i_geminals,.n_orbitals)
   end

   read_starting_group
   ! Read the number of the starting active group
     stdin.read(.starting_group)
   end

   read_max_iterations
   ! Read  maximum allowed iterations and resize vectors of self dependent
   ! upon it
     n_step :: INT
     tolerance :: INT
     ld_tol :: REAL
     ig_tol :: REAL
     truncation :: REAL
     do_triplet_energies :: BIN
     do_electric_dipole :: BIN
     stdin.read(.max_iterations)
     n_step=.max_iterations-1
     if(n_step>0) then
       ld_tol=.ld_tol_scheme(1)
       .ld_tol_scheme.resize(n_step)
       .ld_tol_scheme = ld_tol
       ig_tol=.ig_tol_scheme(1)
       .ig_tol_scheme.resize(n_step)
       .ig_tol_scheme = ig_tol
     else
       ld_tol=.ld_tol_scheme(1)
       .ld_tol_scheme.resize(1)
       .ld_tol_scheme = ld_tol
       ig_tol=.ig_tol_scheme(1)
       .ig_tol_scheme.resize(1)
       .ig_tol_scheme = ig_tol
     end
     tolerance=.tolerance_scheme(0)
     .tolerance_scheme.destroy
     truncation=.truncation_scheme(0)
     .truncation_scheme.destroy
     do_triplet_energies=.do_triplet_energies(0)
     .do_triplet_energies.destroy
     do_electric_dipole=.do_electric_dipole(0)
     .do_electric_dipole.destroy
     .tolerance_scheme.create(0,n_step)
     .tolerance_scheme  = tolerance
     .truncation_scheme.create(0,n_step)
     .truncation_scheme  = truncation
     .do_triplet_energies.create(0,n_step)
     .do_triplet_energies = do_triplet_energies
     .do_electric_dipole.create(0,n_step)
     .do_electric_dipole = do_electric_dipole
   end

     read_do_triplet_energies
     ! Read do_triplet_energies global flag
       do_triplet_energies :: BIN
       stdin.read(do_triplet_energies)
       .do_triplet_energies=do_triplet_energies
     end

     read_do_electric_dipole
     ! Read do_electric_dipole global flag
       do_electric_dipole :: BIN
       stdin.read(do_electric_dipole)
       .do_electric_dipole=do_electric_dipole
     end

     read_ld_tol
     ! Read  ld_tol_scheme global flag
       ld_tol :: REAL
       stdin.read(ld_tol)
       .ld_tol_scheme =ld_tol
     end

     read_ig_tol
     ! Read  ig_tol_scheme global flag
       ig_tol :: REAL
       stdin.read(ig_tol)
       .ig_tol_scheme =ig_tol
     end

     read_truncation
     ! Read  truncation_scheme global flag
       truncation :: REAL
       stdin.read(truncation)
       .truncation_scheme =truncation
     end

     read_tolerance
     ! Read  tolerance_scheme global flag
       tolerance :: INT
       stdin.read(tolerance)
       .tolerance_scheme =tolerance
     end

   read_convergence_tolerance
   ! Read  convergence tolerance
      stdin.read(.convergence_threshold)
   end

   read_print_hamiltonian
   ! Read  print_hamiltonian flag
      stdin.read(.print_hamiltonian)
   end

   read_units ::: get_from(OBJECT)
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT)
   ! Read in a junk string, useful for ignoring a field
   end

   get_n_iterations
   ! get number of GMFCI already performed in previous jobs from an archive file
     n_iterations_archive :: ARCHIVE
     name :: STR
     
     name="n_iterations"
     n_iterations_archive.set(.spectrum.name,name)
     n_iterations_archive.read(.n_iterations)
   end

   get_old_tolerance(old_tolerance)
   ! get old cutoff thresholds from an archive file
     old_tolerance :: VEC{INT}
     old_tolerance_archive :: ARCHIVE
     name :: STR
     
     name="old_tolerance"
     old_tolerance_archive.set(.spectrum.name,name)
     old_tolerance_archive.read(old_tolerance)
   end

   get_gs_energies(gs_energies)
   ! get ground state energies from an archive file
     gs_energies :: VEC{REAL}
     gs_energies_archive :: ARCHIVE
     name :: STR
     
     name="gs_energies"
     gs_energies_archive.set(.spectrum.name,name)
     gs_energies_archive.read(gs_energies)
   end

!  ********************
!  Key related routines
!  ********************

   read_keys ::: get_from(OBJECT)
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
      res :: BIN
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT)
   ! This is for destroying the "keys" externally.
   end

   put_table_footer ::: get_from(OBJECT)
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   end

   put_table_header
   ! Output a table header from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   ENSURE(keys.created,"no keys")
     word :: STR
     width,k :: INT
     width = .table_width
     if (width > 0) then
       stdout.dash(width=width)
       do k = 1,size(keys)
         word = keys(k)
         word.to_lower_case
         select case (word)
           case default; DIE("unknown option")
         end
         if (k==size(keys)) then
           stdout.flush ! In case they didn't write one.
           WARN("no flush keyword - you may later overrun the output buffer")
         end
       end
       stdout.dash(width=width)
     end
   end

   table_width result (res)
   ! Return the table width in characters, based on "keys".  Note that not all
   ! keywords need to contribute to the banner - if a keyword is not recognised,
   ! then it is skipped.
     res :: INT
   ENSURE(keys.created,"no keys")
     int_dash,real_dash,k :: INT
     word :: STR
     int_dash = 0
     real_dash = 0
     do k = 1,size(keys)
       word = keys(k)
       word.to_lower_case
       select case (word)
         case ("}                "); ! exit surrounding loop
         case ("put_configuration"); real_dash = real_dash + 1
         case ("put_label        "); int_dash = int_dash + 1
         case ("put_n_shells     "); int_dash = int_dash + 1
         case ("put_n_bf         "); int_dash = int_dash + 1
         case ("put_n_prim       "); int_dash = int_dash + 1
         case ("flush            "); exit
         case default
       end
     end
     res = int_dash * stdout.int_width + real_dash * stdout.real_width
   end

!  ***************
!  Inquiry methods
!  ***************

   same_as(b) result(res) 
   ! Return TRUE if the basis set "self" is the same as "b". Only the
   ! shell vector is compared to see if they are "really" the same.
      self :: IN
      b :: GEMINAL_MF_SCHEME, IN
      res :: BIN
      res = FALSE
   end

!  **************
!  Output methods
!  **************

   put
   ! Print out the object
      n_step :: INT
      i_step :: INT

      stdout.text("GEMINAL_MF_SCHEME:")
      stdout.text(" ")
      stdout.show("molecule      =",.spectrum.name)
      stdout.show("n_geminals    =",.spectrum.n_geminals)
      stdout.show("n_bf          =",.spectrum.n_bf)
      stdout.show("nuclear_energy=",.spectrum.nuclear_energy)
      if(any(.do_electric_dipole)) then
        stdout.show("nuclear_electric_dipole=",.spectrum.nuclear_electric_dipole)
      end
      stdout.show("add_core=",.add_core)
      stdout.show("make_integrals=",.make_integrals)
      stdout.show("readin_scheme=",.readin_scheme)
      stdout.show("readin_mos=",.readin_mos)
      stdout.show("use_brillouin =",.use_brillouin)
      stdout.show("guess_type =",.guess_type)
      stdout.show("orthogonality_type =",.orthogonality_type)
      stdout.show("starting_group =",.starting_group)
      stdout.show("print_hamiltonian =",.print_hamiltonian)
      stdout.show("convergence   =",.convergence_threshold,precision=12)
      stdout.show("max_iterations   =",.max_iterations)
      stdout.show("n_iterations   =",.n_iterations)
      stdout.text(" ")

      if(.readin_scheme AND .print_hamiltonian) then
    !  n_step=size(.truncation_scheme)
        n_step=.max_iterations-1

!steps from 1 to nsteps - 1
        stdout.show("step :",0)
        stdout.text(" ")
        stdout.show("Cutoff tolerance =",TOL(.tolerance_scheme(0)),precision=12)
        stdout.show("do_triplet_energies=",.do_triplet_energies(0))
        stdout.show("do_electric_dipole=",.do_electric_dipole(0))
        stdout.show("truncation =",.truncation_scheme(0),precision=12)
        stdout.text(" ")
        do i_step=1,n_step
          stdout.show("step :",i_step)
          stdout.text(" ")
          stdout.show("Linear dependence tolerance =",.ld_tol_scheme(i_step),precision=12)
          stdout.show("Internal geminal tolerance =",.ig_tol_scheme(i_step),precision=12)
          stdout.show("Cutoff tolerance =",TOL(.tolerance_scheme(i_step)),precision=12)
          stdout.show("do_triplet_energies=",.do_triplet_energies(i_step))
          stdout.show("do_electric_dipole=",.do_electric_dipole(i_step))
          stdout.show("truncation =",.truncation_scheme(i_step),precision=12)
          stdout.text(" ")
        end
      else
        stdout.text(" ")
        stdout.show("Starting Linear dependence tolerance =",.ld_tol_scheme(1),precision=12)
        stdout.show("Starting internal geminal tolerance =",.ig_tol_scheme(1),precision=12)
        stdout.show("Starting cutoff tolerance =",TOL(.tolerance_scheme(0)),precision=12)
        stdout.show("Starting do_triplet_energies=",.do_triplet_energies(0))
        stdout.show("Starting do_electric_dipole=",.do_electric_dipole(0))
        stdout.show("Starting truncation =",.truncation_scheme(0),precision=12)
        stdout.text(" ")

      end
   end

   put_gs_energies(gs_energies)
   ! put ground state energies to an archive file
     gs_energies :: VEC{REAL}
     gs_energies_archive :: ARCHIVE
     name :: STR
     
     name="gs_energies"
     gs_energies_archive.set(.spectrum.name,name)
     gs_energies_archive.write(gs_energies)
   end

   put_n_iterations
   ! get number of GMFCI already performed in previous jobs from an archive file
     n_iterations_archive :: ARCHIVE
     name :: STR
     
     name="n_iterations"
     n_iterations_archive.set(.spectrum.name,name)
     n_iterations_archive.write(.n_iterations)
   end

   put_old_tolerance(old_tolerance)
   ! put old cutoff thresholds to an archive file
     old_tolerance :: VEC{INT}
     old_tolerance_archive :: ARCHIVE
     name :: STR
     
     name="old_tolerance"
     old_tolerance_archive.set(.spectrum.name,name)
     old_tolerance_archive.write(old_tolerance)
   end

!  ***************
!  EMFCI methods
!  ***************

   do_gmf_auto ::: leaky !because of the set_defaults
   ! implement the contraction-truncation scheme
   ! designed for a singlet ground state
   ! take advantage of the possible truncation of the geminal basis
     ham :: MAT{REAL}*
     gs_energies :: VEC{REAL}*
     old_tolerance :: VEC{INT}*
     group_order :: VEC{INT}*
     lowest_energy :: REAL
   !  highest_energy :: REAL
     old_energy :: REAL
     i,j,i_step,i_geminals :: INT
     n_nonzero,max_bas :: INT
     n_step,n_geminals,n_bf :: INT
     i_loop,loop_count :: INT
     eigenvec :: MAT{REAL}*
     timer :: TIME
     set :: BIN
     save_step :: BIN
     n_geminals=.spectrum.n_geminals
     n_bf=.spectrum.n_bf
     max_bas=.spectrum.n_bas
  !   n_step=size(.truncation_scheme)-1
     n_step=.max_iterations-1
     .n_iterations=0
     gs_energies.create(n_geminals)
     old_tolerance.create(n_geminals)
! step 0
     timer.start_timing
     stdout.text(" ")
     stdout.show("step number: ",0)
     stdout.text(" ")
     old_tolerance=.tolerance_scheme(0)
     .put_old_tolerance(old_tolerance)
     .spectrum.tol=TOL(.tolerance_scheme(0))
     select case (.guess_type)
       case ("hf")
       case ("agp")
         .spectrum.set_singlet_agp
       case ("random")
         .spectrum.set_singlet_random
       case ("readin")
         .spectrum.set_singlet_readin
       case default
         DIE("unknown guess option: "//trim(.guess_type))
     end 
     .spectrum.do_step_0(.use_brillouin,.print_hamiltonian,.truncation_scheme(0),.do_electric_dipole(0))
     gs_energies(1)=.spectrum.contraction_energies(1)
     do i=2,n_geminals
       .spectrum.set_defaults(i_geminals=i)
       select case (.guess_type)
         case ("hf")
           .spectrum.set_singlet_defaults
         case ("agp")
           .spectrum.set_singlet_agp
         case ("random")
           .spectrum.set_singlet_random
         case ("readin")
           .spectrum.set_singlet_readin
         case default
           DIE("unknown guess option: "//trim(.guess_type))
       end 
       .spectrum.do_step_0(.use_brillouin,.print_hamiltonian,.truncation_scheme(0),.do_electric_dipole(0))
       gs_energies(i)=.spectrum.contraction_energies(1)
     end
     timer.stop_timing
     stdout.show("time taken for step 0 in s:",timer.elapsed_time)
     stdout.text(" ")
     .put_gs_energies(gs_energies)  
     if(n_geminals==1) then
       stdout.text("only one geminal in the system")
       stdout.text("job stops at step 0")
       stop
     end
     group_order.create(n_geminals)
     gs_energies.quick_sort(group_order)
     stdout.text(" ")
     stdout.text(" ")
     stdout.text("group_order:")
     stdout.text(" ")
     stdout.put(group_order)
     stdout.text(" ")
     stdout.text(" ")
  !   i_loop=1 !index for group_order
  !   i_geminals=group_order(i_loop)
     loop_count=2 !nb of step after step 0 or after a change of tolerance 
     if(.starting_group==0) then
       i_loop=2
     else
       do i=1,n_geminals
         if(.starting_group==group_order(i)) then
           i_loop=i
           exit
         end
       end
     end
! step 1 to .max_iterations -1
     do i_step=1,n_step
       timer.start_timing
       stdout.text(" ")
       stdout.show("step number: ",i_step)
       stdout.text(" ")
       .spectrum.ld_tol=.ld_tol_scheme(i_step)
       stdout.show("Linear dependence tolerance",.ld_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.ig_tol=.ig_tol_scheme(i_step)
       stdout.show("Internal geminal tolerance",.ig_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.tol=TOL(.tolerance_scheme(i_step))
       stdout.show("Cutoff tolerance: (n in 10^-n) ",.tolerance_scheme(i_step))
       stdout.text(" ")
       do i=1,n_geminals
         .spectrum.set_defaults(i_geminals=i)
         .spectrum.get_ground_state
       end
       .spectrum.set_to_zero_special_ket 
       set=FALSE
       DIE_IF(maxval(old_tolerance)>.tolerance_scheme(i_step),"Cutoff tolerance has decreased")
       do i=0,n_geminals-1
         if(i_loop+i > n_geminals) then
           j=group_order(mod(i_loop+i,n_geminals))
         else
           j=group_order(i_loop+i)
         end  
         if(old_tolerance(j)<.tolerance_scheme(i_step))then
           stdout.text(" ")
           stdout.show("tolerance has increased for group",j) 
           stdout.text(" ")
           .spectrum.set_defaults(i_geminals=j)
           i_geminals=j
           set=TRUE
           if(i_loop+i > n_geminals) then
             i_loop=mod(i_loop+i,n_geminals)
           else
             i_loop=i_loop+i
           end  
           exit
         end
       end
       if(NOT set) then
         j=group_order(i_loop)
         .spectrum.set_defaults(i_geminals=j)
         i_geminals=j
       end
       old_energy=gs_energies(i_geminals)
  !     highest_energy=maxval(gs_energies)
       lowest_energy=minval(gs_energies)
       .spectrum.gs_permutation
       .remove_singlet_dependencies
       n_nonzero=.spectrum.n_bas !number of quasilinearly independent basis functions
       .spectrum.set_to_zero_special_ket !maybe not needed but safer
       ham.create(n_nonzero,n_nonzero)
       ham = .spectrum.hamiltonian !.spectrum.n_bas may be smaller than
                                  ! .spectrum.contraction_energies.dim but
                                  ! should work
       if(.print_hamiltonian) then
         stdout.text(" ")
         stdout.text("singlet Hamiltonian") 
         stdout.text(" ")
         stdout.put(ham) 
         stdout.text(" ")
       end
       eigenvec.create(n_nonzero,n_nonzero)
       ham.solve_eigenproblem(.spectrum.contraction_energies(1:n_nonzero),eigenvec) 
       ham.destroy
       if(.print_hamiltonian) then
         stdout.text(" ")
         stdout.text("singlet eigenvectors") 
         stdout.text(" ")
         stdout.put(eigenvec) 
         stdout.text(" ")
       end
       .spectrum.contraction_energies(1:n_nonzero)= &
          .spectrum.contraction_energies(1:n_nonzero)+.spectrum.nuclear_energy
       .spectrum.get_max_bas !now .spectrum.n_bas is the size of the truncated
                             ! set of possibly quasilinearly dependent basis
                             ! functions
       do j=n_nonzero+1,.spectrum.n_bas
         .spectrum.contraction_energies(j)=.spectrum.nuclear_energy
       end
       stdout.text(" ")
       stdout.show("i_geminals    =",i_geminals)
       stdout.text(" ")
       stdout.show("first eigenvalue is ",.spectrum.contraction_energies(1),precision=12)
       stdout.text(" ")
       stdout.text(" ")
       stdout.text("singlet active function energies (in Hartree)") 
       stdout.text(" ")
       stdout.put(.spectrum.contraction_energies) 
       stdout.text(" ")
!begin testing convergence
       if(set)then
         stdout.text(" ")
         stdout.text("the tolerance having changed, the job continue ...") 
         stdout.text(" ")
         old_tolerance(i_geminals)=.tolerance_scheme(i_step)
         .put_old_tolerance(old_tolerance)
         loop_count=1
         save_step=TRUE
       else  
         if(.spectrum.contraction_energies(1)+.convergence_threshold<lowest_energy) then
           stdout.text(" ")
           stdout.text("Energy difference not within tolerance, the job continue ...") 
           stdout.text(" ")
           loop_count=1
           save_step=TRUE
         else
           if(.spectrum.contraction_energies(1)<old_energy) then
             stdout.show("The energy has improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=TRUE
           else
             stdout.show("The energy has not improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=FALSE
           end
           if(loop_count==n_geminals) then
             stdout.text(" ")
             stdout.text("all electron groups have been considered")
             stdout.text(" ")
             stdout.show("Energy seems converged to within",.convergence_threshold,precision=12)
             stdout.text(" ")
             if(.convergence_threshold<.spectrum.tol) then
               stdout.show("WARNING, tolerance was only",.spectrum.tol,precision=12)
               stdout.text(" ")
             end
             stdout.text(std_time.elapsed_time_message(" "))
             stdout.text(std_time.elapsed_cpu_time_message(" "))
             stop
           else
             timer.stop_timing
             stdout.show("time taken for this step in s:",timer.elapsed_time)
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("Energy difference within tolerance, however ...") 
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("not all electron groups have been considered, the job continue ...") 
             stdout.text(" ")
             loop_count=loop_count+1
             save_step=FALSE
           end
         end
       end
!end testing convergence
       if(save_step)then
         gs_energies(i_geminals)=.spectrum.contraction_energies(1)
         .spectrum.contraction_wfs(1:n_nonzero).change_basis_using(eigenvec,TRUE)
         .spectrum.put_ground_state_geminals
         eigenvec.destroy 
         if(.truncation_scheme(i_step)/=ZERO) then
           stdout.show("truncation threshold for this step",.truncation_scheme(i_step))
           stdout.text(" ")
           .spectrum.n_bas=maxloc(.spectrum.contraction_energies,1,mask= &
             .spectrum.contraction_energies < .truncation_scheme(i_step))
         end
         stdout.show("number of states saved at this step",.spectrum.n_bas)
         stdout.text(" ")
         timer.stop_timing
         stdout.show("time taken for this step in s:",timer.elapsed_time)
         stdout.text(" ")
         .spectrum.put_wfs
         .spectrum.put_ground_state
         .put_gs_energies(gs_energies)
         .n_iterations=.n_iterations+1
         .put_n_iterations
         if(.do_triplet_energies(i_step)) then
           .do_triplet_spectrum
         end
         if(.do_electric_dipole(i_step)) then
           .electric_dipole_matrices
         end
       end
       if(i_loop == n_geminals) then
         i_loop=1
       else
         i_loop=i_loop+1
       end  
     end
     gs_energies.destroy
     old_tolerance.destroy
     group_order.destroy
   end

   restart_gmf_auto
   ! restart the contraction-truncation scheme
   ! designed for a singlet ground state
   ! does take advantage of the possible truncation of the geminal basis
     ham :: MAT{REAL}*
     gs_energies :: VEC{REAL}*
     old_tolerance :: VEC{INT}*
     group_order :: VEC{INT}*
     lowest_energy :: REAL
     old_energy :: REAL
     i,j,i_step,i_geminals :: INT
     n_nonzero,max_bas :: INT
     n_step,n_geminals,n_bf :: INT
     i_loop,loop_count :: INT
     eigenvec :: MAT{REAL}*
     timer :: TIME
     set :: BIN
     save_step :: BIN
     n_geminals=.spectrum.n_geminals
     n_bf=.spectrum.n_bf
     max_bas=.spectrum.n_bas
!     n_step=size(.truncation_scheme)-1
     n_step=.max_iterations-1
     .get_n_iterations
     .n_iterations=.n_iterations+1
     gs_energies.create(n_geminals)
     .get_gs_energies(gs_energies)
     group_order.create(n_geminals)
     gs_energies.quick_sort(group_order,decreasing_order=TRUE)
     stdout.text(" ")
     stdout.text(" ")
     stdout.text("group order:")
     stdout.text(" ")
     stdout.put(group_order)
     stdout.text(" ")
     stdout.text(" ")
     loop_count=1 !nb of step after step 0 or after a change of tolerance 
     if(.starting_group==0) then
       i_loop=1
     else
       do i=1,n_geminals
         if(.starting_group==group_order(i)) then
           i_loop=i
           exit
         end
       end
     end
     old_tolerance.create(n_geminals)
     .get_old_tolerance(old_tolerance)
     stdout.text(" ")
     stdout.text("WARNING, this is a restart job")
     stdout.text("The step numbering is re-initialised if file name.n.iterations has been erased")
     stdout.text("The group order have been re-initialised ")
     stdout.text("The energy improvement message may be wrong for the first steps")
     stdout.text(" if less than n_geminals steps were performed in the original run ")
     stdout.text(" ")
! step 1 to .max_iterations -1
     do i_step=1,n_step
       timer.start_timing
       stdout.text(" ")
      ! stdout.show("step number: ",i_step)
       stdout.show("step number: ",.n_iterations)
       stdout.text(" ")
       .spectrum.ld_tol=.ld_tol_scheme(i_step)
       stdout.show("Linear dependence tolerance",.ld_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.ig_tol=.ig_tol_scheme(i_step)
       stdout.show("Internal geminal tolerance",.ig_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.tol=TOL(.tolerance_scheme(i_step))
       stdout.show("tolerance: (n in 10^-n) ",.tolerance_scheme(i_step))
       stdout.text(" ")
       do i=1,n_geminals
         .spectrum.set_defaults(i_geminals=i)
         .spectrum.get_ground_state
       end
       .spectrum.set_to_zero_special_ket !really needed here
       set=FALSE
       DIE_IF(maxval(old_tolerance)>.tolerance_scheme(i_step),"Cutoff tolerance has decreased")
       do i=0,n_geminals-1
         if(i_loop+i > n_geminals) then
           j=group_order(mod(i_loop+i,n_geminals))
         else
           j=group_order(i_loop+i)
         end  
         if(old_tolerance(j)<.tolerance_scheme(i_step))then
           stdout.text(" ")
           stdout.show("tolerance has increased for group",j) 
           stdout.text(" ")
           .spectrum.set_defaults(i_geminals=j)
           i_geminals=j
           set=TRUE
           if(i_loop+i > n_geminals) then
             i_loop=mod(i_loop+i,n_geminals)
           else
             i_loop=i_loop+i
           end  
           exit
         end
       end
       if(NOT set) then
         j=group_order(i_loop)
         .spectrum.set_defaults(i_geminals=j)
         i_geminals=j
       end
       old_energy=gs_energies(i_geminals)
       lowest_energy=minval(gs_energies)
       .spectrum.gs_permutation
       if(.do_triplet_energies(i_step)) then
         .do_triplet_spectrum
       end
       if(.do_electric_dipole(i_step)) then
         .electric_dipole_matrices
       end
       .remove_singlet_dependencies
       n_nonzero=.spectrum.n_bas !number of quasilinearly independent basis functions
       .spectrum.set_to_zero_special_ket !really needed here
       ham.create(n_nonzero,n_nonzero)
       ham = .spectrum.hamiltonian !.spectrum.n_bas may be smaller than
                                  ! .spectrum.contraction_energies.dim but
                                  ! ! should work
       eigenvec.create(n_nonzero,n_nonzero)
       ham.solve_eigenproblem(.spectrum.contraction_energies(1:n_nonzero),eigenvec)
       ham.destroy
       if(.print_hamiltonian) then
         stdout.text(" ")
         stdout.text("singlet eigenvectors")
         stdout.text(" ")
         stdout.put(eigenvec)
         stdout.text(" ")
       end
       .spectrum.contraction_energies(1:n_nonzero)= &
          .spectrum.contraction_energies(1:n_nonzero)+.spectrum.nuclear_energy
       .spectrum.get_max_bas !now .spectrum.n_bas is the size of the truncated
                             ! set of possibly quasilinearly dependent basis
                             ! functions

       do j=n_nonzero+1,.spectrum.n_bas
         .spectrum.contraction_energies(j)=.spectrum.nuclear_energy
       end
       stdout.text(" ")
       stdout.show("i_geminals    =",.spectrum.i_geminals)
       stdout.text(" ")
       stdout.show("first eigenvalue is:",.spectrum.contraction_energies(1),precision=12)
       stdout.text(" ")
       stdout.text(" ")
       stdout.text("singlet active function energies (in Hartree)") 
       stdout.text(" ")
       stdout.put(.spectrum.contraction_energies) 
       stdout.text(" ")
!begin testing convergence
       if(set)then
         stdout.text(" ")
         stdout.text("the tolerance having changed, the job continue ...") 
         stdout.text(" ")
         old_tolerance(i_geminals)=.tolerance_scheme(i_step)
         .put_old_tolerance(old_tolerance)
         loop_count=1
         save_step=TRUE
       else  
         if(.spectrum.contraction_energies(1)+.convergence_threshold<lowest_energy) then
           stdout.text(" ")
           stdout.text("Energy difference not within tolerance, the job continue ...") 
           stdout.text(" ")
           loop_count=1
           save_step=TRUE
         else
           if(.spectrum.contraction_energies(1)<old_energy) then
             stdout.show("The energy has improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=TRUE
           else
             stdout.show("The energy has not improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=FALSE
           end
           if(loop_count==n_geminals) then
             stdout.text(" ")
             stdout.text("all electron groups have been considered")
             stdout.text(" ")
             stdout.show("Energy seems converged to within",.convergence_threshold,precision=12)
             stdout.text(" ")
             if(.convergence_threshold<.spectrum.tol) then
               stdout.show("WARNING, tolerance was only",.spectrum.tol,precision=12)
               stdout.text(" ")
             end
             stdout.text(std_time.elapsed_time_message(" "))
             stdout.text(std_time.elapsed_cpu_time_message(" "))
             stop
           else
             timer.stop_timing
             stdout.show("time taken for this step in s:",timer.elapsed_time)
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("Energy difference within tolerance, however ...") 
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("not all electron groups have been considered, the job continue ...") 
             stdout.text(" ")
             loop_count=loop_count+1
             save_step=FALSE
           end
         end
       end
!end testing convergence
       if(save_step)then
      !   .save_gmf_step(i_step,i_geminals)
         gs_energies(i_geminals)=.spectrum.contraction_energies(1)
         .spectrum.contraction_wfs(1:n_nonzero).change_basis_using(eigenvec,TRUE)
         .spectrum.put_ground_state_geminals
         eigenvec.destroy 
         if(.truncation_scheme(i_step)/=ZERO) then
           stdout.show("truncation threshold for this step",.truncation_scheme(i_step))
           stdout.text(" ")
           .spectrum.n_bas=maxloc(.spectrum.contraction_energies,1,mask= &
             .spectrum.contraction_energies < .truncation_scheme(i_step))
         end
         stdout.show("number of states saved at this step",.spectrum.n_bas)
         stdout.text(" ")
         timer.stop_timing
         stdout.show("time taken for this step in s:",timer.elapsed_time)
         stdout.text(" ")
         .spectrum.put_wfs
         .spectrum.put_ground_state
         .put_gs_energies(gs_energies)
         .n_iterations=.n_iterations+1
         .put_n_iterations
       end
       if(i_loop == n_geminals) then
         i_loop=1
       else
         i_loop=i_loop+1
       end  
     end
     gs_energies.destroy
     old_tolerance.destroy
     group_order.destroy
   end

   do_triplet_spectrum ::: leaky !because of the set_defaults
   ! do the triplet spectrum after a geminal mean field singlet step
     ham :: MAT{REAL}*
     i_geminals :: INT
     n_geminals,max_bas :: INT
     eigenvec :: MAT{REAL}*
     timer :: TIME
     timer.start_timing
     n_geminals=.spectrum.n_geminals
     i_geminals=.spectrum.i_geminals
     stdout.text(" ")
     stdout.text("Triplet spectrum for this step")
     stdout.text(" ")
!     .spectrum.set_active_triplet_defaults !now .spectrum.n_bas is again max_bas
     .remove_triplet_dependencies
     max_bas=.spectrum.n_bas
     ham.create(max_bas,max_bas)
     ham = .spectrum.hamiltonian
     if(.print_hamiltonian) then
       stdout.text("The triplet hamiltonian matrix is ")
       stdout.text(" ")
       stdout.put(ham)
       stdout.text(" ")
     end
     eigenvec.create(max_bas,max_bas)
     ham.solve_eigenproblem(.spectrum.contraction_energies,eigenvec) 
     ham.destroy
     if(.print_hamiltonian) then
       stdout.text("triplet eigenvectors") 
       stdout.text(" ")
       stdout.put(eigenvec) 
       stdout.text(" ")
     end
     .spectrum.contraction_energies= .spectrum.contraction_energies+.spectrum.nuclear_energy
     stdout.show("i_geminals    =",i_geminals)
     stdout.text(" ")
     stdout.text(" ")
     stdout.text("triplet active function energies (in Hartree)") 
     stdout.text(" ")
     stdout.put(.spectrum.contraction_energies) 
     stdout.text(" ")
     timer.stop_timing
     stdout.show("time taken for triplet spectrum in s:",timer.elapsed_time)
     stdout.text(" ")
   end

   electric_dipole_matrices 
   ! do the electric dipole matrices
     Dx,Dy,Dz :: MAT{REAL}*
   !  ov :: MAT{REAL}*
     n_bas,max_bas :: INT
     timer :: TIME
     timer.start_timing
     stdout.text(" ")
     stdout.text("Electric dipole moment matrices for this step")
     stdout.text(" ")
     max_bas=.spectrum.n_bas
 !    n_bas=.spectrum.n_bas
 !    max_bas=1
 !    .spectrum.n_bas=1
 !    ov.create(max_bas,max_bas)
 !    ov=.spectrum.overlap
 !    stdout.text("The overlap matrix is ")
 !    stdout.text(" ")
 !    stdout.put(ov)
 !    stdout.text(" ")
     Dx.create(max_bas,max_bas)
     Dx = .spectrum.electric_dipole_x
 !    Dx=Dx/ov(1,1)
     Dx=Dx+.spectrum.nuclear_electric_dipole(1)
     stdout.text("The electric dipole x-component matrix is in a.u. ")
     stdout.text(" ")
     stdout.put(Dx)
     stdout.text(" ")
     Dx.destroy
     Dy.create(max_bas,max_bas)
     Dy = .spectrum.electric_dipole_y
    ! Dy=Dy/ov(1,1)
     Dy=Dy+.spectrum.nuclear_electric_dipole(2)
     stdout.text("The electric dipole y-component matrix is in a.u. ")
     stdout.text(" ")
     stdout.put(Dy)
     stdout.text(" ")
     Dy.destroy
     Dz.create(max_bas,max_bas)
     Dz = .spectrum.electric_dipole_z
    ! Dz=Dz/ov(1,1)
     Dz=Dz+.spectrum.nuclear_electric_dipole(3)
     stdout.text("The electric dipole z-component matrix is in a.u. ")
     stdout.text(" ")
     stdout.put(Dz)
     stdout.text(" ")
     Dz.destroy
     timer.stop_timing
     stdout.show("time taken for dipole moment in s:",timer.elapsed_time)
     stdout.text(" ")
   !  ov.destroy
   !  .spectrum.n_bas=n_bas
   end

   remove_singlet_dependencies ::: leaky
   ! remove linear dependencies in the contraction basis set
     .spectrum.remove_dependencies(.orthogonality_type,.print_hamiltonian)
   end

   remove_triplet_dependencies ::: leaky
   ! remove linear dependencies in the contraction basis set
     .spectrum.remove_triplet_dependencies(.print_hamiltonian)
   end

end
