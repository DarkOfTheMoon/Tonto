!-------------------------------------------------------------------------------
!
! CLUSTER:
!
! An object to store information pertaining to a cluster of atoms or molecules
! generated from an underlying crystal structure.
!
! A lot of information regarding the cluster is generated -- like the unit cell
! connection table, the atom connection table, the occupation list (unit cell
! atom numbers plus cell translation vectors), and the unit cell atom numbers. 
! The symmetry operators for each atom are also available from the unit cell
! numbers if the crystal information is available (it should be, otherwise
! we can't generate a cluster!).
!
! NOTE: an associated crystal and atom list should be supplied. It is intended
! that these will come from the molecule which generates the cluster (perhaps a
! cluster should contain a molecule?). 
!
! Copyright (C) Dylan Jayatilaka, 2002
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module CLUSTER

   implicit none

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

   create ::: get_from(OBJECT), leaky
   ! Create an object. This version does not set defaults.
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts

      nullify(.crystal)
      nullify(.asymmetric_unit_atom)
      nullify(.fragment_geometry)

      nullify(.geometry)
      nullify(.shift)
      nullify(.shift_for_atom)
      nullify(.is_fragment_atom)
      nullify(.occupation_list)
      nullify(.molecule_for_atom)
      nullify(.atom_connection)

   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts

      ! Never destroy these, they are always pointer assigned
      nullify(.crystal)
      nullify(.asymmetric_unit_atom)
      nullify(.fragment_geometry)
    ! .crystal.destroy   
    ! .asymmetric_unit_atom.destroy
    ! .fragment_geometry.destroy

      .geometry.destroy
      .shift.destroy
      .shift_for_atom.destroy
      .is_fragment_atom.destroy
      .occupation_list.destroy
      .molecule_for_atom.destroy
      .atom_connection.destroy

   end

   destroy_cluster_info_ptr_part ::: leaky
   ! Destroy the non-symop informational ptr parts. These incclude the actual
   ! .geometry of the cluster as wellas information relating to the .symop's
   ! used to generate the cluster.
      .geometry.destroy
      .shift.destroy
      .shift_for_atom.destroy
      .is_fragment_atom.destroy
      .occupation_list.destroy
      .molecule_for_atom.destroy
      .atom_connection.destroy
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(cluster) ::: leaky
   ! Copy the contents of "cluster" to self. NOTE: ensure you destroy all the
   ! parts you need to before calling this.
      cluster :: CLUSTER, IN
      self = cluster
      .nullify_ptr_part
      if (cluster.geometry.created)                .geometry.create_copy(cluster.geometry)
      if (cluster.crystal.created)                 .crystal.create_copy(cluster.crystal)
      if (cluster.asymmetric_unit_atom.created)    .asymmetric_unit_atom.create_copy(cluster.asymmetric_unit_atom)
      if (cluster.shift.created)                   .shift.create_copy(cluster.shift)
      if (cluster.shift_for_atom.created)          .shift_for_atom.create_copy(cluster.shift_for_atom)
      if (cluster.is_fragment_atom.created)        .is_fragment_atom.create_copy(cluster.is_fragment_atom)
      if (cluster.occupation_list.created)         .occupation_list.create_copy(cluster.occupation_list)
      if (cluster.molecule_for_atom.created)       .molecule_for_atom.create_copy(cluster.molecule_for_atom)
      if (cluster.atom_connection.created)         .atom_connection.create_copy(cluster.atom_connection)
   end

   create(crystal) ::: leaky
   ! Create the object from the supplied "crystal".
      self :: PTR
      crystal :: CRYSTAL*

   ENSURE(crystal.created,"no crystal created!")
   ENSURE(crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms!")

      .create
      .set_defaults(crystal)

   end

   set_defaults(crystal) ::: leaky
   ! Set up defaults. The "crystal" is pointer assigned. The cluster
   ! is essentially a crystal with additional operations based on the
   ! .fragment_geometry. Thus we must keep the crystal.fragment_geometry 
   ! in sync with the cluster.fragment geometry.
      crystal :: CRYSTAL*

   ENSURE(crystal.created,"no crystal created!")
   ENSURE(crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms!")
   ENSURE(crystal.fragment_geometry.created,"no crystal fragment geometry!")

      .destroy_ptr_part

      .generation_method   = CLUSTER_GENERATION_METHOD
      .radius              = CLUSTER_RADIUS
      .atom_density_cutoff = CLUSTER_ATOM_DENSITY_CUTOFF
      .defragment          = CLUSTER_DEFRAGMENT
      .info_made           = FALSE
      .n_atoms = 0
      .h_min = 0
      .h_max = 0
      .n_fragment_atoms = 0
      .fragment_offset = 0
      .unit_cell_offset = ZERO

      ! Pointer assign these; we use them a lot
      .crystal => crystal
      .asymmetric_unit_atom => .crystal.asymmetric_unit_atom

      ! Set the basis type: slater trumps gaussians for cluster
      ! generation ...
      if      (.asymmetric_unit_atom.has_all_slater_bases) then
         .asymmetric_unit_atom.basis_kind = "slater"
      else if (.asymmetric_unit_atom.has_all_coppens_bases) then
         .asymmetric_unit_atom.basis_kind = "coppens"
      else if (.asymmetric_unit_atom.has_all_gaussian_bases) then
         .asymmetric_unit_atom.basis_kind = "gaussian"
      end

      ! Set the fragment geometry in fractionals & offset from the supplied crystal
      .fragment_geometry => crystal.fragment_geometry
      .n_fragment_atoms = crystal.n_fragment_atoms
      .fragment_offset  = int(crystal.fragment_geometry.mean_column_vector)

   end

   set_fragment_geometry(fragment_geometry,cartesian) ::: leaky
   ! Point assign the fragment_geometry in sync with the crystal one
   ! Set "cartesian" TRUE if the fragment atoms are in xyz coord frame
      fragment_geometry :: MAT{REAL}
      cartesian :: BIN, optional

   ENSURE(.crystal.created,"no crystal created!")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms!")

      .crystal.make_fragment_data(fragment_geometry,cartesian)

      .fragment_geometry =>    .crystal.fragment_geometry
      .n_fragment_atoms  =     .crystal.n_fragment_atoms
      .fragment_offset   = int(.crystal.fragment_geometry.mean_column_vector)
   end

   set_generation_method(method)
   ! Set the generation method, which tells how to generate the cluster e.g.
   ! whether to add atoms to the cluster within a certain radius of the starting
   ! fragment, or whether to use the unit cell ad the cluster, or just the
   ! initial starting fragment (i.e. the null cluster) or the initial fragment
   ! and the unit cell.
      method :: STR
      .generation_method = method
      .generation_method.to_lower_case
      select case (.generation_method)
         case("for_hirshfeld_surface     ")
         case("fragment                  ")
         case("unit_cell                 ")
         case("unit_cell_plus            ")
         case("for_unit_cell_density     ")
         case("offset_unit_cell          ")
         case("offset_unit_cell_density  ")
         case("within_radius             ")
         case default;   UNKNOWN(.generation_method)
      end
   end

   set_unit_cell_offset(offset)
   ! Set the unit_cell_offset to use when making an offset unit cell.
      offset :: VEC{REAL}(3)
   DIE_IF(any(offset>HALF) OR any(offset<-HALF),"offset must be between -1/2 and +1/2")
      .unit_cell_offset = offset
   end

!  *************
!  Input methods
!  *************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR
      word :: STR
      word = keyword
      word.to_lower_case
      select case (word)
         case ("}                             ")  ! exit case
         case ("add_criteria=                 "); .read_generation_method
         case ("atoms=                        "); .read_atoms
         case ("atom_density_cutoff=          "); .read_atom_density_cutoff
         case ("debug_on                      "); .read_debug_on
         case ("debug_off                     "); .read_debug_off
         case ("defragment=                   "); .read_defragment
         case ("fractional_fragment=          "); .read_fractional_fragment
         case ("fragment_geometry=            "); .read_fragment_geometry
         case ("generation_method=            "); .read_generation_method
         case ("make_info                     "); .make_info
         case ("unit_cell_offset=             "); .read_unit_cell_offset
         case ("put                           "); .put
         case ("put_averaged_lff_l_tensors    "); .put_averaged_LFF_tensors
         case ("put_centroid_lff_l_tensors    "); .put_centroid_LFF_tensors
         case ("put_centroid_lff_l_tensors_old"); .put_centroid_LFF_tensors_old
         case ("put_debug_list                "); .put_debug_list
         case ("put_lff_info                  "); .put_LFF_info
         case ("put_tonto_input               "); .put_tonto_input
         case ("radius=                       "); .read_radius
         case ("units=                        "); CLUSTER::read_units
         case ("set_fragment_geometry_from_first_atom_in_asymm_unit");
         .set_fragment_geometry_from_first_atom_in_asymm_unit
         case default;     UNKNOWN(word)
      end
   end

   read_units ::: get_from(OBJECT), selfless, private
   ! Read a string which describes the units to be used
   end

   read_unit_cell_offset
   ! Read the add criteria, whether to add atoms by whole clusters within a
   ! certain radius of the starting fragment, or by individual atoms within a
   ! certain distance of the starting fragment.
      offset :: VEC{REAL}(3)
      stdin.read(offset)
      .set_unit_cell_offset(offset)
   end

   read_generation_method
   ! Read the add criteria, whether to add atoms by whole clusters within a
   ! certain radius of the starting fragment, or by individual atoms within a
   ! certain distance of the starting fragment.
      generation_method :: STR
      stdin.read(generation_method)
      .set_generation_method(generation_method)
   end

   read_defragment
   ! Read whether to defragment the cluster at the boundaries. If set TRUE, the
   ! cluster ends are defragmented, i.e. any atoms which are bonded at the ends
   ! of the cluster are included into the cluster.
      stdin.read(.defragment)
   end

   read_radius
   ! Read the radius of the cluster. Usually, all atoms with this distance of
   ! any atom in the fragment_geometry will appear in the cluster.
      stdin.read(.radius)
   end

   read_atom_density_cutoff
   ! This number is used to define a cluster radius (see above). The radius is
   ! defined from it, as the *largest* distance from any atom in the
   ! asymmetric_cell_atom list where the atomic electron density becomes smaller
   ! than this number. It requires that slater or coppens bases are defined for
   ! the asymmetric_cell_atom's, and it requires that the generation method be
   ! set to "for_hirshfeld_surface". It is primarily used for clusters generated
   ! from a fragment, which will correctly produce the Hirshfeld surface.
      stdin.read(.atom_density_cutoff)
   end

   read_fragment_geometry ::: leaky
   ! Read in the fragment geometry, in cartesian atomic units, and
   ! convert to fractional coordinates. NOTE: All fragment atom
   ! positions must correspond to the positions of actual atoms in the
   ! crystal lattice.

   ENSURE(.crystal.created,"no crystal defined")

      fragment_geometry :: MAT{REAL}*
      tmp :: VEC{REAL}*
      n :: INT

      stdin.read_ptr(tmp)
      ENSURE(mod(tmp.dim,3)==0,"# of elements not divisible by 3")

      n = tmp.dim/3
      fragment_geometry.create(3,n)
      fragment_geometry = reshape(tmp,[3,n])
      .set_fragment_geometry(fragment_geometry,cartesian=TRUE)

      fragment_geometry.destroy; tmp.destroy

   end

   set_fragment_geometry_from_first_atom_in_asymm_unit
   ! Takes the first atom from the asymmetric unit and sets it
   ! to be the current fragment geometry

   ENSURE(.crystal.created,"no crystal defined")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms!")

      fragment_geometry :: MAT{REAL}*
      atom :: ATOM

      atom = .crystal.asymmetric_unit_atom(1)
      fragment_geometry.create(3,1)
      fragment_geometry(1,1) = atom.pos(1)
      fragment_geometry(2,1) = atom.pos(2)
      fragment_geometry(3,1) = atom.pos(3)
      .set_fragment_geometry(fragment_geometry,cartesian=TRUE)

      fragment_geometry.destroy
   end

   read_fractional_fragment ::: leaky
   ! Read in the fragment geometry, in fractional coordinates.
   ! NOTE: All fragment atom positions must correspond to the
   ! positions of actual atoms in the crystal lattice.
   ENSURE(.crystal.created,"no crystal defined")

      fragment_geometry :: MAT{REAL}*
      tmp :: VEC{REAL}*
      n :: INT

      stdin.read_ptr(tmp)
      ENSURE(mod(tmp.dim,3)==0,"# of elements not divisible by 3")

      n = tmp.dim/3
      fragment_geometry.create(3,n)
      fragment_geometry = reshape(tmp,[3,n])
      .set_fragment_geometry(fragment_geometry)

      fragment_geometry.destroy; tmp.destroy

   end

   read_atoms ::: leaky
   ! Modify the atom list information
      DIE_IF(.asymmetric_unit_atom.destroyed,"atom list not created!")

      .asymmetric_unit_atom.read_list_keywords

      if (associated(.crystal)) &
         .asymmetric_unit_atom.resolve_axis_system(.crystal.unit_cell)

   end

!  ***************************
!  Cluster generation routines
!  ***************************

   make_info ::: leaky
   ! Make all the cluster information from an arbitrary .fragment_geometry.
   ! NOTE: .set_defaults must be called before this.

   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_connection.created,"no unit cell connection table")
   ENSURE(.fragment_geometry.created,"no fragment_geometry")

      if (.info_made) return

      ! Depending on the generation_method, make starting cluster
      .make_occupation_list

      ! Generate the cluster
      select case (.generation_method)
         case ("within_radius") 
            .make_within_radius
         case ("for_hirshfeld_surface") 
            .make_radius
            .make_within_radius
            .defragment = FALSE
         case ("for_unit_cell_density")
          ! .do_defragment
            .make_radius
            .make_within_radius
            .defragment = FALSE
         case ("offset_unit_cell_density")
            .make_radius
            .make_within_radius
            .defragment = FALSE
      end

      ! Defragment/find molecules in the cluster
      if (.defragment) then; .do_defragment
      else;                  .do_connectify
      end

      ! Extract cordinatres from ocupation list
      .extract_geometry

      ! Finished ...
      .info_made = TRUE

   end

   make_occupation_list ::: leaky
   ! Codify which atoms in the crystal are fragment atoms i.e. make the
   ! ".occupation_list". If the u-th atom in the unit cell (h1,h2,h3) is
   ! occupied then the number h1' + 10^1*h2' + 10^2*h3' + 10^3*u appears in the
   ! array "list", where hn' = hn + 5 i.e hn in [-4,4] maps to hn' in [1,9].
   ! This means that hn must be restricted to the range [-4,4] i.e. we can't
   ! consider fragments atoms which lie in cells outside this range. This list
   ! allows easy comparison of which atoms are in the fragment by an integer
   ! equality test. 
   ! NO: Also make the ".molecule_for_atom" list which tells which
   ! molecule the atom belongs to. It needs "unit_cell_.molecule_for_atom" list.
   ! These molecule numbers may not be correct, since different molecule numbers
   ! are assigned for atoms in different unit cells, even though they may be
   ! connected across a cell boundary; they are made correct at the end of the
   ! cluster generation procedure, using the connection table.
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.created,"no crystal unit cell")
   ENSURE(.fragment_geometry.created,"no fragment_geometry")

      h,h0 :: VEC{INT}(3)
      tol,radius :: REAL
      pos,b,t :: VEC{REAL}(3)
      i,u,u1000 :: INT
      fragment_geometry :: MAT{REAL}*

      tol = TOL(1)/maxval(.crystal.unit_cell.length)
      tol = TOL(3)                        ! <--- getting this number wrong can stuff things

      select case (.generation_method)

        case("within_radius","for_hirshfeld_surface","fragment")
           ENSURE(.fragment_geometry.created,"no fragment_geometry")
           pos = .fragment_geometry.mean_column_vector
           .fragment_offset = int(pos)
           .occupation_list.destroy
           .occupation_list.create(.n_fragment_atoms)
           do i = 1,.n_fragment_atoms
              pos = .fragment_geometry(:,i) - .fragment_offset
              .crystal.put_to_unit_cell(pos,shift=h)
              u = .crystal.unit_cell_geometry.column_index(pos,tol)
              if (u==0) then
                 WARN("position of fragment atom "//i.to_str.trim//" not found in unit cell")
                 stdout.show("fragment pos =",pos)
                 stdout.text("unit cell geometry:")
                 stdout.put(transpose(.crystal.unit_cell_geometry))
                 DIE("position of fragment atom "//i.to_str.trim//" not found in unit cell")
              end
              h = -h + 5
              .occupation_list(i) = h(1) + h(2)*10 + h(3)*100 + u*1000
           end

        case("unit_cell             ")
           .occupation_list.destroy
           .occupation_list.create(.crystal.n_unit_cell_atoms)
           fragment_geometry.create(3,.crystal.n_unit_cell_atoms)
           h = 5
           do u = 1,.crystal.n_unit_cell_atoms
              .occupation_list(u) = h(1) + h(2)*10 + h(3)*100 + u*1000
              pos = .crystal.unit_cell_geometry(:,u) 
              fragment_geometry(:,u) = pos
           end
           .set_fragment_geometry(fragment_geometry)
           .fragment_offset = 0
           fragment_geometry.destroy

        case("unit_cell_plus","for_unit_cell_density")
           .occupation_list.destroy
           .occupation_list.create(.crystal.n_unit_cell_atoms)
           fragment_geometry.create(3,.crystal.n_unit_cell_atoms)
           do u = 1,.crystal.n_unit_cell_atoms
              .occupation_list(u) = 5 + 5*10 + 5*100 + u*1000
              pos = .crystal.unit_cell_geometry(:,u) 
              fragment_geometry(:,u) = pos
           end
           .set_fragment_geometry(fragment_geometry)
           .fragment_offset = 0
           fragment_geometry.destroy
           ! Go 2 angstrom from unit cell edges for unit cell densities
           if (.generation_method=="unit_cell_plus") then; radius = .radius
           else;                                           radius = max(TWO,.radius)
           end
           b = radius.from_units("angstrom")/.crystal.unit_cell.length
           DIE_IF(any(b>ONE),"radius around unit cell exceeds at least one cell dimension")
           t = ONE - b
           u1000 = 0
           do u = 1,.crystal.n_unit_cell_atoms
              pos = .crystal.unit_cell_geometry(:,u) 
              u1000 = u1000 + 1000

              if (pos(1)<b(1)) .occupation_list.append(6+5*10+5*100+u1000)
              if (pos(2)<b(2)) .occupation_list.append(5+6*10+5*100+u1000)
              if (pos(3)<b(3)) .occupation_list.append(5+5*10+6*100+u1000)
              if (pos(1)>t(1)) .occupation_list.append(4+5*10+5*100+u1000)
              if (pos(2)>t(2)) .occupation_list.append(5+4*10+5*100+u1000)
              if (pos(3)>t(3)) .occupation_list.append(5+5*10+4*100+u1000)

              if (pos(1)<b(1) AND pos(2)<b(2)) .occupation_list.append(6+6*10+5*100+u1000)
              if (pos(1)<b(1) AND pos(3)<b(3)) .occupation_list.append(6+5*10+6*100+u1000)
              if (pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(5+6*10+6*100+u1000)
              if (pos(1)>t(1) AND pos(2)<b(2)) .occupation_list.append(4+6*10+5*100+u1000)
              if (pos(1)>t(1) AND pos(3)<b(3)) .occupation_list.append(4+5*10+6*100+u1000)
              if (pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(5+4*10+6*100+u1000)
              if (pos(1)<b(1) AND pos(2)>t(2)) .occupation_list.append(6+4*10+5*100+u1000)
              if (pos(1)<b(1) AND pos(3)>t(3)) .occupation_list.append(6+5*10+4*100+u1000)
              if (pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(5+6*10+4*100+u1000)
              if (pos(1)>t(1) AND pos(2)>t(2)) .occupation_list.append(4+4*10+5*100+u1000)
              if (pos(1)>t(1) AND pos(3)>t(3)) .occupation_list.append(4+5*10+4*100+u1000)
              if (pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(5+4*10+4*100+u1000)

              if (pos(1)<b(1) AND pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(6+6*10+6*100+u1000)
              if (pos(1)>t(1) AND pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(4+6*10+6*100+u1000)
              if (pos(1)<b(1) AND pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(6+4*10+6*100+u1000)
              if (pos(1)>t(1) AND pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(4+4*10+6*100+u1000)
              if (pos(1)<b(1) AND pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(6+6*10+4*100+u1000)
              if (pos(1)>t(1) AND pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(4+6*10+4*100+u1000)
              if (pos(1)<b(1) AND pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(6+4*10+4*100+u1000)
              if (pos(1)>t(1) AND pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(4+4*10+4*100+u1000)
           end

        case("offset_unit_cell","offset_unit_cell_density")
           .occupation_list.destroy
           .occupation_list.create(.crystal.n_unit_cell_atoms)
           fragment_geometry.create(3,.crystal.n_unit_cell_atoms)
           h0 = 5
           do u = 1,.crystal.n_unit_cell_atoms
              h = h0
              pos = .crystal.unit_cell_geometry(:,u) 
              if (pos(1)<    .unit_cell_offset(1)) h(1) = h0(1) + 1
              if (pos(2)<    .unit_cell_offset(2)) h(2) = h0(2) + 1
              if (pos(3)<    .unit_cell_offset(3)) h(3) = h0(3) + 1
              if (pos(1)>ONE+.unit_cell_offset(1)) h(1) = h0(1) - 1
              if (pos(2)>ONE+.unit_cell_offset(2)) h(2) = h0(2) - 1
              if (pos(3)>ONE+.unit_cell_offset(3)) h(3) = h0(3) - 1
              .occupation_list(u) = h(1) + h(2)*10 + h(3)*100 + u*1000
              fragment_geometry(:,u) = pos + h - h0
           end
           .set_fragment_geometry(fragment_geometry)
           .fragment_offset = 0
           fragment_geometry.destroy

        case default
           UNKNOWN(.generation_method)

      end
   end

   make_radius
   ! This routine makes an appropriate value for the cluster .radius in the
   ! case where the .generation_method is "for_hirshfeld_surface". The radius is
   ! made so that the accuracy of any atomic term neglected is smaller than
   ! .atom_density_cutoff. The radius is defined to the nearesr 0.02 bohr (or
   ! whatever is set as the default for the interpolator table spacing). Likewise,
   ! we can't cope with atom density cutoffs where the distances are larger than
   ! 30 bohr (or whatever is set as the default interpolator table length). To
   ! do this properly we'd have to solve numerical equations for exactly where
   ! the atom density equals the desired cutoff; that seems like too much
   ! effort.

   ENSURE(.asymmetric_unit_atom.created,"no asymmetric cell atoms")
   ENSURE(.asymmetric_unit_atom.has_all_bases,"incomplete atom bases")
   ENSURE(.atom_density_cutoff>ZERO,"atom density cutoff must be positve")

      .radius = .asymmetric_unit_atom.max_interpolator_table_length(.atom_density_cutoff)

   end

   make_within_radius ::: leaky
   ! Make the maximum unit cell offsets so that we get all atoms within a
   ! certain radius of the fragment geometry.

   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.fragment_geometry.created,"no fragment_geometry")
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.created,"no crystal unit_cell_geometry")

      geom0,frag :: MAT{REAL}*
      rcm :: MAT{REAL}(3,3)
      pos,off,d :: VEC{REAL}(3)
      hlist,ulist,match :: VEC{INT}*
      uskip :: VEC{BIN}*
      d2,radius2 :: REAL
      within_radius,has_frag_atoms,not000,offset :: BIN 
      n_unit_cell_atoms,h1,h2,h3,hcode,code,k,u :: INT

      ! Constants
      n_unit_cell_atoms = .crystal.n_unit_cell_atoms
      radius2 = .radius*.radius
      rcm = .crystal.unit_cell.direct_matrix               

      ! Cartesian fragment geometry
      frag.create(3,.n_fragment_atoms)                     
      frag  = matmul(rcm,.fragment_geometry)

      ! Put fragment geometry close to origin cell
      offset = any(.fragment_offset/=0)
      if (offset) then
        off = matmul(rcm,.fragment_offset)
        frag = frag - spread(off,2,.n_fragment_atoms)
      end

      ! Look this many cells away for cluster atoms ...
      .h_max = ceiling(( .radius+maxval(frag,dim=2))/.crystal.unit_cell.length)
      .h_min =   floor((-.radius+minval(frag,dim=2))/.crystal.unit_cell.length)
      .h_max = max(.h_max,[1,1,1])                         ! Look at least one cell away
      .h_min = min(.h_min,[-1,-1,-1])
   ! .h_max = max(.h_max,[2,2,2])                         ! Look at least two cells away
   ! .h_min = min(.h_min,[-2,-2,-2])                      ! This was put by Josh I think

      ENSURE(all(.h_min>=-5),"search range too low, h_min = "//trim(.h_min.to_str))
      ENSURE(all(.h_max<=4),"search range too high, h_max = "//trim(.h_max.to_str))

      ! Put back fragment geometry
      if (offset) &
      frag = frag + spread(off,2,.n_fragment_atoms)

      ! Get (0,0,0) cell offset by .fragment_offset in cartesians...
      geom0.create(3,n_unit_cell_atoms)                    
      geom0 = matmul(rcm,.crystal.unit_cell_geometry)
      if (offset) &
      geom0 = geom0 + spread(off,2,n_unit_cell_atoms)

      ! Cells which fragment occupies
      hlist.create(.n_fragment_atoms)
      hlist = mod(.occupation_list,1000)                    

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_fragment_atoms)
      ulist = .occupation_list/1000                         

      ! Skip fragment atoms in a particular unit cell
      uskip.create(n_unit_cell_atoms)

      ! Loop over allowed cells
      do h1 = .h_min(1),.h_max(1)                           
      do h2 = .h_min(2),.h_max(2)
      do h3 = .h_min(3),.h_max(3)

        ! Get cell displacement vector if needed
        not000 = h1/=0 OR h2/=0 OR h3/=0
        if (not000) off = matmul(rcm,[h1,h2,h3])

        ! Get list of atoms "match" which are in this cell
        hcode = (h1+5) + (h2+5)*10 + (h3+5)*100
        match => hlist.indices_of_elements_matching(hcode)

        ! Are there any fragment atoms in this cell?
        ! Set the unit cell atoms corresponding to them
        has_frag_atoms = match.dim>0                      
        if (has_frag_atoms) then
           uskip = FALSE                                  
           do k = 1,match.dim
              uskip(ulist(match(k))) = TRUE
           end
        end

        ! Loop over unit cell atoms in this cell
        do u = 1,n_unit_cell_atoms                        

           ! If there are fragment atoms here, skip them
           if (has_frag_atoms) then
              if (uskip(u)) cycle
           end

           pos = geom0(:,u)
           if (not000) pos = pos + off

           ! Test if this atom pos is within .radius
           within_radius = FALSE                          
           do k = 1,.n_fragment_atoms              

              d = frag(:,k) - pos

              ! Sequentially eliminate far points
              if (abs(d(1))>.radius) cycle                
              if (abs(d(2))>.radius) cycle
              if (abs(d(3))>.radius) cycle

              ! Don't use square root
              d2 = d(1)*d(1)+d(2)*d(2)+d(3)*d(3)
              if (d2>radius2) cycle                       

              within_radius = TRUE
              exit

           end

           if (NOT within_radius) cycle

           ! New atom ... add it in ...
           code = hcode + u*1000                          
           .occupation_list.append(code)                   

        end

        match.destroy

      end
      end
      end

      uskip.destroy; ulist.destroy; hlist.destroy
      geom0.destroy
      frag.destroy

   end

   do_connectify ::: leaky
   ! Find the connected molecules in the "occupation_list" from the
   ! .crystal.unit_cell_connection table.

   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_connection.created,"no unit cell connection table")

      i,c,code,h1,h2,h3,u,k1,k2,k3,t,old,mi,mo :: INT
      con,unique,molecule_for_atom :: VEC{INT}*
      unit_cell_connection :: VEC{VEC_{VEC_{INT}}}* 

      unit_cell_connection => .crystal.unit_cell_connection

      .n_atoms = .occupation_list.dim
      .atom_connection.destroy
      .atom_connection.create(.n_atoms)
      .molecule_for_atom.destroy
      .molecule_for_atom.create(.n_atoms)

      molecule_for_atom.create(.n_atoms)
      do i = 1,.n_atoms
        molecule_for_atom(i) = i
      end

      i = 0
      do 

        i = i + 1
        if (i>.n_atoms) exit        ! no more connections found

        mi = molecule_for_atom(i)   ! atom i belongs to molecule "m"

        code = .occupation_list(i)  ! Occupation list code

        u  = code/1000

        ! No connections? next ...
        if (unit_cell_connection(u).element.destroyed) cycle

        ! Decode the unit cell atom and offset
                        code = code - u*1000
        h3 = code/100;  code = code - h3*100
        h2 = code/10;   code = code - h2*10
        h1 = code; 
        h1 = h1 - 5                 ! h is the cell offset
        h2 = h2 - 5
        h3 = h3 - 5                 

        ! Find atoms which connect to u
        do c = 1,unit_cell_connection(u).element.dim

           con => unit_cell_connection(u)[c].element

           k1 = h1 + con(1) + 5     ! get new code
           k2 = h2 + con(2) + 5
           k3 = h3 + con(3) + 5
           t  = con(4)              
           code = k1 + k2*10 + k3*100 + t*1000

           ! Is it new in the occupation list?
           old = .occupation_list.index_of_value(code)

           if (old>0) then          ! this is not a new atom
              mo = molecule_for_atom(old)
              if (mo<mi) then       ! replace all previous by the lowest molecule
                 where (molecule_for_atom==mi) molecule_for_atom = mo
                 mi = mo            ! replace molecule for atom i too
              else if (mo>mi) then
                 where (molecule_for_atom==mo) molecule_for_atom = mi
              end
              .atom_connection(i).element.append(old)
           end

        end
      end

      ! Sort molecule indices
      .molecule_for_atom = molecule_for_atom
      unique => molecule_for_atom.unique_elements
      .n_molecules = unique.dim
      unique.sort
      do mi = 1,.n_molecules
        mo = unique(mi)
        if (mo==mi) cycle
        where (molecule_for_atom==mo) .molecule_for_atom = mi
      end

      unique.destroy
      molecule_for_atom.destroy

   end

   do_defragment ::: leaky
   ! Defragment the generated cluster and find the connected molecules using the
   ! .unit_cell_connection table.

   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_connection.created,"no unit cell connection table")

      i,c,code,h1,h2,h3,u,k1,k2,k3,t,old,mi,mo :: INT
      con,unique,molecule_for_atom :: VEC{INT}*
      unit_cell_connection :: VEC{VEC_{VEC_{INT}}}* 

      unit_cell_connection => .crystal.unit_cell_connection

      .n_atoms = .occupation_list.dim
      .atom_connection.destroy
      .atom_connection.create(.n_atoms)
      .molecule_for_atom.destroy

      molecule_for_atom.create(.n_atoms)
      do i = 1,.n_atoms
        molecule_for_atom(i) = i
      end

      i = 0
      do 

        i = i + 1
        if (i>.n_atoms) exit        ! no more connections found

        mi = molecule_for_atom(i)   ! atom i belongs to molecule "m"

        code = .occupation_list(i)   ! decode the unit cell atom and offset

        u  = code/1000; code = code - u*1000
        h3 = code/100;  code = code - h3*100
        h2 = code/10;   code = code - h2*10
        h1 = code; 
        h1 = h1 - 5                 ! h is the cell offset
        h2 = h2 - 5
        h3 = h3 - 5                 ! find atoms which connect to u

        if (unit_cell_connection(u).element.destroyed) cycle

        do c = 1,unit_cell_connection(u).element.dim

           con => unit_cell_connection(u)[c].element
           k1 = h1 + con(1) + 5     ! get new code
           k2 = h2 + con(2) + 5
           k3 = h3 + con(3) + 5
           t  = con(4)              ! is it new in the occupation list?
           code = k1 + k2*10 + k3*100 + t*1000

           old = .occupation_list.index_of_value(code)

           if (old>0) then          ! this is not a new atom
              mo = molecule_for_atom(old)
              if (mo<mi) then       ! replace all previous by the lowest molecule
                 where (molecule_for_atom==mi) molecule_for_atom = mo
                 mi = mo            ! replace molecule for atom i too
              else if (mo>mi) then
                 where (molecule_for_atom==mo) molecule_for_atom = mi
              end
              .atom_connection(i).element.append(old)
           else                     ! this is new
              .occupation_list.append(code)
              molecule_for_atom.append(mi)
              .n_atoms = .n_atoms + 1
              .atom_connection.expand(.n_atoms)
              .atom_connection(i).element.append(.n_atoms)
           end                     

        end
      end

      .molecule_for_atom => molecule_for_atom
      molecule_for_atom.create_copy(.molecule_for_atom)
      unique => molecule_for_atom.unique_elements
      .n_molecules = unique.dim
      unique.sort
      do mi = 1,.n_molecules
        mo = unique(mi)
        if (mo==mi) cycle
        where (molecule_for_atom==mo) .molecule_for_atom = mi
      end

      unique.destroy
      molecule_for_atom.destroy

   end

   do_defragment(occupation_list) ::: leaky
   ! Defragment the "occupation_list"
      occupation_list :: VEC{INT}*

   ENSURE(occupation_list.created,"no occupation_list")
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_connection.created,"no unit cell connection table")

      n_atoms,i,c,code,h1,h2,h3,u,k1,k2,k3,t,old :: INT
      con :: VEC{INT}*
      unit_cell_connection :: VEC{VEC_{VEC_{INT}}}* 

      unit_cell_connection => .crystal.unit_cell_connection

      n_atoms = occupation_list.dim
      i = 0
      do 

        i = i + 1
        if (i>n_atoms) exit         ! no more connections found

        code = occupation_list(i)   ! decode the unit cell atom and offset

        u  = code/1000; code = code - u*1000
        h3 = code/100;  code = code - h3*100
        h2 = code/10;   code = code - h2*10
        h1 = code; 
        h1 = h1 - 5                 ! h is the cell offset
        h2 = h2 - 5
        h3 = h3 - 5                 ! find atoms which connect to u

        if (unit_cell_connection(u).element.destroyed) cycle

        do c = 1,unit_cell_connection(u).element.dim
           con => unit_cell_connection(u)[c].element
           k1 = h1 + con(1) + 5     ! get new code
           k2 = h2 + con(2) + 5
           k3 = h3 + con(3) + 5
           t  = con(4)              ! is it new in the occupation list?
           code = k1 + k2*10 + k3*100 + t*1000
           old = occupation_list.index_of_value(code)
           if (old>0) cycle         ! this is new
           occupation_list.append(code)
           n_atoms = n_atoms + 1
        end

      end
   end

   do_defragment_uc_atom(u,geometry) ::: leaky
   ! Defragment the "occupation_list" and produce a "geometry" in
   ! crystal coordinates.
      u :: INT, IN
      geometry :: MAT{REAL}*

      occupation_list :: VEC{INT}*

      occupation_list.create(1)
      occupation_list(1) = 5 + 5*10 + 5*100 + u*1000

      .do_defragment(occupation_list)
      .extract_geometry(occupation_list,geometry)

      occupation_list.destroy

   end

   do_defragment_uc_atom(u,symop,par,pos,mass) ::: leaky
   ! Defragment the "occ_list" and get some positional and symop
   ! information for, e.g. LFF refractive index calculations.
      u :: INT, IN
      symop :: INT, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      mass   :: VEC{REAL}, OUT

      occ_list :: VEC{INT}*

      ! Get symop for first atom in molecule
      symop = .crystal.symop_for_unit_cell_atom(u)

      ! Make the coded occ_list for this atom
      occ_list.create(1)
      occ_list(1) = 5 + 5*10 + 5*100 + u*1000

      ! Defragment this atom and get the molecule info
      .do_defragment(occ_list)
      .extract_molecule_atom_info(occ_list,par,pos,mass)

      ! Clean up
      occ_list.destroy

   end

   do_defragment_uc_atom(u,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m) ::: leaky
   ! Defragment the "occ_list" and get a whole load of electric
   ! property info for LFF refractive index calculations.
      u :: INT, IN
      symop :: MAT{REAL}, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT
      mass   :: VEC{REAL}, OUT
      dipole :: MAT{REAL}, OUT
      alpha_q :: MAT{REAL}, OUT
      alpha_m :: MAT3{REAL}, OUT

      occ_list :: VEC{INT}*

      occ_list.create(1)
      occ_list(1) = 5 + 5*10 + 5*100 + u*1000

      .do_defragment(occ_list)
      .extract_atom_info(occ_list,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m)

      occ_list.destroy

   end

   do_defragment_uc_atom(u,pos,charge,dipole,frag_atom) ::: leaky
   ! Defragment the "occ_list" and get a whole load of electric
   ! property info for LFF refractive index calculations.
      u :: INT, IN
      pos :: MAT{REAL}, OUT
      charge,dipole :: VEC{REAL}, OUT
      frag_atom :: VEC{INT}, optional

      occ_list :: VEC{INT}*

      occ_list.create(1)
      occ_list(1) = 5 + 5*10 + 5*100 + u*1000

      .do_defragment(occ_list)
      .extract_atom_info(occ_list,pos,charge,dipole,frag_atom)

      occ_list.destroy

   end

   extract_geometry ::: leaky
   ! Extract the geometry from the final .occupation list.
   ! Also extract the unit cell atoms.
   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.created,"no crystal unit cell geometry")

      i,code,h1,h2,h3,u :: INT

      .n_atoms = .occupation_list.dim
      .geometry.destroy
      .geometry.create(3,.n_atoms)
      .is_fragment_atom.destroy
      .is_fragment_atom.create(.n_atoms)

      i = 1
      do  i = 1,.n_atoms

        code = .occupation_list(i)  ! decode the unit cell atom and offset

        u  = code/1000; code = code - u*1000
        h3 = code/100;  code = code - h3*100
        h2 = code/10;   code = code - h2*10
        h1 = code; 
        h1 = h1 - 5                 ! h is the cell offset
        h2 = h2 - 5
        h3 = h3 - 5

        .geometry(:,i) = .crystal.unit_cell_geometry(:,u) &
                       + [h1,h2,h3] &
                       + .fragment_offset

        if (i<=.n_fragment_atoms) then; .is_fragment_atom(i) = TRUE 
        else;                           .is_fragment_atom(i) = FALSE
        end

      end
   end

   extract_geometry(occupation_list,geometry) ::: leaky
   ! Extract the cluster "geometry" from the "occupation_list".
      occupation_list :: VEC{INT}, IN
      geometry :: MAT{REAL}*

   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.created,"no crystal unit cell geometry")

      n_atoms,i,code,h1,h2,h3,u :: INT

      ! Create the cluster geometry array
      n_atoms = occupation_list.dim
      geometry.create(3,n_atoms)

      do  i = 1,n_atoms

        code = occupation_list(i)   

        ! Get unit cell atom u and cell offset h
        u  = code/1000; code = code - u*1000
        h3 = code/100;  code = code - h3*100
        h2 = code/10;   code = code - h2*10
        h1 = code; 
        h1 = h1 - 5          
        h2 = h2 - 5
        h3 = h3 - 5

        ! Get the cluster atom position
        geometry(:,i) = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset

      end

   end

   extract_molecule_atom_info(occ_list,par,pos,mass)
   ! From a *molecule* "occ_list", extract the atom positions "pos",
   ! the "symop" for the first atom, the asymmetric atom parents "par", 
   ! and masses "mass".
      occ_list :: VEC{INT}, IN
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      mass :: VEC{REAL}, OUT

   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.created,"no crystal unit cell geometry")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")
   ENSURE(.crystal.frag_atom_for_unit_cell_atom.created,"no frag_atom_for_unit_cell_atom")
   ENSURE(.asymmetric_unit_atom.created, "no asymmetric_cell_atom data")
   ENSURE(mass.dim==occ_list.dim, "mass, wrong size")
   ENSURE(pos.dim1==3 AND pos.dim2==occ_list.dim, "pos, wrong size")

      i,code,u,h1,h2,h3,p,s :: INT


      ! Get atom info
      do  i = 1,occ_list.dim

        code = occ_list(i)   

        ! Get unit cell atom u and cell offset [h1,h2,h3]
        u  = code/1000; code = code - u*1000
        h3 = code/100;  code = code - h3*100
        h2 = code/10;   code = code - h2*10
        h1 = code; 
        h1 = h1 - 5          
        h2 = h2 - 5
        h3 = h3 - 5

        ! Get the atom position (cartesian)
        pos(:,i) = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
        pos(:,i) = matmul(.crystal.unit_cell.direct_matrix,pos(:,i))

        ! Get parent asymmetric atom and symop
        p = .crystal.asym_atom_for_unit_cell_atom(u)
        par(i) = p

        ! Atomic mass
        mass(i) = .asymmetric_unit_atom(p).mass

      end

   end

   extract_atom_info(occ_list,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m)
   ! From the "occ_list", extract the atom positions "pos" , the
   ! atomic charges and masses "charge" and "mass", atomic dipoles
   ! "dipole", atomic charge polarisabilities "alpha_q" and dipole
   ! polarisabilities "alpha_m". This assumes that the quantities are
   ! available and non-zero. NOTE: "pos" and everything is in cartesians.
      occ_list :: VEC{INT}, IN
      symop :: MAT{REAL}, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT
      mass   :: VEC{REAL}, OUT
      dipole :: MAT{REAL}, OUT
      alpha_q :: MAT{REAL}, OUT
      alpha_m :: MAT3{REAL}, OUT

   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.created,"no crystal unit cell geometry")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")
   ENSURE(.crystal.symop_for_unit_cell_atom.created,"no crystal symop_for_unit_cell_atom")
   ENSURE(.crystal.symop_for_unit_cell_atom.created,"no crystal symop_for_unit_cell_atom")
   ENSURE(.crystal.frag_atom_for_unit_cell_atom.created,"no frag_atom_for_unit_cell_atom")
   ENSURE(.asymmetric_unit_atom.created, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_dipoles,"no atomic dipoles, did you calc them?")
   ENSURE(.asymmetric_unit_atom.has_polarisabilities,"no atomic polarisabilities, did you calc?")
   ENSURE(charge.dim==occ_list.dim, "charge, wrong size")
   ENSURE(mass.dim==occ_list.dim, "mass, wrong size")
   ENSURE(pos.dim1==3 AND pos.dim2==occ_list.dim, "pos, wrong size")
   ENSURE(dipole.dim1==3 AND dipole.dim2==occ_list.dim, "dipole, wrong size")
   ENSURE(alpha_q.dim1==3 AND alpha_q.dim2==occ_list.dim, "alpha_q, wrong size")
   ENSURE(alpha_m.dim1==3 AND alpha_m.dim2==3 AND alpha_m.dim3==occ_list.dim, "alpha_m, wrong size")

      T  :: MAT{REAL}*
      inverse_seitz :: MAT3{REAL}*
      i,code,h1,h2,h3,u, p,s :: INT

      ! Transposed/Inverse symops
      inverse_seitz => .crystal.transposed_xyz_seitz_matrices

      do  i = 1,occ_list.dim

        code = occ_list(i)   

        ! Get unit cell atom u and cell offset h
        u  = code/1000; code = code - u*1000
        h3 = code/100;  code = code - h3*100
        h2 = code/10;   code = code - h2*10
        h1 = code; 
        h1 = h1 - 5          
        h2 = h2 - 5
        h3 = h3 - 5

        ! Get the cluster atom position
        pos(:,i) = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
        pos(:,i) = matmul(.crystal.unit_cell.direct_matrix,pos(:,i))

        ! Get parent asymmetric atom and symop
        p = .crystal.asym_atom_for_unit_cell_atom(u)
        s = .crystal.symop_for_unit_cell_atom(u)
        T => inverse_seitz(:,:,s) 
        par(i) = p

        ! Return inverse symop
        symop = T

!  stdout.show("atom          = ",i)
!  stdout.show("atomic number =",.asymmetric_unit_atom(p).atomic_number)
!  stdout.show("asym parent   =",p)
!  stdout.show("asym pos      =",.asymmetric_unit_atom(p).pos)
!  stdout.text("T:")
!  stdout.put(T)

        ! Warning, the asymmetric_unit_atom's should be generated from
        ! the fragment on which the charge and dipole polarisability
        ! calculations (see below) have been done.

        ! Atomic charge. 
        charge(i) = .asymmetric_unit_atom(p).charge &
                  - .asymmetric_unit_atom(p).atomic_number
        mass(i)   = .asymmetric_unit_atom(p).mass
!  stdout.show("charge        =",charge(i))
!  stdout.show("mass          =",mass(i))

        ! Atomic dipole
        dipole(:,i) = matmul(transpose(T),.asymmetric_unit_atom(p).dipole)
!  stdout.show("dipole parent =",.asymmetric_unit_atom(p).dipole)
!  stdout.show("dipole        =",dipole(:,i))

        ! Atomic charge polarisability
        alpha_q(:,i) = matmul(.asymmetric_unit_atom(p).charge_polarisability,T)
!  stdout.show("alpha_q par   =",.asymmetric_unit_atom(p).charge_polarisability)
!  stdout.show("alpha_q       =",alpha_q(:,i))

        ! Atomic dipole polarisability
        alpha_m(:,:,i) = .asymmetric_unit_atom(p).dipole_polarisability
        alpha_m(:,:,i).change_basis_using(T)
!  stdout.text("alpha_m:")
!  stdout.put(alpha_m(:,:,i))

      end

      inverse_seitz.destroy

   end

   extract_atom_info(occ_list,pos,charge,dipole,frag_atom)
   ! From the "occ_list", extract the atom positions "pos" , the
   ! atomic charges and masses "charge" and "mass", atomic dipoles
   ! "dipole", atomic charge polarisabilities "alpha_q" and dipole
   ! polarisabilities "alpha_m". This assumes that the quantities are
   ! available and non-zero. NOTE: "pos" and everything is in cartesians.
      occ_list :: VEC{INT}, IN
      pos :: MAT{REAL}, OUT
      charge,dipole :: VEC{REAL}, OUT
      frag_atom :: VEC{INT}, OUT, optional

   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.created,"no crystal unit cell geometry")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")
   ENSURE(.crystal.symop_for_unit_cell_atom.created,"no crystal symop_for_unit_cell_atom")
   ENSURE(.crystal.frag_atom_for_unit_cell_atom.created,"no frag_atom_for_unit_cell_atom")
   ENSURE(.asymmetric_unit_atom.created, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_dipoles,"no atomic dipoles, did you calc them?")
   ENSURE(pos.dim1==3 AND pos.dim2==occ_list.dim, "pos, wrong size")
   ENSURE(charge.dim==occ_list.dim, "charge, wrong size")
   ENSURE(dipole.dim==3*occ_list.dim, "dipole, wrong size")

      seitz :: MAT3{REAL}*
      i,l,code,h1,h2,h3,u, p,s :: INT

      ! Symops
      seitz => .crystal.xyz_seitz_matrices
      l = 0

      do  i = 1,occ_list.dim

        code = occ_list(i)   

        ! Get unit cell atom u and cell offset h
        u  = code/1000; code = code - u*1000
        h3 = code/100;  code = code - h3*100
        h2 = code/10;   code = code - h2*10
        h1 = code; 
        h1 = h1 - 5          
        h2 = h2 - 5
        h3 = h3 - 5

        ! Get the cluster atom position
        pos(:,i) = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
        pos(:,i) = matmul(.crystal.unit_cell.direct_matrix,pos(:,i))

        ! Get parent asymmetric atom and symop
        p = .crystal.asym_atom_for_unit_cell_atom(u)
        s = .crystal.symop_for_unit_cell_atom(u)

        ! Parent and symop
      ! par(i) = p
      ! symop(i) = s

        ! Warning, the asymmetric_unit_atom's should be generated from
        ! the fragment on which the charge and dipole polarisability
        ! calculations (see below) have been done.

        ! Get the info
        charge(i) = .asymmetric_unit_atom(p).charge 
        dipole(l+1:l+3) = matmul(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)
        l = l + 3

        ! Fragment atom list
        if (NOT present(frag_atom)) cycle
        frag_atom(i) = .crystal.frag_atom_for_unit_cell_atom(u)

      end

      seitz.destroy

   end

!  *******************
!  Cluster information
!  *******************

!   minimum_distance2_to_xyz(pos,closest_atom) result (res)
!   ! Return the minimum atom separation squared between the .fragment_geometry
!   ! and a position "pos" given in cartesian coordinates. If present,
!   ! "closest_atom" is set to the index of the atom (i.e. column) of
!   ! .fragment_geometry whose position is closest to "pos".
!     pos :: VEC{REAL}(3)
!     closest_atom :: INT, optional
!     res :: REAL
!   ENSURE(.fragment_geometry.created,"no fragment geometry")
!   ENSURE(.crystal.created,"no crystal data")
!     diff :: MAT{REAL}*
!     r2 :: VEC{REAL}*
!     diff.create(3,.n_fragment_atoms)
!     r2.create(.n_fragment_atoms)
!     diff = .fragment_geometry - spread(pos,2,.n_fragment_atoms)
!     diff.get_column_dot_products(r2)
!     res = minval(r2)
!     if (present(closest_atom)) closest_atom = minval(minloc(r2))
!     r2.destroy
!     diff.destroy
!   end

!   minimum_distance_to(pos,closest_atom) result (res)
!   ! Return the minimum atom separation between the .fragment_geometry
!   ! and a position "pos" given in crystal axis coordinates. If present,
!   ! "closest_atom" is set to the index of the atom (i.e. column) of
!   ! .fragment_geometry whose position is closest to "pos".
!     pos :: VEC{REAL}(3)
!     closest_atom :: INT, optional
!     res :: REAL
!   ENSURE(.fragment_geometry.created,"no fragment geometry")
!   ENSURE(.crystal.created,"no crystal data")
!     diff :: MAT{REAL}*
!     norms :: VEC{REAL}*
!     diff.create(3,.n_fragment_atoms)
!     norms.create(.n_fragment_atoms)
!     diff = .fragment_geometry - spread(pos,2,.n_fragment_atoms)
!     .crystal.unit_cell.change_from_fractional(diff)  ! Put in cartesians.
!     diff.get_column_norms(norms)
!     res = minval(norms)
!     if (present(closest_atom)) closest_atom = minval(minloc(norms))
!     norms.destroy
!     diff.destroy
!   end

!   minimum_distance_to(pos) result (res)
!   ! Return the minimum atom separation between the .fragment_geometry
!   ! and another geometry "pos" given in crystal axis coordinates.
!     pos :: MAT{REAL}
!     res :: REAL
!   ENSURE(pos.dim2>0,"no atom positions")
!     i :: INT
!     res = .minimum_distance_to(pos(:,1))
!     do i = 2,pos.dim2
!        res = min(.minimum_distance_to(pos(:,i)),res)
!     end
!   end

   cartesian_geometry result (res) ::: leaky
   ! Return the cartesian geometry for the cluster
      res :: MAT{REAL}*
   ENSURE(.fragment_geometry.created,"no fragment geometry")
   ENSURE(.crystal.created,"no crystal data")
      res.create(3,.n_atoms)
      .crystal.unit_cell.change_from_fractional(.geometry)
   end

   cluster_width result (res)
   ! Return the width "res" of the cluster in each of the 3 axis directions.
   ! NOTE: using crystal axis system.
      res :: VEC{REAL}(3)
   ENSURE(.geometry.created,"no fragment geometry")
      res = .geometry.max_abs_column_difference
   end

   create_fragment_atom_list(fragment_atom) ::: leaky
   ! Create the "fragment_atom" list.
      fragment_atom :: VEC{ATOM}*
   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.is_fragment_atom.created,"no fragment atoms")
   ENSURE(.crystal.created,"no crystal info")
      fragment_atom.create(.n_fragment_atoms)
      .make_fragment_atom_list(fragment_atom)
   end

   make_fragment_atom_list(fragment_atom)
   ! Make the "fragment_atom" list, a VEC{ATOM}
      fragment_atom :: VEC{ATOM}
   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.n_atoms>0,"no atoms")
   ENSURE(.is_fragment_atom.created,"no fragment atoms")
   ENSURE(.geometry.created,"no geometry")
   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric_cell_atom")
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")

      ulist :: VEC{INT}*
      a,n,u,p :: INT

      ulist.create(.n_atoms)
      ulist = .occupation_list/1000              
      n = 0
      do a = 1,.n_atoms
         if (NOT .is_fragment_atom(a)) cycle
         n = n + 1
         u = ulist(a)
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         fragment_atom(n) = .asymmetric_unit_atom(p)
         fragment_atom(n).pos = .geometry(:,a)
         fragment_atom(n).axis_system = "crystal"
         fragment_atom(n).thermal_axis_system = "cartesian"
      end

      ulist.destroy

      fragment_atom.resolve_axis_system(.crystal.unit_cell)

   end

   fragment_atom_indices result (res) 
   ! Return the indices of the fragment atoms in the cluster.
      res :: VEC{INT}(.n_fragment_atoms)
   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.is_fragment_atom.created,"no fragment atoms")
      a,n :: INT
      n = 0
      do a = 1,.n_atoms
         if (NOT .is_fragment_atom(a)) cycle
         n = n + 1
         res(n) = a
      end
   end

   nonfragment_atom_indices result (res) 
   ! Return the indices of the nonfragment atoms in the cluster.
      res :: VEC{INT}(.n_atoms-.n_fragment_atoms)
   ENSURE(.n_atoms>.n_fragment_atoms,"no nonfragment atoms")
   ENSURE(.is_fragment_atom.created,"no fragment atoms")
      a,n :: INT
      n = 0
      do a = 1,.n_atoms
         if (.is_fragment_atom(a)) cycle
         n = n + 1
         res(n) = a
      end
   end

   create_atom_list(atom) ::: leaky
   ! Create and make a new atom list for the cluster
   ! NOTE: basis sets are pointer copied!
      atom :: VEC{ATOM}*
   ENSURE(.fragment_geometry.created, "no crystal fragment geometry")
   ENSURE(.crystal.created, "no crystal data")
   ENSURE(.asymmetric_unit_atom.created, "no atom data")
   ENSURE(.n_atoms>0,"no atoms in cluster")
      atom.create(.n_atoms)
      .make_atom_list(atom)
   end

   make_atom_list(atom)
   ! Make a new atom list for the cluster. Note that the .asymmetric_unit_atom's
   ! must have thermal tensors in the cartesian axis system; this will normally
   ! be the case for Tonto's internal representation ....
   ! NOTE: basis sets are pointer copied!
      atom :: VEC{ATOM}
   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(atom.dim==.n_atoms,"wrong size, atomsr")
   ENSURE(.geometry.created,"no geometry")
   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.crystal.created, "no crystal data")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")
   ENSURE(.crystal.symop_for_unit_cell_atom.created,"no crystal symop_for_unit_cell_atom")
   ENSURE(.asymmetric_unit_atom.created, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_cartesian_thermal_axes, "thermal tensors must be in cartesian axis system")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      therm :: MAT{REAL}(3,3)
      a,u,p,s :: INT

      ulist.create(.n_atoms)
      ulist = .occupation_list/1000              

      seitz => .crystal.transposed_xyz_seitz_matrices    ! transposed !

      do a = 1,.n_atoms
        u = ulist(a)
        p = .crystal.asym_atom_for_unit_cell_atom(u)
        s = .crystal.symop_for_unit_cell_atom(u)
        atom(a).copy(.asymmetric_unit_atom(p))          ! make copy, but .basis is a ptr copy
        atom(a).pos = .geometry(:,a)                    ! position is in crystal axis system
        atom(a).axis_system = "crystal"                 ! ... 
        therm = .asymmetric_unit_atom(p).thermal_tensor ! This must be in cartesian axes
        therm.change_basis_using(seitz(:,:,s))          ! Use R^T to change U tensor basis
        atom(a).thermal_tensor = therm                  
        atom(a).thermal_axis_system = "cartesian"       ! ... in cartesians ...
      end

      seitz.destroy
      ulist.destroy
     
      atom.resolve_axis_system(.crystal.unit_cell)       ! Change pos & thermals to cartesian

   end

   make_non_fragment_mu_charges(pos,charge)
   ! Make a list of the non-fragment atom positions and charges.
   ! The point charges used are derived from the atomic charges and
   ! dipoles only.
      pos :: MAT{REAL}
      charge :: VEC{REAL}

   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(pos.dim2==3*(.n_atoms-.n_fragment_atoms),"wrong dim2, pos")
   ENSURE(charge.dim==pos.dim2,"wrong dim, charge")
   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.crystal.created, "no crystal data")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")
   ENSURE(.crystal.symop_for_unit_cell_atom.created,"no crystal symop_for_unit_cell_atom")
   ENSURE(.asymmetric_unit_atom.created, "no asymmetric_cell_atom data")

      seitz  :: MAT3{REAL}*
      dipole :: VEC{REAL}(3)
      d,mu,q :: REAL
      a,i,code,h1,h2,h3,u, p,s :: INT

      ! XYZ symops
      seitz => .crystal.xyz_seitz_matrices       

      i = -2
      do a = 1,.n_atoms

        if (.is_fragment_atom(a)) cycle

        i = i + 3

        code = .occupation_list(a)   

        ! Get unit cell atom u and cell offset h
        u  = code/1000; code = code - u*1000
        h3 = code/100;  code = code - h3*100
        h2 = code/10;   code = code - h2*10
        h1 = code; 
        h1 = h1 - 5          
        h2 = h2 - 5
        h3 = h3 - 5

        ! Get the cluster atom position
        pos(:,i) = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
        pos(:,i) = matmul(.crystal.unit_cell.direct_matrix,pos(:,i))

        ! Get parent asymmetric atom and symop
        p = .crystal.asym_atom_for_unit_cell_atom(u)
        s = .crystal.symop_for_unit_cell_atom(u)

        ! Atomic charge
        charge(i) = .asymmetric_unit_atom(p).charge 

        ! Atomic dipole
        dipole    = matmul(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)

        ! Make the two charges
        d = TOL(2) ! Twice the shift along dipole direction
        mu = dipole.norm
        q = mu/d
        dipole = dipole/mu * d * HALF
        pos(:,i+1) = pos(:,i) + dipole
        pos(:,i+2) = pos(:,i) - dipole
        charge(i+1) =  q
        charge(i+2) = -q

      end
      seitz.destroy

   end

   make_non_fragment_qq_charges(pos,charge)
   ! Make a list of the non-fragment atom positions and charges
   ! The point charges used are derived from the atomic charges, 
   ! dipoles, and *quadrupoles*
      pos :: MAT{REAL}
      charge :: VEC{REAL}

   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(pos.dim2==9*(.n_atoms-.n_fragment_atoms),"wrong dim2, pos")
   ENSURE(charge.dim==pos.dim2,"wrong dim, charge")
   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.crystal.created, "no crystal data")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")
   ENSURE(.crystal.symop_for_unit_cell_atom.created,"no crystal symop_for_unit_cell_atom")
   ENSURE(.asymmetric_unit_atom.created, "no asymmetric_cell_atom data")

      seitz  :: MAT3{REAL}*
      dipole,eval :: VEC{REAL}(3)
      quadrupole,evec :: MAT{REAL}(3,3)
      d,mu,q :: REAL
      a,i,code,h1,h2,h3,u, p,s :: INT

      ! XYZ symops
      seitz => .crystal.xyz_seitz_matrices       

      i = 1
      do a = 1,.n_atoms

        if (.is_fragment_atom(a)) cycle

        code = .occupation_list(a)   

        ! Get unit cell atom u and cell offset h
        u  = code/1000; code = code - u*1000
        h3 = code/100;  code = code - h3*100
        h2 = code/10;   code = code - h2*10
        h1 = code; 
        h1 = h1 - 5          
        h2 = h2 - 5
        h3 = h3 - 5

        ! Get the cluster atom position
        pos(:,i) = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
        pos(:,i) = matmul(.crystal.unit_cell.direct_matrix,pos(:,i))

        ! Get parent asymmetric atom and symop
        p = .crystal.asym_atom_for_unit_cell_atom(u)
        s = .crystal.symop_for_unit_cell_atom(u)

        ! Atomic charge
        charge(i)  = .asymmetric_unit_atom(p).charge 

        ! Atomic dipole
        dipole     = matmul(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)

        ! Atomic quadrupole
        .asymmetric_unit_atom(p).quadrupole.back_transform_to(quadrupole,seitz(:,:,s))

        ! Make the two charges
        d = TOL(2) ! Twice the shift along dipole direction
        mu = dipole.norm
        q = mu/d
        dipole = dipole/mu * d * HALF
        pos(:,i+1) = pos(:,i) + dipole
        pos(:,i+2) = pos(:,i) - dipole
        charge(i+1) =  q
        charge(i+2) = -q

        ! Make the diagonal quadrupoles
        quadrupole.solve_eigenproblem(eval,evec)
        evec = d*evec/TWO             ! Charge at d/2 along eigenvectors
        eval = eval/(d*d) ! Should be x 4 for single charge
        ! Two charges on axis at +d/2 and -d/2
        pos(:,i+3)   = pos(:,i) + evec(:,1)
        pos(:,i+4)   = pos(:,i) - evec(:,1)
        pos(:,i+5)   = pos(:,i) + evec(:,2)
        pos(:,i+6)   = pos(:,i) - evec(:,2)
        pos(:,i+7)   = pos(:,i) + evec(:,3)
        pos(:,i+8)   = pos(:,i) - evec(:,3)
        charge(i+3)  = TWO*eval(1)
        charge(i+4)  = TWO*eval(1)
        charge(i+5)  = TWO*eval(2)
        charge(i+6)  = TWO*eval(2)
        charge(i+7)  = TWO*eval(3)
        charge(i+8)  = TWO*eval(3)
        charge(i  )  = charge(i) & ! correct monopole charge
                     - FOUR*eval(1) - FOUR*eval(2) - FOUR*eval(3)
!        ! Four charges in the plane at 
!        ! (+d/2,+d/2), (-d/2,-d/2)
!        ! (+d/2,-d/2), (-d/2,+d/2)
!        pos(:,i+9 )  = pos(:,i) + unit(:,1) + unit(:,2)
!        pos(:,i+10)  = pos(:,i) - unit(:,1) - unit(:,2)
!        pos(:,i+11)  = pos(:,i) + unit(:,1) - unit(:,2)
!        pos(:,i+12)  = pos(:,i) - unit(:,1) + unit(:,2)
!        charge(i+9 ) =  quadrupole(1,2)
!        charge(i+10) =  quadrupole(1,2)
!        charge(i+11) = -quadrupole(1,2)
!        charge(i+12) = -quadrupole(1,2)
!        pos(:,i+13)  = pos(:,i) + unit(:,1) + unit(:,3)
!        pos(:,i+14)  = pos(:,i) - unit(:,1) - unit(:,3)
!        pos(:,i+15)  = pos(:,i) + unit(:,1) - unit(:,3)
!        pos(:,i+16)  = pos(:,i) - unit(:,1) + unit(:,3)
!        charge(i+13) =  quadrupole(1,3)
!        charge(i+14) =  quadrupole(1,3)
!        charge(i+15) = -quadrupole(1,3)
!        charge(i+16) = -quadrupole(1,3)
!        pos(:,i+17)  = pos(:,i) + unit(:,2) + unit(:,3)
!        pos(:,i+18)  = pos(:,i) - unit(:,2) - unit(:,3)
!        pos(:,i+19)  = pos(:,i) + unit(:,2) - unit(:,3)
!        pos(:,i+20)  = pos(:,i) - unit(:,2) + unit(:,3)
!        charge(i+17) =  quadrupole(2,3)
!        charge(i+18) =  quadrupole(2,3)
!        charge(i+19) = -quadrupole(2,3)
!        charge(i+20) = -quadrupole(2,3)

        i = i + 9

      end
      seitz.destroy

   end

!   make_non_fragment_positions2(pos,charge)
!   ! Make a list of the non-fragment atom positions and charges.
!   ! The point charges used are derived from the atoic charges and
!   ! dipoles only.
!      pos :: MAT{REAL}
!      charge :: VEC{REAL}
!
!   ENSURE(.n_atoms>0,"no atoms in cluster")
!   ENSURE(pos.dim2==2*(.n_atoms-.n_fragment_atoms),"wrong dim2, pos")
!   ENSURE(charge.dim==pos.dim2,"wrong dim, charge")
!   ENSURE(.occupation_list.created,"no occupation_list")
!   ENSURE(.crystal.created, "no crystal data")
!   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")
!   ENSURE(.crystal.symop_for_unit_cell_atom.created,"no crystal symop_for_unit_cell_atom")
!   ENSURE(.asymmetric_unit_atom.created, "no asymmetric_cell_atom data")
!
!      seitz  :: MAT3{REAL}*
!      dipole,r :: VEC{REAL}(3)
!      d,mu,q :: REAL
!      a,i,code,h1,h2,h3,u, p,s :: INT
!
!      ! XYZ symops
!      seitz => .crystal.xyz_seitz_matrices       
!
!      i = -1
!      do a = 1,.n_atoms
!
!        if (.is_fragment_atom(a)) cycle
!
!        i = i + 2
!
!        code = .occupation_list(a)   
!
!        ! Get unit cell atom u and cell offset h
!        u  = code/1000; code = code - u*1000
!        h3 = code/100;  code = code - h3*100
!        h2 = code/10;   code = code - h2*10
!        h1 = code; 
!        h1 = h1 - 5          
!        h2 = h2 - 5
!        h3 = h3 - 5
!
!        ! Get the cluster atom position
!        r = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
!        r = matmul(.crystal.unit_cell.direct_matrix,r)
!
!        ! Get parent asymmetric atom and symop
!        p = .crystal.asym_atom_for_unit_cell_atom(u)
!        s = .crystal.symop_for_unit_cell_atom(u)
!
!        ! Atomic charge
!        charge(i) = .asymmetric_unit_atom(p).charge 
!
!        ! Atomic dipole
!        dipole    = matmul(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)
!
!        ! Make the two charges
!        d = TOL(2) ! Twice the shift along dipole direction
!        mu = dipole.norm
!        q = mu/d
!        dipole = dipole/mu * d * HALF
!        pos(:,i+0) = r + dipole
!        pos(:,i+1) = r - dipole
!        charge(i+0) =  q
!        charge(i+1) = -q
!
!      end
!      seitz.destroy
!
!   end
!
!   make_non_fragment_positions3(pos,charge)
!   ! Make a list of the non-fragment atom positions and charges.
!   ! The point charges used are derived from the atoic charges and
!   ! dipoles only.
!      pos :: MAT{REAL}
!      charge :: VEC{REAL}
!
!   ENSURE(.n_atoms>0,"no atoms in cluster")
!   ENSURE(pos.dim2==(.n_atoms-.n_fragment_atoms),"wrong dim2, pos")
!   ENSURE(charge.dim==pos.dim2,"wrong dim, charge")
!   ENSURE(.occupation_list.created,"no occupation_list")
!   ENSURE(.crystal.created, "no crystal data")
!   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")
!   ENSURE(.crystal.symop_for_unit_cell_atom.created,"no crystal symop_for_unit_cell_atom")
!   ENSURE(.asymmetric_unit_atom.created, "no asymmetric_cell_atom data")
!
!      seitz  :: MAT3{REAL}*
!      dipole,r :: VEC{REAL}(3)
!      d,mu,q :: REAL
!      a,i,code,h1,h2,h3,u, p,s :: INT
!
!      ! XYZ symops
!      seitz => .crystal.xyz_seitz_matrices       
!
!      i = 0
!      do a = 1,.n_atoms
!
!        if (.is_fragment_atom(a)) cycle
!
!        i = i + 1
!
!        code = .occupation_list(a)   
!
!        ! Get unit cell atom u and cell offset h
!        u  = code/1000; code = code - u*1000
!        h3 = code/100;  code = code - h3*100
!        h2 = code/10;   code = code - h2*10
!        h1 = code; 
!        h1 = h1 - 5          
!        h2 = h2 - 5
!        h3 = h3 - 5
!
!        ! Get the cluster atom position
!        r = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
!        r = matmul(.crystal.unit_cell.direct_matrix,r)
!
!        ! Get parent asymmetric atom and symop
!        p = .crystal.asym_atom_for_unit_cell_atom(u)
!        s = .crystal.symop_for_unit_cell_atom(u)
!
!        ! Atomic charge
!        charge(i) = .asymmetric_unit_atom(p).charge 
!
!        ! Atomic dipole
!        dipole    = matmul(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)
!
!        ! Make the two charges
!        d = TOL(2) ! Twice the shift along dipole direction
!        mu = dipole.norm
!        q = mu/d
!        dipole = dipole/mu * d * HALF
!        pos(:,i+0) = r 
!
!      end
!      seitz.destroy
!
!   end

   add_uc_tensors(tensor) ::: template
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
      tensor :: TENSOR_TYPE

   ENSURE(.generation_method=="unit_cell","only for unit_cell clusters, for whole molecule fragment")
   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.crystal.created, "no crystal data")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")
   ENSURE(.crystal.symop_for_unit_cell_atom.created,"no crystal symop_for_unit_cell_atom")
   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      tensor0,tensor1 :: TENSOR_TYPE
      m,a,u,s :: INT

      tensor0 = tensor
      tensor = ZERO

      ulist.create(.n_atoms)
      ulist = .occupation_list/1000              
      seitz => .crystal.transposed_xyz_seitz_matrices       ! transposed !
         ! stdout.text("Making unit cell tensor")
         ! stdout.text("original tensor")
         ! stdout.put(tensor0)

      do m = 1,.crystal.n_unit_cell_mols
        do a = 1,.n_atoms
           if (.crystal.unit_cell_mol_for_atom(a)/=m) cycle
           u = ulist(a)
           s = .crystal.symop_for_unit_cell_atom(u)
           tensor0.change_basis_to(tensor1,seitz(:,:,s))   ! Use R^T to change U tensor basis
           tensor = tensor + tensor1

         ! stdout.show("molecule =",m)
         ! stdout.show("symop    =",s)
         ! stdout.put(seitz(:,:,s))
         ! stdout.text("transformed tensor")
         ! stdout.put(tensor1)

           exit

        end
      end

      seitz.destroy
      ulist.destroy

   end

   add_uc_tensors(tensor) ::: get_from(CLUSTER, TENSOR_TYPE=>MAT{REAL}(3,3))
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
   end

   add_uc_tensors(tensor) ::: get_from(CLUSTER, TENSOR_TYPE=>MAT3{REAL}(3,3,3))
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
   end

!  ****************************************
!  Cluster transformations on matrices, etc
!  ****************************************

!   read_partition_factors ::: leaky
!   ! Read the partition factors to be used. Note that the length of this array
!   ! must correspond to the number of atoms in the generated cluster in order to
!   ! be used. This cannot be checked at this point in the code.
!      stdin.read_ptr(.partition_factor)
!   end

!   make_partition_factors(matrix) ::: leaky
!   ! Make the partition factors from the cluster-fragment mapping information.
!     matrix :: MAT{REAL}
!   ENSURE(.asymmetric_unit_atom.created, "no atom data")
!     n_atom,a1,a2,f1,l1,f2,l2 :: INT
!     first_basis_fn_for_atom,last_basis_fn_for_atom :: VEC{INT}*
!     factor :: REAL
!     .asymmetric_unit_atom.make_atom_basis_fn_limits(first_basis_fn_for_atom,last_basis_fn_for_atom)
!     n_atom = .asymmetric_unit_atom.n_atom
!     do a1 = 1,n_atom
!       f1 = first_basis_fn_for_atom(a1)
!       l1 = last_basis_fn_for_atom(a1)
!       do a2 = 1,n_atom
!         f2 = first_basis_fn_for_atom(a2)
!         l2 = last_basis_fn_for_atom(a2)
!         ! Mulliken partitioning
!         factor = (.partition_factor(a1)+.partition_factor(a2))/TWO
!         matrix(f1:l1,f2:l2) = factor * matrix(f1:l1,f2:l2)
!       end
!     end
!     last_basis_fn_for_atom.destroy
!     first_basis_fn_for_atom.destroy
!   end

!   partition_density(matrix) ::: leaky
!   ! Applies atomic partition factors to the density matrix, useful for zeroing
!   ! out certain atoms.
!     matrix :: MAT{REAL}
!   ENSURE(.asymmetric_unit_atom.created, "no atom data")
!     n_atom,a1,a2,f1,l1,f2,l2 :: INT
!     first_basis_fn_for_atom,last_basis_fn_for_atom :: VEC{INT}*
!     factor :: REAL
!     .asymmetric_unit_atom.make_atom_basis_fn_limits(first_basis_fn_for_atom,last_basis_fn_for_atom)
!     n_atom = .asymmetric_unit_atom.n_atom
!     do a1 = 1,n_atom
!       f1 = first_basis_fn_for_atom(a1)
!       l1 = last_basis_fn_for_atom(a1)
!       do a2 = 1,n_atom
!         f2 = first_basis_fn_for_atom(a2)
!         l2 = last_basis_fn_for_atom(a2)
!         ! Mulliken partitioning
!         factor = (.partition_factor(a1)+.partition_factor(a2))/TWO
!         matrix(f1:l1,f2:l2) = factor * matrix(f1:l1,f2:l2)
!       end
!     end
!     last_basis_fn_for_atom.destroy
!     first_basis_fn_for_atom.destroy
!   end

!   make_density_matrix(P,D,atom)
!   ! Make a cluster density matrix "P" from a fragment density matrix "D", given
!   ! a new cluster "atom" list (see routine create_atom_list).
!     P,D :: MAT{REAL}
!     atom :: VEC{ATOM}
!   ENSURE(.crystal.created, "no crystal data")
!   ENSURE(.asymmetric_unit_atom.created, "no atom data")
!   ENSURE(.asymmetric_unit_atom.bases_are_all_labeled,"unlabelled bases!")
!   ENSURE(D.is_square AND D.dim1==.asymmetric_unit_atom.n_bf,"D wrong shape")
!   ENSURE(P.is_square AND P.dim1==atom.n_bf,"P wrong shape")
!   ENSURE(.partition_factor.created,"no partition factors")
!     ptr :: MAT3{REAL}*
!     tr :: VEC{MAT3_{REAL}}*
!     tr1,tr2,pc, W :: MAT{REAL}*
!     f1,l1,s1,n1,m1,a1,c1,f2,l2,s2,n2,m2,a2,c2 :: INT
!     n_shell, q,s,f3,l3,f4,l4 :: INT
!     atom_for_shell, first,last, first_fn,last_fn :: VEC{INT}*
!     n_shell = .asymmetric_unit_atom.n_shell
!     atom_for_shell => .asymmetric_unit_atom.atom_for_shell
!     .asymmetric_unit_atom.make_atom_basis_fn_limits(first,last)
!      atom.make_atom_basis_fn_limits(first_fn,last_fn)
!     ptr => .crystal.transposed_xyz_seitz_matrices ! transposes here
!     ptr.transpose_12
!     tr.make_gaussian_xyz_matrices(ptr)
!     ptr.destroy
!     pc => .atom_pair_parent_count
!     do q = 1,.n_symop
!       s = .symop(1,q)
!       ! Transform each shell pair by symop "s"
!       do s1 = 1,n_shell
!         f1 = first(s1); l1 = last(s1); n1 = (l1-f1+1)
!         a1 = atom_for_shell(s1)
!         c1 = .atom_for_cell_atom(a1,q) ! cluster atom index
!         f3 = first_fn(c1); l3 = last_fn(c1)
!         m1 = n1.inverse_triangle_number - 1
!         tr1  => tr(m1)[:,:,s]
!         ! Transform 1st index of density matrix
!         W.create(n1,n2)
!         W = matmul(tr1,D(f1:l1,f2:l2))
!         do s2 = 1, n_shell
!           f2 = first(s2); l2 = last(s2); n2 = (l2-f2+2)
!           a2 = atom_for_shell(s2)
!           c2 = .atom_for_cell_atom(a2,q) ! cluster atom index
!           f4 = first_fn(c2); l4 = last_fn(c2)
!           m2 = n2.inverse_triangle_number - 1
!           ! Transform 2nd index of density matrix
!           tr2  => tr(m2)[:,:,s]
!           P(f3:l3,f4:l4) = P(f3:l3,f4:l4) &
!                          + matmul(W,transpose(tr2))/pc(c1,c2)
!         end
!         W.destroy
!       end
!     end
!     pc.destroy
!     last_fn.destroy; first_fn.destroy
!     last.destroy; first.destroy
!     tr.destroy
!     atom_for_shell.destroy
!   end

!   atom_pair_parent_count result(n2) ::: leaky
!   ! Make the atom pair parent count, i.e. the number of times n2(i,j) a
!   ! particular atom pair (i,j) is *generated from* a fragment atom pair (i',j')
!   ! by the symmerty operations whose indices are stored in .symop. We divide
!   ! by this factor to ensure that the pair effectively appears as being
!   ! generated once, as an average of all the symmetry operations.  This is
!   ! quite similar to the n2 factor in the Dacre-Elder-Dupuis-King symmetry
!   ! method. For insight see:
!   ! P.D. Dacre, CPL (1970) 7, 47
!   ! M. Elder, IJQC (1973) 7, 75
!   ! M. Dupuis and H.F> King, IJQC (1977) 11, 613
!     n2 :: MAT{REAL}*
!   ENSURE(.asymmetric_unit_atom.created, "no atom data")
!   ENSURE(.atom_for_cell_atom.created, "no atom_for_cell_atom data")
!     s1,a1,c1,s2,a2,c2 :: INT
!     n_shell,q :: INT
!     atom_for_shell :: VEC{INT}*
!     n2.create(.n_atoms,.n_atoms)
!     n_shell = .asymmetric_unit_atom.n_shell
!     atom_for_shell => .asymmetric_unit_atom.atom_for_shell
!     do q = 1,.n_symop
!       ! Transform each shell pair by symop "s"
!       do s1 = 1,n_shell
!         a1 = atom_for_shell(s1)
!         c1 = .atom_for_cell_atom(a1,q)   ! cluster atom index
!         do s2 = 1, n_shell
!           a2 = atom_for_shell(s2)
!           c2 = .atom_for_cell_atom(a2,q) ! cluster atom index
!           n2(c1,c2) = n2(c1,c2) + 1
!         end
!       end
!     end
!     atom_for_shell.destroy
!   end

!  **************************
!  Local field factor tensors
!  **************************

   put_averaged_LFF_tensors
   ! Put the heavy-atom averaged local field factor dipole L tensors
   ! for the molecules in the unit cell. This uses the Reis formula.

   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")
   ENSURE(.asymmetric_unit_atom.created,"no asymetric cell atoms")

      n_mol,n_H,n,a,i1,i2,j1,j2,k1,k2,m1,m2 :: INT
      pos,pos0,com,L,L0,L1 :: MAT{REAL}* 
      symop,non_H,par,mol,mol0 :: VEC{INT}*
      label0 :: VEC{STR}*
      inverse_seitz :: MAT3{REAL}*

      ! Header
      stdout.flush
      stdout.text("Molecule-averaged Dipole L(1) tensor:")

      ! Get the positions, COM's for the molecules in the unit cell.
      ! By construction, the atoms in each molecule occur consecutively.
      .get_uc_molecule_info(mol,symop,par,pos,com) 

      ! Get indices of non-Hydrogen-atom positions.
      n_mol = .crystal.n_unit_cell_mols
      n_H   = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_H)
      non_H = pack([(a,a=1,par.dim)],.asymmetric_unit_atom(par).atomic_number>1)

      ! Set the non-Hydrogen-atom positions, molecules.
      label0.create(n_H)
      pos0.create(3,n_H)
      mol0.create(n_H)
      label0 = .asymmetric_unit_atom(par(non_H)).label
      pos0   = pos(:,non_H)
      mol0   = mol(non_H)

      non_H.destroy
      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy

      ! Make the non-Hydrogen-atom Lorentz factor tensors
      L.create(3*n_mol,3*n_mol)
      L0.create(3*n_H,n_H)         ! charge L tensor
      L1.create(3*n_H,3*n_H)       ! dipole L tensor
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      mol0.destroy; pos0.destroy

      ! Print monopole and dipole L tensor out
      n = n_H/n_mol
      stdout.flush
      stdout.text("Heavy-atom monopole L(0) tensor and Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=4,real_fields=4)
      stdout.put("Mol. 1",int_width=TRUE)
      stdout.put("Mol. 2",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("L(0)")
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=4,real_fields=4)
      do i1 = 1,n_mol
      do i2 = 1,n_mol
      do j1 = 1,n
      do j2 = 1,n
         k1 = n*(i1-1) + j1
         k2 = n*(i2-1) + j2
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(i1)
         stdout.put(i2)
         stdout.put(trim(j1.to_str)//" "//trim(label0(k1)),int_width=TRUE)
         stdout.put(trim(j2.to_str)//" "//trim(label0(k2)),int_width=TRUE)
         stdout.put(L0(m1+1,k2))
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=4)
         stdout.put(L0(m1+2,k2))
         stdout.put(L1(m1+2,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=4)
         stdout.put(L0(m1+3,k2))
         stdout.put(L1(m1+3,m2+1))
         stdout.put(L1(m1+3,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.flush
      end
      end
      end
      end
      stdout.dash(int_fields=4,real_fields=4)

      label0.destroy

      ! Average the L(1) tensors over molecules
      L = ZERO
      do i1 = 1,n_mol
      do i2 = 1,n_mol
         m1 = 3*(i1-1)
         m2 = 3*(i2-1)
         do j1 = 1,n
         do j2 = 1,n
            k1 = 3*(n*(i1-1)+j1-1)
            k2 = 3*(n*(i2-1)+j2-1)
            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
         end
         end
      end
      end
      L = L/real(n*n,kind=REAL_KIND)

      ! Print averaged dipole L tensor
      stdout.flush
      stdout.text("Spackman's molecule-averaged Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Mol. 1",int_width=TRUE)
      stdout.put("Mol. 2",int_width=TRUE)
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do k1 = 1,n_mol
      do k2 = 1,n_mol
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L(m1+1,m2+1))
         stdout.put(L(m1+1,m2+2))
         stdout.put(L(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L(m1+2,m2+1))
         stdout.put(L(m1+2,m2+2))
         stdout.put(L(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L(m1+3,m2+1))
         stdout.put(L(m1+3,m2+2))
         stdout.put(L(m1+3,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=3)

      ! Clean up
      L1.destroy; L0.destroy; L.destroy

   end

   put_centroid_LFF_tensors
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell. This uses the Reis formula.
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")

      n,i,k1,k2,m1,m2 :: INT
      L0,L1 :: MAT{REAL}* 
      centroid :: MAT{REAL}*
      mol_for  :: VEC{INT}*

      ! Header
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_mols = ",.crystal.n_unit_cell_mols)

      ! Allocate
      n = .crystal.n_unit_cell_mols
      L0.create(3*n,n)
      L1.create(3*n,3*n)

      ! Get centroids
      centroid.create(3,n)
      .get_uc_molecule_centroids(centroid) 
      stdout.flush
      stdout.text("Molecule centroids (cell coordinates):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Change centroids into cartesian
      centroid = matmul(.crystal.unit_cell.direct_matrix,centroid)
      stdout.flush
      stdout.text("Molecule centroids (cartesian/Bohr):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Make L tensor
      mol_for.create(n);   mol_for = [ (i,i=1,n) ]
      .crystal.unit_cell.make_LFF_tensors(L0,L1,centroid,mol_for)
      mol_for.destroy
      centroid.destroy

      ! Print monopole and dipole L tensor out
      stdout.flush
      stdout.text("Monopole L(0) tensor and Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=4)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(0)")
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=4)
      do k1 = 1,n
      do k2 = 1,k1
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L0(m1+1,k2))
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L0(m1+2,k2))
         stdout.put(L1(m1+2,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L0(m1+3,k2))
         stdout.put(L1(m1+3,m2+1))
         stdout.put(L1(m1+3,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=4)

      ! Clean up
      L1.destroy
      L0.destroy

   end

   put_centroid_LFF_tensors_old 
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell. This uses the Cummins code.
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")
      m,u,n,k,k1,k2 :: INT
      L2 :: MAT3{REAL}* 
      centroid :: MAT{REAL}*

      ! Header
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_mols = ",.crystal.n_unit_cell_mols)

      ! Allocate space
      n = .crystal.n_unit_cell_mols
      L2.create(3,3,n.triangle)
      centroid.create(3,n)

      ! Get unit cell molecule centroids
      .get_uc_molecule_centroids(centroid) 
      stdout.flush
      stdout.text("Molecule centroids (cell coordinates):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Change centroids into cartesian
      centroid = matmul(.crystal.unit_cell.direct_matrix,centroid)
      stdout.flush
      stdout.text("Molecule centroids (cartesian/Bohr):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Make L tensor
      .crystal.unit_cell.make_LFF_tensors(L2,centroid)

      ! Print L tensor out
      stdout.flush
      stdout.text("L tensors:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(xx)")
      stdout.put("L(yy)")
      stdout.put("L(zz)")
      stdout.put("L(xy)")
      stdout.put("L(xz)")
      stdout.put("L(yz)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      k = 0
      do k1 = 1,n
      do k2 = 1,k1
         k = k + 1
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L2(1,1,k))
         stdout.put(L2(2,2,k))
         stdout.put(L2(3,3,k))
         stdout.put(L2(1,2,k))
         stdout.put(L2(1,3,k))
         stdout.put(L2(2,3,k))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=6)

      ! Clean up
      centroid.destroy
      L2.destroy

   end

   get_uc_molecule_centroids(centroid) 
   ! Get the unit cell molecule centroids; they are transformed back
   ! into the unit cell if the defragmented molecule lies outside the
   ! unit cell.
      centroid :: MAT{REAL}
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")
   ENSURE(centroid.dim1==3 AND centroid.dim2==.crystal.n_unit_cell_mols,"wrong shape, centroid")
      m,u :: INT
      geometry :: MAT{REAL}*
      centroid = ZERO
      do m = 1,.crystal.n_unit_cell_mols
         nullify(geometry)
         do u = 1,.crystal.n_unit_cell_atoms
            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle
            .do_defragment_uc_atom(u,geometry)
            exit
         end
         centroid(:,m) = sum(geometry,dim=2)/geometry.dim2
         .crystal.put_to_unit_cell(centroid(:,m))
         geometry.destroy
      end
   end

!   get_uc_non_H_positions(pos,mol_for) 
!   ! Get "pos", the unit cell non hydrogen atom positions; they are
!   ! transformed back into the unit cell if the defragmented molecule
!   ! lies outside the unit cell. Also get "mol_for", the molecule that
!   ! the atom belongs to.
!      centroid :: MAT{REAL}
!   ENSURE(.crystal.created,"no crystal")
!   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")
!   ENSURE(centroid.dim1==3 AND centroid.dim2==.crystal.n_unit_cell_mols,"wrong shape, centroid")
!      m,u :: INT
!      geometry :: MAT{REAL}*
!      centroid = ZERO
!      do m = 1,.crystal.n_unit_cell_mols
!         nullify(geometry)
!         do u = 1,.crystal.n_unit_cell_atoms
!            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle
!            .do_defragment_uc_atom(u,geometry)
!            exit
!         end
!         centroid(:,m) = sum(geometry,dim=2)/geometry.dim2
!         .crystal.put_to_unit_cell(centroid(:,m))
!         geometry.destroy
!      end
!   end

   put_LFF_info
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell.
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")
      n,i,k1,k2,m1,m2 :: INT
      L0,L1 :: MAT{REAL}* 
      mol,par :: VEC{INT}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      symop,alpha_m :: MAT3{REAL}*

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m) 

      ! Make the charge and dipole Lorentz factor tensors
      n = par.dim
      L0.create(3*n,n)
      L1.create(3*n,3*n)
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Output
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_atoms = ",par.dim)
      stdout.show("n_unit_cell_mols = ",coc.dim2)
      stdout.flush
      stdout.text("Molecule atom positions:")
      stdout.flush
      stdout.put(transpose(pos))

      stdout.flush
      stdout.text("L tensors:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(xx)")
      stdout.put("L(yy)")
      stdout.put("L(zz)")
      stdout.put("L(xy)")
      stdout.put("L(xz)")
      stdout.put("L(yz)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      do k1 = 1,n
      do k2 = 1,k1
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=6)

      ! Clean up
      L1.destroy
      L0.destroy
      alpha_m.destroy; alpha_q.destroy
      com.destroy; coc.destroy; par.destroy
      symop.destroy; mol.destroy

   end

!   make_averaged_LFF_tensor(L)
!   ! Put the heavy-atom averaged local field factor dipole L tensor L1
!   ! for the molecules in the unit cell. This uses the Reis formula.
!
!      L :: MAT{REAL}
!
!   ENSURE(.crystal.created,"no crystal")
!   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")
!   ENSURE(.asymmetric_unit_atom.created,"no asymetric cell atoms")
!   ENSURE(L.is_square,"L is square")
!   ENSURE(L.dim1==.crystal.n_unit_cell_mols,"wrong size, L")
!
!      n_mol,n_H,n,a,i1,i2,j1,j2,k1,k2,m1,m2 :: INT
!      pos,pos0,com, L0,L1 :: MAT{REAL}* 
!      symop,non_H,par,mol,mol0 :: VEC{INT}*
!
!      ! Get the positions, COM's for the molecules in the unit cell.
!      ! By construction, the atoms in each molecule occur consecutively.
!      .get_uc_molecule_info(mol,symop,par,pos,com) 
!
!      ! Get indices of non-Hydrogen-atom positions.
!      n_mol = .crystal.n_unit_cell_mols
!      n_H   = count(.asymmetric_unit_atom(par).atomic_number>1)
!      non_H.create(n_H)
!      non_H = pack([(a,a=1,par.dim)],.asymmetric_unit_atom(par).atomic_number>1)
!
!      ! Set the non-Hydrogen-atom positions, molecules.
!      pos0.create(3,n_H)
!      mol0.create(n_H)
!      pos0 = pos(:,non_H)
!      mol0 = mol(  non_H)
!
!      non_H.destroy
!      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy
!
!      ! Make the non-Hydrogen-atom Lorentz factor tensors
!      L0.create(3*n_H,n_H)         ! charge L tensor
!      L1.create(3*n_H,3*n_H)       ! dipole L tensor
!      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)
!
!      mol0.destroy; pos0.destroy
!
!      ! Print monopole and dipole L tensor out
!      n = n_H/n_mol
!
!      ! Average the L(1) tensors over molecules
!      L = ZERO
!      do i1 = 1,n_mol
!      do i2 = 1,n_mol
!         m1 = 3*(i1-1)
!         m2 = 3*(i2-1)
!         do j1 = 1,n
!         do j2 = 1,n
!            k1 = 3*(n*(i1-1)+j1-1)
!            k2 = 3*(n*(i2-1)+j2-1)
!            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
!         end
!         end
!      end
!      end
!      L = L/real(n*n,kind=REAL_KIND)
!
!      ! Clean up
!      L1.destroy; L0.destroy
!
!   end

!  **********************
!  Susceptibility tensors
!  **********************

   make_chi1_naive(chi1,alpha_mol)
   ! Make the naive second order susceptibility from the
   ! polarisability of the molecule.
      chi1 :: MAT{REAL}(3,3), OUT ! Clausius-Mossotti, L=1/3
      alpha_mol :: MAT{REAL}(3,3), IN

      alpha_uc :: MAT{REAL}(3,3)
      D :: MAT{REAL}* 
      fac :: REAL

      .make_alpha_uc(alpha_uc,alpha_mol)

      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.crystal.unit_cell.volume

      D.create(3,3)
      D.to_unit_matrix
      D = D - fac*THIRD*alpha_uc
      D.to_inverse_of(D)
      chi1 = fac*matmul(alpha_uc,D)
      D.destroy

   end

   make_alpha_uc(alpha_uc,alpha_mol)
   ! Make the unit cell alpha.
      alpha_uc :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

   ENSURE(.crystal.created,"no crystal")

      alpha :: MAT{REAL}(3,3)
      mol,symop,par :: VEC{INT}*
      pos,com :: MAT{REAL}* 
      inverse_seitz :: MAT3{REAL}*
      n_mol,m :: INT

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com) 
      com.destroy; pos.destroy; par.destroy; mol.destroy

      ! Transposed/Inverse symops
      inverse_seitz => .crystal.transposed_xyz_seitz_matrices

      ! No of molecules
      n_mol = symop.dim

      !    stdout.text("original tensor")
      !    stdout.put(alpha_mol)

      ! Add up the polarisabilities
      alpha_uc = ZERO
      do m = 1,n_mol
         alpha_mol.change_basis_to(alpha,inverse_seitz(:,:,symop(m)))
         alpha_uc = alpha_uc + alpha
      !    stdout.show("molecule =",m)
      !    stdout.show("symop :",symop(m))
      !    stdout.put(symop(m))
      !    stdout.text("transformed tensor")
      !    stdout.put(alpha)
      end

      !    stdout.text("UC alpha")
      !    stdout.put(alpha_uc)

      ! Clean
      inverse_seitz.destroy
      symop.destroy

   end


   make_chi1_ALFFA(chi1,alpha_mol)
   ! Make the ALFFA "chi1" matrix: chi = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol". The L
   ! tensors are evaluated at the molecular center-of_masses.
   ! The trace is over 3x3 blocks.
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,par,non_H :: VEC{INT}*
      inverse_seitz,alpha :: MAT3{REAL}*
      pos,com, L0,L1, D,Df :: MAT{REAL}* 
      alph :: MAT{REAL}(3,3)
      n,n_mol,n_atom_per_mol,dim,a,b,i,j,m :: INT
      fac :: REAL

      n = .crystal.n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .crystal.n_unit_cell_mols ! No. of molecules
      n_atom_per_mol = n/n_mol          ! No. of atoms per molecules

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! D matrix: D = (1 - aL)^-1 
      dim = 3*n_mol
      D.create(dim,dim)          

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com) 

      ! Get the molecule indices (they are consecutive by construction)
      mol0.create(n_mol)
      mol0 = [(m,m=1,n_mol)]

      ! Print out centroid info ... important
      stdout.flush
      stdout.show("Center of mass =",com(:,1))

      ! Make the centroid charge and dipole Lorentz factor tensors
      L0.create(dim,n_mol)
      L1.create(dim,dim)
      .crystal.unit_cell.make_LFF_tensors(L0,L1,com,mol0)

      ! Get the reduced molecular polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz => .crystal.transposed_xyz_seitz_matrices
      fac = FOUR*PI/.crystal.unit_cell.volume
      alph = fac*alpha_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Print out centroid info ... important
      if (.debugging("make_chi1_ALFFA")) then
      stdout.flush
      stdout.text("Arrays for centroid calculation:")
      stdout.text("com (center of mass):")
      stdout.put(transpose(com))
      stdout.text("mol0:")
      stdout.put(mol0,"column")
      stdout.text("Alpha for each molecule:")
      stdout.put(alpha,as_matrices=TRUE)
      stdout.text("Dipole L1 tensor:")
      stdout.put(L1)
      end

      ! Make the (inverse) D matrix
      D.to_unit_matrix
      i = 0
      do a = 1,n_mol
         j = 0
         do b = 1,n_mol
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L1(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      L1.destroy; L0.destroy; mol0.destroy
      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy

      ! Invert
      D.to_inverse_of(D)
    
      ! Make the local field factors
      Df.create(dim,3)
      .make_local_field_factors(Df,D)

      ! Make the chi1 (ALFFA) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_mol
         chi1.plus_product_of(alpha(:,:,a),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy; D.destroy; alpha.destroy

   end

!   make_chi1_ALFFA(chi1,alpha_mol)
!   ! Make the ALFFA "chi1" matrix: chi = Tr_block a^1(1 - L^1 a^1)^-1
!   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
!   ! transformed) molecular dipole polarisability "alpha_mol". The L
!   ! tensors are evaluated at the molecular center-of_masses.
!   ! The trace is over 3x3 blocks.
!      chi1 :: MAT{REAL}(3,3), OUT
!      alpha_mol :: MAT{REAL}(3,3), IN
!
!      mol,mol0,symop,par,non_H :: VEC{INT}*
!      inverse_seitz,alpha :: MAT3{REAL}*
!      pos,com, L0,L1, D,Df :: MAT{REAL}* 
!      alph :: MAT{REAL}(3,3)
!      n,n_mol,n_atom_per_mol,dim,a,b,i,j,m :: INT
!      fac :: REAL
!
!      ! Get the unit cell molecule atom info
!      .get_uc_molecule_info(mol,symop,par,pos,com) 
!
!      n = .crystal.n_unit_cell_atoms   ! No. of atoms in unit cell
!      n_mol = symop.dim                ! No. of molecules
!      n_atom_per_mol = n/n_mol         ! No. of atoms per molecules
!
!      ! Get the molecule indices (they are consecutive by construction)
!      mol0.create(n_mol)
!      mol0 = [(m,m=1,n_mol)]
!
!      ! Print out centroid info ... important
!      stdout.flush
!      stdout.show("Center of mass =",com(:,1))
!
!      ! Make the centroid charge and dipole Lorentz factor tensors
!      dim = 3*n_mol
!      alpha.create(3,3,n_mol)
!      D.create(dim,dim)
!      L0.create(dim,n_mol)
!      L1.create(dim,dim)
!      .crystal.unit_cell.make_LFF_tensors(L0,L1,com,mol0)
!
!      ! Get the reduced molecular polarisabilities
!      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
!      inverse_seitz => .crystal.transposed_xyz_seitz_matrices
!      fac = FOUR*PI/.crystal.unit_cell.volume
!      alph = fac*alpha_mol
!      do m = 1,n_mol
!         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
!      end
!
!      ! Print out centroid info ... important
!      if (.debugging("make_chi1_ALFFA")) then
!      stdout.flush
!      stdout.text("Arrays for centroid calculation:")
!      stdout.text("com (center of mass):")
!      stdout.put(transpose(com))
!      stdout.text("mol0:")
!      stdout.put(mol0,"column")
!      stdout.text("Alpha for each molecule:")
!      stdout.put(alpha,as_matrices=TRUE)
!      stdout.text("Dipole L1 tensor:")
!      stdout.put(L1)
!      end
!
!      ! Mini Clean up
!      inverse_seitz.destroy
!      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy
!
!      ! Make the (inverse) D matrix
!      D.to_unit_matrix
!      i = 0
!      do a = 1,n_mol
!         j = 0
!         do b = 1,n_mol
!            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L1(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
!            j = j + 3
!         end
!         i = i + 3
!      end
!
!      ! Clean up
!
!      ! Invert
!      D.to_inverse_of(D)
!    
!      ! Make the local field factors
!      Df.create(dim,3)
!      .make_local_field_factors(Df,D)
!
!      ! Make the chi1 (ALFFA) susceptibility
!      chi1 = ZERO
!      i = 0
!      do a = 1,n_mol
!         chi1.plus_product_of(alpha(:,:,a),Df(i+1:i+3,:))
!         i = i + 3
!      end
!
!      ! Clean up
!      Df.destroy
!      L1.destroy; L0.destroy; D.destroy; alpha.destroy
!      mol0.destroy
!
!   end

   make_chi1_RLFTn(chi1,alpha_mol)
   ! Make the RLFTn "chi1" matrix: chi1 = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol" divided
   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
   ! are evaluated at these non H atom sites. The trace is over 3x3 blocks
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,par,non_H :: VEC{INT}*
      inverse_seitz,alpha :: MAT3{REAL}*
      pos,pos0,com, L0,L1, D,Df :: MAT{REAL}* 
      alph :: MAT{REAL}(3,3)
      n,n_mol,n_non_H,n_non_H_per_mol,dim,a,b,i,j,m :: INT
      fac :: REAL

      n = .crystal.n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .crystal.n_unit_cell_mols ! No. of molecules

      ! No of non-hydrogen atoms in unit cell
      par => .crystal.asym_atom_for_unit_cell_atom
      n_non_H = count(.asymmetric_unit_atom(par).atomic_number>1)

      ! No. of non-H hydrogen atoms per molecule
      DIE_IF(mod(n_non_H,n_mol)/=0,"no of non-Hydrogen atoms wrong")
      n_non_H_per_mol = n_non_H/n_mol

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! D matrix: D = (1 - aL)^-1 
      dim = 3*n_non_H
      D.create(dim,dim)          

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com) 

      ! Get the reduced averaged site polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz => .crystal.transposed_xyz_seitz_matrices
      fac = FOUR*PI/.crystal.unit_cell.volume
      alph = fac*alpha_mol/n_non_H_per_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Get *indices* for non-H positions
      non_H.create(n_non_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! Get the non-H positions and molecules
      pos0.create(3,n_non_H)
      mol0.create(  n_non_H)
      pos0 = pos(:,non_H)
      mol0 = mol(  non_H)

      ! Make the non H charge and dipole Lorentz factor tensors
      L0.create(dim,n_non_H)     ! charge L tensor
      L1.create(dim,dim)         ! dipole L tensor
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Print out position info ... 
      if (.debugging("make_chi1_RLFTn")) then
      stdout.flush
      stdout.text("Arrays for non H calculation:")
      stdout.text("non_H:")
      stdout.put(non_H,"column")
      stdout.text("pos0:")
      stdout.put(transpose(pos0))
      stdout.text("mol0:")
      stdout.put(mol0,"column")
      stdout.text("symop :")
      stdout.put(symop)
      stdout.text("Alpha for each molecule:")
      stdout.put(n_non_H_per_mol*alpha/fac,as_matrices=TRUE)
      stdout.text("UC Alpha :")
      stdout.put(sum(n_non_H_per_mol*alpha/fac,dim=3))
      stdout.text("Dipole L1 tensor:")
      stdout.put(L1)
      end

      ! Make the (inverse) D matrix: D = (1 - aL)^-1 
      D.to_unit_matrix
      i = 0
      do a = 1,n_non_H
         j = 0
         do b = 1,n_non_H
            m  = (b-1)/n_non_H_per_mol + 1
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L1(i+1:i+3,j+1:j+3),alpha(:,:,m),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      L1.destroy; L0.destroy 
      mol0.destroy; pos0.destroy; non_H.destroy
      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy

      ! Invert
      D.to_inverse_of(D)
    
      ! Make the local field factors
      Df.create(dim,3)
      .make_local_field_factors(Df,D)

      ! Make the chi1 (RLFTn) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_non_H
         m = (a-1)/n_non_H_per_mol + 1
         chi1.plus_product_of(alpha(:,:,m),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy; D.destroy; alpha.destroy

   end

!   make_chi1_RLFTn(chi1,alpha_mol)
!   ! Make the RLFTn "chi1" matrix: chi1 = Tr_block a^1(1 - L^1 a^1)^-1
!   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
!   ! transformed) molecular dipole polarisability "alpha_mol" divided
!   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
!   ! are evaluated at these non H atom sites. The trace is over 3x3 blocks
!      chi1 :: MAT{REAL}(3,3), OUT
!      alpha_mol :: MAT{REAL}(3,3), IN
!
!      mol,mol0,symop,par,non_H :: VEC{INT}*
!      inverse_seitz,alpha :: MAT3{REAL}*
!      pos,pos0,com, L0,L1, D,Df :: MAT{REAL}* 
!      alph :: MAT{REAL}(3,3)
!      n,n_mol,n_non_H,n_non_H_per_mol,dim,a,b,i,j,m :: INT
!      fac :: REAL
!
!      ! Get the unit cell molecule atom info
!      .get_uc_molecule_info(mol,symop,par,pos,com) 
!
!      n = .crystal.n_unit_cell_atoms   ! No. of atoms in unit cell
!      n_mol = symop.dim                ! No. of molecules
!
!      ! Get *indices* for non-H positions
!      n_non_H = count(.asymmetric_unit_atom(par).atomic_number>1)
!      non_H.create(n_non_H)
!      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)
!
!      ! No. of non-H hydrogen atoms per molecule
!      DIE_IF(mod(n_non_H,n_mol)/=0,"no of non-Hydrogen atoms wrong")
!      n_non_H_per_mol = n_non_H/n_mol
!
!      ! Get the non-H positions and molecules
!      pos0.create(3,n_non_H)
!      mol0.create(n_non_H)
!      pos0 = pos(:,non_H)
!      mol0 = mol(non_H)
!
!      ! Make the non H charge and dipole Lorentz factor tensors
!      dim = 3*n_non_H
!      alpha.create(3,3,n_mol)
!      D.create(dim,dim)          ! (1 - aL)^-1 
!      L0.create(dim,n_non_H)     ! charge L tensor
!      L1.create(dim,dim)         ! dipole L tensor
!      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)
!
!      ! Get the reduced averaged site polarisabilities
!      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
!      inverse_seitz => .crystal.transposed_xyz_seitz_matrices
!      fac = FOUR*PI/.crystal.unit_cell.volume
!      alph = fac*alpha_mol/n_non_H_per_mol
!      do m = 1,n_mol
!         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
!      end
!
!      ! Print out position info ... important
!      if (.debugging("make_chi1_RLFTn")) then
!      stdout.flush
!      stdout.text("Arrays for non H calculation:")
!      stdout.text("non_H:")
!      stdout.put(non_H,"column")
!      stdout.text("pos0:")
!      stdout.put(transpose(pos0))
!      stdout.text("mol0:")
!      stdout.put(mol0,"column")
!      stdout.text("symop :")
!      stdout.put(symop)
!      stdout.text("Alpha for each molecule:")
!      stdout.put(n_non_H_per_mol*alpha/fac,as_matrices=TRUE)
!      stdout.text("UC Alpha :")
!      stdout.put(sum(n_non_H_per_mol*alpha/fac,dim=3))
!      stdout.text("Dipole L1 tensor:")
!      stdout.put(L1)
!      end
!
!      ! Mini Clean up
!      inverse_seitz.destroy
!      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy
!
!      ! Make the (inverse) D matrix
!      D.to_unit_matrix
!      i = 0
!      do a = 1,n_non_H
!         j = 0
!         do b = 1,n_non_H
!            m  = (b-1)/n_non_H_per_mol + 1
!            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L1(i+1:i+3,j+1:j+3),alpha(:,:,m),-ONE)
!            j = j + 3
!         end
!         i = i + 3
!      end
!
!      ! Invert
!      D.to_inverse_of(D)
!    
!      ! Make the local field factors
!      Df.create(dim,3)
!      .make_local_field_factors(Df,D)
!
!      ! Make the chi1 (RLFTn) susceptibility
!      chi1 = ZERO
!      i = 0
!      do a = 1,n_non_H
!         m = (a-1)/n_non_H_per_mol + 1
!         chi1.plus_product_of(alpha(:,:,m),Df(i+1:i+3,:))
!         i = i + 3
!      end
!
!      ! Clean up
!      Df.destroy
!      L1.destroy; L0.destroy; D.destroy; alpha.destroy
!      mol0.destroy; pos0.destroy
!      non_H.destroy
!
!   end

   make_chi1_RLFTn_av_L(chi1,alpha_mol)
   ! Make the RLFTn "chi1" matrix: chi1 = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol" divided
   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
   ! are evaluated at these non H atom sites. The trace is over 3x3 blocks
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,par,non_H :: VEC{INT}*
      inverse_seitz,alpha :: MAT3{REAL}*
      pos,pos0,com, L,L0,L1, D,Df :: MAT{REAL}* 
      alph :: MAT{REAL}(3,3)
      n,n_mol,n_non_H,n_non_H_per_mol,dim, i1,i2,j1,j2,k1,k2,m1,m2, a,b,i,j,m :: INT
      fac :: REAL

      n = .crystal.n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .crystal.n_unit_cell_mols ! No. of molecules

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! Molecule averaged L1
      dim = 3*n_mol
      L.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com) 

      ! Get *indices* for non-H positions
      n_non_H = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_non_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! No. of non-H hydrogen atoms per molecule
      DIE_IF(mod(n_non_H,n_mol)/=0,"no of non-Hydrogen atoms wrong")
      n_non_H_per_mol = n_non_H/n_mol

      ! Get the non-H positions and molecules
      pos0.create(3,n_non_H)
      mol0.create(  n_non_H)
      pos0 = pos(:,non_H)
      mol0 = mol(  non_H)

      ! Get the reduced molecular polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz => .crystal.transposed_xyz_seitz_matrices
      fac = FOUR*PI/.crystal.unit_cell.volume
      alph = fac*alpha_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Make the non H charge and dipole Lorentz factor tensors
      dim = 3*n_non_H
      L0.create(dim,n_non_H)     ! charge L tensor
      L1.create(dim,dim)         ! dipole L tensor
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Average the L(1) tensors over molecules
      L = ZERO
      do i1 = 1,n_mol
      do i2 = 1,n_mol
         m1 = 3*(i1-1)
         m2 = 3*(i2-1)
         do j1 = 1,n_non_H_per_mol
         do j2 = 1,n_non_H_per_mol
            k1 = 3*(n_non_H_per_mol*(i1-1)+j1-1)
            k2 = 3*(n_non_H_per_mol*(i2-1)+j2-1)
            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
         end
         end
      end
      end
      fac = ONE/(n_non_H_per_mol*n_non_H_per_mol)
      L = fac*L

      ! Mini Clean up
      L1.destroy; L0.destroy
      mol0.destroy; pos0.destroy; non_H.destroy
      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy

      ! Print out position info ... important
      if (.debugging("make_chi1_RLFTn_av_L1")) then
      stdout.text("Averaged L1 tensor:")
      stdout.put(L)
      end

      ! Make the (inverse) D matrix: D = (1 - aL)^-1 
      dim = 3*n_mol
      D.create(dim,dim)          
      D.to_unit_matrix
      i = 0
      do a = 1,n_mol
         j = 0
         do b = 1,n_mol
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Invert
      D.to_inverse_of(D)
    
      ! Make the local field factors
      Df.create(dim,3)
      .make_local_field_factors(Df,D)

      ! Make the chi1 (ALFFA-like) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_mol
         chi1.plus_product_of(alpha(:,:,a),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy; D.destroy
      L.destroy; alpha.destroy

   end

   make_local_field_factors(Df,D)
   ! Make the second ortder susceptibility from distributed
   ! polarisabilities.
      Df :: MAT{REAL}, OUT
      D  :: MAT{REAL}, IN

   ENSURE(D.is_square,     "non square D")
   ENSURE(mod(D.dim1,3)==0,"D dim1 is not divisible by 3")
   ENSURE(Df.dim1==D.dim1, "wrong dim1, Df")
   ENSURE(Df.dim2==3,      "wrong dim2, Df")

      n,a,b,i,j :: INT

      n = D.dim1/3

      Df = ZERO
      i = 0
      do a = 1,n
         j = 0
         do b = 1,n
            Df(i+1:i+3,:) = Df(i+1:i+3,:) + D(i+1:i+3,j+1:j+3)      
            j = j + 3
         end
         i = i + 3
      end

   end

! These are for more complicated calculations

   make_D_matrix(D)
   ! Make the D matrix: D = (1 - L^0 a^0 - L^1 a^1)^-1
   ! where L^0 and L^1 are the monopole and dipole L tensors and
   ! where a^0 and a^1 are the monopole and dipole polarisabilities
   ! for every atom site at which the L tensors are evaluated.
      D :: MAT{REAL}, target

   ENSURE(D.is_square,  "non square D")
   ENSURE(.crystal.created,"no crystal")

      mol,par :: VEC{INT}*
      symop,alpha_m :: MAT3{REAL}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      L0,L1,Lm, DD :: MAT{REAL}* 
      Lq :: VEC{REAL}*
      n,dim,a,b,i,j :: INT
      fac :: REAL

      ! Factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.crystal.unit_cell.volume

      ! Get the electrical properties for each atom
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m) 

      com.destroy
      coc.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Get no of atoms in unit cell
      n   = par.dim
      dim = D.dim1
      ENSURE(dim==3*n,"wrong size, par array")

      ! Make the charge and dipole Lorentz factor tensors
      L0.create(dim,n)
      L1.create(dim,dim)
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Make the (inverse) D matrix
      D.to_unit_matrix

      i = 0
      do a = 1,n

         j = 0
         do b = 1,n

            Lq => L0(i+1:i+3,b)      
            Lm => L1(i+1:i+3,j+1:j+3)      

            DD =>   D(i+1:i+3,j+1:j+3)      
            DD = DD - fac*Lq.outer_product_with(alpha_q(:,b))
            DD = DD - fac*matmul(Lm,alpha_m(:,:,b))
            
            j = j + 3
         end

         i = i + 3
      end

      ! Clean up
      alpha_m.destroy; alpha_q.destroy
      L1.destroy; L0.destroy

      ! Invert
      D.to_inverse_of(D)

   end

   make_Dnc_matrix(Dnc)
   ! Make the Dnc matrix: Dnc = (1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensors and where a^1 is the dipole 
   ! polarisability for every atom site at which the L tensors are 
   ! evaluated.  NOTE: Dnc means "no charge dipole terms"
      Dnc :: MAT{REAL}, target

   ENSURE(Dnc.is_square,"non square Dnc")
   ENSURE(.crystal.created,"no crystal")

      mol,par :: VEC{INT}*
      symop,alpha_m :: MAT3{REAL}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      L0,L1,Lm, DD :: MAT{REAL}* 
      n,dim,a,b,i,j :: INT
      fac :: REAL

      ! Factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.crystal.unit_cell.volume

      ! Get the unit cell electrical properties for each atom
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m) 

      alpha_q.destroy
      com.destroy
      coc.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Get no of atoms in unit cell
      n   = par.dim
      dim = Dnc.dim1
      ENSURE(dim==3*n,"wrong size, par array")

      ! Make the charge and dipole Lorentz factor tensors
      L0.create(dim,n)
      L1.create(dim,dim)
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Make the (inverse) D matrix
      Dnc.to_unit_matrix

      i = 0
      do a = 1,n

         j = 0
         do b = 1,n

            Lm => L1(i+1:i+3,j+1:j+3)      

            DD => Dnc(i+1:i+3,j+1:j+3)      
            DD = DD - fac*matmul(Lm,alpha_m(:,:,b))

            j = j + 3
         end

         i = i + 3
      end

      ! Clean up
      L1.destroy
      L0.destroy

      ! Invert
      Dnc.to_inverse_of(Dnc)

   end

! Old distributed polarisability code

!   make_susceptibility2(alpha_mol,beta_mol,uc_alpha,chi1_naive,chi1_centroid,chi1_nonH,chi2_nonH,chi1_nc,chi1_do,chi1)
!   ! Make the second ortder susceptibility from distributed
!   ! polarisabilities.
!      alpha_mol :: MAT{REAL}(3,3), IN
!      beta_mol  :: MAT3{REAL}(3,3,3), IN
!      uc_alpha      :: MAT{REAL}(3,3), OUT ! Unit cell alpha
!      chi1_naive    :: MAT{REAL}(3,3), OUT ! Clausius-Mossotti, L=1/3
!      chi1_centroid :: MAT{REAL}(3,3), OUT ! Dipoles at the COM
!      chi1_nonH     :: MAT{REAL}(3,3), OUT ! Non-hydrogen model, RLFTn
!      chi1_nc       :: MAT{REAL}(3,3), OUT ! No charge contributons to polarisability
!      chi1_do       :: MAT{REAL}(3,3), OUT ! Atomic alpha used
!      chi1          :: MAT{REAL}(3,3), OUT ! Distributed polarisability
!      chi2_nonH     :: MAT3{REAL}(3,3,3)
!
!   ENSURE(.crystal.created,"no crystal")
!   ENSURE(.asymmetric_unit_atom.created,"no asymetric cell atoms")
!
!      alph,al :: MAT{REAL}(3,3)
!      beta,be :: MAT3{REAL}(3,3,3)
!      L0,L1,Lm,D,Dnc,Ddo,Dd,AA, df :: MAT{REAL}* 
!      pos,pos0,coc,com,coc0,dipole,alpha_q,centroid :: MAT{REAL}*
!      mol,mol0,par,non_H :: VEC{INT}*
!      charge,r,Lq :: VEC{REAL}*
!      symop,alpha_m,alpha :: MAT3{REAL}*
!      n,n_m,n_a,n_H,nH,a,b,i,j,m :: INT
!      fac :: REAL
!
!      ! Get the unit cell electrical properties for each atom
!      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m) 
!
!      ! Get no of atoms in unit cell
!      n = par.dim
!
!      ! Factor to reduce polarisabilities (in au)
!      fac = FOUR*PI/.crystal.unit_cell.volume
!
!      ! Make the charge and dipole Lorentz factor tensors
!      D.create(3*n,3*n)
!      Dnc.create(3*n,3*n)
!      Ddo.create(3*n,3*n)
!      alpha.create(3,3,n)
!      L0.create(3*n,n)
!      L1.create(3*n,3*n)
!      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos,mol)
!
!      ! Get the atomic alpha's
!      alpha = ZERO
!      AA.create(3,3)
!      r.create(3)
!      do a = 1,n
!         r = pos(:,a) - coc(:,a)
!         AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
!         alpha(:,:,a) = alpha(:,:,a) + AA
!      end
!      r.destroy; AA.destroy
!
!      ! Make the D matrix
!      D.to_unit_matrix
!      Dnc.to_unit_matrix
!      Ddo.to_unit_matrix
!      i = 0
!      do a = 1,n
!         j = 0
!         do b = 1,n
!            Lq => L0(i+1:i+3,b)      
!            Lm => L1(i+1:i+3,j+1:j+3)      
!
!            Dd =>   D(i+1:i+3,j+1:j+3)      
!            Dd = Dd - fac*Lq.outer_product_with(alpha_q(:,b))
!            Dd = Dd - fac*matmul(Lm,alpha_m(:,:,b))
!
!            Dd => Dnc(i+1:i+3,j+1:j+3)      
!            Dd = Dd - fac*matmul(Lm,alpha_m(:,:,b))
!
!            Dd => Ddo(i+1:i+3,j+1:j+3)      
!            Dd = Dd - fac*matmul(Lm,alpha(:,:,b))
!            
!            j = j + 3
!         end
!         i = i + 3
!      end
!      D.to_inverse_of(D)
!      Dnc.to_inverse_of(Dnc)
!      Ddo.to_inverse_of(Ddo)
!      L1.destroy
!      L0.destroy
!
!      ! Make the distributed polarisability chi1 
!      chi1 = ZERO
!      chi1_nc = ZERO
!      chi1_do = ZERO
!      uc_alpha = ZERO
!      AA.create(3,3)
!      r.create(3)
!      i = 0
!      do a = 1,n
!         r = pos(:,a) - coc(:,a)
!         AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
!         uc_alpha = uc_alpha + AA
!         AA = fac*AA
!         j = 0
!         do b = 1,n
!            Dd =>   D(i+1:i+3,j+1:j+3)      
!            chi1 = chi1 + matmul(AA,Dd)
!            Dd => Dnc(i+1:i+3,j+1:j+3)      
!            chi1_nc = chi1_nc + matmul(AA,Dd)
!            Dd => Ddo(i+1:i+3,j+1:j+3)      
!            chi1_do = chi1_do + matmul(AA,Dd)
!            j = j + 3
!         end
!         i = i + 3
!      end
!
!      ! Clean up
!      r.destroy; AA.destroy
!      alpha.destroy
!      Ddo.destroy; Dnc.destroy; D.destroy
!
!      ! ************************************************
!
!      ! Make chi1_naive
!      D.create(3,3)
!      D.to_unit_matrix
!      D = D - fac*THIRD*uc_alpha
!      D.to_inverse_of(D)
!      chi1_naive = fac*matmul(uc_alpha,D)
!      D.destroy
!
!      ! ************************************************
!
!      ! Get the no of molecules
!      n_m = maxval(mol) 
!      DIE_IF(mod(n,n_m)/=0,"no of atoms in a molecule is not integral")
!
!      ! Get the no of atoms per molecule
!      n_a = n/n_m
!
!      ! Get the molecular alpha's
!      alpha.create(3,3,n_m)
!      alpha = ZERO
!      AA.create(3,3)
!      r.create(3)
!      a = 0
!      do m = 1,n_m
!         do i = 1,n_a
!            a = a + 1
!            r = pos(:,a) - coc(:,a)
!            AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
!            alpha(:,:,m) = alpha(:,:,m) + AA
!         end
!      end
!      r.destroy; AA.destroy
!
!      ! Get the centroids, use COM
!      coc0.create(3,n_m)
!      mol0.create(n_m)
!      coc0 = com(:,1:(n_m-1)*n_a+1:n_a)
!      mol0 = mol(1:(n_m-1)*n_a+1:n_a)
!
!      ! Print out centroid info ... important
!      stdout.flush
!      stdout.show("Center of mass =",coc0(:,1))
!
!      ! Make the centroid charge and dipole Lorentz factor tensors
!      D.create(3*n_m,3*n_m)
!      L0.create(3*n_m,n_m)
!      L1.create(3*n_m,3*n_m)
!      .crystal.unit_cell.make_LFF_tensors(L0,L1,coc0,mol0)
!
!      ! Print out centroid info ... important
!
!      if (.debugging("make_susceptibility2")) then
!      stdout.flush
!      stdout.text("Arrays for centroid calculation:")
!      stdout.text("coc0 (center of mass):")
!      stdout.put(transpose(coc0))
!      stdout.text("mol0:")
!      stdout.put(mol0,"column")
!      stdout.text("Dipole L1 tensor:")
!      stdout.put(L1)
!      stdout.text("Alpha for each molecule:")
!      stdout.put(alpha,as_matrices=TRUE)
!      end
!
!      ! Make the D matrix
!      D.to_unit_matrix
!      i = 0
!      do a = 1,n_m
!         j = 0
!         do b = 1,n_m
!            Dd => D(i+1:i+3,j+1:j+3)      
!            Lm => L1(i+1:i+3,j+1:j+3)      
!            Dd = Dd - fac*matmul(Lm,alpha(:,:,b))
!            j = j + 3
!         end
!         i = i + 3
!      end
!      D.to_inverse_of(D)
!      L1.destroy
!      L0.destroy
!
!      ! Make the chi1_centroid susceptibility
!      chi1_centroid = ZERO
!      AA.create(3,3)
!      r.create(3)
!      i = 0
!      do a = 1,n_m
!         AA = alpha(:,:,a)
!         AA = fac*AA
!         j = 0
!         do b = 1,n_m
!            Dd => D(i+1:i+3,j+1:j+3)      
!            chi1_centroid = chi1_centroid + matmul(AA,Dd)
!            j = j + 3
!         end
!         i = i + 3
!      end
!
!      ! Clean up
!      r.destroy; AA.destroy
!      D.destroy
!      mol0.destroy; coc0.destroy
!
!      ! ************************************************
!      ! RLFTn
!      ! ************************************************
!
!      ! Get non H positions.
!      n_H = count(.asymmetric_unit_atom(par).atomic_number>1)
!      non_H.create(n_H)
!      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)
!
!      ! Get the non H positions, indices, molecules.
!      pos0.create(3,n_H)
!      mol0.create(n_H)
!      pos0 = pos(:,non_H)
!      mol0 = mol(non_H)
!
!      ! Make the non H charge and dipole Lorentz factor tensors
!      D.create(3*n_H,3*n_H)        ! (1 - aL)^-1 
!      df.create(3*n_H,3)           ! local field factor tensor
!      L0.create(3*n_H,n_H)         ! charge L tensor
!      L1.create(3*n_H,3*n_H)       ! dipole L tensor
!      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)
!
!      ! Print out position info ... important
!      if (.debugging("make_susceptibility2")) then
!      stdout.flush
!      stdout.text("Arrays for non H calculation:")
!      stdout.text("non_H:")
!      stdout.put(non_H,"column")
!      stdout.text("pos0:")
!      stdout.put(transpose(pos0))
!      stdout.text("mol0:")
!      stdout.put(mol0,"column")
!      stdout.text("Dipole L1 tensor:")
!      stdout.put(L1)
!      end
!    
!      ! Get number of Non-H hydrogen atoms per molecule
!      DIE_IF(mod(n_H,n_m)/=0,"no of non-Hydrogen atoms wrong")
!      nH = n_H/n_m        
!
!      ! Average alpha over non-H sites
!      alpha = alpha/nH
!
!      ! Get the reduced average molecular polarisabilities
!      alph = fac*alpha_mol/nH
!      beta = fac*beta_mol/nH
!
!      ! Make the D matrix
!      D.to_unit_matrix
!      i = 0
!      do a = 1,n_H
!         j = 0
!         do b = 1,n_H
!            Dd => D(i+1:i+3,j+1:j+3)      
!            Lm => L1(i+1:i+3,j+1:j+3)      
!            m  = (b-1)/nH + 1
!
!            ! Old way
!         !  Dd = Dd - fac*matmul(Lm,alpha(:,:,m))
!
!            ! New way -- should be better -- check
!            alph.change_basis_to(al,symop(:,:,m))
!            Dd = Dd - matmul(Lm,al)
!
!            j = j + 3
!         end
!         i = i + 3
!      end
!      D.to_inverse_of(D)
!      L1.destroy
!      L0.destroy
!
!      ! Make the chi1_nonH susceptibility
!      chi1_nonH = ZERO
!      AA.create(3,3)
!      i = 0
!      do a = 1,n_H
!         m  = (a-1)/nH + 1
!         AA = alpha(:,:,m)
!         AA = fac*AA
!         j = 0
!         do b = 1,n_H
!            Dd => D(i+1:i+3,j+1:j+3)      
!            chi1_nonH = chi1_nonH + matmul(AA,Dd)
!            j = j + 3
!         end
!         i = i + 3
!      end
!
!      ! Local field factors
!      df = ZERO
!      i = 0
!      do a = 1,n_H
!         j = 0
!         do b = 1,n_H
!            df(i+1:i+3,:) = df(i+1:i+3,:) + D(i+1:i+3,j+1:j+3)      
!            j = j + 3
!         end
!         i = i + 3
!      end
!
!      ! Make the chi1_nonH and chi2_nonH susceptibility
!      chi1_nonH = ZERO
!      chi2_nonH = ZERO
!      i = 0
!      do a = 1,n_H
!         m = (a-1)/nH + 1
!         alph.change_basis_to(al,symop(:,:,m))
!         chi1_nonH = chi1_nonH + matmul(al,df(i+1:i+3,:))
!         beta.change_basis_to(be,symop(:,:,m))
!         be.change_basis_using(df(i+1:i+3,:))
!         chi2_nonH = chi2_nonH + be
!         i = i + 3
!      end
!      chi2_nonH = HALF*chi2_nonH
!
!      ! Clean up
!      df.destroy; D.destroy
!      mol0.destroy; pos0.destroy
!      non_H.destroy
!      alpha.destroy
!      alpha_m.destroy; alpha_q.destroy
!      com.destroy; coc.destroy; pos.destroy
!      par.destroy; symop.destroy; mol.destroy
!
!   end

!  ***************
!  Electric fields
!  ***************

   make_Lorentz_fields(F,sphere_sum)
   ! Make the Lorentz electric fields at the unit cell atom sites.
   ! Warning: the asymmetric_unit_atom's should be generated from the
   ! fragment where charges and dipoles have been done.
      F :: MAT{REAL}, OUT
      sphere_sum :: BIN, optional

      mol,frag_atom :: VEC{INT}*
      charge,dipole :: VEC{REAL}*
      pos,L0,L1 :: MAT{REAL}* 
      fac :: REAL
      n_atom,dim, u,a,s, fu,lu :: INT

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,pos,charge,dipole,frag_atom) 

      ! Make the Lorentz factor tensors L0, L1
      n_atom = charge.dim
      dim    = dipole.dim
      L0.create(dim,n_atom)      ! charge L0 tensor
      L1.create(dim,dim)         ! dipole L1 tensor
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos,mol,sphere_sum)
      fac = FOUR*PI/.crystal.unit_cell.volume
      L0 = fac*L0
      L1 = fac*L1

      ! Assign electric fields
      lu = 0
      do a = 1,.n_fragment_atoms
         u  = frag_atom(a) ! map to the actual frag atom in 1st molecule
         fu = lu + 1
         lu = lu + 3
         F(:,u) = matmul(L0(fu:lu,:),charge) + matmul(L1(fu:lu,:),dipole)
       ! F(:,u) = matmul(L1(fu:lu,:),dipole)
       ! F(:,u) = matmul(L0(fu:lu,:),charge)
      end

      .put_debug(charge,"make_Lorentz_fields: charge")
      .put_debug(dipole,"make_Lorentz_fields: dipole")
      .put_debug(transpose(pos),"make_Lorentz_fields: pos")
      .put_debug(mol,"make_Lorentz_fields: mol")
      .put_debug(transpose(F),"make_Lorentz_fields: F")
      .put_debug(L0,"make_Lorentz_fields: L0")
      .put_debug(L1,"make_Lorentz_fields: L1")
      .put_debug(matmul(L0,charge),"make_Lorentz_fields: L0 x charge")
      .put_debug(matmul(L1,dipole),"make_Lorentz_fields: L1 x dipole")
      .put_debug(frag_atom,"make_Lorentz_fields: frag_atom")

      ! Clean up
      L1.destroy; L0.destroy 
      frag_atom.destroy
      dipole.destroy; charge.destroy
      pos.destroy

   end

!  *****************************************************
!  Cluster positions, charges, dipoles, polarisabilities
!  *****************************************************

   get_uc_molecule_info(mol,symop,par,pos,com) ::: leaky
   ! Get the unit cell molecule information for a distributed local
   ! field factor (LFF) calculation. "mol" is the molecule index for
   ! an atom in the unit cell. "pos" are the positions. "par" is the
   ! asymmetric unit atom parent. "com" are the molecular center of
   ! masses.
      mol,symop,par :: VEC{INT}*
      pos,com :: MAT{REAL}*

   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")

      n_atom,n_mol,n,m,u,a :: INT
      mass,mass0 :: VEC{REAL}*
      r,cm  :: VEC{REAL}(3)
      mol0,par0 :: VEC{INT}*
      pos0 :: MAT{REAL}*

      ! Create the info arrays
      n_mol  = .crystal.n_unit_cell_mols
      n_atom = .crystal.n_unit_cell_atoms

      mol.create(n_atom)
      symop.create(n_mol)
      par.create(n_atom)
      pos.create(3,n_atom)
      com.create(3,n_mol)
      mass.create(n_atom)

      ! Set n_atom to the # of atoms in one molecule
      DIE_IF(mod(n_atom,n_mol)/=0,"# of unit cell atoms is not divisible by number of molecules")
      n_atom = n_atom/n_mol

      n = 0
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.crystal.n_unit_cell_atoms

            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle

            mol(n+1:n+n_atom) = m
            par0     => par(  n+1:n+n_atom)
            pos0     => pos(:,n+1:n+n_atom)
            mass0    => mass( n+1:n+n_atom)

            .do_defragment_uc_atom(u,symop(m),par0,pos0,mass0)

            exit

         end

         ! Calculate the center of mass (COM)
         cm = ZERO
         do a = 1,n_atom
            cm = cm + mass0(a)*pos0(:,a)
         end
         cm = cm/sum(mass0)
         com(:,m) = cm

         n = n + n_atom

      end

      mass.destroy

   end

   get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m) ::: leaky
   ! Get the unit cell molecule information for a distributed local field factor
   ! (LFF) calculation. "coc" are the molecular center of charges.
      mol,par :: VEC{INT}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      symop,alpha_m :: MAT3{REAL}*

   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")

      n_atom,n_mol,n,m,u,a :: INT
      charge,charge0,mass,mass0 :: VEC{REAL}*
      e_dipole,r,cm  :: VEC{REAL}(3)
      mol0,par0 :: VEC{INT}*
      symop0,pos0,dipole,dipole0,alpha_q0 :: MAT{REAL}*
      alpha_m0 :: MAT3{REAL}*

      ! Create the info arrays
      n_mol  = .crystal.n_unit_cell_mols
      n_atom = .crystal.n_unit_cell_atoms
      mol.create(n_atom)
      symop.create(3,3,n_mol)
      par.create(n_atom)
      pos.create(3,n_atom)
      coc.create(3,n_atom)
      com.create(3,n_atom)
      alpha_q.create(3,n_atom)
      alpha_m.create(3,3,n_atom)
      charge.create(n_atom)
      mass.create(n_atom)
      dipole.create(3,n_atom)

      ! Set n_atom to the # of atoms in one molecule
      DIE_IF(mod(n_atom,n_mol)/=0,"# of unit cell atoms is not divisible by number of molecules")
      n_atom = n_atom/n_mol

      n = 0
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.crystal.n_unit_cell_atoms

            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle

            mol(n+1:n+n_atom) = m
            symop0   => symop(:,:,m)
            par0     => par(n+1:n+n_atom)
            pos0     => pos(:,n+1:n+n_atom)
            charge0  => charge(n+1:n+n_atom)
            mass0    => mass(n+1:n+n_atom)
            dipole0  => dipole(:,n+1:n+n_atom)
            alpha_q0 => alpha_q(:,n+1:n+n_atom)
            alpha_m0 => alpha_m(:,:,n+1:n+n_atom)

            .do_defragment_uc_atom(u,symop0,par0,pos0,charge0,mass0,dipole0,alpha_q0,alpha_m0)

            exit

         end

         ! Calculate electronic dipole and centre of charge
         e_dipole = ZERO
         do a = 1,n_atom
            e_dipole = e_dipole + dipole0(:,a)
            e_dipole = e_dipole + charge0(a)*pos0(:,a)
         end
         e_dipole = e_dipole/sum(charge0)
         coc(:,n+1:n+n_atom) = spread(e_dipole,2,n_atom)

         ! Calculate the center of mass (COM): make coc the COM
         cm = ZERO
         do a = 1,n_atom
            cm = cm + mass0(a)*pos0(:,a)
         end
         cm = cm/sum(mass0)
         com(:,n+1:n+n_atom) = spread(cm,2,n_atom)

         n = n + n_atom

      end

         ! Debug
       ! stdout.flush
       ! stdout.text("mol:")
       ! stdout.put(mol,"column")
       ! stdout.text("pos:")
       ! stdout.put(transpose(pos))
       ! stdout.text("coc:")
       ! stdout.put(transpose(coc))
       ! stdout.text("charge:")
       ! stdout.put(charge,"column")
       ! stdout.text("dipole:")
       ! stdout.put(transpose(dipole))
       ! stdout.text("alpha_q:")
       ! stdout.put(transpose(alpha_q))
       ! stdout.text("alpha_m:")
       ! do a = 1,alpha_m.dim3
       ! stdout.put(alpha_m(:,:,a))
       ! end

       dipole.destroy
       mass.destroy
       charge.destroy

   end

   get_uc_molecule_info(mol,pos,charge,dipole,frag_atom) ::: leaky
   ! Get the unit cell molecule information for a distributed local field factor
   ! (LFF) calculation. "coc" are the molecular center of charges.
      mol :: VEC{INT}*
      pos :: MAT{REAL}*
      charge,dipole :: VEC{REAL}*
      frag_atom :: VEC{INT}*

   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")

      n_atom,n_mol,n,n3,m,u :: INT
      charge0,dipole0 :: VEC{REAL}*
      mol0 :: VEC{INT}*
      pos0 :: MAT{REAL}*

      ! Create the info arrays
      n_mol  = .crystal.n_unit_cell_mols
      n_atom = .crystal.n_unit_cell_atoms
      mol.create(n_atom)
      pos.create(3,n_atom)
      charge.create(n_atom)
      dipole.create(3*n_atom)
      frag_atom.create(.crystal.n_fragment_atoms)


      ! Set n_atom to the # of atoms in one molecule
      DIE_IF(mod(n_atom,n_mol)/=0,"# of unit cell atoms is not divisible by number of molecules")
      n_atom = n_atom/n_mol

      n  = 0
      n3 = 0
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.crystal.n_unit_cell_atoms

            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle

            mol(n+1:n+n_atom) = m
            pos0     => pos(:,n+1:n+n_atom)
            charge0  => charge(n +1:n +  n_atom)
            dipole0  => dipole(n3+1:n3+3*n_atom)

            if (m==1) then
               .do_defragment_uc_atom(u,pos0,charge0,dipole0,frag_atom)
            else
               .do_defragment_uc_atom(u,pos0,charge0,dipole0)
            end

            exit

         end

         n  = n  +   n_atom
         n3 = n3 + 3*n_atom

      end

   end

!   get_atom_LFF_tensors(L2)
!   ! Get the local field factor tensors for the atom centers of all
!   ! molecules in the unit cell.
!      L2 :: MAT3{REAL}* 
!   ENSURE(.crystal.created,"no crystal")
!   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")
!      nu,m,u,n,k,k1,k2 :: INT
!      pos :: MAT{REAL}*
!      nu = .crystal.n_unit_cell_atoms
!      L2.create(3,3,nu.triangle)
!      pos.create(3,nu)
!      .get_uc_molecule_positions(pos) 
!      pos = matmul(.crystal.unit_cell.direct_matrix,pos)
!      .crystal.unit_cell.make_LFF_tensors(L2,pos)
!      pos.destroy
!    ! L2.destroy
!   end

!   get_uc_molecule_positions(pos) 
!   ! Get the unit cell molecule positions as a flat list. It helps if
!   ! there is only one molecule in the unit cell.
!      pos :: MAT{REAL}
!   ENSURE(.crystal.created,"no crystal")
!   ENSURE(.crystal.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")
!   ENSURE(pos.dim1==3 AND pos.dim2==.crystal.n_unit_cell_atoms,"wrong shape, centroid")
!      m,n,na,u :: INT
!      geometry :: MAT{REAL}*
!      n = 0
!      do m = 1,.crystal.n_unit_cell_mols
!         nullify(geometry)
!         do u = 1,.crystal.n_unit_cell_atoms
!            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle
!            .do_defragment_uc_atom(u,geometry)
!            exit
!         end
!         na = geometry.dim2
!         pos(:,n+1:n+na) = geometry
!         n  = n + na
!         geometry.destroy
!      end
!   end

!  **************
!  Output methods
!  **************

   put
   ! Put the list of vertices for the object
   ENSURE(.info_made,"call make_info first")
      stdout.flush
      stdout.text("Cluster information:")
      stdout.flush
      stdout.show("Generation method       =",.generation_method)
      stdout.show("Defragment?             =",.defragment)
      stdout.show("Radius                  =",.radius)
      stdout.show("No. of atoms            =",.n_atoms)
      stdout.show("No. of fragment atoms   =",.n_fragment_atoms)
      stdout.show("Fragment offset         =",.fragment_offset)
      stdout.show("h_min                   =",.h_min)
      stdout.show("h_max                   =",.h_max)
      if (.fragment_geometry.created)    .put_fragment_geometry
      if (.occupation_list.created)      .put_occupation_list
      if (.atom_connection.created)      .put_atom_connection_table
      if (.occupation_list.created)      .put_atom_symmetry_table
   end

   put_fragment_geometry
   ! Put the initial fragment geometry information
   ENSURE(.fragment_geometry.created,"no fragment_geometry")
      a :: INT
      stdout.flush
      stdout.text("Fragment geometry (crystal axis system):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.flush
      stdout.put("#",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)
      stdout.flush
      do a = 1,.n_fragment_atoms
         stdout.put(a)
         stdout.put(.fragment_geometry(1,a))
         stdout.put(.fragment_geometry(2,a))
         stdout.put(.fragment_geometry(3,a))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=3)
   end

   put_occupation_list
   ! Put the .occupation_list table
   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.created,"no crystal unit cell geometry")
      a,code,h1,h2,h3,u :: INT
      stdout.flush
      stdout.text("Occupation list:")
      stdout.flush
      stdout.dash(int_fields=6,real_fields=3)
      stdout.tab(int_fields=1)
      stdout.put("Unit cell",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Molecule",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=6,real_fields=3)
      do a = 1,.occupation_list.dim
         code = .occupation_list(a)
         u  = code/1000; code = code - u*1000
         h3 = code/100;  code = code - h3*100
         h2 = code/10;   code = code - h2*10
         h1 = code; 
         h1 = h1 - 5                 ! h is the cell offset
         h2 = h2 - 5
         h3 = h3 - 5                 
         stdout.put(a)
         stdout.put(u)
         if (.molecule_for_atom.created) then; stdout.put(.molecule_for_atom(a))
         else;                                 stdout.put(0)
         end
         stdout.put(.crystal.unit_cell_geometry(1,u)+h1)
         stdout.put(.crystal.unit_cell_geometry(2,u)+h2)
         stdout.put(.crystal.unit_cell_geometry(3,u)+h3)
         stdout.put(h1)
         stdout.put(h2)
         stdout.put(h3)
         stdout.flush
      end
      stdout.dash(int_fields=6,real_fields=3)
   end

   put_atom_connection_table
   ! Put the .atom_connection table

   ENSURE(.atom_connection.created,"no atom_connection")
   ENSURE(.molecule_for_atom.created,"no molecule_for_atom")

      m,a,i :: INT
      first :: BIN

      stdout.save
      stdout.set_int_width(5)

      stdout.flush
      stdout.text("Atom connection table:")
      stdout.flush
      stdout.show("n_molecules = ",.n_molecules)

      stdout.flush
      stdout.dash(int_fields=8)
      stdout.put("Cluster",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.flush

      stdout.put("Mol",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom(s)",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=8)

      do m = 1,.n_molecules

         ! Molecule label
         stdout.put(m)

         first = TRUE
         do a = 1,.n_atoms

            if (.molecule_for_atom(a)/=m) cycle
   
            if (NOT first) &
            stdout.tab(int_fields=1) 
            stdout.put(a)
            first = FALSE
   
            if (.atom_connection(a).element.destroyed) then
   
               stdout.flush
   
            else
   
               do i = 1,.atom_connection(a).element.dim
                  stdout.put(.atom_connection(a)[i])
               end
               stdout.flush
   
            end
         end
      end

      stdout.dash(int_fields=8)

      stdout.unsave

   end

!   put_atom_connection_table
!   ! Put the atom connection table
!   ENSURE(.atom_connection.created,"no atom_connection")
!   ENSURE(.molecule_for_atom.created,"no molecule_for_atom")
!      m,n,a,b :: INT
!      stdout.save
!      stdout.set_int_width(5)
!      stdout.flush
!      stdout.text("Molecules and atom connections:")
!      stdout.flush
!      do m = 1,.n_molecules                   ! Loop over molecules
!         stdout.flush
!         stdout.show("Molecule =",m)
!         stdout.flush
!         stdout.put("Atom",int_width=TRUE)
!         stdout.put("Conn",int_width=TRUE)
!         stdout.flush
!
!         n = count(.molecule_for_atom==m)
!         do a = 1,.n_atoms                    ! Loop over atoms in molecules
!            if (.molecule_for_atom(a)/=m) cycle
!            stdout.put(a)
!            if (.atom_connection(a).element.created) then
!            do b = 1,.atom_connection(a).element.dim
!               stdout.put(.atom_connection(a).element(b))
!            end
!            end
!            stdout.flush
!         end
!
!      end
!      stdout.unsave
!   end

   put_atom_symmetry_table
   ! Put the atom symmetry table i.e. those atoms in the cluste related by
   ! symmetry.

   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")
   ENSURE(.crystal.symop_for_unit_cell_atom.created,"no crystal symop_for_unit_cell_atom")

      asym_atom_for_atom,unique :: VEC{INT}*
      symop :: MAT3{REAL}*
      a,u,i :: INT

      asym_atom_for_atom.create(.n_atoms)
      do a = 1,.n_atoms
           u = .occupation_list(a)/1000
           asym_atom_for_atom(a) = .crystal.asym_atom_for_unit_cell_atom(u) 
      end
      unique => asym_atom_for_atom.indices_of_unique_elements

      stdout.flush
      stdout.text("Asymmetric (unique) atoms:")
      stdout.flush
      stdout.show("n_asym_atoms =",unique.dim)
      stdout.put(unique,"column")
      stdout.flush
      stdout.text("Asymmetric (unique) atoms for each atom in the cluster, and associated symop:")
      stdout.flush
      stdout.dash(int_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Unique",int_width=TRUE)
      stdout.put("Symop",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=3)
      do a = 1,.n_atoms                       ! Loop over molecules
         u = .occupation_list(a)/1000
         stdout.put(a)
         stdout.put(asym_atom_for_atom(a))
         stdout.put(.crystal.symop_for_unit_cell_atom(u))
         stdout.flush
      end
      stdout.dash(int_fields=3)
      unique.destroy
      asym_atom_for_atom.destroy
      stdout.flush
      stdout.text("Symop matrices:")
      symop => .crystal.xyz_seitz_matrices
      do i = 1,symop.dim3
         stdout.flush
         stdout.text("Symop "//trim(i.to_str))
         stdout.put(symop(:,:,i),"row_wise")
         stdout.flush
      end
      symop.destroy
   end

   put_tonto_input
   ! Outputs the tonto input file for the cluster, given additionally the list
   ! of atoms which was used to generate the fragment_geometry in crystal.
   ! (See routine make_fragment_data).
   ENSURE(.info_made,"call make_info first")
   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.asymmetric_unit_atom.created,"no atom data")
   ENSURE(.crystal.created,"no crystal data")
      seitz :: MAT3{REAL}*
      therm :: MAT{REAL}(3,3)
      a,u,p,s :: INT
      stdout.text("   atoms= {")
      stdout.flush
      stdout.text("      keys= { label= ")
      stdout.text('              { axis_system= crystal } pos=')
      stdout.text('              { units= angstrom^2 } thermal_tensor= }')
      stdout.flush
      stdout.text("      data= {")
      seitz => .crystal.transposed_xyz_seitz_matrices ! transposed !
      do a = 1,.n_atoms
         u = .occupation_list(a)/1000
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         s = .crystal.symop_for_unit_cell_atom(u)
         stdout.put(.asymmetric_unit_atom(p).label.trim,int_width=TRUE)
         stdout.put(.geometry(1,a))
         stdout.put(.geometry(2,a))
         stdout.put(.geometry(3,a))
!         stdout.put(.asymmetric_unit_atom(p).basis.label.trim)
         therm = .asymmetric_unit_atom(p).thermal_tensor ! in cartesians?
         therm.change_basis_using(seitz(:,:,s))
         therm.convert_to("angstrom^2")
         stdout.put(therm(1,1))
         stdout.put(therm(2,2))
         stdout.put(therm(3,3))
         stdout.put(therm(1,2))
         stdout.put(therm(1,3))
         stdout.put(therm(2,3))
         stdout.flush
      end
      seitz.destroy
      stdout.text("      }")
      stdout.text("   }")
      stdout.flush
   end

!   put_CX(label,special_pos,special_label)
!   ! Outputs some information for the Crystal Explorer program: the list of atoms in
!   ! the cluster, their positions, and whether they are part of the generating
!   ! fragment or not.
!      label :: STR
!      special_pos :: MAT{REAL}, optional
!      special_label :: STR, optional
!   ENSURE(.info_made,"call make_info first")
!   ENSURE(.occupation_list.created,"no occupation_list")
!   ENSURE(.geometry.created,"no cluster geometry")
!   ENSURE(.crystal.created,"no crystal data")
!   ENSURE(.asymmetric_unit_atom.created,"no atom data")
! ! ENSURE(.parent_for_atom.created,"no parent atoms")
!   ENSURE(.is_fragment_atom.created,"no is_fragment_atom array")
!      n,u,a,s :: INT
!      geometry :: MAT{REAL}*
!      pos :: VEC{REAL}(3)
!      therm :: MAT{REAL}(3,3)
!      seitz :: MAT3{REAL}*
!      seitz => .crystal.transposed_xyz_seitz_matrices    ! transposed !
!      geometry.create_copy(.geometry)
!      .crystal.unit_cell.change_from_fractional(geometry)
!    ! geometry = ANGSTROM_PER_BOHR*geometry
!      stdout.flush
!      stdout.text("begin atoms " // label.trim)
!      do n = 1,.n_atoms
!         u = .occupation_list(n)/1000
!         a = .crystal.asym_atom_for_unit_cell_atom(u)
!         s = .crystal.symop_for_unit_cell_atom(u)
!         stdout.put(.asymmetric_unit_atom(a).chemical_symbol)
!         stdout.put(geometry(1,n))
!         stdout.put(geometry(2,n))
!         stdout.put(geometry(3,n))
!       ! therm = .asymmetric_unit_atom(a).thermal_tensor ! This must be in cartesian axes
!       ! therm.change_basis_using(seitz(:,:,s))          ! Use R^T to change U tensor basis
!       ! stdout.put(therm(1,1))
!       ! stdout.put(therm(2,2))
!       ! stdout.put(therm(3,3))
!       ! stdout.put(therm(1,2))
!       ! stdout.put(therm(1,3))
!       ! stdout.put(therm(2,3))
!         if (.is_fragment_atom(n)) stdout.put_text(" IN")
!         stdout.flush
!      end
!      if (present(special_pos) OR present(special_label)) then
!      ENSURE(present(special_pos),"must supply special_pos")
!      ENSURE(present(special_label),"must supply special_label")
!      ENSURE(special_pos.dim1==3,"wrong 1st dimension, special_pos")
!      do n = 1,special_pos.dim2
!         stdout.put(special_label)
!         stdout.put(special_pos(1,n))
!         stdout.put(special_pos(2,n))
!         stdout.put(special_pos(3,n))
!       ! stdout.put(ZERO)
!       ! stdout.put(ZERO)
!       ! stdout.put(ZERO)
!       ! stdout.put(ZERO)
!       ! stdout.put(ZERO)
!       ! stdout.put(ZERO)
!         stdout.flush
!      end
!      end
!      stdout.text("end atoms")
!      geometry.destroy
!      if (.asymmetric_unit_atom.has_thermal_tensors) then
!         stdout.text("begin adp " // label.trim)
!         do n = 1,.n_atoms
!            u = .occupation_list(n)/1000
!            a = .crystal.asym_atom_for_unit_cell_atom(u)
!            s = .crystal.symop_for_unit_cell_atom(u)
!            stdout.put(.asymmetric_unit_atom(a).chemical_symbol)
!            therm = .asymmetric_unit_atom(a).thermal_tensor ! This must be in cartesian axes
!            therm.change_basis_using(seitz(:,:,s))          ! Use R^T to change U tensor basis
!            stdout.put(therm(1,1))
!            stdout.put(therm(2,2))
!            stdout.put(therm(3,3))
!            stdout.put(therm(1,2))
!            stdout.put(therm(1,3))
!            stdout.put(therm(2,3))
!            if (.is_fragment_atom(n)) stdout.put_text(" IN")
!            stdout.flush
!         end
!         if (present(special_pos) OR present(special_label)) then
!         ENSURE(present(special_pos),"must supply special_pos")
!         ENSURE(present(special_label),"must supply special_label")
!         ENSURE(special_pos.dim1==3,"wrong 1st dimension, special_pos")
!         do n = 1,special_pos.dim2
!            stdout.put(special_label)
!            stdout.put(ZERO)
!            stdout.put(ZERO)
!            stdout.put(ZERO)
!            stdout.put(ZERO)
!            stdout.put(ZERO)
!            stdout.put(ZERO)
!            stdout.flush
!         end
!         end
!         stdout.text("end adp " // label.trim)
!      end
!   end

   put_CX(label,angstrom)
   ! Outputs some information for the Crystal Explorer program: the list of atoms in
   ! the cluster, their positions, and whether they are part of the generating
   ! fragment or not.
      label :: STR
      angstrom :: BIN, optional
   ENSURE(.geometry.created,"no cluster geometry")
   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.is_fragment_atom.created,"no is_fragment_atom")
   ENSURE(.asymmetric_unit_atom.created,"no atom data")
   ENSURE(.crystal.created,"no crystal data")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.created,"no crystal asym_atom_for_unit_cell_atom")
   ENSURE(.crystal.symop_for_unit_cell_atom.created,"no crystal symop_for_unit_cell_atom")
      n,u,a,s :: INT
      geometry :: MAT{REAL}*
      ulist :: VEC{INT}*
      therm :: MAT{REAL}(3,3)
      angst :: BIN
      seitz :: MAT3{REAL}*

      angst = FALSE
      if (present(angstrom)) angst = angstrom

      ! Transposed seutz matrices
      seitz => .crystal.transposed_xyz_seitz_matrices 

      ! Geometry coordinates
      ulist.create(.n_atoms)
      ulist = .occupation_list/1000              
      geometry.create_copy(.geometry)
      .crystal.unit_cell.change_from_fractional(geometry)
      if (angst) geometry = ANGSTROM_PER_BOHR*geometry  

      ! Print atom_coords
      stdout.flush
      stdout.text("begin atom_coords " // label.trim)
      do n = 1,.n_atoms
         u = ulist(n)
         a = .crystal.asym_atom_for_unit_cell_atom(u)
         stdout.put(.asymmetric_unit_atom(a).label)
         stdout.put(.asymmetric_unit_atom(a).chemical_symbol)
         stdout.put(geometry(1,n))
         stdout.put(geometry(2,n))
         stdout.put(geometry(3,n))
         if (.is_fragment_atom(n)) stdout.put_text(" IN")
         stdout.put(.asymmetric_unit_atom(a).site_disorder_group)
         stdout.put(.asymmetric_unit_atom(a).site_occupancy)
         stdout.flush
      end
      stdout.text("end atom_coords")

      ! Print geometry
      stdout.flush
      stdout.text("begin atoms " // label.trim)
      do n = 1,.n_atoms
         u = ulist(n)
         a = .crystal.asym_atom_for_unit_cell_atom(u)
         stdout.put(.asymmetric_unit_atom(a).chemical_symbol)
         stdout.put(geometry(1,n))
         stdout.put(geometry(2,n))
         stdout.put(geometry(3,n))
         if (.is_fragment_atom(n)) stdout.put_text(" IN")
         stdout.flush
      end
      stdout.text("end atoms")

      geometry.destroy

      ! Print ADP's
      if (.asymmetric_unit_atom.has_thermal_tensors) then
         stdout.flush
         stdout.text("begin adp " // label.trim)
         do n = 1,.n_atoms
            u = ulist(n)
            a = .crystal.asym_atom_for_unit_cell_atom(u)
            s = .crystal.symop_for_unit_cell_atom(u)
            stdout.put(.asymmetric_unit_atom(a).chemical_symbol)
            therm = .asymmetric_unit_atom(a).thermal_tensor ! This must be in cartesian axes
            therm.change_basis_using(seitz(:,:,s))          ! Use R^T to change U tensor basis
            if (angst) therm = BOHR_PER_ANGSTROM*BOHR_PER_ANGSTROM*therm
            stdout.put(therm(1,1))
            stdout.put(therm(2,2))
            stdout.put(therm(3,3))
            stdout.put(therm(1,2))
            stdout.put(therm(1,3))
            stdout.put(therm(2,3))
            if (.is_fragment_atom(n)) stdout.put_text(" IN")
            stdout.flush
         end
         stdout.text("end adp " // label.trim)
      end

      ! Cleanup
      ulist.destroy
      seitz.destroy

   end

   put_spartan(label)
   ! Outputs some information for the Spartan program: the list of atoms in
   ! the cluster, their positions, and whether they are part of the generating
   ! fragment or not.
      label :: STR
   ENSURE(.info_made,"call make_info first")
   ENSURE(.occupation_list.created,"no occupation_list")
   ENSURE(.geometry.created,"no cluster geometry")
   ENSURE(.crystal.created,"no crystal data")
   ENSURE(.asymmetric_unit_atom.created,"no atom data")
 ! ENSURE(.parent_for_atom.created,"no parent atoms")
   ENSURE(.is_fragment_atom.created,"no is_fragment_atom array")
      word :: STR
      n,u,a :: INT
      geometry :: MAT{REAL}*
      geometry.create_copy(.geometry)
      .crystal.unit_cell.change_from_fractional(geometry)
      geometry = ANGSTROM_PER_BOHR*geometry
      stdout.flush
      stdout.text("=== SPARTAN DATA ===")
      stdout.text(label.trim)
      stdout.text("M001")
      stdout.text("0 1")
      do n = 1,.n_atoms
         u = .occupation_list(n)/1000
         a = .crystal.asym_atom_for_unit_cell_atom(u)
         stdout.put(.asymmetric_unit_atom(a).atomic_number)
         stdout.put(geometry(1,n))
         stdout.put(geometry(2,n))
         stdout.put(geometry(3,n))
         stdout.flush
      end
      stdout.text("ENDCART")
      stdout.text("ATOMLABELS")
      do n = 1,.n_atoms
         u = .occupation_list(n)/1000
         a = .crystal.asym_atom_for_unit_cell_atom(u)
         word = .asymmetric_unit_atom(a).label
         word = '"'//trim(word)//'"'
         stdout.put(trim(word))
         stdout.flush
      end
      stdout.text("ENDATOMLABELS")
      geometry.destroy
   end

!  **************
!  Debug printing
!  **************

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{INT})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end


end
