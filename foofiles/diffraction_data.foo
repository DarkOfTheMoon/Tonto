!-------------------------------------------------------------------------------
!
! DIFFRACTION_DATA: Diffraction data structure for crystals
!
! $Id$
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module DIFFRACTION_DATA

   implicit none

   saved_self :: DIFFRACTION_DATA*, private

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  ==========================
!  Create and destroy methods
!  ==========================

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the diffraction data object

      nullify(.reflections)

      nullify(.scale_factors)

      nullify(.refine_U_iso_for_atom)
      nullify(.refine_3rd_order_for_atom)
      nullify(.refine_4th_order_for_atom)
      nullify(.refine_atom_parameters)

      nullify(.LS_exp)
      nullify(.LS_fit)
      nullify(.LS_ref)

   end

   destroy_ptr_part ::: leaky
   ! Erase all pointer information

      ! Reflection related data
      .destroy_reflection_data

      ! Refinement/fit related data
      .refine_U_iso_for_atom.destroy 

      .refine_3rd_order_for_atom.destroy 
      .refine_4th_order_for_atom.destroy 
      .refine_atom_parameters.destroy 

      ! Least-squares-related data
      .destroy_LS_rigid_fit_data
      .destroy_LS_refinement_data

   end

   destroy_reflection_data ::: leaky
   ! Erase all reflection data

      if (.reflections.created) then

         .exp_scale_factor = ONE
         .Larsen_extinction_factor = ZERO
         .reflections.destroy
         .scale_factors.destroy

      end

   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(data) ::: leaky
   ! Set self to be crystal.
      data :: DIFFRACTION_DATA, IN

      self = data

      .nullify_ptr_part

      ! Reflection-related data
      if (data.reflections.created)                .reflections.create_copy(data.reflections)
      if (data.scale_factors.created)              .scale_factors.create_copy(data.scale_factors)

      if (data.refine_U_iso_for_atom.created)      .refine_U_iso_for_atom.create_copy(data.refine_U_iso_for_atom)
      ! Refinement/fit related data

      if (data.refine_3rd_order_for_atom.created)  .refine_3rd_order_for_atom.create_copy(data.refine_3rd_order_for_atom)
      if (data.refine_4th_order_for_atom.created)  .refine_4th_order_for_atom.create_copy(data.refine_4th_order_for_atom)
      if (data.refine_atom_parameters.created)     .refine_atom_parameters.create_copy(data.refine_atom_parameters)

      if (data.LS_exp.created)                     .LS_exp.create_copy(data.LS_exp)
      if (data.LS_fit.created)                     .LS_fit.create_copy(data.LS_fit)
      if (data.LS_ref.created)                     .LS_ref.create_copy(data.LS_ref)

   end

!  ===========
!  Set methods
!  ===========

   set_saved_self ::: get_from(OBJECT)
   ! Set saved_self
   end

   set_from_saved_self ::: get_from(OBJECT)
   ! Set from saved_self
   end

   set_defaults ::: leaky
   ! Set up a default diffraction_data object

      .destroy_reflection_data

      ! Set the data kind
      .data_kind              = " "

      ! Experimental data
      .wavelength             = DIFFRACTION_DATA_WAVELENGTH
      .temperature            = ZERO
      .NKA_T_sequence_no      = 0

      ! Data treatment options
      .obs_on_sigma_cutoff    = DIFFRACTION_DATA_OBS_ON_SIGMA_CUTOFF
      .z_statistic_cutoff     = -ONE
      .stl_cutoff             = -ONE
      .show_rejects           = TRUE

      ! Structure factor calculation parameters
      .partition_model        = DIFFRACTION_DATA_PARTITION_MODEL
      .thermal_smearing_model = DIFFRACTION_DATA_THERMAL_SMEARING_MODEL
      .use_Voronoi_atoms      = FALSE

      ! Experimental corrections
      .exp_scale_factor       = ONE
      .use_Larsen_extinction    = DIFFRACTION_DATA_OPTIMISE_EXTINCTION
      .Larsen_extinction_factor = ZERO 
      .correct_dispersion     = DIFFRACTION_DATA_CORRECT_DISPERSION

      ! Agreement statistics
      .n_param                  = 0
      .chi2                     = ZERO

      ! Refine/fit switches
      .fit_structure            = FALSE
      .refine_structure         = FALSE
      .refine_positions_only    = FALSE
      .refine_ADPs_only         = FALSE
      .refine_H_ADPs            = TRUE
      .refine_H_U_iso           = FALSE
      .refine_anharmonicity     = FALSE
      .restart_HAR_with_promolecule = FALSE

      ! Set the for a LS rigid-atom fit
      .destroy_LS_rigid_fit_data
      .set_LS_rigid_fit_data

      ! Set the for a LS refinement
      .destroy_LS_refinement_data
      .set_LS_refinement_data

   end

   update(unit_cell,spacegroup)
   ! Update the crystal information after setting values. If the
   ! "unit_cell" is provided, then that is used to define the reflection
   ! .theta values.
      self :: OUT
      unit_cell :: UNIT_CELL, IN, optional
      spacegroup :: SPACEGROUP, IN, optional
 
      ! Any reflections?
      if (.reflections.destroyed) return
 
      ! If reflections are to be manuially scaled
      if (.reflections.have_obs) then
         if (NOT .exp_scale_factor.equals(ONE)) then
         .reflections.scale_obs_and_sigma(.exp_scale_factor)
         .exp_scale_factor = ONE
         end
         .set_obs_on_sigma
      end

      if (present(unit_cell))  .set_theta_angles(unit_cell.reciprocal_matrix)

      if (present(spacegroup)) .set_equivalence_factors(spacegroup)

   end

   update(data,free_data,free_percentage)
   ! Update "data" to be an alias of "self" and create the "free_data"
   ! be the diffraction data
      self :: PTR
      data :: DIFFRACTION_DATA*
      free_data :: DIFFRACTION_DATA*
      free_percentage :: INT, IN

   DIE_IF(data.created,     "data already exists!")
   DIE_IF(free_data.created,"free_data already exists!")

      data => self
        
      if (free_percentage>0 AND data.reflections.created) then
         free_data.create_copy(self)
         free_data.reflections.destroy
         free_data.reflections.set_free_reflections_from(data.reflections,free_percentage)
      end

   end

   set_data_kind(kind) 
   ! Set the kind of reflection data that is being used.
      kind :: STR, IN

      .data_kind = kind

      .data_kind.to_lower_case

      select case (.data_kind)
         case ("free-neutron-f")
         case ("free-neutron-f2")
         case ("free-pnd-f")
         case ("free-x-ray-f")
         case ("free-x-ray-f2")
         case ("neutron-f")
         case ("neutron-f2")
         case ("pnd-f")
         case ("x-ray-f")
         case ("x-ray-f2")
         case default; UNKNOWN(.data_kind)
      end
   
   end

   set_obs_on_sigma_cutoff(val) 
   ! Set the obs/sigma cutoff to use for rejecting weak reflections.
      val :: REAL, IN

   DIE_IF(val<=ZERO,"cutoff must be positive")

      .obs_on_sigma_cutoff = val

   end

   set_z_statistic_cutoff(val) 
   ! Set the z_statistic_cutoff to use for rejecting weak reflections.
      val :: REAL, IN

   DIE_IF(val<=ZERO,"cutoff must be positive")

      .z_statistic_cutoff = val

   end

   set_equivalence_factors(spacegroup) 
   ! Set the equivalence factors, the number of distinct reflections
   ! which are symmetry equivalent to a particular (hkl) triple, for all
   ! the reflections.
      spacegroup :: SPACEGROUP , IN

   ENSURE(.reflections.created,"no reflection data")

      H,new :: VEC{INT}(3)
      n,s,u,n_refl :: INT

      n_refl = .reflections.n_refl

      do n = 1,n_refl

         H = .reflections.miller_indices(n)

         ! Count the times H maps to itself
         u = 1
         do s = 2,spacegroup.n_seitz
            new = int(matmul(REALIFY(H),spacegroup.seitz(1:3,1:3,s)))
            if (H(1)/=new(1) OR H(2)/=new(2) OR H(3)/=new(3)) u = u + 1
         end

         .reflections(n).equivalence_factor = spacegroup.n_seitz/u

      end
   
   end

   set_theta_angles(reciprocal_matrix)
   ! This routine is called after the reflections are read in, in order to set
   ! all the .theta values, which are used later all over the place ...
      reciprocal_matrix :: MAT{REAL}(3,3), IN

      H,K :: VEC{REAL}(3)
      sin_theta :: REAL
      stl :: REAL
      n :: INT

      do n = 1,.reflections.n_refl

         H = .reflections.miller_indices(n)
 
         K.to_product_of(reciprocal_matrix,H)
 
         sin_theta = HALF* K.norm * .wavelength
         .reflections(n).theta = asin(sin_theta)
         stl = HALF * K.norm 
         .reflections(n).stl = stl

      end

   end

   set_obs_on_sigma
   ! This routine is called after the reflections are read in, in order to set
   ! all the .theta values, which are used later all over the place ...

      obs_on_sigma :: REAL
      n :: INT

      do n = 1,.reflections.n_refl

         obs_on_sigma = .reflections(n).obs/.reflections(n).sigma
         .reflections(n).obs_on_sigma = obs_on_sigma

      end

   end

   set_refine_structure(val)
   ! Generic set
      val :: BIN

      .refine_structure = val

      ! If refining you can't be fitting
      if (val) .fit_structure = NOT val 

   end

   set_fit_structure(val)
   ! Generic set
      val :: BIN

      .fit_structure = val

      ! If fitting, you can't be refining
      if (NOT val) .refine_structure = NOT val

   end

!  ============
!  Read methods
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: PTR
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: PTR
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)

         case ("}                             ")  ! exit read_loop

         case ("correct_dispersion=           "); .read_correct_dispersion

         case ("data_kind=                    "); .read_data_kind
         case ("debug_off                     "); .read_debug_off
         case ("debug_on                      "); .read_debug_on
         case ("destroy_reflection_data       "); .destroy_reflection_data

         case ("exp_scale_factor=             "); .read_exp_scale_factor

         case ("junk=                         "); .read_junk

         case ("make_predictions              "); .make_predictions

         case ("nka_t_sequence_no=            "); .read_NKA_T_seq_no

         case ("obs_on_sigma_cutoff=          "); .read_obs_on_sigma_cutoff
         case ("use_Larsen_extinction=          "); .read_use_Larsen_extinction
         case ("optimize_extinction=          "); .read_use_Larsen_extinction

         case ("partition_model=              "); .read_partition_model
         case ("prune_bad_reflections         "); .prune_bad_reflections
         case ("prune_high_angle_reflections  "); .prune_high_angle_reflections
         case ("prune_low_angle_reflections   "); .prune_low_angle_reflections
         case ("prune_negative_reflections    "); .prune_negative_F_reflections
         case ("prune_weak_reflections        "); .prune_weak_reflections
         case ("put                           "); .put
         case ("put_debug_list                "); .put_debug_list
         case ("put_sin_theta_on_lambda       "); .put_sin_theta_on_lambda

         case ("read_cif                      "); .read_CIF
         case ("redirect                      "); .redirect
         case ("refine_3rd_order_for_atoms=   "); .read_refine_3rd_order
         case ("refine_4th_order_for_atoms=   "); .read_refine_4th_order
         case ("refine_adps_only=             "); .read_refine_ADPs_only
         case ("refine_h_adps=                "); .read_refine_H_ADPs
         case ("refine_h_u_iso=               "); .read_refine_H_U_iso
         case ("refine_positions_only=        "); .read_refine_positions_only
         case ("refine_u_iso_for_atoms=       "); .read_refine_U_iso_atoms
         case ("reflection_data=              "); .read_reflection_data
         case ("restart_har_with_promolecule= "); .read_restart_with_promolecule
         case ("revert                        "); .revert

         case ("show_rejects=                 "); .read_show_rejects
         case ("stl_cutoff=                   "); .read_stl_cutoff

         case ("thermal_smearing_model=       "); .read_thermal_smearing_model
         case ("temperature=                  "); .read_temperature

         case ("units=                        "); .read_units
         case ("use_voronoi_atoms=            "); .read_use_Voronoi_atoms

         case ("wavelength=                   "); .read_wavelength


         case ("z_statistic_cutoff=           "); .read_z_statistic_cutoff
         case ("zero_negative_obs             "); .zero_negative_obs

         case default;                       UNKNOWN(word)

      end

   end

! Reading

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file
   end

   read_data_kind
   ! Read the kind of diffraction data kind obtained in the experiment
      kind :: STR

      stdin.read(kind)

      .set_data_kind(kind)

   end

   read_obs_on_sigma_cutoff ::: private
   ! Read obs_on_sigma_cutoff

      val :: REAL

      stdin.read(val)

      .set_obs_on_sigma_cutoff(val)

   end

   read_z_statistic_cutoff ::: private
   ! Read the z_statistic_cutoff for prune_bad_reflections

      val :: REAL

      stdin.read(val)

      .set_z_statistic_cutoff(val)

   end

   read_stl_cutoff ::: private
   ! Read the stl_cutoff for prune_high_angle_reflections

      stdin.read(.stl_cutoff)

      ENSURE(.stl_cutoff>=ZERO,"must be positive")

   end

   read_show_rejects ::: private
   ! Read wether to show the rejected reflections
      stdin.read(.show_rejects)
   end

   read_exp_scale_factor ::: private
   ! Read the structure factor multiplier
      stdin.read(.exp_scale_factor)
   end

   read_wavelength ::: private
   ! Read the experimental wavelength
      stdin.read_quantity(.wavelength)
   end

   read_use_Larsen_extinction ::: private
   ! Read the switch whether to correct extinction or not, according to the
   ! Larson formula
      stdin.read(.use_Larsen_extinction)
   end

   read_correct_dispersion ::: private
   ! Read the switch whether to correct dispersion or not, according to the
   ! atomic dispersion factors
      stdin.read(.correct_dispersion)
   end

   read_thermal_smearing_model ::: private
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      stdin.read(.thermal_smearing_model)
      .thermal_smearing_model.to_lower_case
      select case (.thermal_smearing_model)
         case("         ")
         case("none     ")
         case("coppens  ")
         case("hirshfeld")
         case("stewart  ")
         case("tanaka   ")
         case default;    UNKNOWN(.thermal_smearing_model)
      end
   end

   read_partition_model ::: private
   ! Read the partition model to used to correct for oversampled fragments
   ! of the unit cell when calculating the structure factors
      stdin.read(.partition_model)
      .partition_model.to_lower_case
      select case(.partition_model)
         case("        ")
         case("none    ")
         case("mulliken")
         case("gaussian")
         case default;    UNKNOWN(.partition_model)
      end
   end

   zero_negative_obs ::: leaky
   ! This routine zero's negative observations, and adjusts the sigma
   ! to be appropriately larger. This is intended for use with
   ! structure factor maghnitude data, |F|'s.
      self :: PTR

   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_obs,"no experimental data")

      n_refl,i :: INT
      ref :: REFLECTION*

      n_refl = .reflections.n_refl

      do i = 1,n_refl

         ref => .reflections(i)

         if (ref.obs < ZERO) then
            ref.sigma = ref.sigma + abs(ref.obs)
            ref.obs   = ZERO
         end

      end

   end

   read_temperature
   ! Read the temperature
      stdin.read(.temperature)
      ENSURE(.temperature>=0,"temperature is not positive!")
   end

   read_NKA_T_seq_no
   ! Read the temperature sequence no for NKA output file
      stdin.read(.NKA_T_sequence_no)
      ENSURE(.NKA_T_sequence_no>0,"sequence no is not positive!")
   end

   read_reflection_data ::: leaky, private
   ! Read in reflection data in the standard order from "stdin".
      DIE_IF(.data_kind==" ","Use data_kind= to say the kind data to be inputted")
      .reflections.read_list_keywords
   end


   read_refine_ADPs_only
   ! Read whether to refine only the ADP's
      stdin.read(.refine_ADPs_only)
   end

   read_refine_H_ADPs
   ! Read whether to refine only the H atom ADP's
      stdin.read(.refine_H_ADPs)
   end

   read_refine_H_U_iso
   ! Read whether to refine only the H atom U_iso's
      stdin.read(.refine_H_U_iso)
   end

   read_refine_positions_only
   ! Read whether to refine only the atom positions
      stdin.read(.refine_positions_only)
   end

   read_refine_3rd_order ::: leaky
   ! Read the list of atoms for which third-order anharmonicty
   ! parameters are to be refined.
      stdin.read_ptr(.refine_3rd_order_for_atom)
      .refine_anharmonicity = TRUE
   end

   read_refine_4th_order ::: leaky
   ! Read the list of atoms for which fourth-order anharmonicty
   ! parameters are to be refined.
      stdin.read_ptr(.refine_4th_order_for_atom)
      .refine_anharmonicity = TRUE
   end

   read_refine_U_iso_atoms ::: leaky
   ! Read the list of atoms refined isotropically
      stdin.read_ptr(.refine_U_iso_for_atom)
      stdout.text("Check input")
      stdout.put(.refine_U_iso_for_atom)
   end

   read_use_Voronoi_atoms
   ! Read whether to use Voronoi atoms in refinement
      stdin.read(.use_Voronoi_atoms)
   end

   read_restart_with_promolecule ::: leaky
   ! Read whether to restart with promolecule initial guess.
      stdin.read(.restart_HAR_with_promolecule)
   end


!  ========
!  Read CIF
!  ========

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File
   ! with the "name" taken from stdin.

      name :: STR
      found :: BIN
      cif :: CIF*

      ! Read name from stdin
      stdin.read(name)

      ! Create and open the CIF
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found") 

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif,n_pADPs) ::: leaky
   ! Read information from a Crystallographic Information File "cif".
      cif :: CIF, IN
      n_pADPs :: INT, IN, optional

      ! Read reflections
      .read_CIF_reflections(cif)

      ! Read covariance matrix
      if (present(n_pADPs)) .read_CIF_covariance(cif,n_pADPs)

   end

   read_CIF_reflections(cif) ::: leaky
   ! Read information from a Crystallographic Information File "cif".
      cif :: CIF, IN

      there :: VEC{BIN}(5)
      h,k,l :: VEC{INT}*
      Fm,Sg :: VEC{REAL}*

      ! Find reflections
      cif.find_looped_item("_diffrn_refln_index_h",there(1))
      cif.find_looped_item("_diffrn_refln_index_k",there(2))
      cif.find_looped_item("_diffrn_refln_index_l",there(3))
      cif.find_looped_item("_diffrn_refln_obs" ,there(4))
      cif.find_looped_item("_diffrn_refln_sigma",there(5))

      ! Read reflections
      if (all(there)) then

         ! Read
         cif.read_looped_item("_diffrn_refln_index_h",h)
         cif.read_looped_item("_diffrn_refln_index_h",k)
         cif.read_looped_item("_diffrn_refln_index_h",l)
         cif.read_looped_item("_diffrn_refln_obs" ,Fm)
         cif.read_looped_item("_diffrn_refln_sigma",Sg)

         ! Create and assign
         .reflections.create(h.dim)
         .reflections.set_h(h)
         .reflections.set_k(k)
         .reflections.set_l(l)
         .reflections.set_obs_to(Fm)
         .reflections.set_sigma_to(Sg)

         ! Clean
         Sg.destroy
         Fm.destroy
         l.destroy
         k.destroy
         h.destroy

      end

   end

   read_CIF_covariance(cif,n_pADPs) ::: leaky
   ! Read information from a Crystallographic Information File "cif".
      cif :: CIF, IN
      n_pADPs :: INT, IN

      there :: VEC{BIN}(5)
      cov :: VEC{REAL}*
      np :: INT

      ! Find Tonto asymmetric unit covariance matrix
      cif.find_item("_covariance_matrix",there(1))

      ! Read reflections -- must have n_pADPs
      if (there(1)) then

         ! Dimension
         np = n_pADPs

         ! Create
         .LS_fit.covariance_matrix.create(np,np)

         ! Read and set
         cov.create(np*np)
         cif.read_item("_covariance_matrix",cov)
         .LS_fit.covariance_matrix = reshape(cov,[np,np])

         ! Clean
         cov.destroy

      end

   end


!  ===================
!  Pruning reflections
!  ===================

   prune ::: template
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
      self :: PTR

   ENSURE(.created,"No data")
   ENSURE(.reflections.created,"No reflection data")

   end

   prune_bad_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_large_z_statistic, EPS?=>.z_statistic), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_high_angle_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_high_stl, EPS?=>.stl), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_low_angle_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_low_stl, EPS?=>.stl), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_negative_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_weak_obs, EPS?=>ZERO, SHOW?=>"Obs"), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_weak_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_weak_obs, EPS?=>.obs_on_sigma, SHOW?=>"Obs/sigma"), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end


!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end


!  ===========
!  Intensities
!  ===========

   lp_factor result (res)
   ! Return the array of the Lorentz Polarization factors for all the
   ! reflections
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflections.created,"no reflection data")

      n_refl,n :: INT
      c,s,two_theta :: REAL

      n_refl = .reflections.n_refl

      do n = 1,n_refl

         two_theta = TWO*.reflections(n).theta
         c = cos(two_theta)
         s = sin(two_theta)

         if (s.is_zero(TOL(8))) then
            res(n) = ZERO
            WARN("lp_factor for (000) reflection set to zero")
         else
            res(n) = (1+c*c)/(TWO*s)
         end

      end

   end


! New

!  ==========
!  Model F's
!  ==========

   make_xray_F_pred ::: leaky
   ! Make predicted X-ray F's by optimizing all requested experimental
   ! parameters.
   self :: PTR

      ! Initialize (leaky)
      .init_xray_F

      ! Do the least squares (leaky)
      .set_saved_self
      .LS_exp.do_fit(::put_xray_F_to,::put_xray_dF_to,::set_xray_F_params_to)

   end

! F set/put routines

   init_xray_F ::: leaky
   ! Initialize least-squares for fitting X-ray F's with experimental
   ! phenomenological parameters.

   ENSURE(.data_kind=="xray-f","wrong data_kind, "//trim(.data_kind))
   ENSURE(.reflections.created,"no reflections")
   DIE_IF(NOT .reflections.have_obs,"no obs")
   DIE_IF(NOT .reflections.have_sigma,"no sigma")

      n_g,n_p,n_d,p :: INT
      X,Y0,sigma :: VEC{REAL}*
      X_labels :: VEC{STR}*

      ! Get no. of parameters
      n_g = .reflections.no_of_groups
      n_p = .no_of_non_pADPs
      n_d = .reflections.dim

      ! Reset scale factors
      .scale_factors.destroy
      .scale_factors.create(n_g)
      .scale_factors = ONE

      ! Reset extinction
      .Larsen_extinction_factor = ZERO

      ! Create parameter vector and labels
      X.create(n_p)
      X_labels.create(n_p)

      ! Set parameter vector and labels
      do p = 1,n_p
         X(p) = .scale_factors(p)                   
         X_labels(p) = "Scale factor "//trim(p.to_str)
      end
      if (.use_Larsen_extinction) then
         X(n_p)       = .Larsen_extinction_factor
         X_labels(n_p) = "Larsen extinction factor"
      end

      ! Initialize F data
      Y0.create(n_d)
      sigma.create(n_d)
      .reflections.put_obs_to(Y0)
      .reflections.put_sigma_to(sigma)

      ! Set up least squares
      .LS_exp.create
      .LS_exp.initialize(X,Y0,sigma,X_labels)

      ! Clean
      sigma.destroy
      Y0.destroy
      X_labels.destroy
      X.destroy

   end

   set_xray_F_params_to(X) ::: selfless
   ! Set the non-pADP parameters for predicting x-ray F's to "X"
   ! This version for least-squares optimization.
      X :: VEC{REAL}, IN

      self :: DIFFRACTION_DATA*

      ! Recover self
      .set_from_saved_self

      ! Set parameters
      .set_xray_F_params(X)

   end

   set_xray_F_params(X)
   ! Set the non pADP parameters for predicting x-ray F's to "X"
      X :: VEC{REAL}, IN

   ENSURE(.data_kind=="xray-f","wrong data_kind, "//trim(.data_kind))
   ENSURE(.reflections.created,"no reflections")
   ENSURE(X.dim==.no_of_non_pADPs,"wrong size, X")

      p,n_g,n_p :: INT

      ! Get no. of parameters
      n_g = .reflections.no_of_groups
      n_p = .no_of_non_pADPs

      ! Set scale factors
      do p = 1,n_g
         .scale_factors(p) = X(p)
      end

      ! Set extinction parameter
      if (.use_Larsen_extinction) then
         .Larsen_extinction_factor = X(n_p)
      end

   end

   put_xray_F_to(Y) ::: selfless
   ! Make and put the *predicted* x-ray F's in "Y"
   ! This version for least-squares optimization.
      Y :: VEC{REAL}, OUT

      self :: DIFFRACTION_DATA*

      ! Recover self
      .set_from_saved_self

      ! Get F_pred
      .put_xray_F(Y)

   end

   put_xray_F(Y)
   ! Make and put the *predicted* x-ray F's in "Y"
   ! NOTE: This routine sets .reflections(:).pred
   ! NOTE: Must set reflections(:).cal = abs(reflections(:).calc)
      Y :: VEC{REAL}, OUT

      F,C,ext :: VEC{REAL}*
      n_d :: INT

      ! No. of data
      n_d = Y.dim

      ! Temporaries
      F.create(n_d)
      C.create(n_d)

      ! Get the (uncorrected) values
      ! >> NOTE: cal must have been set <<
      .reflections.put_cal_to(F)

      ! Get experimental corrections
      .put_scale_correction_to(C,.scale_factors)
      if (.use_Larsen_extinction) then
         ext.create(n_d)
         .put_Larsen_correction_to(ext,.Larsen_extinction_factor)
         C = ext*C
         ext.destroy
      end

      ! Apply corrections
      Y = C*F

      ! >> Set predicted data <<
      .reflections.set_pred_to(Y)

      ! Clean
      C.destroy
      F.destroy

   end

   put_xray_dF_to(dY) ::: selfless
   ! Make and put the derivative of the *predicted* x-ray F's in "dY"
   ! This version for least-squares optimization.
      dY :: MAT{REAL}, OUT

      self :: DIFFRACTION_DATA*

      ! Recover self
      .set_from_saved_self

      ! Get F_pred derivatives
      .put_dF_pred(dY)

   end

   put_xray_dF(dY)
   ! Make and put the derivative of the *predicted* x-ray F's in "dY"
      dY :: MAT{REAL}, OUT

      n_p,n_g :: INT

      ! No. of data
      n_p = dY.dim2
      n_g = .reflections.no_of_groups

      ! Set scale derivatives
      .put_dF_dscales(dY(:,1:n_g))

      ! Set extinction correction
      if (.use_Larsen_extinction) .put_dF_dLarsen(dY(:,n_p))

   end

! Larsen extinction correction for F's

   put_dF_dLarsen(dF)
   ! Get derivative of structure factor magnitudes wrt Larsen
   ! extinction parameter in "dF(n_refl,1)"
      dF :: VEC{REAL}, OUT

   ENSURE(dF.dim1==saved_self.reflections.dim1,"wrong dim1, dF")
   ENSURE(dF.dim2==1,"wrong dim2, dF")

      dL,s :: VEC{REAL}*
      n_d :: INT

      ! No. of data
      n_d = dF.dim

      ! Get scale correction only
      s.create(n_d)
      .put_scale_correction_to(s,.scale_factors)

      ! Get derivative extinction correction
      dL.create(n_d)
      .put_dLarsen_correction_to(dL)

      ! Get derivatives
      dF(:) = s(:) * dL(:)

      ! Clean
      dL.destroy
      s.destroy

   end

   put_Larsen_correction_to(C,extinction_factor) ::: private
   ! Return the Larsen extinction correction in "C".
   ! NOTE: F_cal must be set to abs(F_calc).
      C :: VEC{REAL}, OUT
      extinction_factor :: REAL, IN

   ENSURE(C.dim==.reflections.dim1,"wrong dim1, dF")

      F_abs2,F_abs,val :: REAL
      angle_part :: VEC{REAL}*
      n,n_refl :: INT

      if (extinction_factor.is_zero(TOL(9))) then

         C = ONE

      else

         ! Get the angle part
         angle_part.create(n_refl)
         .put_Larsen_angle_part_to(angle_part)

         ! Make Larsen correction without scale factors
         do n = 1,.reflections.dim

            F_abs  = .reflections(n).cal
            F_abs2 = F_abs*F_abs

            val    = ONE + extinction_factor*F_abs2*angle_part(n)
            val    = ONE/sqrt(sqrt(val))

            C(n)   = val

         end

         ! Clean
         angle_part.destroy

      end

   end

   put_dLarsen_correction_to(dC) ::: private
   ! Return the derivative Larsen extinction correction in "res".
   ! NOTE: F_cal must be set to abs(F_calc).
      dC :: VEC{REAL}, OUT

   ENSURE(dC.dim==.reflections.dim1,"wrong dim1, dF")

      F_abs2,F_abs,val,ang :: REAL
      angle_part :: VEC{REAL}*
      n_refl,g,n :: INT

      if (.Larsen_extinction_factor.is_zero(TOL(9))) then

         dC = ZERO

      else

         ! Get the Larsen angle part
         n_refl = .reflections.dim
         angle_part.create(n_refl)
         .put_Larsen_angle_part_to(angle_part)

         do n = 1,.reflections.dim

            F_abs  = .reflections(n).cal
            F_abs2 = F_abs*F_abs
    
            ang = angle_part(n)

            val = ONE + .Larsen_extinction_factor*F_abs2*ang
            val = ONE/val

            dC(n) = -HALF * .Larsen_extinction_factor * sqrt(F_abs2*sqrt(val)) * val * ang

         end

         ! Clean
         angle_part.destroy

      end

   end

   put_Larsen_angle_part_to(res) ::: private
   ! Return the angular part of the Larsen extinction correction.
      res :: VEC{REAL}, OUT

      n :: INT
      twotheta,c,s :: REAL

      do n = 1,.reflections.dim

         twotheta = TWO*.reflections(n).theta

         c = cos(twotheta)
         s = sin(twotheta)

         res(n) = (ONE+c*c)/(ONE+c*s)

      end

   end

!  ==========
!  Model F2's
!  ==========

   make_xray_F2_pred ::: leaky
   ! Make predicted X-ray F2's by optimizing all requested experimental
   ! parameters.
   self :: PTR

      ! Initialize (leaky)
      .init_xray_F2

      ! Do the least squares (leaky)
      .set_saved_self
      .LS_exp.do_fit(::put_xray_F2_to,::put_xray_dF2_to,::set_xray_F2_params_to)

   end

! F2 set/put routines

   init_xray_F2 ::: leaky
   ! Initialize least-squares for fitting X-ray F2's with experimental
   ! phenomenological parameters.

   ENSURE(.data_kind=="xray-f2","wrong data_kind, "//trim(.data_kind))
   ENSURE(.reflections.created,"no reflections")
   DIE_IF(NOT .reflections.have_obs,"no F2_obs")
   DIE_IF(NOT .reflections.have_sigma,"no F2_sigma")

      n_g,n_p,n_d,p :: INT
      X,Y0,sigma :: VEC{REAL}*
      X_labels :: VEC{STR}*

      ! Get no. of parameters
      n_g = .reflections.no_of_groups
      n_p = .no_of_non_pADPs
      n_d = .reflections.dim

      ! Reset scale factors
      .scale_factors.destroy
      .scale_factors.create(n_g)
      .scale_factors = ONE

      ! Create parameter vector and labels
      X.create(n_p)
      X_labels.create(n_p)

      ! Set parameter vector and labels
      do p = 1,n_p
         X(p) = .scale_factors(p)                   
         X_labels(p) = "Scale factor "//trim(p.to_str)
      end

      ! Initialize F2 data
      Y0.create(n_d)
      sigma.create(n_d)
      .reflections.put_obs_to(Y0)
      .reflections.put_sigma_to(sigma)

      ! Set up least squares
      .LS_exp.create
      .LS_exp.initialize(X,Y0,sigma,X_labels)

      ! Clean
      sigma.destroy
      Y0.destroy
      X_labels.destroy
      X.destroy

   end

   set_xray_F2_params_to(X) ::: selfless
   ! Set the non-pADP parameters for predicting x-ray F2's to "X"
   ! This version for least-squares optimization.
      X :: VEC{REAL}, IN

      self :: DIFFRACTION_DATA*

      ! Recover self
      .set_from_saved_self

      ! Set parameters
      .set_xray_F2_params(X)

   end

   set_xray_F2_params(X)
   ! Set the non pADP parameters for predicting x-ray F2's to "X"
      X :: VEC{REAL}, IN

   ENSURE(.data_kind=="xray-f2","wrong data_kind, "//trim(.data_kind))
   ENSURE(.reflections.created,"no reflections")
   ENSURE(X.dim==.no_of_non_pADPs,"wrong size, X")

      p,n_g,n_p :: INT

      ! Get no. of parameters
      n_g = .reflections.no_of_groups
      n_p = .no_of_non_pADPs

      ! Set scale factors
      do p = 1,n_g
         .scale_factors(p) = X(p)
      end

   end

   put_xray_F2_to(Y) ::: selfless
   ! Make and put the *predicted* x-ray F2's in "Y"
   ! This version for least-squares optimization.
      Y :: VEC{REAL}, OUT

      self :: DIFFRACTION_DATA*

      ! Recover self
      .set_from_saved_self

      ! Get F_pred
      .put_xray_F2(Y)

   end

   put_xray_F2(Y)
   ! Make and put the *predicted* x-ray F2's in "Y"
   ! NOTE: This routine sets .reflections(:).pred
   ! NOTE: Must set reflections(:).cal = abs(reflections(:).calc)
      Y :: VEC{REAL}, OUT

      F2,C :: VEC{REAL}*
      n_d :: INT

      ! No. of data
      n_d = Y.dim

      ! Temporaries
      F2.create(n_d)
      C.create(n_d)

      ! Get the (uncorrected) values
      ! >> NOTE: cal must have been set <<
      .reflections.put_cal_to(F2)

      ! Get experimental corrections
      .put_scale_correction_to(C,.scale_factors)

      ! Apply corrections
      Y = C*F2

      ! >> Set predicted data <<
      .reflections.set_pred_to(Y)

      ! Clean
      C.destroy
      F2.destroy

   end

   put_xray_dF2_to(dY) ::: selfless
   ! Make and put the derivative of the *predicted* x-ray F2's in "dY"
   ! This version for least-squares optimization.
      dY :: MAT{REAL}, OUT

      self :: DIFFRACTION_DATA*

      ! Recover self
      .set_from_saved_self

      ! Get F_pred derivatives
      .put_dF2_pred(dY)

   end

   put_xray_dF2(dY)
   ! Make and put the derivative of the *predicted* x-ray F2's in "dY"
      dY :: MAT{REAL}, OUT

      n_p,n_g :: INT

      ! No. of data
      n_p = dY.dim2
      n_g = .reflections.no_of_groups

      ! Set scale derivatives
      .put_dF2_dscales(dY(:,1:n_g))

   end


   put_dF_dscales(dF)
   ! Get derivative of structure factor magnitudes wrt scale factors
   ! in "dF(n_refl,n_group)"
      dF :: MAT{REAL}, OUT

   ENSURE(dF.dim1==.reflections.dim1,"wrong dim1, dF")
   ENSURE(dF.dim2==.reflections.no_of_groups,"wrong dim2, dF")

      ext :: VEC{REAL}*
      g,n,n_p,n_d :: INT

      ! No. of parameters
      n_d = dF.dim1
      n_p = dF.dim2

      ! Get extinction corrections only
      ext.create(n_d)
      ext = ONE
      .put_Larsen_correction_to(ext,.Larsen_extinction_factor)

      ! Get derivatives
      do g = 1,n_p
      do n = 1,n_d

         if (.reflections(n).group==g) then
            dF(n,g) = ext(n) * .reflections(n).cal
         else
            dF(n,g) = ZERO
         end

      end
      end

      ! Clean
      ext.destroy

   end

   put_scale_correction_to(C,scale_factors) ::: private
   ! Return experimental scale factor correction in "C".
      C :: VEC{REAL}, OUT
      scale_factors :: VEC{REAL}, IN

      g,n,n_group,n_refl :: INT

      ! Sizes
      n_group = .reflections.no_of_groups
      n_refl  = .reflections.dim

      ! Make scale factor correction
      do g = 1,n_group
      do n = 1,n_refl
      
         if (.reflections(n).group/=g) cycle
      
         C(n) = scale_factors(g)
      
      end
      end

   end


   put_dF2_dscales(dF2)
   ! Get derivative of squared structure factor magnitudes wrt scale factors
   ! in "dF(n_refl,n_group)"
      dF2 :: MAT{REAL}, OUT

   ENSURE(dF2.dim1==.reflections.dim1,"wrong dim1, dF2")
   ENSURE(dF2.dim2==.reflections.no_of_groups,"wrong dim2, dF2")

      g,n,n_p,n_d :: INT

      ! No. of parameters
      n_d = dF2.dim1
      n_p = dF2.dim2

      ! Get derivatives
      do g = 1,n_p
      do n = 1,n_d

         if (.reflections(n).group==g) then
            dF2(n,g) = .reflections(n).cal
         else
            dF2(n,g) = ZERO
         end

      end
      end

   end

!  ==========
!  Model F2's for neutron data refinement
!  ==========

   make_neutron_F2_pred ::: leaky
   ! Make predicted neutron F2's by optimizing all requested experimental
   ! parameters.
   self :: PTR
      ! Initialize (leaky)
      .init_neutron_F2

      ! Do the least squares (leaky)
      .set_saved_self
      .LS_exp.do_fit(::put_neutron_F2_to,::put_neutron_dF2_to,::set_neutron_F2_params_to)

   end

! F2 set/put routines

   init_neutron_F2 ::: leaky
   ! Initialize least-squares for fitting neutron F2's with experimental
   ! phenomenological parameters.

   ENSURE(.data_kind=="neutron-f2","wrong data_kind, "//trim(.data_kind))
   ENSURE(.reflections.created,"no reflections")
   DIE_IF(NOT .reflections.have_obs,"no F2_obs")
   DIE_IF(NOT .reflections.have_sigma,"no F2_sigma")

      n_g,n_p,n_d,p :: INT
      X,Y0,sigma :: VEC{REAL}*
      X_labels :: VEC{STR}*

      ! Get no. of parameters
      n_g = .reflections.no_of_groups
      n_p = .no_of_non_pADPs
      n_d = .reflections.dim

      ! Reset scale factors
      .scale_factors.destroy
      .scale_factors.create(n_g)
      .scale_factors = ONE

      ! Create parameter vector and labels
      X.create(n_p)
      X_labels.create(n_p)

      ! Set parameter vector and labels
      do p = 1,n_p
         X(p) = .scale_factors(p)                   
         X_labels(p) = "Scale factor "//trim(p.to_str)
      end

      ! Initialize F2 data
      Y0.create(n_d)
      sigma.create(n_d)
      .reflections.put_obs_to(Y0)
      .reflections.put_sigma_to(sigma)

      ! Set up least squares
      .LS_exp.create
      .LS_exp.initialize(X,Y0,sigma,X_labels)

      ! Clean
      sigma.destroy
      Y0.destroy
      X_labels.destroy
      X.destroy

   end

   set_neutron_F2_params_to(X) ::: selfless
   ! Set the non-pADP parameters for predicting neutron F2's to "X"
   ! This version for least-squares optimization.
      X :: VEC{REAL}, IN

      self :: DIFFRACTION_DATA*

      ! Recover self
      .set_from_saved_self

      ! Set parameters
      .set_neutron_F2_params(X)

   end

   set_neutron_F2_params(X)
   ! Set the non pADP parameters for predicting neutron F2's to "X"
      X :: VEC{REAL}, IN

   ENSURE(.data_kind=="neutron-f2","wrong data_kind, "//trim(.data_kind))
   ENSURE(.reflections.created,"no reflections")
   ENSURE(X.dim==.no_of_non_pADPs,"wrong size, X")

      p,n_g,n_p :: INT

      ! Get no. of parameters
      n_g = .reflections.no_of_groups
      n_p = .no_of_non_pADPs

      ! Set scale factors
      do p = 1,n_g
         .scale_factors(p) = X(p)
      end

   end

   put_neutron_F2_to(Y) ::: selfless
   ! Make and put the *predicted* neutron F2's in "Y"
   ! This version for least-squares optimization.
      Y :: VEC{REAL}, OUT

      self :: DIFFRACTION_DATA*

      ! Recover self
      .set_from_saved_self

      ! Get F_pred
      .put_neutron_F2(Y)

   end

   put_neutron_F2(Y)
   ! Make and put the *predicted* neutron F2's in "Y"
   ! NOTE: This routine sets .reflections(:).pred
   ! NOTE: Must set reflections(:).cal = abs(reflections(:).calc)
      Y :: VEC{REAL}, OUT

      F2,C :: VEC{REAL}*
      n_d :: INT

      ! No. of data
      n_d = Y.dim

      ! Temporaries
      F2.create(n_d)
      C.create(n_d)

      ! Get the (uncorrected) values
      ! >> NOTE: cal must have been set <<
      .reflections.put_cal_to(F2)

      ! Get experimental corrections
      .put_scale_correction_to(C,.scale_factors)

      ! Apply corrections
      Y = C*F2

      ! >> Set predicted data <<
      .reflections.set_pred_to(Y)

      ! Clean
      C.destroy
      F2.destroy

   end

   put_neutron_dF2_to(dY) ::: selfless
   ! Make and put the derivative of the *predicted* neutron F2's in "dY"
   ! This version for least-squares optimization.
      dY :: MAT{REAL}, OUT

      self :: DIFFRACTION_DATA*

      ! Recover self
      .set_from_saved_self

      ! Get F_pred derivatives
      .put_dF2_pred(dY)

   end

   put_neutron_dF2(dY)
   ! Make and put the derivative of the *predicted* neutron F2's in "dY"
      dY :: MAT{REAL}, OUT

      n_p,n_g :: INT

      ! No. of data
      n_p = dY.dim2
      n_g = .reflections.no_of_groups

      ! Set scale derivatives
      .put_dF2_dscales(dY(:,1:n_g))

   end

!  =====================
!  Parameters to refine?
!  =====================

   no_of_non_pADPs result (res) 
   ! Return the number of parameters which are *not* positions or
   ! ADPs which are refined, e.g. scale factors and extinction.
      res :: INT

   ENSURE(.data_kind/=" ","no data kind set")

      select case (.data_kind)

         case ("free-neutron-f","neutron-f")
            DIE("not implemented")

         case ("free-neutron-f2","neutron-f2")
            DIE("not implemented")

         case ("free-pnd-f","pnd-f")
            DIE("not implemented")

         case ("free-x-ray-f","x-ray-f")
            res = .reflections.no_of_groups
            if (.use_Larsen_extinction) res = res + 1

         case ("free-x-ray-f2","x-ray-f2")
            res = .reflections.no_of_groups
            ! Extinction not available yet

         case default
            UNKNOWN(.data_kind)

      end
   
   end
 
   refine_positions_and_ADPs result (res)
   ! A refinement of all positions and ADP's
      res :: BIN
      res =   NOT .refine_positions_only &
          AND NOT .refine_ADPs_only 
   end
 
   refine_3rd_order result (res)
   ! Refineme third-order anharmonicity for any atoms?
      res :: BIN
      res =  .refine_3rd_order_for_atom.created
   end
 
   refine_4th_order result (res)
   ! Refineme fourth-order anharmonicity for any atoms?
      res :: BIN
      res =  .refine_4th_order_for_atom.created
   end
 
   no_of_3rd_order_atoms result (res)
   ! The number of atoms on which there are third-order anharmonicity
   ! parameters
      res :: INT
      res = 0
      if (.refine_3rd_order_for_atom.created) res = .refine_3rd_order_for_atom.dim
   end
 
   no_of_4th_order_atoms result (res)
   ! The number of atoms on which there are third-order anharmonicity
   ! parameters
      res :: INT
      res = 0
      if (.refine_4th_order_for_atom.created) res = .refine_4th_order_for_atom.dim
   end


!  ==============
!  Output methods
!  ==============

   put
   ! Put out the diffraction data to file "out"

      stdout.flush
      stdout.text("Diffraction information:")
      stdout.show("data_kind                     =", .data_kind)

      if (.reflections.created) then
      stdout.text("Reflection data:")
      stdout.flush
      .put_reflection_data
      end

   end

   put_reflection_data
   ! Output the reflection data

   ENSURE(.reflections.created,"no reflections")

      if (.reflections.have_calc OR .reflections.have_pred) .put_correction_data

      .reflections.put

   end

!   put_sin_theta_on_lambda
!   ! Output sin(theta)/lambda for all reflections.
!   ENSURE(.reflections.created,"No list of reflections")
!   ENSURE(.reflections.have_indices,"No list of reflections")
!      n :: INT
!
!      REFLECTION:set_wavelength(.wavelength)
!
!      stdout.text("sin(theta)/lambda for the reflections")
!      stdout.dash(int_fields=3,real_fields=1)
!      stdout.put("h",int_width=TRUE)
!      stdout.put("k",int_width=TRUE)
!      stdout.put("l",int_width=TRUE)
!      stdout.put("stl")
!      stdout.flush
!      stdout.dash(int_fields=3,real_fields=1)
!      do n=1,size(.reflections)
!         stdout.put(.reflections(n).h)
!         stdout.put(.reflections(n).k)
!         stdout.put(.reflections(n).l)
!         stdout.put(.reflections(n).sin_theta_on_lambda)
!         stdout.flush
!      end
!      stdout.dash(int_fields=3,real_fields=1)
!
!   end

   put_statistics(show_chi2)
   ! Output the structure factor goodness of fit statistics.
      show_chi2 :: BIN, optional

      select case (.data_kind)
         case ("free-neutron-f");  .reflections.put_statistics("Free Neutron F's",show_chi2)
         case ("free-neutron-f2"); .reflections.put_statistics("Free Neutron F2's",show_chi2)
         case ("free-pnd-f");      .reflections.put_statistics("Free PND F's",show_chi2)
         case ("free-x-ray-f");    .reflections.put_statistics("Free X-ray F's",show_chi2)
         case ("free-x-ray-f2");   .reflections.put_statistics("Free X-ray F2's",show_chi2)
         case ("neutron-f");       .reflections.put_statistics("Neutron F's",show_chi2)
         case ("neutron-f2");      .reflections.put_statistics("Neutron F2's",show_chi2)
         case ("pnd-f");           .reflections.put_statistics("PND F's",show_chi2)
         case ("x-ray-f");         .reflections.put_statistics("X-ray F's",show_chi2)
         case ("x-ray-f2");        .reflections.put_statistics("X-ray F2's",show_chi2)
         case default; UNKNOWN(.data_kind)
      end

   end

   put_free_statistics
   ! Output the F2 goodness of fit statistics
      .reflections.put_free_statistics
      .put_correction_data
   end

   put_correction_data
   ! Output the correction data

      stdout.flush
      stdout.show("Using extinction               =", .use_Larsen_extinction)
      stdout.show("Thermal smearing model         =", .thermal_smearing_model)
      stdout.show("Fragment partition model       =", .partition_model)
      stdout.show("Correct dispersion?            =", .correct_dispersion)

      if (.use_Larsen_extinction) then;
      stdout.show("Optimize extinction            =", TRUE)
      stdout.show("Secondary extinction factor    =", .Larsen_extinction_factor)
      else
      stdout.show("Optimize extinction            =", FALSE)
      end

      if (.use_multiple_scale_factors) then
      stdout.show("Using multiple scale factors   =", TRUE)
      stdout.show("Scale factors                  =", .scale_factors)
      else
      stdout.show("Using single scale factor      =", TRUE)
      stdout.show("Scale factor                   =", .scale_factors(1))
      end

   end

   put_qq_plot
   ! Output a qq plot to stdout.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.reflections.created, "no reflection data")
      .reflections.put_qq_plot
   end

   put_labelled_qq_plot
   ! Output a qq plot to stdout.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.reflections.created, "no reflection data")
      .reflections.put_labelled_qq_plot
   end

   put_chi2_vs_angle_plot
   ! Output a table with the chi2 for the structure factor data set
   ! broken into 20 sections.
      num_sections :: INT
      n,num,k,n_refl :: INT
      section_for :: VEC{INT}*
      stl,stl_min,stl_max,chi2,width,stl_mean :: REAL

      num_sections = 20
      n_refl = .reflections.n_refl
      REFLECTION:set_wavelength(.wavelength)

      ! Work out the limits of the sin(theta)/lambda.
      stl_min = 1000
      stl_max = ZERO
      do n =1,n_refl
         stl = .reflections(n).sin_theta_on_lambda
         if (stl < stl_min) stl_min = stl
         if (stl > stl_max) stl_max = stl
      end
      width = (TOL(3) + stl_max - stl_min)/num_sections

      section_for.create(n_refl)
      ! Determine which section each reflection belongs to.
      do n = 1,n_refl
         stl = .reflections(n).sin_theta_on_lambda
         section_for(n) = ceiling((TOL(3) + stl - stl_min) / width)
      end

      stdout.flush
      stdout.text("Chi^2 vs angle plot")
      stdout.flush
      stdout.text("sin(theta)/lambda in Angstrom^(-1)")
      stdout.show("Smallest sin(theta)/lambda  =",stl_min)
      stdout.show("Largest sin(theta)/lambda   =",stl_max)
      stdout.flush
      stdout.put("stl")
      stdout.put("chi^2")
      stdout.flush
      stdout.dash(real_fields=2)

      do n = 1, num_sections

         chi2 = ZERO
         num = 0
         stl_mean = stl_min + (n - HALF) * width
         do k = 1, n_refl
           if (n==section_for(k)) then
             chi2 = chi2 + .reflections(k).z_statistic_squared
             num = num + 1
           end
         end

         stdout.put(stl_mean)

         if (num==0) then
           stdout.flush
           cycle
         else
           chi2 = chi2 / max(num - .n_param,1)
           stdout.put(chi2)
           stdout.flush
         end

      end

      stdout.flush

      section_for.destroy

   end

   put_pred_vs_obs_plots
   ! Output some different plots about the obs vs. predicted structure factors.
      ext :: VEC{REAL}*
      ext_refs :: VEC{REFLECTION}*
      n,n_refl :: INT
      y,w :: REAL

      n_refl = .reflections.n_refl
      REFLECTION:set_wavelength(.wavelength)

      stdout.text("The effects of angle.")
      stdout.text("Scatter plot of z = (pred-obs)/sigma vs. sin(theta)/lambda")
      do n = 1,n_refl
         stdout.put(.reflections(n).sin_theta_on_lambda)
         stdout.put(.reflections(n).z_statistic)
         stdout.flush
      end
      stdout.flush

      stdout.text("The effects of angle.")
      stdout.text("Scatter plot of Delta = (pred-obs) vs. sin(theta)/lambda")
      do n = 1,n_refl
         stdout.put(.reflections(n).sin_theta_on_lambda)
         stdout.put(.reflections(n).delta)
         stdout.flush
      end
      stdout.flush

      stdout.text("The effects of intensity.")
      stdout.text("Scatter plot of z = (pred-obs)/sigma vs obs")
      do n = 1,n_refl
         stdout.put(.reflections(n).obs)
         stdout.put(.reflections(n).z_statistic)
         stdout.flush
      end
      stdout.flush

      ext_refs.create(n_refl)
      ext.create(n_refl)
      .put_Larsen_correction_to(ext,.Larsen_extinction_factor)
      w = sum(abs(ext))/n_refl
      ext_refs.set_obs_to(.reflections.pred)
      ext_refs.set_pred_to(.reflections.pred * ext)
      ext_refs.set_sigma_to(.reflections.sigma)
      ext.destroy

      if (NOT .use_Larsen_extinction) return

      stdout.text("The effects of extinction.")

      y = ZERO
      do n=1,n_refl
       y = y + abs(ext_refs(n).z_statistic)
      end
      y = y / n_refl
      stdout.show("Average value of abs[Fcalc(with ext)-Fcalc(without ext)]/sigma is ",y)
      stdout.show("Average value of abs(extinction correction) is ",w)
      stdout.flush

      stdout.text("The effects of intensity on extinction.")
      stdout.text("Scatter plot of [Fcalc(with ext)-Fcalc(without ext)]/sigma vs pred")
      do n=1,n_refl
       stdout.put(ext_refs(n).pred)
       stdout.put(ext_refs(n).z_statistic)
       stdout.flush
      end
      stdout.flush

      stdout.text("The effects of scattering angle on extinction.")
      stdout.text("Scatter plot of [Fcalc(with ext)-Fcalc(without ext)]/sigma vs sin(theta)/lambda")
      do n = 1,n_refl
         stdout.put(.reflections(n).sin_theta_on_lambda)
         stdout.put(ext_refs(n).z_statistic)
         stdout.flush
      end
      ext_refs.destroy

      stdout.flush
   end

   put_PND_sf(name)
   ! Output the magnetic structure factors
       name :: STR
       FM_s,FM_l :: VEC{CPX}*
       arch :: ARCHIVE
        n :: INT
       FM_s.create(.reflections.n_refl)
       arch.set(name,"PND_spin_sf")
       arch.read(FM_s)
       FM_l.create(.reflections.n_refl)
       arch.set(name,"PND_nabla_sf")
       arch.read(FM_l)
       stdout.text("PND magnetic structure factors:")
       stdout.flush
       stdout.dash(int_fields=3,real_fields=3)
       stdout.put("h", int_width=TRUE)
       stdout.put("k", int_width=TRUE)
       stdout.put("l", int_width=TRUE)
       stdout.put("FM_s")
       stdout.put("FM_l")
       stdout.put("FM")
       stdout.flush
       stdout.dash(int_fields=3,real_fields=3)
       do n = 1, .reflections.n_refl
          stdout.put(.reflections(n).h)
          stdout.put(.reflections(n).k)
          stdout.put(.reflections(n).l)
          stdout.put(real(FM_s(n)) )
          stdout.put(real(FM_l(n)) )
          stdout.put(real(FM_s(n)+FM_l(n)) )
          stdout.flush
       end
       stdout.dash(int_fields=3,real_fields=3)
       FM_l.destroy
       FM_s.destroy
   end

   put_CIF_refinement(basis,scf_type)
   ! Put refinement information in CIF format
   ! No refinement info. possible without reflections!
      basis,scf_type :: STR

      n :: INT
      R :: REAL

      if (.reflections.destroyed) return

      stdout.flush
      stdout.text("# ------------------")
      stdout.text("# Refinement details")
      stdout.text("# ------------------")
      stdout.flush
      stdout.text("_refine_special_details")
      stdout.text(";")
      stdout.text("  .  Hirshfeld atom refinement:")
      stdout.text("     .  Uses aspherical atomic scattering factors")
      stdout.text("        obtained from Hirshfeld partitioning of a ")
      stdout.text("        gaussian quantum chemical wavefunction.")
      stdout.text("     .  Hirshfeld weight functions obtained from")
      stdout.text("        spherically averaged unrestricted atomic")
      stdout.text("        densities.")
      stdout.text("  .  Wavefunction type : "//trim(scf_type))
      stdout.text("  .  Gaussian basis set: "//trim(basis))
      stdout.text("  .  Refinement based on |F| with weight=1/sigma(|F|)")
      stdout.text("  .  Negative |F|^^2 were pruned from the data")
      stdout.text("  .  |F| < "//trim(.obs_on_sigma_cutoff.to_str("f5.1"))//" sigma(|F|) were pruned from the data")
      stdout.text("  .  Eigenvalues < "//trim(.LS_fit.tol_near_0.to_str("e9.1"))//" removed from normal equations")
      stdout.text("  .  Reflection used in the refinement appear below")
      stdout.text("  .  Refined using the Tonto program:")
      stdout.text("     .  Version: "//TONTO_VERSION//" v. "//SVN_VERSION)
      stdout.text("     .  Platform: "//TONTO_PLATFORM)
      stdout.text("     .  Build-date: "//TONTO_BUILD_DATE)
      stdout.text(";")

      stdout.flush

      stdout.text("_refine_ls_structure_factor_coef        F")
      stdout.text("_refine_ls_matrix_type                  full")
      stdout.text("_refine_ls_weighting_details            'w=1/\s(F)'")

      if (.refine_H_ADPs) then
         if (.refine_positions_and_ADPs) &
         stdout.text("_refine_ls_hydrogen_treatment           refall")
         if (.refine_ADPs_only) &
         stdout.text("_refine_ls_hydrogen_treatment           refU")
      else
         if (.refine_positions_only) then
         stdout.text("_refine_ls_hydrogen_treatment           refxyz")
         else
         stdout.text("_refine_ls_hydrogen_treatment           constr")
         end
      end

      stdout.text("_refine_ls_extinction_method            none")
      n = .reflections.dim
      stdout.text("_refine_ls_number_reflns                "//trim(n.to_str))
      stdout.text("_refine_ls_number_parameters           "//trim(.LS_fit.n_parameters.to_str))
      stdout.text("_refine_ls_number_restraints            0")
      stdout.text("_refine_ls_number_constraints          "//trim(.LS_fit.n_near_0.to_str))
      R = .reflections.r_factor
      stdout.text("_refine_ls_R_factor_all                 "//trim(R.to_str("f10.4")))
      R = .reflections.weighted_r_factor
      stdout.text("_refine_ls_wR_factor_ref                "//trim(R.to_str("f10.4")))
      stdout.text("_refine_ls_goodness_of_fit_ref          "//trim(.LS_fit.chi2.to_str("f10.4")))
      stdout.text("_refine_ls_shift/su_max                 ?")
      stdout.text("_refine_ls_shift/su_mean                ?")

   end

   put_CIF_reflections
   ! Put reflection information in CIF format

      i :: INT

      if (.reflections.destroyed) return

      stdout.flush
      stdout.text("# ---------------")
      stdout.text("# Reflection data")
      stdout.text("# ---------------")
      stdout.flush
      stdout.text("loop_")
      stdout.text("    _diffrn_refln_index_h")
      stdout.text("    _diffrn_refln_index_k")
      stdout.text("    _diffrn_refln_index_l")
      stdout.text("    _diffrn_refln_obs")
      stdout.text("    _diffrn_refln_sigma")

      do i = 1,.reflections.dim
         stdout.put(.reflections(i).h)
         stdout.put(.reflections(i).k)
         stdout.put(.reflections(i).l)
         stdout.put(.reflections(i).obs)
         stdout.put(.reflections(i).sigma)
         stdout.flush
      end

   end


!  =============================
!  Inherited reflection routines
!  =============================

   use_multiple_scale_factors result (res)
   ! Return TRUE if we are supposed to use multiple scale factors.
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = any(.reflections.group>1)
   end

   simulate_new_obs
   ! Simulate a new experiment by adding normally distributed experimental
   ! errors the the F_exp.

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.have_obs,"no experimental structure factors")
   ENSURE(.have_sigma,"no experimental structure factor errors")

      obs :: VEC{REAL}*
      n_refl,n :: INT
      chi2,z :: REAL

      stdout.flush
      stdout.text("Adding simulated errors to obs using sigma.")

      n_refl = .reflections.n_refl
      obs.create(n_refl)
      obs = .reflections.obs

      .reflections.simulate_new_obs

      chi2 = ZERO
      do n = 1,n_refl
         z = .reflections(n).z_statistic
         chi2 = chi2 + z*z
      end
      chi2 = chi2 / max(n_refl - 1,1)

      stdout.text("chi^2 of old obs to new obs is " // trim(chi2.to_str))
      stdout.flush
      stdout.dash(real_fields=4)
      stdout.put("obs (old)")
      stdout.put("obs (new)")
      stdout.put("sigma")
      stdout.put("dF/sigma")
      stdout.flush
      stdout.dash(real_fields=4)

      do n=1,n_refl
         z = .reflections(n).z_statistic
         stdout.put(obs(n))
         stdout.put(.reflections(n).obs)
         stdout.put(.reflections(n).sigma)
         stdout.put(z)
         stdout.flush
      end

      stdout.dash(real_fields=4)
      obs.destroy

   end

end
