!-------------------------------------------------------------------------------
!
! CRYSTAL: Data structure for crystals
!
! $Id$
!
! (c) dylan jayatilaka, daniel grimwood, university of western australia (1999)
!-------------------------------------------------------------------------------
module CRYSTAL

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL
   use BUFFER
   use BINVEC
   use IVEC
   use IMAT
   use VEC
   use MAT
   use CVEC
   use CMAT
   use CMAT3
   use CMAT4
   use CMAT5
   use TEXTFILE
   use ARCHIVE
   use ATOM
   use ATOMVEC
   use SPACEGROUP

   implicit none

#  include "macros"
#  include "crystal.int"

!   type crystal_type
!
!   STR :: kind
!   ! Kind of diffraction experiment used.
!
!   SPACEGROUP :: spacegroup
!   ! The crystal spacegroup
!
!   VEC(3) :: unit_cell_angle
!   ! cell angles  (in radians)
!
!   VEC(3) :: unit_cell_length
!   ! cell lengths (in bohr)
!
!   DBL :: unit_cell_volume
!   ! cell volumes (bohr^3)
!
!   MAT(3,3) :: direct_cell_matrix
!   ! direct cell matrix (bohr)
!
!   MAT(3,3) :: direct_U_cell_matrix
!   ! Converts thermal tensors from crystal to cartesian systems.
!
!   MAT(3,3) :: inverse_cell_matrix
!   ! inverse direct cell matrix (bohr^{-1})
!
!   MAT(3,3) :: reciprocal_cell_matrix
!   ! reciprocal cell matrix (bohr^{-1}).
!
!   MAT(3,3) :: reciprocal_U_cell_matrix
!   ! Converts thermal tensors from cartesian to crystal systems.
!
!   INT :: n_fragment_atoms
!   ! No of atoms in the inputted cell fragment
!
!   MAT, PTR :: fragment_geometry
!   ! The geometry for molecular cell fragment under consideration
!
!   INT :: n_unit_cell_atoms
!   ! Total no. of unit cell atoms
!
!   MAT, PTR :: unit_cell_geometry
!   ! The full unit cell geometry
!
!   INT :: n_unique_unit_cell_atoms
!   ! No of unique unit cell atoms
!
!   IVEC, PTR :: unique_atom
!   ! Contains the actual unique (asymmetric) unit cell atoms.
!
!   IVEC, PTR :: unique_atom_for
!   ! If "a" is the index of an atom position in fragment_geometry, fragment_geometry(:,a),
!   ! then unique_atom_for(a) is the index of the unique (asymmetric) unit cell atom
!   ! which generates that position.
!
!   IVEC, PTR :: fragment_atom_for
!   ! If "u" is the index of an atom position in unit_cell_geometry, unit_cell_geometry(:,u),
!   ! then fragment_atom_for(a) is the index of the fragment_atom which generates that position.
!
!   INT :: n_reduced_symops
!   ! No. of symops needed to make the unit_cell_geometry from fragment_geometry
!
!   IVEC, PTR :: reduced_symop
!   ! Indices of the reduced symops in the spacegroup seitz list
!
!   INT :: n_inverted_symops
!   ! Number of symmetry operations related by inversion
!
!   IVEC, PTR :: inverted_symop
!   ! Indices of the unique symops related by inversion
!
!   IVEC, PTR :: translated_symop
!   ! Indices of the unique symops related by translation
!
!   INT :: n_unique_symops
!   ! Number of unique symmetry operations not related by inversion or translation.
!   ! This is used to save work in structure factor calculations.
!
!   IVEC, PTR :: unique_symop
!   ! Indices of the unique symops not related by inversion or translation
!
!   VEC, PTR :: repetition_factor
!   ! The partition factors for cell_geometry
!
!   DBL :: Z
!   ! The crystallographic Z factor for the moleculat cell fragment in the unitcell
!
!   INT :: n_refl
!   ! No. of reflection planes
!
!   IVEC, PTR :: h DEFAULT_NULL
!   ! Miller indices for the reflections
!
!   IVEC, PTR :: k DEFAULT_NULL
!   ! Miller indices for the reflections
!
!   IVEC, PTR :: l DEFAULT_NULL
!   ! Miller indices for the reflections
!
!   VEC, PTR :: F_exp DEFAULT_NULL
!   ! Experimental structure factors
!
!   VEC, PTR :: sigma DEFAULT_NULL
!   ! Experimental sigma
!
!   CVEC, PTR :: F_calc DEFAULT_NULL
!   ! Calculated complex structure factors without including corrections
!
!   VEC, PTR :: F_pred DEFAULT_NULL
!   ! Calculated structure factors including scale and extinction corrections
!  
!   DBL :: scale_factor
!   ! Scale factor to apply to the predicted structure factors
!
!   DBL :: exp_scale_factor
!   ! Fixed scale factor to apply to the experimental structure factors
!
!   BIN :: optimise_scale
!   ! True if an overall scaler factor is to be used in calculating F_predicted
!
!   BIN :: synthesize_sigma_I
!   ! True if artificial sigma(I) errors are to be gereated from poisson statistics
!   ! and used in calculating agreement statistics
!
!   BIN :: optimise_extinction
!   ! True if extinction is to be corrected
!
!   BIN :: correct_dispersion
!   ! True if dispersion is to be corrected
!
!   DBL :: extinction_factor
!   ! Secondary extinction factor
!
!   DBL :: wavelength
!   ! Experimental wavelength, in bohr
!
!   STR :: thermal_smearing_model       DEFAULT("none")
!   ! Thermal smearing model for ft integrals
!
!   STR :: partition_model
!   ! Model for partitioning fragments of the molecule
!
!   INT :: n_param
!   ! No of fitting parameters used
!
!   DBL :: chi2
!   ! Chi^2 agreement statistic for F_pred with F_exp
!
!   DBL :: goodness_of_fit
!   ! Goodness of fit parameter F_pred with F_exp
!
!   DBL :: r_factor
!   ! R factor agreement statistic F_pred with F_exp
!
!   DBL :: weighted_r_factor
!   ! Weighted R factor agreement statistic F_pred with F_exp
!
!   DBL :: I_chi2
!   ! Chi^2 agreement statistic for I_pred with I_exp
!
!   DBL :: I_goodness_of_fit
!   ! Goodness of fit parameter for I_pred with I_exp
!
!   DBL :: I_r_factor
!   ! R factor agreement statistic for I_pred with I_exp
!
!   DBL :: I_weighted_r_factor
!   ! Weighted R factor agreement statistic for I_pred with I_exp
!
!   end

   CRYSTAL, PTR :: saved_self

contains

!  **************************
!  Create and destroy methods
!  **************************

   create
   ! Create an crystal object
      PTR :: self
      nullify(self)
      allocate(self)
      ADD_MEM(CRYSTAL_SIZE)
      .nullify_ptr_part
      .set_default 
   end

   destroy
   ! Destroy an crystal object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(CRYSTAL_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the crystal object
      .spacegroup.nullify_ptr_part
      nullify(.h)
      nullify(.k)
      nullify(.l)
      nullify(.F_exp)
      nullify(.sigma)
      nullify(.F_calc)
      nullify(.F_pred)
   end

   destroy_ptr_part
   ! Erase all pointer information
      .destroy_reflection_data
   end

   destroy_reflection_data
   ! Erase all reflection data
      if (.reflection_data_exists) then
         .h.destroy
         .k.destroy
         .l.destroy
         .n_refl = 0
         .scale_factor = ONE
         .exp_scale_factor = ONE
         .extinction_factor = ZERO
         if (.F_calc_exists) .F_calc.destroy
         if (.F_pred_exists) .F_pred.destroy
         if (.F_exp_exists) then
            .F_exp.destroy
            .sigma.destroy
         end
      end
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_default [leaky]
   ! Set up a default crystal object
      .spacegroup.set_default
      .unit_cell_angle = (/90.0d0,90.0d0,90.0d0/)
      .unit_cell_angle.convert_from("degree")
      .unit_cell_length = (/10.0d0,10.0d0,10.0d0/)
      .make_cell_matrices
      .n_refl = 0
      .destroy_reflection_data
      .synthesize_sigma_I = FALSE
      .optimise_scale = TRUE
      .optimise_extinction = TRUE
      .correct_dispersion = TRUE
      .scale_factor = ONE
      .exp_scale_factor = ONE
      .extinction_factor = ZERO
      .wavelength = 0.71069d0 * BOHR_PER_ANGSTROM
      .kind = "x-ray"
      .thermal_smearing_model = ""
      .partition_model = ""
   end

!  ********************
!  Unit cell operations
!  ********************

   make_cell_matrices
   ! Calculate the various unit cell axis matrices.
      .make_cell_volume
      .make_direct_cell_matrix
      .make_reciprocal_cell_matrix
      .make_direct_U_cell_matrix
      .make_reciprocal_U_cell_matrix
   end

   make_cell_volume
   ! Calculate the cell volume
      DBL :: a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      .unit_cell_volume = a*b*c*sqrt(ONE-ca**2-cb**2-cg**2+TWO*ca*cb*cg)
   end

   make_direct_cell_matrix
   ! Calculate the direct cell matrices, in units of BOHRS.
      DBL :: v,a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      v = .unit_cell_volume
      ! Direct cell matrix
      .direct_cell_matrix(1,1) = a
      .direct_cell_matrix(1,2) = b*cg
      .direct_cell_matrix(1,3) = c*cb
      .direct_cell_matrix(2,1) = ZERO
      .direct_cell_matrix(2,2) = v/(a*c*sb)
      .direct_cell_matrix(2,3) = ZERO
      .direct_cell_matrix(3,1) = ZERO
      .direct_cell_matrix(3,2) = b*(ca-cg*cb)/sb
      .direct_cell_matrix(3,3) = c*sb
   end

   make_reciprocal_cell_matrix
   ! Calculate the reciprocal cell matrices in units of 1/BOHRS.
      DBL :: v,a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      v = .unit_cell_volume
      ! Reciprocal cell matrix
      .reciprocal_cell_matrix(1,1) = ONE/a
      .reciprocal_cell_matrix(1,2) = ZERO
      .reciprocal_cell_matrix(1,3) = ZERO
      .reciprocal_cell_matrix(2,1) = b*c*(ca*cb-cg)/sb/v
      .reciprocal_cell_matrix(2,2) = a*c*sb/v
      .reciprocal_cell_matrix(2,3) = a*b*(cb*cg-ca)/sb/v
      .reciprocal_cell_matrix(3,1) = -cb/a/sb
      .reciprocal_cell_matrix(3,2) = ZERO
      .reciprocal_cell_matrix(3,3) = ONE/c/sb
      .inverse_cell_matrix = transpose(.reciprocal_cell_matrix)
   end

   make_direct_U_cell_matrix
   ! Return the transformation matrix which changes the thermal tensor
   ! from the crystal axis system into the cartesian axis system.
   ! See comments for reciprocal_U_tensor_matrix below.
      DBL :: len
      INT :: i
      do i = 1,3
         len = .reciprocal_cell_matrix(:,i).norm
         .direct_U_cell_matrix(i,:) = len*.direct_cell_matrix(:,i)
      end
   end

   make_reciprocal_U_cell_matrix
   ! Return the transformation matrix which changes the thermal tensor
   ! from the cartesian axis system into the crystal axis system.
   ! The thermal tensor in the crystal axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where h are the Miller indices and a^* are the reciprocal lattice
   ! constants (in bohr^{-2}). This is as used by systems like Xtal.
   ! The thermal tensor in the cartesian axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -0.5 U_{ij} k_i k_j )
   ! where k = 2\pi B h, and B is the reciprocal_cell matrix.
      DBL :: len
      INT :: i
      do i = 1,3
         len = ONE/.reciprocal_cell_matrix(:,i).norm
         .reciprocal_U_cell_matrix(:,i) = .reciprocal_cell_matrix(:,i)*len
      end
   end

   change_geometry_from_crystal(g)
   ! Change the geometry array "g" from crystal fractional coordinates into
   ! standard cartesian coordiantes
      MAT :: g
      INT :: n,n_atom
      ENSURE(size(g,1)==3,"incorrect dimension for g")
      n_atom = size(g,2)
      do n = 1,n_atom
         g(:,n).rotate_by(.direct_cell_matrix)
      end
   end

   change_geometry_to_crystal(g)
   ! Change the geometry array "g" from standard cartesian coordinates into
   ! crystal fractional coordinates
      MAT :: g
      INT :: n,n_atom
      ENSURE(size(g,1)==3,"incorrect dimension for g")
      n_atom = size(g,2)
      do n = 1,n_atom
         g(:,n).rotate_by(.inverse_cell_matrix)
      end
   end

!  ************
!  Read methods
!  ************

   read(input) [leaky]
   ! Read an CRYSTAL object from file "input"
      TEXTFILE, target, optional :: input
      TEXTFILE, PTR :: in
      STR :: word
      if (present(input)) then; in => input
      else;                     in => stdin
      end
      .set_default
      read_loop : do
         in.read(word)
         word.to_lower_case
         select case (word)
            case("end");                         exit read_loop
            case("kind");                       .read_kind
            case("spacegroup_symbol");          .read_spacegroup_IT_symbol
            case("spacegroup_it_symbol");       .read_spacegroup_IT_symbol
            case("spacegroup_hall_symbol");     .read_spacegroup_Hall_symbol
            case("unit_cell_angles");           .read_unit_cell_angles
            case("cell_angles");                .read_unit_cell_angles
            case("unit_cell_lengths");          .read_unit_cell_lengths
            case("unit_cell_dimensions");       .read_unit_cell_lengths
            case("cell_lengths");               .read_unit_cell_lengths
            case("n_refl");                     .read_n_refl
            case("n_hkl");                      .read_n_refl
            case("no_of_reflections");          .read_n_refl
            case("reflection_indices");         .read_reflection_indices(in)
            case("reflection_data");            .read_reflection_data(in)
            case("apply_scale_factor");         .read_scale_factor
            case("make_F_predicted");           .make_F_predicted
            case("synthesize_sigma_i");         .read_synthesize_sigma_I
            case("optimise_scale");             .read_optimise_scale
            case("optimise_scale_factor");      .read_optimise_scale
            case("optimise_extinction");        .read_optimise_extinction
            case("optimise_extinction_factor"); .read_optimise_extinction
            case("correct_dispersion");         .read_correct_dispersion
            case("thermal_smearing_model");     .read_thermal_smearing_model
            case("partition_model");            .read_partition_model
            case("erase_spacegroup");           .spacegroup.destroy_ptr_part
            case("destroy_spacegroup");         .spacegroup.destroy_ptr_part
            case("erase_reflection_data");      .destroy_reflection_data
            case("destroy_reflection_data");    .destroy_reflection_data
            case default;    DIE("unknown option, "// trim(word))
         end
      end do read_loop
      .update
   end

   update [leaky]
   ! Update the crystal information
      .spacegroup.analyse
      .make_cell_matrices
      if (.F_exp.created) .F_exp = .F_exp * .exp_scale_factor
      if (.sigma.created) .sigma = .sigma * .exp_scale_factor
      .exp_scale_factor = ONE
      if (.F_exp.destroyed OR .sigma.destroyed) then
        .optimise_scale = FALSE
        .optimise_extinction = FALSE
      end
   end

   read_kind
   ! Read the kind of crystal experiment
      stdin.read(.kind)
   end

   read_spacegroup_IT_symbol
   ! Read the spacegroup international table symbol
      .spacegroup.read_IT_symbol(stdin)
   end

   read_spacegroup_Hall_symbol
   ! Read the spacegroup Hall symbol
      .spacegroup.read_Hall_symbol(stdin)
   end

   read_unit_cell_angles
   ! Read the unit cell angles
      stdin.read(.unit_cell_angle)
   end

   read_unit_cell_lengths
   ! Read the unit cell axis lengths
      stdin.read(.unit_cell_length)
   end

   read_n_refl
   ! Read the number of reflection data
      stdin.read(.n_refl)
   end

   read_reflection_indices(in) [leaky]
   ! Read the hkl Miller index triples from the input
      TEXTFILE :: in
      INT :: i
      STR :: word
      ENSURE(.n_refl>0, "no reflections to read")
      ENSURE(.no_reflection_data, "hkl data already exists")
      .h.create(.n_refl)
      .k.create(.n_refl)
      .l.create(.n_refl)
      do i = 1,.n_refl
         in.read(.h(i))
         in.read(.k(i))
         in.read(.l(i))
      end
      in.read(word)            !  Expecting the end keyword
      word.to_lower_case
      ENSURE(trim(word) == "end", 'expecting "end" keyword')
   end

   read_reflection_data(in) [leaky]
   ! Read the hkl Miller index triple followed by the experimental structure
   ! factor and the experimental standard deviation
      TEXTFILE :: in
      INT :: i
      STR :: word
      ENSURE(.n_refl>0, "no reflections to read")
      ENSURE(.no_reflection_data, "hkl data already exists")
      .h.create(.n_refl)
      .k.create(.n_refl)
      .l.create(.n_refl)
      .F_exp.create(.n_refl); .F_exp = ZERO
      .sigma.create(.n_refl); .sigma = ZERO
      do i = 1,.n_refl
         in.read(.h(i))
         in.read(.k(i))
         in.read(.l(i))
         in.read(.F_exp(i))
         in.read(.sigma(i))
      end
      in.read(word)            !  Expecting the end keyword
      word.to_lower_case
      ENSURE(trim(word) == "end", 'expecting "end" keyword')
   end

   put_F_calc [leaky]
   ! Put the hkl Miller index triple followed by the calculated
   ! structure factor to add onto existing structure factors.
      INT :: i,h,k,l
      CDBL :: Fc
      ENSURE(.n_refl>0, "no reflections to put")
      ENSURE(.F_calc.created, "require F_calc")
      stdout.flush(2)
      do i = 1,.n_refl
         stdout.put(.h(i))
         stdout.put(.k(i))
         stdout.put(.l(i))
         stdout.put(.F_calc(i),flush=1)
      end
      stdout.flush(1)
   end

   add_F_calc [leaky]
   ! Read the hkl Miller index triple followed by the calculated
   ! structure factor to add onto the existing structure factors.
      INT :: i,h,k,l
      CDBL :: Fc
      STR :: word
      ENSURE(.n_refl>0, "no reflections to read")
      ENSURE(.F_calc.created, "require F_calc already")
      do i = 1,.n_refl
         stdin.read(h)
         stdin.read(k)
         stdin.read(l)
         stdin.read(Fc)
         .F_calc(i) = .F_calc(i) + Fc
      end
      stdin.read(word)            !  Expecting the end keyword
      word.to_lower_case
      ENSURE(trim(word) == "end", 'expecting "end" keyword')
      .make_F_predicted
   end

   read_scale_factor
   ! Read the structure factor multiplier
      stdin.read(.exp_scale_factor)
   end 

   read_optimise_scale
   ! Read the switch whether to use and overall scale factor to minimise
   ! the chi2 statistic when calculating the structure factors.
   ! NOTE: this is not the same at the overall .scale_factor which is applied
   ! to the experimental structure factors.
      stdin.read(.optimise_scale)
   end

   read_synthesize_sigma_I
   ! Read the switch whether to artificially create sigma(I) errors when
   ! evaluating the chi2 statistics based on intensities. Refer to routine
   ! .I_sigma
      stdin.read(.synthesize_sigma_I)
   end

   read_optimise_extinction
   ! Read the switch whether to correct extinction or not, according to the
   ! Larson formula
      stdin.read(.optimise_extinction)
   end

   read_correct_dispersion
   ! Read the switch whether to correct dispersion or not, according to the
   ! atomic dispersion factors
      stdin.read(.correct_dispersion)
   end

   read_thermal_smearing_model
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      BIN :: allowed_model
      stdin.read(.thermal_smearing_model)
      .thermal_smearing_model.to_lower_case
      allowed_model = .thermal_smearing_model=="none"    OR &
                      .thermal_smearing_model==""        OR &
                      .thermal_smearing_model=="coppens" OR &
                      .thermal_smearing_model=="stewart" OR &
                      .thermal_smearing_model=="tanaka"
      ENSURE(allowed_model,"unknown thermal smearing model")
   end

   read_partition_model
   ! Read the partition model to used to correct for oversampled fragments
   ! of the unit cell when calculating the structure factors
      stdin.read(.partition_model)
   end

   lp_factor result(res)
   ! Return the array of the Lorentz Polarization factors for all the reflections
     VEC( .n_refl ) :: res
     MAT(3,3) :: rcm
     INT :: n
     DBL :: kx,ky,kz,stl,c,s,two_theta
     ENSURE(.n_refl>0,"no reflections entered")
     rcm = .reciprocal_cell_matrix
     do n=1, .n_refl
       kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
       ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
       kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
       stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)
       two_theta = TWO*asin( stl * .wavelength )
       c = cos(two_theta)
       s = sin(two_theta)
       if (s.is_zero(TOL(8))) then
          res(n) = ZERO
          WARN("lp_factor for (000) reflection set to zero")
       else
          res(n) = (1+c*c)/(TWO*s)
       end
     end
   end
 
   I_pred result(res)
   ! Return the array of predicted Intensities. Only the Lorentz Polarization 
   ! factor and the angular velocity factor for a single crystal are used. 
   ! Fundamental constants appearing in front of this are not calculated
   ! NOTE: unlike I_exp, these may include extinction and dispersion effects.
     VEC( .n_refl ) :: res
     MAT(3,3) :: rcm
     INT :: n
     DBL :: kx,ky,kz,stl,c,s,two_theta,F2
     ENSURE(.n_refl>0,"no reflections entered")
     ENSURE(.F_pred.created, "no predicted structure factors")
     rcm = .reciprocal_cell_matrix
     do N=1, .n_refl
       kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
       ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
       kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
       stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)
       two_theta = TWO*asin( stl * .wavelength )
       c = cos(two_theta)
       s = sin(two_theta)
       F2 = .F_pred(n)
       F2 = F2*F2
       if (s.is_zero(TOL(8))) then
          res(n) = F2
       else
          res(n) = (1+c*c)/(TWO*s)*F2
       end
     end
   end
 
   I_exp result(res)
   ! Return the array of experimental Intensities. Only the Lorentz Polarization 
   ! factor and the angular velocity factor for a single crystal are used. 
   ! Fundamental constants appearing in front of this are not calculated
   ! NOTE: extinction factors, dispersion, multiple scattering corrections
   ! are not included. These are the experimental intensities with these effects
   ! removed.
     VEC( .n_refl ) :: res
     MAT(3,3) :: rcm
     INT :: n
     DBL :: kx,ky,kz,stl,c,s,two_theta,F2
     ENSURE(.n_refl>0,"no reflections entered")
     ENSURE(.F_exp_exists, "no experimental structure factors")
     rcm = .reciprocal_cell_matrix
     do N=1, .n_refl
       kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
       ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
       kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
       stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)
       two_theta = TWO*asin( stl * .wavelength )
       c = cos(two_theta)
       s = sin(two_theta)
       F2 = abs(.F_exp(n))
       F2 = F2*F2
       if (s.is_zero(TOL(8))) then
          res(n) = F2
       else
          res(n) = (1+c*c)/(TWO*s)*F2
       end
     end
   end
 
   I_sigma result(res)
   ! Return the array of experimental sigma's in the Intensities. 
     VEC( .n_refl ) :: res
     MAT(3,3) :: rcm
     INT :: n
     DBL :: kx,ky,kz,stl,c,s,two_theta,F2
     ENSURE(.n_refl>0,"no reflections entered")
     ENSURE(.F_exp_exists OR .F_calc_exists, "can't generate sigma")
     if (.no_F_exp AND NOT .synthesize_sigma_I) then
        WARN("The synthesize_sigma_I flag was not set; it is now set")
        .synthesize_sigma_I = TRUE
     end
     if (.synthesize_sigma_I) then
        res = .I_pred
        res = sqrt(res/.equivalence_factors)
     else
       rcm = .reciprocal_cell_matrix
       do N=1, .n_refl
         kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
         ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
         kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
         stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)
         two_theta = TWO*asin( stl * .wavelength )
         c = cos(two_theta)
         s = sin(two_theta)
         F2 = abs(.F_exp(n))
         if (s.is_zero(TOL(8))) then
            res(n) = F2
         else
            res(n) = TWO*(1+c*c)/(TWO*s)*F2
         end
       end
     end
   end
 
   equivalence_factors result (res)
   ! Return the equivalence factors, the number of distinct reflections
   ! which are symmetry equivalent to a particular (hkl) triple, for all
   ! the reflections.
      IVEC(.n_refl) :: res
      IVEC(3) :: hkl,new
      INT :: n,s,u
      ENSURE(.n_refl>0,"no reflections")
      do n = 1,.n_refl
         hkl = (/ .h(n),.k(n),.l(n) /)
         u = 1
         do s = 2,.spacegroup.n_seitz
            new = matmul(.spacegroup.seitz(1:3,1:3,s),hkl)
            if (hkl(1)/=new(1) OR hkl(2)/=new(2) OR hkl(3)/=new(3)) u = u + 1
         end
         res(n) = u
      end
   end

   make_F_predicted [leaky]
   ! Make the predicted magnitude of the structure factors, including possibly
   ! an overall scale factor and extinction correction.
      INOUT :: self
      ENSURE(.F_calc_exists, "no calculated structure factors")
      .n_param = 0
      if (.optimise_extinction OR .optimise_scale) .get_optimum_parameters
      .F_pred.destroy
      .F_pred.create(.n_refl)
      .F_pred = abs(.F_calc) * .extinction_correction
      if (.F_exp.created AND .sigma.created) .make_agreement_statistics
   end
 
   get_optimum_parameters
   ! Get the scale factors, extinction parameters, etc, which minimise the chi2.
   ! (To get the corrections cooresponding to these parameters see routine
   ! .extinction_correction)
      ENSURE(.F_calc_exists, "No calculated structure factors")
      ENSURE(.F_exp.created, "No experimental structure factors.")
      ENSURE(.sigma.created, "No experimental errors.")
      if (.optimise_extinction) then
         .optimise_extinction_factor
      else if (.optimise_scale) then
         .optimise_scale_factor
      end
   end

   extinction_correction result(res)
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors.
      VEC( .n_refl ) :: res
      VEC, PTR :: angle_part
      res = .extinction_correction(.scale_factor,.extinction_factor)
   end
 
   extinction_correction(scale_factor,extinction_factor) result(res)
   ! Return the extinction correction  factors "res" to the calculated individual 
   ! structure factors. NOTE: this routine also does scaling corrections without
   ! extinction.
      DBL :: scale_factor,extinction_factor
      VEC( .n_refl )  :: res
      VEC, PTR :: angle_part
      ENSURE(.F_calc_exists, "no calculated structure factors")
      if (extinction_factor.is_zero(TOL(9))) then
         res(:) = scale_factor
      else
         angle_part.create( .n_refl )
         angle_part = .extinction_angle_part
         res(:) = scale_factor/sqrt(sqrt(ONE + extinction_factor*.F_calc*conjg(.F_calc)*angle_part))
         angle_part.destroy
      end
   end
 
   extinction_angle_part result(res)
   ! Return the angular part of the extinction correction.
      MAT(3,3) :: rcm
      VEC( .n_refl ) :: res
      INT :: n
      DBL :: kx,ky,kz,stl,twotheta, c,s
      rcm = .reciprocal_cell_matrix
      do n=1, .n_refl
         kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
         ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
         kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
         stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)
         twotheta=TWO*asin( stl * .wavelength )
         c = cos(twotheta)
         s = sin(twotheta)
         res(n) = (1+c*c)/(1+c*s)
      end
   end
 
   optimise_scale_factor
   ! Determine the structure factor scale factor to scale the calculated structure 
   ! factors .F_calc by in order to minimise the chi2. (But it does not do any 
   ! scaling; see .extinction_correction routine for that)
      DBL :: top,bot
      VEC, PTR :: F_pred
      ENSURE(.F_calc.created, "No calculated structure factors.")
      ENSURE(.F_exp.created,  "No experimental structure factors.")
      ENSURE(.sigma.created,  "No experimental errors.")
      F_pred.create(.n_refl)
      F_pred = abs(.F_calc)
      top = sum( F_pred * .F_exp  / (.sigma * .sigma) )
      bot = sum( F_pred *  F_pred / (.sigma * .sigma) )
      .scale_factor = top/bot
      F_pred.destroy
      .n_param = 1
   end

   optimise_extinction_factor
   ! Optimize the .scale_factor and .extinction_factor parameter of Larson's method.  
   ! NOTE: the corrections are not applied to .F_pred; use the routine 
   ! .extinction_corrections to do that.
   ! Reference: Larson, A. C., in <I>Crystallographic Computing</I> 
   !            Ed. Ahmed, F. R. (Copenhagen, Munksgaard 1970), pp. 291-294.
      target :: self
      VEC(2) :: p
      DBL :: chi2_min
      .optimise_scale_factor
      p(1) = .scale_factor
      p(2) = ZERO          ! This is the .extinction_factor 
      saved_self => self
      call minimise_BFGS_(chi2,d_chi2,p,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(4))
      nullify(saved_self)
      .scale_factor = p(1)
      .extinction_factor = p(2)
      .n_param = 2
   end
 
   chi2(p) result (res) [selfless]
   ! Make the predicted magnitude of the structure factors, including possibly
   ! an overall scale factor and extinction correction. Update agreement
   ! statistcics as well, but do not update .F_pred. This routine is for use
   ! in the BFGS minimiser.
      VEC :: p
      DBL :: res
      VEC, PTR :: F_pred
      CRYSTAL, PTR :: self; self => saved_self
      ENSURE(.F_calc_exists, "no calculated structure factors")
      ENSURE(.F_exp.created, "No experimental structure factors.")
      ENSURE(.sigma.created, "No experimental errors.")
      ENSURE(size(p)==2, "wrong size, p")
      F_pred.create(.n_refl)
      F_pred = abs(.F_calc) * .extinction_correction(p(1),p(2))
      res = sum( ((F_pred - .F_exp)/.sigma)**2 ) / max(.n_refl-.n_param,1)
      F_pred.destroy
   end
 
   d_chi2(p) result (res) [selfless]
   ! Return the derivative of the chi2 with respect to the .scale_factor in p(1),
   ! and with respect to .extinction_factor in p(2). This routine is for use
   ! in the BFGS minimiser.
      VEC :: p
      VEC(size(p)) :: res
      CRYSTAL, PTR :: self; self => saved_self
      ENSURE(size(p)==2, "wrong size, p")
      res(1) = .d_chi2_d_scale(p)
      res(2) = .d_chi2_d_ext(p)
   end
 
   d_chi2_d_scale(p) result (res)
   ! Derivative of the chi^2 with respect to the scale factor
      VEC :: p
      DBL :: res
      VEC, PTR :: F_pred
      ENSURE(.F_calc_exists, "no calculated structure factors")
      ENSURE(size(p)==2, "wrong size, p")
      F_pred.create(.n_refl)
      F_pred = abs(.F_calc) * .extinction_correction(p(1),p(2))
      res = sum( F_pred*F_pred - .F_exp*F_pred/(.sigma*.sigma) )
      res = TWO*res/(p(1)*max(.n_refl-.n_param,1))
      F_pred.destroy
   end
 
   d_chi2_d_ext(p) result (res)
   ! Derivative of the chi^2 with respect to the extinction parameter.
      VEC :: p
      DBL :: res
      VEC, PTR :: angle_bit,tmp,ext
      ENSURE(.F_calc_exists, "no calculated structure factors")
      ENSURE(size(p)==2, "wrong size, p")
      angle_bit.create(.n_refl)
      ext.create(.n_refl)
      tmp.create(.n_refl)
      angle_bit = .extinction_angle_part
      ext = .extinction_correction(ONE,p(2))
      tmp = p(1) * abs(.F_calc) * ext
      ext = ext*ext*ext*ext*ext
      ext = ext*.F_calc*.F_calc*.F_calc
      tmp = (tmp - .F_exp) * ext * angle_bit / (.sigma * .sigma)
      res = -p(1)*sum(tmp)/(TWO * max(.n_refl-.n_param,1))
      tmp.destroy
      ext.destroy
      angle_bit.destroy
   end
 
   d_chi2_dU(dF) result (res)
   ! Evaluate the derivative of the chi^2 with respect to parameters U 
   ! (e.g. thermal parameters) given the derivatives "dF" of where 
   ! .F_calc with respect to these parameters U. NOTE: this routine
   ! assumes that the .scale_factor and .extinction_factor are fixed.
      CMAT :: dF
      VEC(size(dF,2)) :: res
      VEC, PTR :: Fc,ext,angle_bit
      DBL :: fac
      INT :: u
      ENSURE(size(dF,1)==.n_refl, "wrong size, dF")
      ENSURE(.F_calc_exists, "no calculated structure factors")
      angle_bit.create(.n_refl)
      angle_bit = .extinction_angle_part
      ext.create(.n_refl)
      ext = .extinction_correction(ONE,.extinction_factor)
      Fc.create(.n_refl)
      Fc = abs(.F_calc)
      Fc = ((.scale_factor*ext*Fc - .F_exp)/(.sigma*.sigma)) * &
           (ext/Fc - HALF*ext*ext*ext*ext*ext*.extinction_factor*Fc*angle_bit)
      do u = 1,size(dF,2)
         res(u) = sum( Fc * conjg(.F_calc) * dF(:,u) )
      end
      fac = TWO*.scale_factor/max(.n_refl-.n_param,1)
      res = fac * res
      Fc.destroy
      ext.destroy
      angle_bit.destroy
   end

!  d_chi2_d_ext(p) result (res)
!  ! Derivative of the chi^2 with respect to the extinction parameter.
!     DBL :: res
!     DBL :: Fc2,factor,total,a,b,Fc,Fexp,sig
!     VEC, PTR :: angle_bit
!     INT :: j
!     ENSURE(.F_calc_exists, "no calculated structure factors")
!     angle_bit.create(.n_refl)
!     angle_bit = .extinction_angle_part
!     total = ZERO
!     do j = 1, .n_refl
!        Fc     = abs(.F_calc(j))
!        Fexp   = .F_exp(j)
!        sig    = .sigma(j)
!        Fc2    = Fc*Fc
!        factor = ONE + p(2)*Fc2*angle_bit(j)
!        a      = sqrt(factor)
!        b      = sqrt(a)
!        total  = total + angle_bit(j)*Fc2*Fc*(Fexp/b - p(1)*Fc/a)/(factor*sig*sig)
!     end
!     res = p(1)*total/(TWO * max(.n_refl-.n_param,1))
!     angle_bit.destroy
!  end

!  get_extinction_parameters
!  ! Gets the g and x parameters of Larson's method.  Does not apply the
!  ! correction, just calculates .extinction_factor and .scale_factor.
!  ! Larson, A. C., in <I>Crystallographic Computing</I> Ed. Ahmed, F. R.
!  ! (Copenhagen, Munksgaard 1970), pp. 291-294.
!    DBL :: old_scale
!    DBL :: high,low,new,dhigh,dlow,dnew,xprev
!    VEC, PTR :: Fc,angle
!    INT :: j
!
!    ! Get initial scale factor, with no extinction.
!    Fc.create(.n_refl)
!    Fc = abs(.F_calc)
!    .extinction_factor  = ZERO
!    .get_scale_factor(Fc,.F_exp,.sigma)
!    Fc.destroy
!    DIE_IF(.scale_factor<0, "scale_factor < 0, this is not realistic!")
!    RETURN_IF( .dchi_dext > ZERO)
!
!    old_scale = .scale_factor
!    xprev = ZERO
!    angle.create( .n_refl )
!    angle = .extinction_angle_part
!
!    low=0
!    do j=-15,10
!      high=TEN**(j-1)
!      .extinction_factor = high
!      if (.dchi_dext >= ZERO) then
!        exit
!      end
!      low = high
!      if (j == 10) then ! extinction correction failed.
!        .extinction_factor  = ZERO
!        .get_scale_factor(Fc,.F_exp,.sigma)
!        RETURN
!      end
!    end
!    new = (low+high)/TWO
!    
!    do
!      .extinction_factor=new;   dnew  = .dchi_dext
!      xprev= .extinction_factor
!      old_scale = .scale_factor
!
!      Fc.create(.n_refl)                    ! minimise dchi2/dscale
!      Fc = abs(.F_calc) * ONE/sqrt(sqrt(ONE + new * .F_calc(:)*conjg(.F_calc(:)) * angle(:))) ! **-1/4
!      .get_scale_factor(Fc,.F_exp,.sigma)
!      Fc.destroy
!
!      do                                    ! minimise dchi2/dext
!        .extinction_factor=low;   dlow  = .dchi_dext
!        .extinction_factor=high;  dhigh = .dchi_dext
!        .minimise_param(dlow,dhigh,dnew,low,high,new)
!        .extinction_factor=new;   dnew  = .dchi_dext
!        if (abs(dnew) <= TEN) exit
!      end
! 
!      ! Exit if both converged to 6 significant figures.
!      if ((abs(xprev-new) <= abs(new*TOL(6))) &
!        AND (abs(old_scale-.scale_factor) <= abs(.scale_factor*TOL(6)))) exit
!    end
!
!    angle.destroy
!  end
!
!  minimise_param(dlow,dhigh,dnew,low,high,new)
!  ! Use the bisection method to minimise the extinction parameter.
!    DBL, IN :: dlow,dhigh,dnew
!    DBL, INOUT :: low,high,new
!    if (dnew < 0) then     ! minimum right of "new".
!      if (dhigh < 0) then  ! minimum right of "high".
!        high=1.25d0*high
!        low=high
!      else                 ! minumum between "new" and "high".
!        low=new
!      end
!    else                   ! minimum left of "new".
!      if (dlow > 0) then   ! minimum left of "low".
!        low=0.75d0 * low
!        high=new
!      else                 ! minumum between "low" and "new".
!        high=new
!      end
!    end
!    new=(low+high)/TWO
!  end

   make_agreement_statistics
   ! Make the agreement statistics
      DBL :: top1,top2,bot1,bot2
      VEC, PTR :: I_pred,I_exp,I_sigma
      ENSURE(.F_pred.created,"No predicted structure fac's")
      ENSURE(.F_exp.created, "No experimental structure factors.")
      ENSURE(.sigma.created, "No experimental errors.")
      top1 = sum( abs(.F_pred - .F_exp) )
      bot1 = sum( abs(.F_exp) )
      top2 = sum( ((.F_pred - .F_exp) /.sigma)**2 )
      bot2 = sum( (.F_exp/.sigma)**2 )
      .r_factor          = top1/bot1
      .weighted_r_factor = sqrt(top2/bot2)
      .chi2              = top2/max(.n_refl-.n_param,1)
      .goodness_of_fit   = sqrt(.chi2)

      I_pred.create(.n_refl);    I_pred  = .I_pred
      I_exp.create(.n_refl);     I_exp   = .I_exp
      I_sigma.create(.n_refl);   I_sigma = .I_sigma
      top1 = sum( abs(I_pred - I_exp) )
      bot1 = sum( abs(I_exp) )
      top2 = sum( ((I_pred - I_exp) /I_sigma)**2 )
      bot2 = sum( (I_exp/I_sigma)**2 )
      .I_r_factor          = top1/bot1
      .I_weighted_r_factor = sqrt(top2/bot2)
      .I_chi2              = top2/max(.n_refl-.n_param,1)
      .I_goodness_of_fit   = sqrt(.chi2)
      I_sigma.destroy
      I_exp.destroy
      I_pred.destroy
   end

   make_k_pts(res)
   ! Convert the hkl indices to reciprocal lattice vectors
   ! Dimension of res is [.n_refl,3]
      MAT :: res
      INT :: n
      MAT(3,3) :: rcm
      rcm = 2*PI*.reciprocal_cell_matrix
      do n = 1, .n_refl
         res(n,1) = rcm(1,1)*.h(n) + rcm(1,2)*.k(n) + rcm(1,3)*.l(n)
         res(n,2) = rcm(2,1)*.h(n) + rcm(2,2)*.k(n) + rcm(2,3)*.l(n)
         res(n,3) = rcm(3,1)*.h(n) + rcm(3,2)*.k(n) + rcm(3,3)*.l(n)
      end
   end

  unique_k_pts result(res) [pure]
    IN :: self
    INT :: res
    res = .n_unique_symops * .n_refl
  end

   make_unique_k_pts(k)
   ! Convert the hkl indices to unique reciprocal lattice vectors "k" required
   ! in the reduced crystal spacegroup
   ! (c) Dylan Jayatilaka, UWA, feb 1996
      MAT :: k
      INT :: p,u,n
      MAT(3,3) :: b,rcm
      ENSURE(.unique_symop.created,"no unique_symop array!")
      p = 0
      rcm = 2*PI*.reciprocal_cell_matrix
      do u = 1,.n_unique_symops
         b = matmul(rcm,.unique_symop_mat(u))
         do n = 1, .n_refl
            p = p + 1
            k(p,1) = b(1,1)*.h(n) + b(1,2)*.k(n) + b(1,3)*.l(n)
            k(p,2) = b(2,1)*.h(n) + b(2,2)*.k(n) + b(2,3)*.l(n)
            k(p,3) = b(3,1)*.h(n) + b(3,2)*.k(n) + b(3,3)*.l(n)
         end
      end
   end

!  *************************************
!  Service methods used by other modules
!  *************************************

   make_phases_for_symop(u,phase,mask)
   ! Return the sum of the "phase" shifts for each (hkl) reflection from each
   ! glide vector for all symops which are equivalent to the "u"-th
   ! unique symmetry operation, .unique_symop(u), as determined by the mask
   ! array.
      INT, IN :: u
      CVEC, OUT :: phase
      IVEC, IN :: mask
      DBL :: pi2,tx,ty,tz
      INT :: s
      ENSURE( .unique_symop.created,"no unique_symop array!")
      ENSURE( u<=.n_unique_symops,"symop index out of range")
      ENSURE( size(phase)==.n_refl,"wrong length for phase array")
      pi2 = TWO*PI
      phase = ZERO
      do s = 1,.spacegroup.n_seitz
         if (mask(s)/=.unique_symop(u)) cycle
         tx = pi2*.spacegroup.seitz(4,1,s)
         ty = pi2*.spacegroup.seitz(4,2,s)
         tz = pi2*.spacegroup.seitz(4,3,s)
         phase(:) = phase(:) + exp(cmplx(ZERO,.h(:)*tx+.k(:)*ty+.l(:)*tz))
      end
   end

   sum_unique_sf(sf,unique_sf)
   ! Form the structure factors "sf" from the sum of the list of
   ! unique structure factors, "unique_sf".
      CVEC :: sf
      CVEC, IN :: unique_sf
      CVEC, PTR :: phase
      INT :: u,uf,ul
      ENSURE( size(sf)==.n_refl,"incorrect size for array sf")
      phase.create(.n_refl)
      sf = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)+1
         ul = .n_refl*u
         .make_phases_for_symop(u,phase,.translated_symop)
         sf(:) = sf(:) + phase(:)*unique_sf(uf:ul)
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         sf(:) = sf(:) + phase(:)*conjg(unique_sf(uf:ul))
      end
      phase.destroy
   end

   sum_unique_sf_ints(sf_ints,unique_sf_ints)
   ! Form the structure factor integrals "sf_ints" from a sum of the list
   ! of unique structure factors integrals  "unique_sf_ints".
      CMAT3 :: sf_ints
      CMAT3, IN :: unique_sf_ints
      CVEC, PTR :: phase
      INT :: u,uf,n
      ENSURE(size(sf_ints,1)==.n_refl,"wrong size for sf_ints!")
      phase.create(.n_refl)
      sf_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*unique_sf_ints(uf+n,:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*conjg(unique_sf_ints(uf+n,:,:))
         end
      end
      phase.destroy
   end

   sum_unique_sf_deriv_U(sf,unique_sf)
   ! Form the structure factor derivatives "sf" (wrt the thermal paramaters,U)
   !  from a sum of the list of unique structure factor derivatives "unique_sf".
      CMAT :: sf
      CMAT, IN :: unique_sf
      CVEC, PTR :: phase
      INT :: u,uf, n
      ENSURE( size(sf,1)==.n_refl,"incorrect size for array sf")
      phase.create(.n_refl)
      sf = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         sf(n,:) = sf(n,:) + phase(n)*unique_sf(uf+n,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         sf(n,:) = sf(n,:) + phase(n)*conjg(unique_sf(uf+n,:))
         end
      end
      phase.destroy
   end

   sum_ft_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints" from a sum of the list
   ! of unique integrals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b].
      CMAT3 :: ft_ints
      CMAT3, IN :: unique_ft_ints
      CVEC, PTR :: phase
      INT :: u,uf, n
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*unique_ft_ints(uf+n,:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*conjg(unique_ft_ints(uf+n,:,:))
         end
      end
      phase.destroy
   end

   sum_ft_spin_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints", required for the spin
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b,3,3].
      CMAT5 :: ft_ints
      CMAT3, IN :: unique_ft_ints
      CVEC, PTR :: phase
      MAT, PTR :: q
      CMAT, PTR :: ints
      INT :: u,uf, n
      ENSURE(size(ft_ints,1)==.n_refl,"wrong size for ft_ints!")
      phase.create(.n_refl)
      q.create(.n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3))
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:)
            ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
            ints = phase(n)*conjg(unique_ft_ints(uf+n,:,:))
            ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
         end
      end
      ints.destroy
      ! The factor of two for conversion to Bohr magnetons cancels the
      ! factor of half for the S operator
      do n = 1, .n_refl
          ft_ints(n,:,:,:,:) = -ft_ints(n,:,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

   sum_ft_r_ints(ft_ints,unique_ft_ints,B)
   ! Form the Fourier transform dipole integrals "ft_ints", required for the PND
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  "B" is the external magnetic field.
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Dimensions of ft are [.n_refl,n_comp_a,n_comp_b,3].
      CMAT4 :: ft_ints
      CMAT4, IN :: unique_ft_ints
      VEC(3) :: B
      CVEC, PTR :: phase
      MAT, PTR :: q
      CMAT3, PTR :: ints
      INT :: u,uf, n
      CDBL :: ci
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      q.create(.n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3),3)
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                                - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                                - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                                - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                                - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                                - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                                - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
         end
      end
      ints.destroy
     ! The factor of two for conversion to Bohr magnetons cancels the
     ! factor of half for the S operator
      ci = (ZERO,ONE)
      do n = 1, .n_refl
          ft_ints(n,:,:,:) = -ci*ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

   sum_ft_nabla_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform nabla_a integrals "ft_ints", required for the
   ! PND magnetic striucture factors, from a sum of "unique_ft_ints".
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Note: the complex conjugate nabla_b integrals are not included.
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
      CMAT4 :: ft_ints
      CMAT4, IN :: unique_ft_ints
      CVEC, PTR :: phase
      MAT, PTR :: q
      CMAT3, PTR :: ints
      INT :: u,uf, n
      ENSURE(size(ft_ints,1)==.n_refl,"wrong size for ft_ints!")
      phase.create(.n_refl)
      q.create(.n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3),3)
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
      end
      ints.destroy
      ! The factor of 2 to convert to Bohr magnetons cancels the factor
      ! of 1/2 for the Bohr magneton
      ! Extra minus sign introduced, but not sure why ...
      ! Reversed minus sign introduced ...
      do n = 1, .n_refl
          ft_ints(n,:,:,:) =  ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

   sum_ft_j_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform j integrals "ft_ints", required for the PND
   ! magnetic striucture factors, from a sum of "unique_ft_ints".
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Note: the complex conjugate nabla_b integrals are not included.
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
      CMAT4 :: ft_ints
      CMAT4, IN :: unique_ft_ints
      CVEC, PTR :: phase
      INT :: u,uf, n
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:,:) = ft_ints(n,:,:,:) + phase(n)*unique_ft_ints(uf+n,:,:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:,:) = ft_ints(n,:,:,:) - phase(n)*conjg(unique_ft_ints(uf+n,:,:,:))
         end
      end
      phase.destroy
   end

! ***********************************
! Operations on atomvecs in a crystal
! ***********************************

  generate_unique_symop_list(list)
  ! Returns a list of which seitz matrices generate unique molecules.
  ! Usefull when the molecule is on a special position.
    IN :: self
    BINVEC, OUT :: list
    MAT, PTR :: pos1,pos2
    BINVEC, PTR :: matched
    BIN :: same
    INT :: s1,s2,n,q

    ENSURE(size(list)==.spacegroup.n_seitz,"list size?")
    pos1.create(3,.n_fragment_atoms)
    pos2.create(3,.n_fragment_atoms)
    matched.create(.n_fragment_atoms)

    do s1=1,.spacegroup.n_seitz
      pos1 = .fragment_geometry
      .move_to_unit_cell(pos1)
      .transform_geometry(pos1,s1)
      .move_to_unit_cell(pos1)
      same = FALSE
      do s2=1,s1-1
        pos2 = .fragment_geometry
        .move_to_unit_cell(pos2)
        .transform_geometry(pos2,s2)
        .move_to_unit_cell(pos2)
        matched = FALSE
        do n = 1, .n_fragment_atoms
          do q = 1, .n_fragment_atoms
            same = pos2(:,n).same_as(pos1(:,q), TOL(3))
            if (same) then
              matched(q) = TRUE
              exit
            end
          end
          if (NOT same) exit   ! atom q doesn't have a match.
        end
        same = all(matched)    ! They are the same if all have a match.
        if (same) exit
      end
      list(s1) = NOT same
    end

    matched.destroy
    pos2.destroy
    pos1.destroy
  end

  create_closest_molecule_list(op_list,dist_list,position,distance_max) [leaky]
  ! Creates a list of the symmetry operations and translations of the molecules
  ! which are within max_distance of the centre of the molecule.
  ! If "position" is specified, it is used instead of the centre of the
  ! molecule.
    IMAT, PTR :: op_list
    VEC, PTR :: dist_list
    VEC, IN :: position
    DBL, optional :: distance_max
    MAT, PTR :: pos1,pos2,pos3
    BINVEC, PTR :: unique_symop_list
    VEC(3) :: centre,diff
    IVEC(3) :: offset
    INT :: n,s,h,k,l,d_h,d_k,d_l,q,maxnum
    DBL :: distance,dist,max_distance,max_cell_distance,a,b,c

    unique_symop_list.create(.spacegroup.n_seitz)
    .generate_unique_symop_list(unique_symop_list)

    max_distance = 10d0
    if (present(distance_max)) max_distance = distance_max

    a = .unit_cell_length(1)
    b = .unit_cell_length(2)
    c = .unit_cell_length(3)
    max_cell_distance = max_distance + a + b + c
    maxnum = unique_symop_list.n_true * &
                              (ceiling(max_cell_distance/min(a,b,c)))**3

    dist_list.create(maxnum)
    op_list.create(4,maxnum)

    pos1.create(3,.n_fragment_atoms)
    pos2.create(3,.n_fragment_atoms)
    pos3.create(3,.n_fragment_atoms)
    pos1 = .fragment_geometry
    .move_to_unit_cell(pos1)

    centre = position                        ! Center of the cluster
    centre.rotate_by(.inverse_cell_matrix)
    offset = floor(centre+0.001d0)           ! hkl offset of cluster
    ! We work with the 0,0,0 cell as the center of the cluster, then translate
    ! by the offset.
    centre = position - offset

    q = 0
    do s = 1, .spacegroup.n_seitz
      if (NOT unique_symop_list(s)) cycle
      pos2 = pos1
      .transform_geometry(pos2,s)

      d_h = ceiling(max_cell_distance/a)
      do h = -d_h,+d_h
        d_k = ceiling((max_cell_distance-abs(h)*a)/b)
        do k = -d_k,+d_k
          d_l = ceiling((max_cell_distance-abs(h)*a-abs(k)*b)/c)
          do l = -d_l,+d_l
            do n=1,.n_fragment_atoms
              pos3(:,n) = pos2(:,n) + (/h,k,l/)      ! Translate through lattice
            end
            .change_geometry_from_crystal(pos3)      ! Put in cartesians.
            diff = pos3(:,1) - centre
            distance = dot_product(diff,diff)
            do n=2,.n_fragment_atoms
              diff = pos3(:,n) - centre
              dist = dot_product(diff,diff)
              if (dist<distance) distance=dist
            end
            if (distance < TOL(6)) distance = ZERO
            distance = sqrt(distance)
            if (distance < max_distance) then
              q = q + 1; dist_list(q) = distance
              op_list(:,q) = (/s,h,k,l/)
            end
          end
        end
      end
    end

    do n=1,q
      op_list(2:4,n) = op_list(2:4,n) + offset       ! Translate cluster to
    end                                              ! correct cell.

    if (q==0) then ! None within required distance.
      dist_list.shrink(1);               dist_list = ZERO
      op_list.shrink(4,1);               op_list = 0
    else
      ! Truncate the lists.
      dist_list.shrink(q)
      op_list.shrink(4,q)

      ! Sort by distance.
      do k = 1, q
       do l = k, q
        if (dist_list(l) < dist_list(k)) then
          op_list.swap_columns(k,l)
          dist_list.swap_elements(k,l)
        end
       end
      end
    end

    unique_symop_list.destroy
  end

!  *****************************************
!  Reduced group, Unique operators, Z number
!  *****************************************

   make_reduced_group_data(atom) [leaky]
   ! The reduced group are those unique seitz operators which are needed to
   ! generate the complete ".unit_cell_geometry" from the atom fragment "atom".
   ! Some of these symmetry operations may only lead to geometries which are
   ! inversions of, or translations of, other operations in the reduced group.
   ! This information is also worked out here, and it can be used to save work
   ! in structure factor calculations.
      ATOMVEC :: atom
      .n_fragment_atoms = size(atom)
      .fragment_geometry.create(3,.n_fragment_atoms)
      atom.get_geometry(.fragment_geometry)
      .change_geometry_to_crystal(.fragment_geometry)
      .make_reduced_symops
      .make_inverted_symops
      .make_translated_symops
      .make_unique_symops
      .make_unique_atoms
      .make_unit_cell_geometry
      .make_repetition_factors
      .Z = .z_factor(atom)
   end

   z_factor(atom) result (res)
   ! The Z crystallographic factor for ".fragment_geometry", defined as the
   ! ratio of the number of electrons in the unit cell on the number of
   ! electrons in the fragment. Hence, we require information for each "atom" in
   ! the fragment.
      ATOMVEC :: atom
      DBL :: res,u,f
      INT :: n,a
      ENSURE(.reduced_symop.created,"no reduced_symop array")
      ENSURE(.fragment_atom_for.created,"no reduced_symop array")
      u = ZERO
      do n = 1,.n_unit_cell_atoms
         a = .fragment_atom_for(n)
         u = u + atom(a).atomic_number
      end
      f = ZERO
      do n = 1,.n_fragment_atoms
         f = f + atom(n).atomic_number
      end
      res = u/f
   end

   make_reduced_symops [leaky]
   ! Make a list of the indices of the Seitz matrices, ".reduced_symop",
   ! which will generate distinctly different geometries from that in
   ! ".fragment_geometry". ".n_reduced_symops" is set to the number of
   ! reduced symmetry operations.
      MAT, PTR  :: gi,gu
      INT :: i,j,u, n
      BIN :: identical
      gi.create(3,.n_fragment_atoms)
      gu.create(3,.n_fragment_atoms)
      .reduced_symop.create(.spacegroup.n_seitz)
      n = 1
      .reduced_symop(1) = 1
      do i = 2,.spacegroup.n_seitz
         do j = 1,n                            ! Loop over reduced symops
            gi = .fragment_geometry
            gu = .fragment_geometry
            u = .reduced_symop(j)
            .transform_geometry(gi,i,to_unit_cell=TRUE)
            .transform_geometry(gu,u,to_unit_cell=TRUE)
            identical  = .is_same_geometry(gi,gu)
            if (identical) exit
         end
         if (NOT identical) then
            n = n + 1
            .reduced_symop(n) = i
         end
      end
      .n_reduced_symops = n
      .reduced_symop.shrink(n)
      gu.destroy
      gi.destroy
   end

   make_inverted_symops [leaky]
   ! Determine which of the reduced symops can generate geometries from
   ! ".fragment cell_geometry" which are related by inversion.
      INT :: n,i,j
      BIN :: inverted
      ENSURE(.reduced_symop.created,"no reduced_symop array")
      .inverted_symop.create(.spacegroup.n_seitz)
      .inverted_symop = 0
      n = 0
      do i = 2,.spacegroup.n_seitz
         do j = 1,i-1
            inverted = .spacegroup.seitz(1:3,1:3,i).equals( &
                      -.spacegroup.seitz(1:3,1:3,j) )
            if (inverted) then
               n = n + 1
               .inverted_symop(i) = j
               exit
            end
         end
      end
      .n_inverted_symops = n
   end

   make_translated_symops [leaky]
   ! Determine which of the reduced symops can generate geometries from
   ! ".fragment cell_geometry" which are related by translation, (including
   ! translation by the zero vector), but not inversion
      INT :: i,j
      BIN :: translated
      ENSURE(.inverted_symop.created,"no inverted_symop array")
      .translated_symop.create(.spacegroup.n_seitz)
      .translated_symop = 0
      do i = 1,.spacegroup.n_seitz
         .translated_symop(i) = i
         if (.inverted_symop(i)>0) cycle
         do j = 1,i-1
            translated = .spacegroup.seitz(1:3,1:3,i).equals( &
                         .spacegroup.seitz(1:3,1:3,j) )
            if (translated) then
               .translated_symop(i) = j
               exit
            end
         end
      end
   end

   make_unique_symops [leaky]
   ! Determine which are the unique symops (independent of inversion and
   ! translation) which are a subset of the reduced symops.
      INT :: n,i
      ENSURE(.inverted_symop.created,  "no inverted_symop array")
      ENSURE(.translated_symop.created,"no translated_symop array")
      n = 0
      do i = 1,.spacegroup.n_seitz
         if (.inverted_symop(i)>0) cycle
         if (.translated_symop(i)<i) cycle ! Only true translations count
         n = n + 1
      end
      .n_unique_symops = n
      .unique_symop.create(n)
      n = 0
      do i = 1,.spacegroup.n_seitz
         if (.inverted_symop(i)>0) cycle
         if (.translated_symop(i)<i) cycle
         n = n + 1
         .unique_symop(n) = i
      end
   end

   is_same_geometry(geom_i,geom_j) result(res)
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional
   ! coordinates are the same, exactly.
      MAT :: geom_i,geom_j
      BIN :: res
      INT :: i,j,n_atom
      BIN :: same
      BINVEC, PTR :: skip
      n_atom = size(geom_i,2)
      ENSURE(.spacegroup.seitz.created, "Seitz matrices not initialised")
      ENSURE(size(geom_i,1)==3, "incorrect size for array geom_i")
      ENSURE(size(geom_j,1)==3, "incorrect size for array geom_j")
      ENSURE(n_atom==size(geom_j,2), "incompatible sizes for geom_i, geom_j")
      skip.create(n_atom); skip(:) = FALSE
      do i = 1,n_atom
         do j = 1,n_atom
            same = geom_i(:,i).same_as(geom_j(:,j), TOL(3))
            if (NOT same OR skip(j)) cycle
            skip(j) = TRUE
            exit
         end
      end
      res = all(skip) ! True if all atoms in i were matched (skipped) in j
      skip.destroy
   end

   make_unique_atoms [leaky]
   ! Make the asymmetric unit atoms for the ".fragment_geometry".
      MAT, PTR :: geometry
      VEC(3) :: pa
      INT :: u,a,s,col
      BIN :: found
      ENSURE(.fragment_geometry.created, "no fragment_geometry")
      .unique_atom_for.create(.n_fragment_atoms)
      .unique_atom_for    = 0
      .unique_atom_for(1) = 1
      .unique_atom.create(1)
      .unique_atom(1) = 1
      geometry.create(3,.n_fragment_atoms)
      geometry = .fragment_geometry
      .put_to_unit_cell(geometry)
      u = 1
      do a = 2,.n_fragment_atoms
         found = FALSE
         do s = 1,.spacegroup.n_seitz
            pa = geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)
            found = geometry(:,.unique_atom).has_column(pa,TOL(3),col)
            if (.unique_atom_for(a)==0 AND found) then
               .unique_atom_for(a) = col
               exit
            end
         end
         if (NOT found) then
            u = u + 1
            .unique_atom_for(a) = u
            .unique_atom.expand(u)
            .unique_atom(u) = a
         end
      end
      .n_unique_unit_cell_atoms = u
      geometry.destroy
   end

   make_unit_cell_geometry [leaky]
   ! Get the all the atom positions in the unit cell, ".unit_cell_geometry",
   ! given a (possibly) partial or overcomplete set for the cell in array
   ! ".fragment_geometry".
      VEC(3) :: pa
      INT :: n,a,s
      BIN :: found
      ENSURE(.fragment_geometry.created,"no fragment_geometry")
      .fragment_atom_for.create(1)
      .fragment_atom_for(1) = 1
      .unit_cell_geometry.create(3,1)
      pa = .fragment_geometry(:,1)
      .put_to_unit_cell(pa)
      .unit_cell_geometry(:,1) = pa
      n = 1
      do a = 1,.n_fragment_atoms
         do s = 1,.spacegroup.n_seitz
            pa = .fragment_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)
            found = .unit_cell_geometry.has_column(pa,TOL(3))
            if (NOT found) then
               n = n + 1
               .fragment_atom_for.expand(n)
               .fragment_atom_for(n) = a
               .unit_cell_geometry.expand(3,n)
               .unit_cell_geometry(:,n) = pa
            end
         end
      end
      .n_unit_cell_atoms = n
   end

   make_repetition_factors [leaky]
   ! The number of times an atom with index "a" in mapped into itself under
   ! the reduced group is the ".repetition_factor(a)". It is used to correct
   ! structure factors for fragment geometries which are "oversampled" relative
   ! to the asymmetric cell geometry.
      VEC(3)  :: pa,pb
      INT :: a,b,n,n_same
      BIN :: same
      ENSURE(.reduced_symop.created, "no reduced_symops!")
      .repetition_factor.create(.n_fragment_atoms)
      do a = 1,.n_fragment_atoms
         pa = .fragment_geometry(:,a)
         .put_to_unit_cell(pa)
         n_same = 0
         do b = 1,.n_fragment_atoms
         do n = 1,.spacegroup.n_seitz
            pb = .fragment_geometry(:,b)
            .transform_position(pb,n,to_unit_cell=TRUE)
            same = pa.same_as(pb,TOL(3))
            if (same) n_same = n_same + 1
         end
         end
         .repetition_factor(a) = n_same
      end
   end

   transform_geometry(g,op,ignore_glide,to_unit_cell)
   ! Transform the geometry "g" in fractional coordinates with the
   ! Seitz operator with index "op". If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translated fractional
   ! coordinates into the (1,1,1) unit cell.
      MAT :: g
      INT :: op
      BIN, optional :: ignore_glide,to_unit_cell
      INT :: n,n_atom,n_seitz
      n_atom = size(g,2)
      n_seitz = .spacegroup.n_seitz
      ENSURE( size(g,1)==3, "incorrect size for array g")
      do n = 1,n_atom
         .transform_position(g(:,n),op,ignore_glide,to_unit_cell)
      end
   end

   transform_position(p,op,ignore_glide,to_unit_cell)
   ! Transform the position "p" in fractional coordinates with the
   ! Seitz operator with index "op". If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translated fractional
   ! coordinates into the (1,1,1) unit cell.
      VEC(3) :: p
      INT :: op
      BIN, optional :: ignore_glide,to_unit_cell
      BIN :: ignore,to_cell
      INT :: n_seitz
      n_seitz = .spacegroup.n_seitz
      ENSURE( op>0,        "operator index out of bounds")
      ENSURE( op<=n_seitz, "operator index out of bounds")
      ignore = FALSE
      if (present(ignore_glide)) ignore = ignore_glide
      if (ignore) then
        p = matmul(p,.spacegroup.seitz(1:3,1:3,op))
      else
        p = matmul(p,.spacegroup.seitz(1:3,1:3,op)) + .spacegroup.seitz(4,1:3,op)
      end
      to_cell = FALSE
      if (present(to_unit_cell)) to_cell = to_unit_cell
      if (to_cell) .put_to_unit_cell(p)
   end

   put_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell.  All atoms will be shifted into the first unit cell
   ! independently, so the resulting geometry may not reflect the shape of the
   ! original molecule.
      MAT :: g
      INT :: n,n_atom
      ENSURE( size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      do n = 1,n_atom
         .put_to_unit_cell(g(:,n))
      end
   end

   put_to_unit_cell(p)
   ! Transform the position "p" in fractional coordinates into the
   ! (1,1,1) unit cell.
      VEC(3) :: p
      ENSURE( size(p)==3, "incorrect size for position vector p")
      p(:) = mod(p(:)+TWO+0.001d0,ONE) - 0.001d0
   end

   move_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the first
   ! lattice cell.  The shape of the molecule remains intact, so some of it
   ! may cross into other cells.  The center of the molecule will be in the
   ! first cell.
      MAT :: g
      INT :: n,n_atom
      IVEC(3) :: centre
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      centre = .unit_cell_offset(g)
      do n = 1, n_atom
        g(:,n) = g(:,n) - centre
      end
   end

   unit_cell_offset(g) result(res)
   ! Which hkl indices match the centre of the fragment.
   ! Usually it's 0,0,0 but not always
      MAT :: g
      INT :: n,n_atom
      IVEC(3) :: res
      VEC(3) :: centre
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      .change_geometry_from_crystal(g)
      centre =  0.001d0
      do n = 1, n_atom
        centre = centre + g(:,n)
      end
      centre.rotate_by(.inverse_cell_matrix)
      res = floor(centre / n_atom)
      .change_geometry_to_crystal(g)
   end

   reduced_symop_mat(r) result (res)
   ! Return the "r"-th reduced symop matrix in the unique list made by routine
   ! ".make_reduced_symops".
      MAT(3,3) :: res
      INT :: r
      ENSURE(.reduced_symop.created,"no reduced_symops!")
      ENSURE(r<=.n_reduced_symops,"symop index out of range")
      ENSURE(r>0, "symop index out of range")
      res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
   end

   unique_symop_mat(u) result (res)
   ! Return the "u"-th reduced symop matrix in the unique list made by routine
   ! ".make_reduced_symops".
      MAT(3,3) :: res
      INT :: u,r
      ENSURE(.unique_symop.created,"no unique_symops!")
      ENSURE(u<=.n_unique_symops,"symop index out of range")
      ENSURE(u>0,"symop index out of range")
      r = .unique_symop(u)
      res = .spacegroup.seitz(1:3,1:3,r)
   !  res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
   end

!  **************
!  Output methods
!  **************

   put(atom)
   ! Put out the crystal data to stdout
      ATOMVEC, optional :: atom
     .put(stdout,atom)
   end

   put(out,atom)
   ! Put out the crystal data to file "out"
      ATOMVEC, optional :: atom
      TEXTFILE, PTR :: out
      out.flush
      out.text("CRYSTAL information:")
      out.show("kind                        =", .kind)
      .put_unitcell_data(out)
      .spacegroup.put(out)
      if (.fragment_data_exists)   .put_fragment_data(out,atom)
      if (.reflection_data_exists) .put_reflection_data(out)
   end

   put_unitcell_data(out)
   ! Put unitcell information to file "out"
      TEXTFILE :: out
      out.flush
      out.text("Crystal unitcell information:",flush=2)
      out.show("alpha angle(rad)       = ",.unit_cell_angle(1))
      out.show("beta  angle(rad)       = ",.unit_cell_angle(2))
      out.show("gamma angle(rad)       = ",.unit_cell_angle(3))
      out.show("a cell parameter(bohr) = ",.unit_cell_length(1))
      out.show("b cell parameter(bohr) = ",.unit_cell_length(2))
      out.show("c cell parameter(bohr) = ",.unit_cell_length(3))
      out.show("cell volume(bohr^3)    = ",.unit_cell_volume)
      out.flush
      out.text("Direct cell matrix/bohr:")
      out.put(.direct_cell_matrix)
      out.flush
      out.text("Reciprocal cell matrix/(bohr^{-1}):")
      out.put(.reciprocal_cell_matrix)
      out.flush
   end

   put_fragment_data(out,atom)
   ! Put fragment information to file "out". Optional "atom" list may
   ! be used to enhace output.
      TEXTFILE :: out
      ATOMVEC, optional :: atom
      out.flush
      out.text("Crystal cell-fragment data:")
      out.flush
      out.show("Fragment partition model      = ",.partition_model)
      out.show("Thermal smearing model        = ",.thermal_smearing_model)
      out.show("No. of inputted atoms         = ",.n_fragment_atoms,dbl_width=TRUE)
      out.show("No. of unit cell atoms        = ",.n_unit_cell_atoms,dbl_width=TRUE)
      out.show("No. of unique unit cell atoms = ",.n_unique_unit_cell_atoms,dbl_width=TRUE)
      out.show("Z factor                      = ",.Z)
      .put_reduced_symop_data(out)
      .put_inv_trans_symop_data(out)
      if (present(atom)) then
        .put_fragment_geometry(out,atom)
        .put_asymmetric_unit_geometry(out,atom)
        .put_unit_cell_geometry(out,atom)
        .put_repetition_factors(out,atom)
      end
   end

   put_reduced_symop_data(out)
   ! Put out the reduced symop data
      TEXTFILE :: out
      INT :: n,s
      BIN :: inverted,translated
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array!")
      out.flush
      out.text("Crystal fragment reduced group information:")
      out.flush
      out.text("NOTE: this table is NOT used any more in structure factor calculations")
      out.flush
      out.dash(int_fields=5)
      out.put("Reduced",int_width=TRUE)
      out.put("Seitz",int_width=TRUE)
      out.put("Inv.",int_width=TRUE)
      out.put("Trans.",int_width=TRUE)
      out.flush
      out.put("Symop",int_width=TRUE)
      out.put("Symop",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("Unique?",int_width=TRUE)
      out.flush
      out.dash(int_fields=5)
      do n = 1,.n_reduced_symops
         out.put(n)
         s = .reduced_symop(n)
         out.put(s)
         inverted = .inverted_symop(s)>0
         if (inverted) then;   out.put(.inverted_symop(s))
         else;                 out.tab(int_fields=1)
         end
         translated = .translated_symop(s)<n
         out.put(.translated_symop(s))
         if (inverted OR translated) then; out.put("No",int_width=TRUE)
         else;                             out.put("Yes",int_width=TRUE)
         end
         out.flush
      end
      out.dash(int_fields=5)
   end

   put_inv_trans_symop_data(out)
   ! Put out the inverted translated symop data
      TEXTFILE :: out
      INT :: n,s
      BIN :: inverted,translated
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array")
      out.flush
      out.text("Crystal Inversion/Translation related symop information:")
      out.flush
      out.text("NOTE: this table is used in structure factor calculations")
      out.flush
      out.dash(int_fields=4)
      out.put("Seitz",int_width=TRUE)
      out.put("Inv.",int_width=TRUE)
      out.put("Trans.",int_width=TRUE)
      out.flush
      out.put("Symop",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("Unique?",int_width=TRUE)
      out.flush
      out.dash(int_fields=4)
      do n = 1,.spacegroup.n_seitz
         out.put(n)
         inverted = .inverted_symop(n)>0
         if (inverted) then;   out.put(.inverted_symop(n))
         else;                 out.tab(int_fields=1)
         end
         translated = .translated_symop(n)<n
         out.put(.translated_symop(n))
         if (inverted OR translated) then; out.put("No",int_width=TRUE)
         else;                             out.put("Yes",int_width=TRUE)
         end
         out.flush
      end
      out.dash(int_fields=4)
   end

   put_fragment_geometry(out,atom)
   ! Put out the cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      STR :: symbol
      INT :: n
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array")
      out.flush
      out.text("Crystal fragment cell geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Fragment",int_width=TRUE)
      out.put("Unique",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do n = 1,.n_fragment_atoms
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.unique_atom_for(n))
         out.put(.fragment_geometry(1,n))
         out.put(.fragment_geometry(2,n))
         out.put(.fragment_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_asymmetric_unit_geometry(out,atom)
   ! Put out the asymmetric unit cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,u
      STR :: symbol
      ENSURE(.unique_atom.created,"unique_atoms?")
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      out.flush
      out.text("Crystal asymmetric unit geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Unique",int_width=TRUE)
      out.put("Fragment",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do u = 1,.n_unique_unit_cell_atoms
         out.put(u)
         n = .unique_atom(u)
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.fragment_geometry(1,n))
         out.put(.fragment_geometry(2,n))
         out.put(.fragment_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_unit_cell_geometry(out,atom)
   ! Put out the full unit cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,f
      STR :: symbol
      out.flush
      out.text("Full unit cell geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Cell ",int_width=TRUE)
      out.put("Fragment",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do n = 1,.n_unit_cell_atoms
         out.put(n)
         f = .fragment_atom_for(n)
         symbol = atom(f).chemical_symbol.trim // " (" // f.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.unit_cell_geometry(1,n))
         out.put(.unit_cell_geometry(2,n))
         out.put(.unit_cell_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_repetition_factors(out,atom)
   ! Put out the repetition factors
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,rf
      STR :: symbol
      out.flush
      out.text("Crystal fragment atom repetition factors:")
      out.flush
      out.dash(int_fields=2)
      out.put("Fragment",int_width=TRUE)
      out.put("Rep.",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Factor",int_width=TRUE)
      out.flush
      out.dash(int_fields=2)
      do n = 1,.n_fragment_atoms
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         rf = .repetition_factor(n)
         out.put(rf)
         out.flush
      end
      out.dash(int_fields=2)
   end

   put_F_stats(output)
   ! Output the structure factor goodness of fit statistics to file "output" or
   ! stdout.
      TEXTFILE, optional, target :: output
      TEXTFILE, PTR :: out
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      out.flush
      out.text("Goodness of fit parameters based on Structure Factors:",flush=2)
      out.show("R factor                    =", .r_factor)
      out.show("Weighted R factor           =", .weighted_r_factor)
      out.show("chi**2                      =", .chi2)
      out.show("Goodness of fit             =", .goodness_of_fit)
      .put_correction_data(out)
   end

   put_I_stats(output)
   ! Output the intensity goodness of fit statistics to file "output" or stdout.
      TEXTFILE, optional, target :: output
      TEXTFILE, PTR :: out
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      out.flush
      out.text("Goodness of fit parameters based on Intensities:",flush=2)
      out.show("R factor                    =", .I_r_factor)
      out.show("Weighted R factor           =", .I_weighted_r_factor)
      out.show("chi**2                      =", .I_chi2)
      out.show("Goodness of fit             =", .I_goodness_of_fit)
      .put_correction_data(out)
   end

  put_corrections(out)
  ! Output which corrections are being used, to file "out"
    TEXTFILE :: out
    BIN :: dbl_width
    dbl_width = TRUE
    out.flush
    out.show("Optimise scale factor    = ", .optimise_scale,dbl_width)
    out.show("Optimise extinction      = ", .optimise_extinction,dbl_width)
    out.show("Thermal smearing model   = ", .thermal_smearing_model)
    out.show("Fragment partition model = ", .partition_model)
!    out.show("Correct dispersion?      = ", .correct_dispersion)
    out.flush
  end

  put_correction_data(out)
  ! Output the correction data to file "out"
    TEXTFILE :: out
    BIN :: dbl_width
    dbl_width = TRUE
    out.flush
    out.show("Using scale factor          =", .optimise_scale,dbl_width)
    out.show("Using extinction            =", .optimise_extinction,dbl_width)
    out.show("Thermal smearing model      =", .thermal_smearing_model)
    out.show("Fragment partition model    =", .partition_model)
    if (.optimise_extinction) then;
    out.show("Optimize extinction         =", TRUE)
    out.show("Secondary extinction factor =", .extinction_factor)
    else
    out.show("Optimize extinction         =", FALSE)
    end
    if (.optimise_scale) then
    out.show("Optimize scale factor       =", TRUE)
    out.show("Scale factor                =", .scale_factor)
    else
    out.show("Optimize scale factor       =", FALSE)
    end
    out.show("Thermal smearing model      =", .thermal_smearing_model)
    out.show("Fragment partition model    =", .partition_model)
!    out.show("Correct dispersion?         =", .correct_dispersion)
   end

   put_reflection_data(output) [leaky]
   ! Output the reflection data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      if (.F_calc_exists AND .F_exp_exists) then
         .put_structure_factor_data(output)
         .put_intensity_data(output)
      else if (.F_calc_exists) then
         .put_F_pred_data(output)
         .put_I_pred_data(output)
      else if (.F_exp_exists)  then
         .put_F_exp_data(output)
         .put_I_exp_data(output)
      end
   end

   put_structure_factor_data(output) [leaky]
   ! Output the structure factor data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      ENSURE(.F_pred_exists,"No predicted struc fac's")
      ENSURE(.F_exp_exists, "The experimental struc fac's are all zero")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      out.flush
      out.text("Structure factor reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      .put_F_stats(out)
      out.dash(int_fields=3,dbl_fields=5)
      out.tab(int_fields=3,dbl_fields=2)
      out.put("Predicted")
      out.flush
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("Re(F_calc)")
      out.put("Im(F_calc)")
      out.put("|F_calc|")
      out.put("|F_exp|")
      out.put("sigma")
      out.flush
      out.dash(int_fields=3,dbl_fields=5)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(.F_calc(n))
         out.put(.F_pred(n))
         out.put(.F_exp(n))
         out.put(.sigma(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=5)
   end

   put_F_pred_data(output) [leaky]
   ! Output only the predicted structure factor data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      ENSURE(.F_pred_exists,"The predicted SF's do not exists")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      out.flush
      out.text("Structure factor reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      out.flush
      out.dash(int_fields=3,dbl_fields=3)
      out.tab(int_fields=3,dbl_fields=2)
      out.put("Predicted")
      out.flush
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("Re(F_calc)")
      out.put("Im(F_calc)")
      out.put("|F_calc|")
      out.flush
      out.dash(int_fields=3,dbl_fields=3)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(.F_calc(n))
         out.put(.F_pred(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=3)
   end

   put_F_exp_data(output)
   ! Output only the experimental structure factor data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      ENSURE(.F_exp_exists,"The experimental SF's are all zero")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      out.flush
      out.text("Structure factor reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("F_exp")
      out.put("sigma")
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(.F_exp(n))
         out.put(.sigma(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=2)
   end

   put_intensity_data(output)
   ! Output the structure factor data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      VEC, PTR :: I_exp,I_pred,sigma
      ENSURE(.F_calc_exists,"The calculated SF's are all zero")
      ENSURE(.F_exp_exists, "The experimental SF's are all zero")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      I_pred.create(.n_refl)
      I_exp.create(.n_refl)
      sigma.create(.n_refl)
      I_pred = .I_pred
      I_exp =  .I_exp
      sigma =  .I_sigma
      out.flush
      out.text("Intensity Reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      .put_I_stats
      out.dash(int_fields=3,dbl_fields=5)
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("I_pred")
      out.put("I_exp")
      out.put("sigma")
      out.flush
      out.dash(int_fields=3,dbl_fields=5)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(I_pred(n))
         out.put(I_exp(n))
         out.put(sigma(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=5)
      sigma.destroy
      I_exp.destroy
      I_pred.destroy
   end

   put_I_pred_data(output)
   ! Output only the predicted intensity data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n,dbl_fields
      VEC, PTR :: I_pred,sigma
      ENSURE(.F_calc_exists,"The calculated SF's are all zero")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      I_pred.create(.n_refl)
      I_pred = .I_pred
      sigma.create(.n_refl)
      sigma =  .I_sigma
      out.flush
      out.text("Intensity Reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      dbl_fields = 1
      .put_correction_data(out)
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      out.tab(int_fields=3,dbl_fields=1)
      out.put("Estimated")
      out.flush
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("I_pred")
      out.put("I_sigma")
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(I_pred(n))
         out.put(sigma(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=2)
      I_pred.destroy
      sigma.destroy
   end

   put_I_exp_data(output)
   ! Output only the experimental structure factor data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      VEC, PTR :: I_exp,sigma
      ENSURE(.F_exp_exists,"The experimental SF's are all zero")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      I_exp.create(.n_refl)
      sigma.create(.n_refl)
      I_exp =  .I_exp
      sigma =  .I_sigma
      out.flush
      out.text("Intensity Reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("F_exp")
      out.put("sigma")
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(I_exp(n))
         out.put(sigma(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=2)
      sigma.destroy
      I_exp.destroy
   end

  put_qq_plot(name)
  ! Output a qq plot to the text file.
  ! It is a plot of the experimental quantile vs expected quantile.
    STR, optional :: name
    ARCHIVE :: archive
    MAT, PTR :: grid
    grid.create(.n_refl,2)
    .make_qq_plot_grid(grid)
    archive.set(root_name=name,name="qq_plot",format="ascii")
    archive.write(grid,order="by_row")
    archive.close
    grid.destroy
  end

   make_qq_plot_grid(grid)
   ! Make the grid for the Q-Q plot, which is a plot of the deviations X-Y
   ! versus the expected deviations, assuming that the expected devaitions
   ! are normally distributed. grid(1,:) contains the expected deviation d0j,
   ! grid(2,:) contains actual deviation dj.
      MAT, target :: grid
      VEC, PTR :: d,e
      DBL :: temp
      INT :: n,j
      ENSURE(size(grid,1)==.n_refl, "grid wrong size")
      ENSURE(size(grid,2)==2,       "grid wrong size")
      n = .n_refl
      d => grid(:,2)
      d(:)  = (.F_exp - .F_pred(:)) * sign(ONE,real(.F_calc)) /.sigma(:)
      d.sort                           ! sort array from lowest to highest
      e => grid(:,1)
      do j=1,n                         ! expected quantile, d0j
        temp = (TWO*(n-j)+ONE)/(TWO*n) ! cumulative probability
        e(n-j+1) = temp.z_from_p
      end
   end

  put_labelled_qq_plot(name)
  ! Output a qq plot to the text file.
  ! It is a plot of the experimental quantile vs expected quantile.
    STR, optional :: name
    TEXTFILE, PTR :: textfile
    MAT, PTR :: grid
    IVEC, PTR :: h,k,l
    INT :: n
    l.create(.n_refl); l = .l
    k.create(.n_refl); k = .k
    h.create(.n_refl); h = .h
    grid.create(.n_refl,2)
    .make_qq_plot_grid(grid,h,k,l)
    textfile.create(trim(name) // ":qq_plot_labelled")
    textfile.open_for_write
    textfile.set_labels(FALSE)
    do n=1,.n_refl
      textfile.put(grid(n,1))
      textfile.put(grid(n,2))
      textfile.put(h(n))
      textfile.put(k(n))
      textfile.put(l(n))
      textfile.flush
    end
    textfile.close
    textfile.destroy
    grid.destroy
    h.destroy
    k.destroy
    l.destroy
  end

  make_qq_plot_grid(grid,h,k,l)
  ! Make the grid for the Q-Q plot, which is a plot of the deviations X-Y
  ! versus the expected deviations, assuming that the expected devaitions
  ! are normally distributed. grid(1,:) contains the expected deviation d0j,
  ! grid(2,:) contains actual deviation dj.
    MAT, target :: grid
    VEC, PTR :: d,e
    IVEC :: h,k,l
    DBL :: temp
    INT :: n,i,j
    n = .n_refl
    ENSURE(size(grid,1)==n, "grid wrong size")
    ENSURE(size(grid,2)==2, "grid wrong size")
    d => grid(:,2)
    d(:)  = (sign(.F_exp(:),.F_pred(:)) - .F_pred(:))/.sigma(:)
    do i=1,n-1                   ! sort array from lowest to highest
      do j=i+1,n
        if (d(j) < d(i)) then
          d.swap_elements(i,j)
          h.swap_elements(i,j)
          k.swap_elements(i,j)
          l.swap_elements(i,j)
        end
      end
    end                                                                       
    e => grid(:,1)
    do j=1,n                         ! expected quantile, d0j
      temp = (TWO*(n-j)+ONE)/(TWO*n) ! cumulative probability
      e(n-j+1) = temp.z_from_p
    end
  end

  put_chi2_vs_angle_plot
  ! Output a table with the chi^2 for the structure factor data set broken
  ! into sections.
  ! Reads from stdin the number of divisions in the plot.
    INT :: num_sections
    INT :: n,n_hkl,num,k
    MAT(3,3) :: rcm
    IVEC( .n_refl ) :: section_for
    VEC( .n_refl ) :: Fc
    DBL :: kx,ky,kz,stl,stl_min,stl_max,chi2,width,stl_mean

    stdin.read(num_sections)
    ENSURE(num_sections > 0, "number of sections to plot not positive")
    ENSURE(.F_pred.created,"no predicted structure factors")
    rcm = .reciprocal_cell_matrix

    ! Work out the limits of the sin(theta)/lambda.
    stl_min = 1000
    stl_max = ZERO
    do n=1, .n_refl
      kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
      ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
      kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
      stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)*BOHR_PER_ANGSTROM
      if (stl < stl_min) stl_min = stl
      if (stl > stl_max) stl_max = stl
    end
    width = (TOL(3) + stl_max - stl_min)/num_sections

    ! Determine which section each reflection belongs to.
    do n=1, .n_refl
      kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
      ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
      kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
      stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)*BOHR_PER_ANGSTROM
      section_for(n) = ceiling((TOL(3) + stl - stl_min) / width)
    end

    stdout.flush
    stdout.text("Chi^2 vs angle plot")
    stdout.flush
    stdout.text("sin(theta)/lambda in Angstrom^(-1)")
    stdout.show("Smallest sin(theta)/lambda  = ",stl_min)
    stdout.show("Largest sin(theta)/lambda   = ",stl_max)
    stdout.flush
    stdout.put("stl")
    stdout.put("chi^2",flush=1)
    stdout.dash(dbl_fields=2)
    do n = 1, num_sections
      chi2 = ZERO
      num = 0
      stl_mean = stl_min + (n - HALF) * width
      do k = 1, .n_refl
        if (n==section_for(k)) then
          chi2 = chi2 + ((.F_pred(k) - .F_exp(k)) / .sigma(k))**2
          num = num + 1
        end
      end
      stdout.put(stl_mean)
      if (num==0) then
        stdout.flush
        cycle
      else
        chi2 = chi2 / max(num - .n_param,1)
        stdout.put(chi2,flush=1)
      end
    end
    stdout.flush
  end

!  *******************
!  Tests for existence
!  *******************

   fragment_data_exists result(res)
   ! Return TRUE if a fragment information exists
      BIN :: res
      res = associated(.fragment_geometry)
   end

   no_fragment_data result(res)
   ! Return TRUE if a fragment information exists
      BIN :: res
      res = NOT associated(.fragment_geometry)
   end

   no_reflection_data result(res)
   ! Return TRUE if no reflection data exists
      BIN :: res
      res = NOT associated(.h) OR (.n_refl==0)
   end

   reflection_data_exists result(res)
   ! Return TRUE if reflection data exists
      BIN :: res
      res = associated(.h) AND (.n_refl>0)
   end

   no_F_exp result(res)
   ! Return TRUE if experimental structure factors does not exist
      BIN :: res
      res = NOT associated(.F_exp)
   end

   F_exp_exists result(res)
   ! Return TRUE if experimental structure factors exist
      BIN :: res
      res = associated(.F_exp)
   end

   no_F_calc result(res)
   ! Return TRUE if calculated structure factors does not exist
      BIN :: res
      res = NOT associated(.F_calc)
   end

   F_calc_exists result(res)
   ! Return TRUE if calculated structure factors exist
      BIN :: res
      res = associated(.F_calc)
   end

   no_F_pred result(res)
   ! Return TRUE if predicted structure factor magnitudes do not exist
      BIN :: res
      res = NOT associated(.F_pred)
   end

   F_pred_exists result(res)
   ! Return TRUE if predicted structure factor magnitudes exist
      BIN :: res
      res = associated(.F_pred)
   end

end
