!-------------------------------------------------------------------------------
!
! CRYSTAL: Data structure for crystals
!
! $Id$
!
! (c) dylan jayatilaka, daniel grimwood, university of western australia (1999)
!-------------------------------------------------------------------------------
module CRYSTAL

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL
   use BUFFER
   use BINVEC
   use IVEC
   use IMAT
   use VEC
   use MAT
   use CVEC
   use CMAT
   use CMAT3
   use CMAT4
   use CMAT5
   use TEXTFILE
   use ATOM
   use ATOMVEC
   use ARCHIVE
   use SPACEGROUP
   use PAIRSTATISTICS

   implicit none

#  include "macros"
#  include "crystal.int"

!   type crystal_type
!
!   STR :: kind
!   ! Kind of diffraction experiment used.
!
!   SPACEGROUP :: spacegroup
!   ! The crystal spacegroup
!
!   VEC(3) :: unit_cell_angle
!   ! cell angles  (in radians)
!
!   VEC(3) :: unit_cell_length
!   ! cell lengths (in bohr)
!
!   DBL :: unit_cell_volume
!   ! cell volumes (bohr^3)
!
!   MAT(3,3) :: direct_cell_matrix
!   ! direct cell matrix (bohr)
!
!   MAT(3,3) :: direct_U_cell_matrix
!   ! Converts thermal tensors from crystal to cartesian systems.
!
!   MAT(3,3) :: inverse_cell_matrix
!   ! inverse direct cell matrix (bohr^{-1})
!
!   MAT(3,3) :: reciprocal_cell_matrix
!   ! reciprocal cell matrix (bohr^{-1}).
!
!   MAT(3,3) :: reciprocal_U_cell_matrix
!   ! Converts thermal tensors from cartesian to crystal systems.
!
!   INT :: n_fragment_atoms
!   ! No of atoms in the inputted cell fragment
!
!   MAT, PTR :: fragment_geometry
!   ! The geometry for molecular cell fragment under consideration
!
!   INT :: n_unit_cell_atoms
!   ! Total no. of unit cell atoms
!
!   MAT, PTR :: unit_cell_geometry
!   ! The full unit cell geometry
!
!   INT :: n_unique_unit_cell_atoms
!   ! No of unique unit cell atoms
!
!   IVEC, PTR :: unique_atom
!   ! Contains the actual unique (asymmetric) unit cell atoms.
!
!   IVEC, PTR :: unique_atom_for
!   ! If "a" is the index of an atom position in fragment_geometry, fragment_geometry(:,a),
!   ! then unique_atom_for(a) is the index of the unique (asymmetric) unit cell atom
!   ! which generates that position.
!
!   IVEC, PTR :: fragment_atom_for
!   ! If "u" is the index of an atom position in unit_cell_geometry, unit_cell_geometry(:,u),
!   ! then fragment_atom_for(a) is the index of the fragment_atom which generates that position.
!
!   INT :: n_reduced_symops
!   ! No. of symops needed to make the unit_cell_geometry from fragment_geometry
!
!   IVEC, PTR :: reduced_symop
!   ! Indices of the reduced symops in the spacegroup seitz list
!
!   INT :: n_inverted_symops
!   ! Number of symmetry operations related by inversion
!
!   IVEC, PTR :: inverted_symop
!   ! Indices of the unique symops related by inversion
!
!   IVEC, PTR :: translated_symop
!   ! Indices of the unique symops related by translation
!
!   INT :: n_unique_symops
!   ! Number of unique symmetry operations not related by inversion or translation.
!   ! This is used to save work in structure factor calculations.
!
!   IVEC, PTR :: unique_symop
!   ! Indices of the unique symops not related by inversion or translation
!
!   VEC, PTR :: repetition_factor
!   ! The partition factors for cell_geometry
!
!   DBL :: Z
!   ! The crystallographic Z factor for the moleculat cell fragment in the unitcell
!
!   INT :: n_refl
!   ! No. of reflection planes
!
!   IVEC, PTR :: h DEFAULT_NULL
!   ! Miller indices for the reflections
!
!   IVEC, PTR :: k DEFAULT_NULL
!   ! Miller indices for the reflections
!
!   IVEC, PTR :: l DEFAULT_NULL
!   ! Miller indices for the reflections
!
!   VEC, PTR :: F_exp DEFAULT_NULL
!   ! Experimental structure factors
!
!   VEC, PTR :: sigma DEFAULT_NULL
!   ! Experimental sigma
!
!   CVEC, PTR :: F_calc DEFAULT_NULL
!   ! Calculated complex structure factors without including corrections
!
!   VEC, PTR :: F_pred DEFAULT_NULL
!   ! Calculated structure factors including scale and extinction corrections
!  
!   PAIRSTATISTICS :: F_stats
!   ! Statistics for comparing predicted and experimental structure factor magnitudes
!
!   DBL :: scale_factor
!   ! Fixed scale factor to apply to the experimental structure factors
!
!   BIN :: use_scale_factor
!   ! True if an overall scaler factor is to be used in calculating F_predicted
!
!   BIN :: synthesize_sigma_I
!   ! True if artificial sigma(I) errors are to be gereated from poisson statistics
!   ! and used in calculating agreement statistics
!
!   BIN :: correct_extinction
!   ! True if extinction is to be corrected
!
!   BIN :: correct_dispersion
!   ! True if dispersion is to be corrected
!
!   DBL :: ext_factor
!   ! Secondary extinction factor
!
!   DBL :: wavelength
!   ! Experimental wavelength, in bohr
!
!   STR :: thermal_smearing_model       DEFAULT("none")
!   ! Thermal smearing model for ft integrals
!
!   STR :: partition_model
!   ! Model for partitioning fragments of the molecule
!
!   end

contains

!  **************************
!  Create and destroy methods
!  **************************

   create
   ! Create an crystal object
      PTR :: self
      nullify(self)
      allocate(self)
      ADD_MEM(CRYSTAL_SIZE)
      .nullify_ptr_part
      .set_default 
   end

   destroy
   ! Destroy an crystal object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(CRYSTAL_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the crystal object
      .spacegroup.nullify_ptr_part
      nullify(.h)
      nullify(.k)
      nullify(.l)
      nullify(.F_exp)
      nullify(.sigma)
      nullify(.F_calc)
      nullify(.F_pred)
   end

   destroy_ptr_part
   ! Erase all pointer information
      .destroy_reflection_data
   end

   destroy_reflection_data
   ! Erase all reflection data
      if (.reflection_data_exists) then
         .h.destroy
         .k.destroy
         .l.destroy
         .n_refl = 0
         .scale_factor = ONE
         .ext_factor = ZERO
         if (.F_calc_exists) .F_calc.destroy
         if (.F_pred_exists) .F_pred.destroy
         if (.F_exp_exists) then
            .F_exp.destroy
            .sigma.destroy
         end
      end
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_default [leaky]
   ! Set up a default crystal object
      .spacegroup.set_default
      .unit_cell_angle = (/90.0d0,90.0d0,90.0d0/)
      .unit_cell_angle.convert_from("degree")
      .unit_cell_length = (/10.0d0,10.0d0,10.0d0/)
      .make_cell_matrices
      .n_refl = 0
      .destroy_reflection_data
      .scale_factor = ONE
      .synthesize_sigma_I = FALSE
      .use_scale_factor = FALSE
      .correct_extinction = FALSE
      .correct_dispersion = TRUE
      .ext_factor = ZERO
      .wavelength = 0.71069d0 * BOHR_PER_ANGSTROM
      .kind = "x-ray"
      .thermal_smearing_model = ""
      .partition_model = ""
   end

!  ********************
!  Unit cell operations
!  ********************

   make_cell_matrices
   ! Calculate the various unit cell axis matrices.
      .make_cell_volume
      .make_direct_cell_matrix
      .make_reciprocal_cell_matrix
      .make_direct_U_cell_matrix
      .make_reciprocal_U_cell_matrix
   end

   make_cell_volume
   ! Calculate the cell volume
      DBL :: a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      .unit_cell_volume = a*b*c*sqrt(ONE-ca**2-cb**2-cg**2+TWO*ca*cb*cg)
   end

   make_direct_cell_matrix
   ! Calculate the direct cell matrices, in units of BOHRS.
      DBL :: v,a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      v = .unit_cell_volume
      ! Direct cell matrix
      .direct_cell_matrix(1,1) = a
      .direct_cell_matrix(1,2) = b*cg
      .direct_cell_matrix(1,3) = c*cb
      .direct_cell_matrix(2,1) = ZERO
      .direct_cell_matrix(2,2) = v/(a*c*sb)
      .direct_cell_matrix(2,3) = ZERO
      .direct_cell_matrix(3,1) = ZERO
      .direct_cell_matrix(3,2) = b*(ca-cg*cb)/sb
      .direct_cell_matrix(3,3) = c*sb
   end

   make_reciprocal_cell_matrix
   ! Calculate the reciprocal cell matrices in units of 1/BOHRS.
      DBL :: v,a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      v = .unit_cell_volume
      ! Reciprocal cell matrix
      .reciprocal_cell_matrix(1,1) = ONE/a
      .reciprocal_cell_matrix(1,2) = ZERO
      .reciprocal_cell_matrix(1,3) = ZERO
      .reciprocal_cell_matrix(2,1) = b*c*(ca*cb-cg)/sb/v
      .reciprocal_cell_matrix(2,2) = a*c*sb/v
      .reciprocal_cell_matrix(2,3) = a*b*(cb*cg-ca)/sb/v
      .reciprocal_cell_matrix(3,1) = -cb/a/sb
      .reciprocal_cell_matrix(3,2) = ZERO
      .reciprocal_cell_matrix(3,3) = ONE/c/sb
      .inverse_cell_matrix = transpose(.reciprocal_cell_matrix)
   end

   make_direct_U_cell_matrix
   ! Return the transformation matrix which changes the thermal tensor
   ! from the crystal axis system into the cartesian axis system.
   ! See comments for reciprocal_U_tensor_matrix below.
      DBL :: len
      INT :: i
      do i = 1,3
         len = .reciprocal_cell_matrix(:,i).norm
         .direct_U_cell_matrix(i,:) = len*.direct_cell_matrix(:,i)
      end
   end

   make_reciprocal_U_cell_matrix
   ! Return the transformation matrix which changes the thermal tensor
   ! from the cartesian axis system into the crystal axis system.
   ! The thermal tensor in the crystal axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where h are the Miller indices and a^* are the reciprocal lattice
   ! constants (in bohr^{-2}). This is as used by systems like Xtal.
   ! The thermal tensor in the cartesian axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -0.5 U_{ij} k_i k_j )
   ! where k = 2\pi B h, and B is the reciprocal_cell matrix.
      DBL :: len
      INT :: i
      do i = 1,3
         len = ONE/.reciprocal_cell_matrix(:,i).norm
         .reciprocal_U_cell_matrix(:,i) = .reciprocal_cell_matrix(:,i)*len
      end
   end

   change_geometry_from_crystal(g)
   ! Change the geometry array "g" from crystal fractional coordinates into
   ! standard cartesian coordiantes
      MAT :: g
      INT :: n,n_atom
      ENSURE(size(g,1)==3,"incorrect dimension for g")
      n_atom = size(g,2)
      do n = 1,n_atom
         g(:,n).rotate_by(.direct_cell_matrix)
      end
   end

   change_geometry_to_crystal(g)
   ! Change the geometry array "g" from standard cartesian coordinates into
   ! crystal fractional coordinates
      MAT :: g
      INT :: n,n_atom
      ENSURE(size(g,1)==3,"incorrect dimension for g")
      n_atom = size(g,2)
      do n = 1,n_atom
         g(:,n).rotate_by(.inverse_cell_matrix)
      end
   end

!  ************
!  Read methods
!  ************

   read(input) [leaky]
   ! Read an CRYSTAL object from file "input"
      TEXTFILE, target, optional :: input
      TEXTFILE, PTR :: in
      STR :: word
      if (present(input)) then; in => input
      else;                     in => stdin
      end
      .set_default
      read_loop : do
         in.read(word)
         word.to_lower_case
         select case (word)
            case("end");                     exit read_loop
            case("kind");                    .read_kind
            case("spacegroup_symbol");       .read_spacegroup_IT_symbol
            case("spacegroup_it_symbol");    .read_spacegroup_IT_symbol
            case("spacegroup_hall_symbol");  .read_spacegroup_Hall_symbol
            case("unit_cell_angles");        .read_unit_cell_angles
            case("cell_angles");             .read_unit_cell_angles
            case("unit_cell_lengths");       .read_unit_cell_lengths
            case("unit_cell_dimensions");    .read_unit_cell_lengths
            case("cell_lengths");            .read_unit_cell_lengths
            case("n_refl");                  .read_n_refl
            case("n_hkl");                   .read_n_refl
            case("no_of_reflections");       .read_n_refl
            case("reflection_indices");      .read_reflection_indices(in)
            case("reflection_data");         .read_reflection_data(in)
            case("apply_scale_factor");      .read_scale_factor
            case("make_F_predicted");        .make_F_predicted
            case("synthesize_sigma_i");      .read_synthesize_sigma_I
            case("use_scale_factor");        .read_use_scale_factor
            case("correct_extinction");      .read_correct_extinction
            case("correct_dispersion");      .read_correct_dispersion
            case("thermal_smearing_model");  .read_thermal_smearing_model
            case("partition_model");         .read_partition_model
            case("update_gof_parameters");   .update_gof_parameters
            case("erase_spacegroup");        .spacegroup.destroy_ptr_part
            case("destroy_spacegroup");      .spacegroup.destroy_ptr_part
            case("erase_reflection_data");   .destroy_reflection_data
            case("destroy_reflection_data"); .destroy_reflection_data
            case default;    DIE("unknown option, "// trim(word))
         end
      end do read_loop
      .update
   end

   update [leaky]
   ! Update the crystal information
      .spacegroup.analyse
      .make_cell_matrices
      if (.F_exp.created) .F_exp = .F_exp * .scale_factor
      if (.sigma.created) .sigma = .sigma * .scale_factor
      .scale_factor = ONE
   end

   read_kind
   ! Read the kind of crystal experiment
      stdin.read(.kind)
   end

   read_spacegroup_IT_symbol
   ! Read the spacegroup international table symbol
      .spacegroup.read_IT_symbol(stdin)
   end

   read_spacegroup_Hall_symbol
   ! Read the spacegroup Hall symbol
      .spacegroup.read_Hall_symbol(stdin)
   end

   read_unit_cell_angles
   ! Read the unit cell angles
      stdin.read(.unit_cell_angle)
   end

   read_unit_cell_lengths
   ! Read the unit cell axis lengths
      stdin.read(.unit_cell_length)
   end

   read_n_refl
   ! Read the number of reflection data
      stdin.read(.n_refl)
   end

   read_reflection_indices(in) [leaky]
   ! Read the hkl Miller index triples from the input
      TEXTFILE :: in
      INT :: i
      STR :: word
      ENSURE(.n_refl>0, "no reflections to read")
      ENSURE(.no_reflection_data, "hkl data already exists")
      .h.create(.n_refl)
      .k.create(.n_refl)
      .l.create(.n_refl)
      do i = 1,.n_refl
         in.read(.h(i))
         in.read(.k(i))
         in.read(.l(i))
      end
      in.read(word)            !  Expecting the end keyword
      word.to_lower_case
      ENSURE(trim(word) == "end", 'expecting "end" keyword')
   end

   read_reflection_data(in) [leaky]
   ! Read the hkl Miller index triple followed by the experimental structure
   ! factor and the experimental standard deviation
      TEXTFILE :: in
      INT :: i
      STR :: word
      ENSURE(.n_refl>0, "no reflections to read")
      ENSURE(.no_reflection_data, "hkl data already exists")
      .h.create(.n_refl)
      .k.create(.n_refl)
      .l.create(.n_refl)
      .F_exp.create(.n_refl); .F_exp = ZERO
      .sigma.create(.n_refl); .sigma = ZERO
      do i = 1,.n_refl
         in.read(.h(i))
         in.read(.k(i))
         in.read(.l(i))
         in.read(.F_exp(i))
         in.read(.sigma(i))
      end
      in.read(word)            !  Expecting the end keyword
      word.to_lower_case
      ENSURE(trim(word) == "end", 'expecting "end" keyword')
      ! Set defaults for predicting structure factors
      .use_scale_factor = TRUE
      .correct_extinction = TRUE
   end

   put_F_calc [leaky]
   ! Put the hkl Miller index triple followed by the calculated
   ! structure factor to add onto existing structure factors.
      INT :: i,h,k,l
      CDBL :: Fc
      ENSURE(.n_refl>0, "no reflections to put")
      ENSURE(.F_calc.created, "require F_calc")
      stdout.flush(2)
      do i = 1,.n_refl
         stdout.put(.h(i))
         stdout.put(.k(i))
         stdout.put(.l(i))
         stdout.put(.F_calc(i),flush=1)
      end
      stdout.flush(1)
   end

   add_F_calc [leaky]
   ! Read the hkl Miller index triple followed by the calculated
   ! structure factor to add onto the existing structure factors.
      INT :: i,h,k,l
      CDBL :: Fc
      STR :: word
      ENSURE(.n_refl>0, "no reflections to read")
      ENSURE(.F_calc.created, "require F_calc already")
      do i = 1,.n_refl
         stdin.read(h)
         stdin.read(k)
         stdin.read(l)
         stdin.read(Fc)
         .F_calc(i) = .F_calc(i) + Fc
      end
      stdin.read(word)            !  Expecting the end keyword
      word.to_lower_case
      ENSURE(trim(word) == "end", 'expecting "end" keyword')
      .make_F_predicted
   end

   read_scale_factor
   ! Read the structure factor multiplier
      stdin.read(.scale_factor)
   end 

   read_use_scale_factor
   ! Read the switch whether to use and overall scale factor to minimise
   ! the chi2 statistic when calculating the structure factors.
   ! NOTE: this is not the same at the overall .scale_factor which is applied
   ! to the experimental structure factors.
      stdin.read(.use_scale_factor)
   end

   read_synthesize_sigma_I
   ! Read the switch whether to artificially create sigma(I) errors when
   ! evaluating the chi2 statistics based on intensities. Refer to routine
   ! .I_sigma
      stdin.read(.synthesize_sigma_I)
   end

   read_correct_extinction
   ! Read the switch whether to correct extinction or not, according to the
   ! Larson formula
      stdin.read(.correct_extinction)
   end

   read_correct_dispersion
   ! Read the switch whether to correct dispersion or not, according to the
   ! atomic dispersion factors
      stdin.read(.correct_dispersion)
   end

   read_thermal_smearing_model
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      BIN :: allowed_model
      stdin.read(.thermal_smearing_model)
      .thermal_smearing_model.to_lower_case
      allowed_model = .thermal_smearing_model=="none"    OR &
                      .thermal_smearing_model==""        OR &
                      .thermal_smearing_model=="coppens" OR &
                      .thermal_smearing_model=="stewart" OR &
                      .thermal_smearing_model=="tanaka"
      ENSURE(allowed_model,"unknown thermal smearing model")
   end

   read_partition_model
   ! Read the partition model to used to correct for oversampled fragments
   ! of the unit cell when calculating the structure factors
      stdin.read(.partition_model)
   end

  lp_factor result(res)
  ! Return the array of the Lorentz Polarization factors for all the reflections
    VEC( .n_refl ) :: res
    MAT(3,3) :: rcm
    INT :: n
    DBL :: kx,ky,kz,stl,c,s,two_theta
    ENSURE(.n_refl>0,"no reflections entered")
    rcm = .reciprocal_cell_matrix
    do n=1, .n_refl
      kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
      ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
      kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
      stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)
      two_theta = TWO*asin( stl * .wavelength )
      c = cos(two_theta)
      s = sin(two_theta)
      if (s.is_zero(TOL(8))) then
         res(n) = ZERO
         WARN("lp_factor for (000) reflection set to zero")
      else
         res(n) = (1+c*c)/(TWO*s)
      end
    end
  end

  I_pred result(res)
  ! Return the array of predicted Intensities. Only the Lorentz Polarization 
  ! factor and the angular velocity factor for a single crystal are used. 
  ! Fundamental constants appearing in front of this are not calculated
  ! NOTE: unlike I_exp, these may include extinction and dispersion effects.
    VEC( .n_refl ) :: res
    MAT(3,3) :: rcm
    INT :: n
    DBL :: kx,ky,kz,stl,c,s,two_theta,F2
    ENSURE(.n_refl>0,"no reflections entered")
    ENSURE(.F_calc_exists, "no calculated structure factors")
    if (.no_F_pred) .make_F_predicted
    rcm = .reciprocal_cell_matrix
    do N=1, .n_refl
      kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
      ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
      kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
      stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)
      two_theta = TWO*asin( stl * .wavelength )
      c = cos(two_theta)
      s = sin(two_theta)
      F2 = .F_pred(n)
      F2 = F2*F2
      if (s.is_zero(TOL(8))) then
         res(n) = F2
      else
         res(n) = (1+c*c)/(TWO*s)*F2
      end
    end
  end

  I_exp result(res)
  ! Return the array of experimental Intensities. Only the Lorentz Polarization 
  ! factor and the angular velocity factor for a single crystal are used. 
  ! Fundamental constants appearing in front of this are not calculated
  ! NOTE: extinction factors, dispersion, multiple scattering corrections
  ! are not included. These are the experimental intensities with these effects
  ! removed.
    VEC( .n_refl ) :: res
    MAT(3,3) :: rcm
    INT :: n
    DBL :: kx,ky,kz,stl,c,s,two_theta,F2
    ENSURE(.n_refl>0,"no reflections entered")
    ENSURE(.F_exp_exists, "no experimental structure factors")
    rcm = .reciprocal_cell_matrix
    do N=1, .n_refl
      kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
      ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
      kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
      stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)
      two_theta = TWO*asin( stl * .wavelength )
      c = cos(two_theta)
      s = sin(two_theta)
      F2 = abs(.F_exp(n))
      F2 = F2*F2
      if (s.is_zero(TOL(8))) then
         res(n) = F2
      else
         res(n) = (1+c*c)/(TWO*s)*F2
      end
    end
  end

  I_sigma result(res)
  ! Return the array of experimental sigma's in the Intensities. 
    VEC( .n_refl ) :: res
    MAT(3,3) :: rcm
    INT :: n
    DBL :: kx,ky,kz,stl,c,s,two_theta,F2
    ENSURE(.n_refl>0,"no reflections entered")
    ENSURE(.F_exp_exists OR .F_calc_exists, "can't generate sigma")
    if (.no_F_exp AND NOT .synthesize_sigma_I) then
       WARN("The synthesize_sigma_I flag was not set; it is now set")
       .synthesize_sigma_I = TRUE
    end
    if (.synthesize_sigma_I) then
       res = .I_pred
       res = sqrt(res/.equivalence_factors)
    else
      rcm = .reciprocal_cell_matrix
      do N=1, .n_refl
        kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
        ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
        kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
        stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)
        two_theta = TWO*asin( stl * .wavelength )
        c = cos(two_theta)
        s = sin(two_theta)
        F2 = abs(.F_exp(n))
        if (s.is_zero(TOL(8))) then
           res(n) = F2
        else
           res(n) = TWO*(1+c*c)/(TWO*s)*F2
        end
      end
    end
  end

  update_gof_parameters
  ! Make the goodnes of fit parameters, "chi2", "R_factor", "gof",
  ! "scale_factor", for the scaled structure factors.
    DBL :: top1,top2,bot1,bot2
    DIE_IF( .no_F_exp, "no experimental structure factors")
    DIE_IF( .no_F_pred, "no predicted structure factors")
    .F_stats.n_param = 0
    if (.use_scale_factor)   .F_stats.n_param = .F_stats.n_param+1
    if (.correct_extinction) .F_stats.n_param = .F_stats.n_param+1
    .F_stats.set_data(.F_pred,.F_exp,.sigma)
  end

  equivalence_factors result (res)
  ! Return the equivalence factors, the number of distinct reflections
  ! which are symmetry equivalent to a particular (hkl) triple, for all
  ! the reflections.
     IVEC(.n_refl) :: res
     IVEC(3) :: hkl,new
     INT :: n,s,u
     ENSURE(.n_refl>0,"no reflections")
     do n = 1,.n_refl
        hkl = (/ .h(n),.k(n),.l(n) /)
        u = 1
        do s = 2,.spacegroup.n_seitz
           new = matmul(.spacegroup.seitz(1:3,1:3,s),hkl)
           if (hkl(1)/=new(1) OR hkl(2)/=new(2) OR hkl(3)/=new(3)) u = u + 1
        end
        res(n) = u
     end
  end

  make_F_predicted(use_scale_factor,correct_extinction) [recursive] [leaky]
  ! Return the predicted magnitude of the structure factors, including possibly
  ! an overall "scale_factor", and the possibility to "correct_extinction".
  ! NOTE: the optional arguments override the settings in the type.
     INOUT :: self
     BIN, optional :: use_scale_factor,correct_extinction
     VEC(.n_refl) :: res
     VEC, PTR :: ext
     BIN :: scale,extinction
     DBL :: fac
     ENSURE(.F_calc_exists, "no calculated structure factors")
     .F_pred.destroy
     scale      = .use_scale_factor
     extinction = .correct_extinction
     if (present(use_scale_factor))   scale      = use_scale_factor
     if (present(correct_extinction)) extinction = correct_extinction
     if (.no_F_exp) then
        scale = FALSE
        extinction = FALSE
     end
     .F_pred.destroy
     .F_pred.create(.n_refl)
     .F_stats.n_param = 0
     .F_pred = abs(.F_calc)
     if (scale AND extinction) then
        .F_stats.n_param = 2
        .F_stats.set_data(.F_pred,.F_exp,.sigma)
        fac = .F_stats.scale_factor
        ext.create(.n_refl)
        ext = .extinction_correction
        .F_pred = fac * .F_pred * ext
        ext.destroy
     else if (scale) then
        .F_stats.n_param = 1
        .F_stats.set_data(.F_pred,.F_exp,.sigma)
        fac = .F_stats.scale_factor
        .F_pred = fac * .F_pred
     else if (extinction) then
        .F_stats.n_param = 1
        ext.create(.n_refl)
        ext = .extinction_correction
        .F_pred =       .F_pred * ext
        ext.destroy
     end
  end

  extinction_correction result(res)
  ! Return the extinction corrections to the individual structure factors.
  ! NOTE: the extinction correction is optimised together with an overall
  ! scale factor, but this scale factor is not included in this routine.
    INOUT :: self
    VEC( .n_refl ) :: res
    VEC, PTR :: angle_part
    ENSURE(.F_calc_exists, "no calculated structure factors")
    angle_part.create( .n_refl )
    angle_part = .extinction_angle_part
    .get_extinction_parameters
    res(:) = (ONE + .ext_factor * .F_calc(:)*conjg(.F_calc(:)) * angle_part(:))**(-0.25d0)
    angle_part.destroy
  end

  extinction_angle_part result(res)
  ! Return the angular part of the extinciton correction.
    MAT(3,3) :: rcm
    VEC( .n_refl ) :: res
    INT :: n
    DBL :: kx,ky,kz,stl,twotheta, c,s
    rcm = .reciprocal_cell_matrix
    do n=1, .n_refl
      kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
      ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
      kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
      stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)
      twotheta=TWO*asin( stl * .wavelength )
      c = cos(twotheta)
      s = sin(twotheta)
      res(n) = (1+c*c)/(1+c*s)
    end
  end

  get_extinction_parameters
  ! Gets the g and x parameters of Larson's method.  Does not scale the
  ! structure factors.
  ! Larson, A. C., in <I>Crystallographic Computing</I> Ed. Ahmed, F. R.
  ! (Copenhagen, Munksgaard 1970), pp. 291-294.
    DBL :: ghigh,glow,gnew,dghigh,dgnew,dglow, scale_factor
    DBL :: xhigh,xlow,xnew,dxhigh,dxlow,dxnew,xprev,gprev
    VEC, PTR :: Fc
    INT :: j
    .ext_factor  = ZERO
    .F_stats.n_param = 2
    .make_F_predicted(correct_extinction=FALSE)
    .update_gof_parameters
    if (.F_stats.scale_factor < 0) then
      WARN("scale_factor < 0, extinction set to zero")
      RETURN
    end

    glow=HALF;    ghigh=TWO;     gprev=ZERO

    outer_loop : do
      do                                    ! get g which minimises dchi2/dg
        gnew=(glow+ghigh)/TWO
        scale_factor = gnew
        dgnew  = .dchidg(gnew, .ext_factor)
        if (abs(dgnew) <= 1E-8) exit
        dglow  = .dchidg(glow, .ext_factor)
        dghigh = .dchidg(ghigh, .ext_factor)
        .minimise_param(dglow,dghigh,dgnew,glow,ghigh,gnew)
      end

      if ( .dchidx(scale_factor, ZERO) > ZERO) then
         .make_F_predicted(correct_extinction=FALSE)
         scale_factor = .F_stats.scale_factor
         exit outer_loop
      end
      xlow=0
      do j=-15,0
        xhigh=TEN**(j-1)
        if (.dchidx(scale_factor, TEN**(j)) >= ZERO) then
          exit
        end
      end

      do                                    ! get x which minimises dchi2/dx
        xnew=(xlow+xhigh)/TWO
        .ext_factor=xnew
        dxnew  = .dchidx(scale_factor,xnew)
        if (abs(dxnew) <= ONE) exit
        dxlow  = .dchidx(scale_factor,xlow)
        dxhigh = .dchidx(scale_factor,xhigh)
        .minimise_param(dxlow,dxhigh,dxnew,xlow,xhigh,xnew)
        if (xnew >= ONE) then
          .make_F_predicted(correct_extinction=FALSE)
          scale_factor = .F_stats.scale_factor
          exit outer_loop
        end
      end

      if ((abs(xprev-xnew) <= abs(xnew*(1E-6))) AND (abs(gprev-gnew) <= abs(gnew*(1E-6)))) exit
      xprev=xnew
      gprev=gnew
    end do outer_loop
  end

  minimise_param(dlow,dhigh,dnew,low,high,new)
    DBL, IN :: dlow,dhigh,dnew,new
    DBL :: high,low
    if (dlow <= 0) then
      if (dhigh <= 0) then
        high=1.25d0*high
        low=high
      else if (dnew <= 0) then
        low=new
      else
        high=new
      end
    else
      low=0.75d0 * low
      high=new
    end
  end

  dchidg(gparam,xparam) result (res)
  ! Derivative of the chi^2 with respect to g.
  ! (c) Daniel Grimwood, UWA, April 1997
    DBL, IN :: gparam, xparam
    VEC, PTR :: Fc,angle_bit,Fexp,sig
    DBL :: res
    DBL :: factor,totalg,a,b
    INT :: j
    Fc.create(.n_refl)
    Fc = abs(.F_calc)
    angle_bit.create( .n_refl )
    angle_bit = .extinction_angle_part
    Fexp => .F_exp
    sig => .sigma
    totalg = ZERO
    do j = 1, .n_refl
      factor = ONE + xparam * Fc(j) * Fc(j) * angle_bit(j)
      a      = sqrt(factor)
      b      = sqrt(a)
      totalg = totalg + Fc(j) * (Fexp(j)/b - gparam * Fc(j)/a) / (sig(j)*sig(j))
    end
    res = totalg * (-TWO) / .n_refl
    angle_bit.destroy
    Fc.destroy
  end

  dchidx(gparam,xparam) result (res)
  ! Derivative of the chi^2 with respect to x.
  ! (c) Daniel Grimwood, UWA, April 1997
    DBL, IN :: gparam, xparam
    DBL :: res
    DBL :: Fc2,factor,totalx,a,b
    VEC, PTR :: Fc,angle_bit,Fexp,sig
    INT :: j
    Fc.create(.n_refl)
    Fc = abs(.F_calc)
    angle_bit.create( .n_refl )
    angle_bit = .extinction_angle_part
    Fexp => .F_exp;     sig => .sigma
    totalx = ZERO
    do j = 1, .n_refl
      Fc2    = Fc(j) * Fc(j)
      factor = ONE + xparam * Fc2 * angle_bit(j)
      a      = sqrt(factor)
      b      = sqrt(a)
      totalx = totalx + angle_bit(j)*Fc2*Fc(j) * (Fexp(j)/b-gparam*Fc(j)/a) / &
                  (factor*sig(j)*sig(j))
    end
    res= gparam * totalx / (TWO * .n_refl)
    angle_bit.destroy
    Fc.destroy
  end

   make_k_pts(res)
   ! Convert the hkl indices to reciprocal lattice vectors
   ! Dimension of res is [.n_refl,3]
      MAT :: res
      INT :: n
      MAT(3,3) :: rcm
      rcm = 2*PI*.reciprocal_cell_matrix
      do n = 1, .n_refl
         res(n,1) = rcm(1,1)*.h(n) + rcm(1,2)*.k(n) + rcm(1,3)*.l(n)
         res(n,2) = rcm(2,1)*.h(n) + rcm(2,2)*.k(n) + rcm(2,3)*.l(n)
         res(n,3) = rcm(3,1)*.h(n) + rcm(3,2)*.k(n) + rcm(3,3)*.l(n)
      end
   end

  unique_k_pts result(res) [pure]
    IN :: self
    INT :: res
    res = .n_unique_symops * .n_refl
  end

   make_unique_k_pts(k)
   ! Convert the hkl indices to unique reciprocal lattice vectors "k" required
   ! in the reduced crystal spacegroup
   ! (c) Dylan Jayatilaka, UWA, feb 1996
      MAT :: k
      INT :: p,u,n
      MAT(3,3) :: b,rcm
      ENSURE(.unique_symop.created,"unique_symop array does not exist")
      p = 0
      rcm = 2*PI*.reciprocal_cell_matrix
      do u = 1,.n_unique_symops
         b = matmul(rcm,.unique_symop_mat(u))
         do n = 1, .n_refl
            p = p + 1
            k(p,1) = b(1,1)*.h(n) + b(1,2)*.k(n) + b(1,3)*.l(n)
            k(p,2) = b(2,1)*.h(n) + b(2,2)*.k(n) + b(2,3)*.l(n)
            k(p,3) = b(3,1)*.h(n) + b(3,2)*.k(n) + b(3,3)*.l(n)
         end
      end
   end

!  *************************************
!  Service methods used by other modules
!  *************************************

   make_phases_for_symop(u,phase,mask)
   ! Return the sum of the "phase" shifts for each (hkl) reflection from each
   ! glide vector for all symops which are equivalent to the "u"-th
   ! unique symmetry operation, .unique_symop(u), as determined by the mask
   ! array.
      INT, IN :: u
      CVEC, OUT :: phase
      IVEC, IN :: mask
      DBL :: pi2,tx,ty,tz
      INT :: s
      ENSURE( .unique_symop.created,"Unique symop analysis not yet done")
      ENSURE( u<=.n_unique_symops,"symop index out of range")
      ENSURE( size(phase)==.n_refl,"wrong length for phase array")
      pi2 = TWO*PI
      phase = ZERO
      do s = 1,.spacegroup.n_seitz
         if (mask(s)/=.unique_symop(u)) cycle
         tx = pi2*.spacegroup.seitz(4,1,s)
         ty = pi2*.spacegroup.seitz(4,2,s)
         tz = pi2*.spacegroup.seitz(4,3,s)
         phase(:) = phase(:) + exp(cmplx(ZERO,.h(:)*tx+.k(:)*ty+.l(:)*tz))
      end
   end

   sum_unique_sf(sf,unique_sf)
   ! Form the structure factors "sf" from the sum of the list of
   ! unique structure factors, "unique_sf".
      CVEC :: sf
      CVEC, IN :: unique_sf
      CVEC, PTR :: phase
      INT :: u,uf,ul
      ENSURE( size(sf)==.n_refl,"incorrect size for array sf")
      phase.create(.n_refl)
      sf = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)+1
         ul = .n_refl*u
         .make_phases_for_symop(u,phase,.translated_symop)
         sf(:) = sf(:) + phase(:)*unique_sf(uf:ul)
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         sf(:) = sf(:) + phase(:)*conjg(unique_sf(uf:ul))
      end
      phase.destroy
   end

   sum_unique_sf_ints(sf_ints,unique_sf_ints)
   ! Form the structure factor integrals "sf_ints" from a sum of the list
   ! of unique structure factors integrals  "unique_sf_ints".
      CMAT3 :: sf_ints
      CMAT3, IN :: unique_sf_ints
      CVEC, PTR :: phase
      INT :: u,uf,n
      ENSURE( size(sf_ints,1)==.n_refl,"incorrect size for array sf_ints")
      phase.create(.n_refl)
      sf_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*unique_sf_ints(uf+n,:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*conjg(unique_sf_ints(uf+n,:,:))
         end
      end
      phase.destroy
   end

   sum_unique_sf_deriv_U(sf,unique_sf)
   ! Form the structure factor derivatives "sf" (wrt the thermal paramaters,U)
   !  from a sum of the list of unique structure factor derivatives "unique_sf".
      CMAT :: sf
      CMAT, IN :: unique_sf
      CVEC, PTR :: phase
      INT :: u,uf, n
      ENSURE( size(sf,1)==.n_refl,"incorrect size for array sf")
      phase.create(.n_refl)
      sf = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         sf(n,:) = sf(n,:) + phase(n)*unique_sf(uf+n,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         sf(n,:) = sf(n,:) + phase(n)*conjg(unique_sf(uf+n,:))
         end
      end
      phase.destroy
   end

   sum_ft_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints" from a sum of the list
   ! of unique integrals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b].
      CMAT3 :: ft_ints
      CMAT3, IN :: unique_ft_ints
      CVEC, PTR :: phase
      INT :: u,uf, n
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*unique_ft_ints(uf+n,:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*conjg(unique_ft_ints(uf+n,:,:))
         end
      end
      phase.destroy
   end

   sum_ft_spin_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints", required for the spin
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b,3,3].
      CMAT5 :: ft_ints
      CMAT3, IN :: unique_ft_ints
      CVEC, PTR :: phase
      MAT, PTR :: q
      CMAT, PTR :: ints
      INT :: u,uf, n
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      q.create(.n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3))
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:)
            ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
            ints = phase(n)*conjg(unique_ft_ints(uf+n,:,:))
            ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
         end
      end
      ints.destroy
      ! The factor of two for conversion to Bohr magnetons cancels the
      ! factor of half for the S operator
      do n = 1, .n_refl
          ft_ints(n,:,:,:,:) = -ft_ints(n,:,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

   sum_ft_r_ints(ft_ints,unique_ft_ints,B)
   ! Form the Fourier transform dipole integrals "ft_ints", required for the PND
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  "B" is the external magnetic field.
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Dimensions of ft are [.n_refl,n_comp_a,n_comp_b,3].
      CMAT4 :: ft_ints
      CMAT4, IN :: unique_ft_ints
      VEC(3) :: B
      CVEC, PTR :: phase
      MAT, PTR :: q
      CMAT3, PTR :: ints
      INT :: u,uf, n
      CDBL :: ci
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      q.create(.n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3),3)
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                                - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                                - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                                - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                                - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                                - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                                - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
         end
      end
      ints.destroy
     ! The factor of two for conversion to Bohr magnetons cancels the
     ! factor of half for the S operator
      ci = (ZERO,ONE)
      do n = 1, .n_refl
          ft_ints(n,:,:,:) = -ci*ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

   sum_ft_nabla_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform nabla_a integrals "ft_ints", required for the
   ! PND magnetic striucture factors, from a sum of "unique_ft_ints".
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Note: the complex conjugate nabla_b integrals are not included.
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
      CMAT4 :: ft_ints
      CMAT4, IN :: unique_ft_ints
      CVEC, PTR :: phase
      MAT, PTR :: q
      CMAT3, PTR :: ints
      INT :: u,uf, n
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      q.create(.n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3),3)
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
      end
      ints.destroy
      ! The factor of 2 to convert to Bohr magnetons cancels the factor
      ! of 1/2 for the Bohr magneton
      ! Extra minus sign introduced, but not sure why ...
      ! Reversed minus sign introduced ...
      do n = 1, .n_refl
          ft_ints(n,:,:,:) =  ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

   sum_ft_j_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform j integrals "ft_ints", required for the PND
   ! magnetic striucture factors, from a sum of "unique_ft_ints".
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Note: the complex conjugate nabla_b integrals are not included.
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
      CMAT4 :: ft_ints
      CMAT4, IN :: unique_ft_ints
      CVEC, PTR :: phase
      INT :: u,uf, n
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:,:) = ft_ints(n,:,:,:) + phase(n)*unique_ft_ints(uf+n,:,:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:,:) = ft_ints(n,:,:,:) - phase(n)*conjg(unique_ft_ints(uf+n,:,:,:))
         end
      end
      phase.destroy
   end

! ***********************************
! Operations on atomvecs in a crystal
! ***********************************

  generate_unique_symop_list(list)
  ! Returns a list of which seitz matrices generate unique molecules.
  ! Usefull when the molecule is on a special position.
    IN :: self
    BINVEC, OUT :: list
    MAT, PTR :: pos1,pos2
    BINVEC, PTR :: matched
    BIN :: same
    INT :: s1,s2,n,q

    ENSURE(size(list) == .spacegroup.n_seitz, "symop list not correct size")
    pos1.create(3,.n_fragment_atoms)
    pos2.create(3,.n_fragment_atoms)
    matched.create(.n_fragment_atoms)

    do s1=1,.spacegroup.n_seitz
      pos1 = .fragment_geometry
      .move_to_unit_cell(pos1)
      .transform_geometry(pos1,s1)
      .move_to_unit_cell(pos1)
      same = FALSE
      do s2=1,s1-1
        pos2 = .fragment_geometry
        .move_to_unit_cell(pos2)
        .transform_geometry(pos2,s2)
        .move_to_unit_cell(pos2)
        matched = FALSE
        do n = 1, .n_fragment_atoms
          do q = 1, .n_fragment_atoms
            same = pos2(:,n).same_as(pos1(:,q), TOL(3))
            if (same) then
              matched(q) = TRUE
              exit
            end
          end
          if (NOT same) exit   ! atom q doesn't have a match.
        end
        same = all(matched)    ! They are the same if all have a match.
        if (same) exit
      end
      list(s1) = NOT same
    end

    matched.destroy
    pos2.destroy
    pos1.destroy
  end

  create_closest_molecule_list(op_list,dist_list,position,distance_max) [leaky]
  ! Creates a list of the symmetry operations and translations of the molecules
  ! which are within max_distance of the centre of the molecule.
  ! If "position" is specified, it is used instead of the centre of the
  ! molecule.
    IMAT, PTR :: op_list
    VEC, PTR :: dist_list
    VEC, IN :: position
    DBL, optional :: distance_max
    MAT, PTR :: pos1,pos2,pos3
    BINVEC, PTR :: unique_symop_list
    VEC(3) :: centre,diff
    IVEC(3) :: offset
    INT :: n,s,h,k,l,d_h,d_k,d_l,q,maxnum
    DBL :: distance,dist,max_distance,max_cell_distance,a,b,c

    unique_symop_list.create(.spacegroup.n_seitz)
    .generate_unique_symop_list(unique_symop_list)

    max_distance = 10d0
    if (present(distance_max)) max_distance = distance_max

    a = .unit_cell_length(1)
    b = .unit_cell_length(2)
    c = .unit_cell_length(3)
    max_cell_distance = max_distance + a + b + c
    maxnum = unique_symop_list.n_true * &
                              (ceiling(max_cell_distance/min(a,b,c)))**3

    dist_list.create(maxnum)
    op_list.create(4,maxnum)

    pos1.create(3,.n_fragment_atoms)
    pos2.create(3,.n_fragment_atoms)
    pos3.create(3,.n_fragment_atoms)
    pos1 = .fragment_geometry
    .move_to_unit_cell(pos1)

    centre = position                        ! Center of the cluster
    centre.rotate_by(.inverse_cell_matrix)
    offset = floor(centre+0.001d0)           ! hkl offset of cluster
    ! We work with the 0,0,0 cell as the center of the cluster, then translate
    ! by the offset.
    centre = position - offset

    q = 0
    do s = 1, .spacegroup.n_seitz
      if (NOT unique_symop_list(s)) cycle
      pos2 = pos1
      .transform_geometry(pos2,s)

      d_h = ceiling(max_cell_distance/a)
      do h = -d_h,+d_h
        d_k = ceiling((max_cell_distance-abs(h)*a)/b)
        do k = -d_k,+d_k
          d_l = ceiling((max_cell_distance-abs(h)*a-abs(k)*b)/c)
          do l = -d_l,+d_l
            do n=1,.n_fragment_atoms
              pos3(:,n) = pos2(:,n) + (/h,k,l/)      ! Translate through lattice
            end
            .change_geometry_from_crystal(pos3)      ! Put in cartesians.
            diff = pos3(:,1) - centre
            distance = dot_product(diff,diff)
            do n=2,.n_fragment_atoms
              diff = pos3(:,n) - centre
              dist = dot_product(diff,diff)
              if (dist<distance) distance=dist
            end
            if (distance < TOL(6)) distance = ZERO
            distance = sqrt(distance)
            if (distance < max_distance) then
              q = q + 1; dist_list(q) = distance
              op_list(:,q) = (/s,h,k,l/)
            end
          end
        end
      end
    end

    do n=1,q
      op_list(2:4,n) = op_list(2:4,n) + offset       ! Translate cluster to
    end                                              ! correct cell.

    if (q==0) then ! None within required distance.
      dist_list.shrink(1);               dist_list = ZERO
      op_list.shrink(4,1);               op_list = 0
    else
      ! Truncate the lists.
      dist_list.shrink(q)
      op_list.shrink(4,q)

      ! Sort by distance.
      do k = 1, q
       do l = k, q
        if (dist_list(l) < dist_list(k)) then
          op_list.swap_columns(k,l)
          dist_list.swap_elements(k,l)
        end
       end
      end
    end

    unique_symop_list.destroy
  end

!  *****************************************
!  Reduced group, Unique operators, Z number
!  *****************************************

   make_reduced_group_data(atom) [leaky]
   ! The reduced group are those unique seitz operators which are needed to
   ! generate the complete ".unit_cell_geometry" from the atom fragment "atom".
   ! Some of these symmetry operations may only lead to geometries which are
   ! inversions of, or translations of, other operations in the reduced group.
   ! This information is also worked out here, and it can be used to save work
   ! in structure factor calculations.
      ATOMVEC :: atom
      .n_fragment_atoms = size(atom)
      .fragment_geometry.create(3,.n_fragment_atoms)
      atom.get_geometry(.fragment_geometry)
      .change_geometry_to_crystal(.fragment_geometry)
      .make_reduced_symops
      .make_inverted_symops
      .make_translated_symops
      .make_unique_symops
      .make_unique_atoms
      .make_unit_cell_geometry
      .make_repetition_factors
      .Z = .z_factor(atom)
   end

   z_factor(atom) result (res)
   ! The Z crystallographic factor for ".fragment_geometry", defined as the
   ! ratio of the number of electrons in the unit cell on the number of
   ! electrons in the fragment. Hence, we require information for each "atom" in
   ! the fragment.
      ATOMVEC :: atom
      DBL :: res,u,f
      INT :: n,a
      ENSURE(.reduced_symop.created,"no reduced_symop array")
      ENSURE(.fragment_atom_for.created,"no reduced_symop array")
      u = ZERO
      do n = 1,.n_unit_cell_atoms
         a = .fragment_atom_for(n)
         u = u + atom(a).atomic_number
      end
      f = ZERO
      do n = 1,.n_fragment_atoms
         f = f + atom(n).atomic_number
      end
      res = u/f
   end

   make_reduced_symops [leaky]
   ! Make a list of the indices of the Seitz matrices, ".reduced_symop",
   ! which will generate distinctly different geometries from that in
   ! ".fragment_geometry". ".n_reduced_symops" is set to the number of
   ! reduced symmetry operations.
      MAT, PTR  :: gi,gu
      INT :: i,j,u, n
      BIN :: identical
      gi.create(3,.n_fragment_atoms)
      gu.create(3,.n_fragment_atoms)
      .reduced_symop.create(.spacegroup.n_seitz)
      n = 1
      .reduced_symop(1) = 1
      do i = 2,.spacegroup.n_seitz
         do j = 1,n                            ! Loop over reduced symops
            gi = .fragment_geometry
            gu = .fragment_geometry
            u = .reduced_symop(j)
            .transform_geometry(gi,i,to_unit_cell=TRUE)
            .transform_geometry(gu,u,to_unit_cell=TRUE)
            identical  = .is_same_geometry(gi,gu)
            if (identical) exit
         end
         if (NOT identical) then
            n = n + 1
            .reduced_symop(n) = i
         end
      end
      .n_reduced_symops = n
      .reduced_symop.shrink(n)
      gu.destroy
      gi.destroy
   end

   make_inverted_symops [leaky]
   ! Determine which of the reduced symops can generate geometries from
   ! ".fragment cell_geometry" which are related by inversion.
      INT :: n,i,j
      BIN :: inverted
      ENSURE(.reduced_symop.created,"no reduced_symop array")
      .inverted_symop.create(.spacegroup.n_seitz)
      .inverted_symop = 0
      n = 0
      do i = 2,.spacegroup.n_seitz
         do j = 1,i-1
            inverted = .spacegroup.seitz(1:3,1:3,i).equals( &
                      -.spacegroup.seitz(1:3,1:3,j) )
            if (inverted) then
               n = n + 1
               .inverted_symop(i) = j
               exit
            end
         end
      end
      .n_inverted_symops = n
   end

   make_translated_symops [leaky]
   ! Determine which of the reduced symops can generate geometries from
   ! ".fragment cell_geometry" which are related by translation, (including
   ! translation by the zero vector), but not inversion
      INT :: i,j
      BIN :: translated
      ENSURE(.inverted_symop.created,"no inverted_symop array")
      .translated_symop.create(.spacegroup.n_seitz)
      .translated_symop = 0
      do i = 1,.spacegroup.n_seitz
         .translated_symop(i) = i
         if (.inverted_symop(i)>0) cycle
         do j = 1,i-1
            translated = .spacegroup.seitz(1:3,1:3,i).equals( &
                         .spacegroup.seitz(1:3,1:3,j) )
            if (translated) then
               .translated_symop(i) = j
               exit
            end
         end
      end
   end

   make_unique_symops [leaky]
   ! Determine which are the unique symops (independent of inversion and
   ! translation) which are a subset of the reduced symops.
      INT :: n,i
      ENSURE(.inverted_symop.created,  "no inverted_symop array")
      ENSURE(.translated_symop.created,"no translated_symop array")
      n = 0
      do i = 1,.spacegroup.n_seitz
         if (.inverted_symop(i)>0) cycle
         if (.translated_symop(i)<i) cycle ! Only true translations count
         n = n + 1
      end
      .n_unique_symops = n
      .unique_symop.create(n)
      n = 0
      do i = 1,.spacegroup.n_seitz
         if (.inverted_symop(i)>0) cycle
         if (.translated_symop(i)<i) cycle
         n = n + 1
         .unique_symop(n) = i
      end
   end

   is_same_geometry(geom_i,geom_j) result(res)
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional
   ! coordinates are the same, exactly.
      MAT :: geom_i,geom_j
      BIN :: res
      INT :: i,j,n_atom
      BIN :: same
      BINVEC, PTR :: skip
      n_atom = size(geom_i,2)
      ENSURE(.spacegroup.seitz.created, "Seitz matrices not initialised")
      ENSURE(size(geom_i,1)==3, "incorrect size for array geom_i")
      ENSURE(size(geom_j,1)==3, "incorrect size for array geom_j")
      ENSURE(n_atom==size(geom_j,2), "incompatible sizes for geom_i, geom_j")
      skip.create(n_atom); skip(:) = FALSE
      do i = 1,n_atom
         do j = 1,n_atom
            same = geom_i(:,i).same_as(geom_j(:,j), TOL(3))
            if (NOT same OR skip(j)) cycle
            skip(j) = TRUE
            exit
         end
      end
      res = all(skip) ! True if all atoms in i were matched (skipped) in j
      skip.destroy
   end

   make_unique_atoms [leaky]
   ! Make the asymmetric unit atoms for the ".fragment_geometry".
      MAT, PTR :: geometry
      VEC(3) :: pa
      INT :: u,a,s,col
      BIN :: found
      ENSURE(.fragment_geometry.created, "no fragment_geometry")
      .unique_atom_for.create(.n_fragment_atoms)
      .unique_atom_for    = 0
      .unique_atom_for(1) = 1
      .unique_atom.create(1)
      .unique_atom(1) = 1
      geometry.create(3,.n_fragment_atoms)
      geometry = .fragment_geometry
      .put_to_unit_cell(geometry)
      u = 1
      do a = 2,.n_fragment_atoms
         found = FALSE
         do s = 1,.spacegroup.n_seitz
            pa = geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)
            found = geometry(:,.unique_atom).has_column(pa,TOL(3),col)
            if (.unique_atom_for(a)==0 AND found) then
               .unique_atom_for(a) = col
               exit
            end
         end
         if (NOT found) then
            u = u + 1
            .unique_atom_for(a) = u
            .unique_atom.expand(u)
            .unique_atom(u) = a
         end
      end
      .n_unique_unit_cell_atoms = u
      geometry.destroy
   end

   make_unit_cell_geometry [leaky]
   ! Get the all the atom positions in the unit cell, ".unit_cell_geometry",
   ! given a (possibly) partial or overcomplete set for the cell in array
   ! ".fragment_geometry".
      VEC(3) :: pa
      INT :: n,a,s
      BIN :: found
      ENSURE(.fragment_geometry.created, "no fragment geometry")
      .fragment_atom_for.create(1)
      .fragment_atom_for(1) = 1
      .unit_cell_geometry.create(3,1)
      pa = .fragment_geometry(:,1)
      .put_to_unit_cell(pa)
      .unit_cell_geometry(:,1) = pa
      n = 1
      do a = 1,.n_fragment_atoms
         do s = 1,.spacegroup.n_seitz
            pa = .fragment_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)
            found = .unit_cell_geometry.has_column(pa,TOL(3))
            if (NOT found) then
               n = n + 1
               .fragment_atom_for.expand(n)
               .fragment_atom_for(n) = a
               .unit_cell_geometry.expand(3,n)
               .unit_cell_geometry(:,n) = pa
            end
         end
      end
      .n_unit_cell_atoms = n
   end

   make_repetition_factors [leaky]
   ! The number of times an atom with index "a" in mapped into itself under
   ! the reduced group is the ".repetition_factor(a)". It is used to correct
   ! structure factors for fragment geometries which are "oversampled" relative
   ! to the asymmetric cell geometry.
      VEC(3)  :: pa,pb
      INT :: a,b,n,n_same
      BIN :: same
      ENSURE(.reduced_symop.created, "Unique symops not analysed!")
      .repetition_factor.create(.n_fragment_atoms)
      do a = 1,.n_fragment_atoms
         pa = .fragment_geometry(:,a)
         .put_to_unit_cell(pa)
         n_same = 0
         do b = 1,.n_fragment_atoms
         do n = 1,.spacegroup.n_seitz
            pb = .fragment_geometry(:,b)
            .transform_position(pb,n,to_unit_cell=TRUE)
            same = pa.same_as(pb,TOL(3))
            if (same) n_same = n_same + 1
         end
         end
         .repetition_factor(a) = n_same
      end
   end

   transform_geometry(g,op,ignore_glide,to_unit_cell)
   ! Transform the geometry "g" in fractional coordinates with the
   ! Seitz operator with index "op". If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translated fractional
   ! coordinates into the (1,1,1) unit cell.
      MAT :: g
      INT :: op
      BIN, optional :: ignore_glide,to_unit_cell
      INT :: n,n_atom,n_seitz
      n_atom = size(g,2)
      n_seitz = .spacegroup.n_seitz
      ENSURE( size(g,1)==3, "incorrect size for array g")
      do n = 1,n_atom
         .transform_position(g(:,n),op,ignore_glide,to_unit_cell)
      end
   end

   transform_position(p,op,ignore_glide,to_unit_cell)
   ! Transform the position "p" in fractional coordinates with the
   ! Seitz operator with index "op". If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translated fractional
   ! coordinates into the (1,1,1) unit cell.
      VEC(3) :: p
      INT :: op
      BIN, optional :: ignore_glide,to_unit_cell
      BIN :: ignore,to_cell
      INT :: n_seitz
      n_seitz = .spacegroup.n_seitz
      ENSURE( op>0,        "operator index out of bounds")
      ENSURE( op<=n_seitz, "operator index out of bounds")
      ignore = FALSE
      if (present(ignore_glide)) ignore = ignore_glide
      if (ignore) then
        p = matmul(p,.spacegroup.seitz(1:3,1:3,op))
      else
        p = matmul(p,.spacegroup.seitz(1:3,1:3,op)) + .spacegroup.seitz(4,1:3,op)
      end
      to_cell = FALSE
      if (present(to_unit_cell)) to_cell = to_unit_cell
      if (to_cell) .put_to_unit_cell(p)
   end

   put_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell.  All atoms will be shifted into the first unit cell
   ! independently, so the resulting geometry may not reflect the shape of the
   ! original molecule.
      MAT :: g
      INT :: n,n_atom
      ENSURE( size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      do n = 1,n_atom
         .put_to_unit_cell(g(:,n))
      end
   end

   put_to_unit_cell(p)
   ! Transform the position "p" in fractional coordinates into the
   ! (1,1,1) unit cell.
      VEC(3) :: p
      ENSURE( size(p)==3, "incorrect size for position vector p")
      p(:) = mod(p(:)+TWO+0.001d0,ONE) - 0.001d0
   end

   move_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the first
   ! lattice cell.  The shape of the molecule remains intact, so some of it
   ! may cross into other cells.  The center of the molecule will be in the
   ! first cell.
      MAT :: g
      INT :: n,n_atom
      IVEC(3) :: centre
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      centre = .unit_cell_offset(g)
      do n = 1, n_atom
        g(:,n) = g(:,n) - centre
      end
   end

   unit_cell_offset(g) result(res)
   ! Which hkl indices match the centre of the fragment.
   ! Usually it's 0,0,0 but not always
      MAT :: g
      INT :: n,n_atom
      IVEC(3) :: res
      VEC(3) :: centre
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      .change_geometry_from_crystal(g)
      centre =  0.001d0
      do n = 1, n_atom
        centre = centre + g(:,n)
      end
      centre.rotate_by(.inverse_cell_matrix)
      res = floor(centre / n_atom)
      .change_geometry_to_crystal(g)
   end

   reduced_symop_mat(r) result (res)
   ! Return the "r"-th reduced symop matrix in the unique list made by routine
   ! ".make_reduced_symops".
      MAT(3,3) :: res
      INT :: r
      ENSURE( .reduced_symop.created,"Unique symop analysis not yet done")
      ENSURE( r<=.n_reduced_symops,"symop index out of range")
      ENSURE( r>0, "symop index out of range")
      res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
   end

   unique_symop_mat(u) result (res)
   ! Return the "u"-th reduced symop matrix in the unique list made by routine
   ! ".make_reduced_symops".
      MAT(3,3) :: res
      INT :: u,r
      ENSURE( .unique_symop.created,"Unique symop analysis not yet done")
      ENSURE( u<=.n_unique_symops,"symop index out of range")
      ENSURE( u>0,"symop index out of range")
      r = .unique_symop(u)
      res = .spacegroup.seitz(1:3,1:3,r)
   !  res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
   end

!  **************
!  Output methods
!  **************

   put(atom)
   ! Put out the crystal data to stdout
      ATOMVEC, optional :: atom
     .put(stdout,atom)
   end

   put(out,atom)
   ! Put out the crystal data to file "out"
      ATOMVEC, optional :: atom
      TEXTFILE, PTR :: out
      out.flush
      out.text("CRYSTAL information:")
      out.show("kind                        =", .kind)
      .put_unitcell_data(out)
      .spacegroup.put(out)
      if (.fragment_data_exists)   .put_fragment_data(out,atom)
      if (.reflection_data_exists) .put_reflection_data(out)
   end

   put_unitcell_data(out)
   ! Put unitcell information to file "out"
      TEXTFILE :: out
      out.flush
      out.text("Crystal unitcell information:",flush=2)
      out.show("alpha angle(rad)       = ",.unit_cell_angle(1))
      out.show("beta  angle(rad)       = ",.unit_cell_angle(2))
      out.show("gamma angle(rad)       = ",.unit_cell_angle(3))
      out.show("a cell parameter(bohr) = ",.unit_cell_length(1))
      out.show("b cell parameter(bohr) = ",.unit_cell_length(2))
      out.show("c cell parameter(bohr) = ",.unit_cell_length(3))
      out.show("cell volume(bohr^3)    = ",.unit_cell_volume)
      out.flush
      out.text("Direct cell matrix/bohr:")
      out.put(.direct_cell_matrix)
      out.flush
      out.text("Reciprocal cell matrix/(bohr^{-1}):")
      out.put(.reciprocal_cell_matrix)
      out.flush
   end

   put_fragment_data(out,atom)
   ! Put fragment information to file "out". Optional "atom" list may
   ! be used to enhace output.
      TEXTFILE :: out
      ATOMVEC, optional :: atom
      out.flush
      out.text("Crystal cell-fragment data:")
      out.flush
      out.show("Fragment partition model      = ",.partition_model)
      out.show("Thermal smearing model        = ",.thermal_smearing_model)
      out.show("No. of inputted atoms         = ",.n_fragment_atoms,dbl_width=TRUE)
      out.show("No. of unit cell atoms        = ",.n_unit_cell_atoms,dbl_width=TRUE)
      out.show("No. of unique unit cell atoms = ",.n_unique_unit_cell_atoms,dbl_width=TRUE)
      out.show("Z factor                      = ",.Z)
      .put_reduced_symop_data(out)
      .put_inv_trans_symop_data(out)
      if (present(atom)) then
        .put_fragment_geometry(out,atom)
        .put_asymmetric_unit_geometry(out,atom)
        .put_unit_cell_geometry(out,atom)
        .put_repetition_factors(out,atom)
      end
   end

   put_reduced_symop_data(out)
   ! Put out the reduced symop data
      TEXTFILE :: out
      INT :: n,s
      BIN :: inverted,translated
      ENSURE(.fragment_geometry.created,"no fragment_geometry array")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array")
      out.flush
      out.text("Crystal fragment reduced group information:")
      out.flush
      out.text("NOTE: this table is NOT used any more in structure factor calculations")
      out.flush
      out.dash(int_fields=5)
      out.put("Reduced",int_width=TRUE)
      out.put("Seitz",int_width=TRUE)
      out.put("Inv.",int_width=TRUE)
      out.put("Trans.",int_width=TRUE)
      out.flush
      out.put("Symop",int_width=TRUE)
      out.put("Symop",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("Unique?",int_width=TRUE)
      out.flush
      out.dash(int_fields=5)
      do n = 1,.n_reduced_symops
         out.put(n)
         s = .reduced_symop(n)
         out.put(s)
         inverted = .inverted_symop(s)>0
         if (inverted) then;   out.put(.inverted_symop(s))
         else;                 out.tab(int_fields=1)
         end
         translated = .translated_symop(s)<n
         out.put(.translated_symop(s))
         if (inverted OR translated) then; out.put("No",int_width=TRUE)
         else;                             out.put("Yes",int_width=TRUE)
         end
         out.flush
      end
      out.dash(int_fields=5)
   end

   put_inv_trans_symop_data(out)
   ! Put out the inverted translated symop data
      TEXTFILE :: out
      INT :: n,s
      BIN :: inverted,translated
      ENSURE(.fragment_geometry.created,"no fragment_geometry array")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array")
      out.flush
      out.text("Crystal Inversion/Translation related symop information:")
      out.flush
      out.text("NOTE: this table is used in structure factor calculations")
      out.flush
      out.dash(int_fields=4)
      out.put("Seitz",int_width=TRUE)
      out.put("Inv.",int_width=TRUE)
      out.put("Trans.",int_width=TRUE)
      out.flush
      out.put("Symop",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("Unique?",int_width=TRUE)
      out.flush
      out.dash(int_fields=4)
      do n = 1,.spacegroup.n_seitz
         out.put(n)
         inverted = .inverted_symop(n)>0
         if (inverted) then;   out.put(.inverted_symop(n))
         else;                 out.tab(int_fields=1)
         end
         translated = .translated_symop(n)<n
         out.put(.translated_symop(n))
         if (inverted OR translated) then; out.put("No",int_width=TRUE)
         else;                             out.put("Yes",int_width=TRUE)
         end
         out.flush
      end
      out.dash(int_fields=4)
   end

   put_fragment_geometry(out,atom)
   ! Put out the cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      STR :: symbol
      INT :: n
      ENSURE(.fragment_geometry.created,"no fragment_geometry array")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array")
      out.flush
      out.text("Crystal fragment cell geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Fragment",int_width=TRUE)
      out.put("Unique",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do n = 1,.n_fragment_atoms
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.unique_atom_for(n))
         out.put(.fragment_geometry(1,n))
         out.put(.fragment_geometry(2,n))
         out.put(.fragment_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_asymmetric_unit_geometry(out,atom)
   ! Put out the asymmetric unit cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,u
      STR :: symbol
      ENSURE(.fragment_geometry.created,"no fragment geometry")
      ENSURE(.unique_atom.created,"no unique_atoms array")
      out.flush
      out.text("Crystal asymmetric unit geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Unique",int_width=TRUE)
      out.put("Fragment",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do u = 1,.n_unique_unit_cell_atoms
         out.put(u)
         n = .unique_atom(u)
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.fragment_geometry(1,n))
         out.put(.fragment_geometry(2,n))
         out.put(.fragment_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_unit_cell_geometry(out,atom)
   ! Put out the full unit cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,f
      STR :: symbol
      out.flush
      out.text("Full unit cell geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Cell ",int_width=TRUE)
      out.put("Fragment",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do n = 1,.n_unit_cell_atoms
         out.put(n)
         f = .fragment_atom_for(n)
         symbol = atom(f).chemical_symbol.trim // " (" // f.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.unit_cell_geometry(1,n))
         out.put(.unit_cell_geometry(2,n))
         out.put(.unit_cell_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_repetition_factors(out,atom)
   ! Put out the repetition factors
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,rf
      STR :: symbol
      out.flush
      out.text("Crystal fragment atom repetition factors:")
      out.flush
      out.dash(int_fields=2)
      out.put("Fragment",int_width=TRUE)
      out.put("Rep.",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Factor",int_width=TRUE)
      out.flush
      out.dash(int_fields=2)
      do n = 1,.n_fragment_atoms
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         rf = .repetition_factor(n)
         out.put(rf)
         out.flush
      end
      out.dash(int_fields=2)
   end

   put_stats
   ! Output the goodness of fit data to stdout
     .put(.F_stats,stdout)
   end

   put(stats,out)
   ! Output the goodness of fit statistics to file "out"
      PAIRSTATISTICS, IN :: stats
      TEXTFILE :: out
      RETURN_IF(.no_F_calc OR .no_F_exp)
      .update_gof_parameters
      stats.put(out)
      .put_extinction_data(out)
   end

   put_extinction_data(out)
   ! Output the extinctiondata to file "out"
      TEXTFILE :: out
      out.flush
      if (.correct_extinction) then;
         out.show("Secondary extinction factor =", .ext_factor)
      else
         out.show("Correct extinction?         =", FALSE)
      end
!      out.show("Correct dispersion?         =", .correct_dispersion)
   end

   put_reflection_data(output) [leaky]
   ! Output the reflection data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      if (.F_calc_exists AND .F_exp_exists) then
         .put_structure_factor_data(output)
         .put_intensity_data(output)
      else if (.F_calc_exists) then
         .put_F_pred_data(output)
         .put_I_pred_data(output)
      else if (.F_exp_exists)  then
         .put_F_exp_data(output)
         .put_I_exp_data(output)
      end
   end

   put_structure_factor_data(output) [leaky]
   ! Output the structure factor data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      ENSURE(.F_pred_exists,"The predicted SF's do not exists")
      ENSURE(.F_exp_exists, "The experimental SF's are all zero")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      out.flush
      out.text("Structure factor reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      .put(.F_stats,out)
      out.dash(int_fields=3,dbl_fields=5)
      out.tab(int_fields=3,dbl_fields=2)
      out.put("Predicted")
      out.flush
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("Re(F_calc)")
      out.put("Im(F_calc)")
      out.put("|F_calc|")
      out.put("|F_exp|")
      out.put("sigma")
      out.flush
      out.dash(int_fields=3,dbl_fields=5)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(.F_calc(n))
         out.put(.F_pred(n))
         out.put(.F_exp(n))
         out.put(.sigma(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=5)
   end

   put_F_pred_data(output) [leaky]
   ! Output only the predicted structure factor data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      ENSURE(.F_pred_exists,"The predicted SF's do not exists")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      out.flush
      out.text("Structure factor reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      out.flush
      out.dash(int_fields=3,dbl_fields=3)
      out.tab(int_fields=3,dbl_fields=2)
      out.put("Predicted")
      out.flush
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("Re(F_calc)")
      out.put("Im(F_calc)")
      out.put("|F_calc|")
      out.flush
      out.dash(int_fields=3,dbl_fields=3)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(.F_calc(n))
         out.put(.F_pred(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=3)
   end

   put_F_exp_data(output)
   ! Output only the experimental structure factor data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      ENSURE(.F_exp_exists,"The experimental SF's are all zero")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      out.flush
      out.text("Structure factor reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("F_exp")
      out.put("sigma")
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(.F_exp(n))
         out.put(.sigma(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=2)
   end

   put_intensity_data(output)
   ! Output the structure factor data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      VEC, PTR :: I_exp,I_pred,sigma
      PAIRSTATISTICS :: I_stats
      ENSURE(.F_calc_exists,"The calculated SF's are all zero")
      ENSURE(.F_exp_exists, "The experimental SF's are all zero")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      I_pred.create(.n_refl)
      I_exp.create(.n_refl)
      sigma.create(.n_refl)
      I_pred = .I_pred
      I_exp =  .I_exp
      sigma =  .I_sigma
      I_stats.set_data(I_exp,I_pred,sigma)
      out.flush
      out.text("Intensity Reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      .put(I_stats,out)
      out.dash(int_fields=3,dbl_fields=5)
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("I_pred")
      out.put("I_exp")
      out.put("sigma")
      out.flush
      out.dash(int_fields=3,dbl_fields=5)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(I_pred(n))
         out.put(I_exp(n))
         out.put(sigma(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=5)
      sigma.destroy
      I_exp.destroy
      I_pred.destroy
   end

   put_I_pred_data(output)
   ! Output only the predicted intensity data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n,dbl_fields
      VEC, PTR :: I_pred,sigma
      ENSURE(.F_calc_exists,"The calculated SF's are all zero")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      I_pred.create(.n_refl)
      I_pred = .I_pred
      sigma.create(.n_refl)
      sigma =  .I_sigma
      out.flush
      out.text("Intensity Reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      dbl_fields = 1
      .put_extinction_data(out)
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      out.tab(int_fields=3,dbl_fields=1)
      out.put("Estimated")
      out.flush
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("I_pred")
      out.put("I_sigma")
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(I_pred(n))
         out.put(sigma(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=2)
      I_pred.destroy
      sigma.destroy
   end

   put_I_exp_data(output)
   ! Output only the experimental structure factor data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      INT :: n
      VEC, PTR :: I_exp,sigma
      ENSURE(.F_exp_exists,"The experimental SF's are all zero")
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      I_exp.create(.n_refl)
      sigma.create(.n_refl)
      I_exp =  .I_exp
      sigma =  .I_sigma
      out.flush
      out.text("Intensity Reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      out.put("h", int_width=TRUE)
      out.put("k", int_width=TRUE)
      out.put("l", int_width=TRUE)
      out.put("F_exp")
      out.put("sigma")
      out.flush
      out.dash(int_fields=3,dbl_fields=2)
      do n = 1,.n_refl
         out.put(.h(n))
         out.put(.k(n))
         out.put(.l(n))
         out.put(I_exp(n))
         out.put(sigma(n))
         out.flush
      end
      out.dash(int_fields=3,dbl_fields=2)
      sigma.destroy
      I_exp.destroy
   end

  put_qq_plot(name)
  ! Output a qq plot to the text file.
  ! It is a plot of the experimental quantile vs expected quantile.
    STR, optional :: name
    ARCHIVE :: archive
    MAT, PTR :: grid
    ENSURE(.F_calc_exists,"No calculated structure factors")
    ENSURE(.F_exp_exists,"No calculated structure factors")
    if (.no_F_pred) .make_F_predicted
    .F_stats.set_data(.F_pred,.F_exp,.sigma)
    .F_stats.make_qq_plot_grid(grid)
    archive.set(root_name=name,name="qq_plot",format="ascii")
    archive.write(grid,order="by_column")
    archive.close
    grid.destroy
  end

  put_chi2_vs_angle_plot
  ! Output a table with the chi^2 for the structure factor data set broken
  ! into sections.
  ! Reads from stdin the number of divisions in the plot.
    INT :: num_sections
    INT :: n,n_hkl,num,k
    MAT(3,3) :: rcm
    IVEC( .n_refl ) :: section_for
    VEC( .n_refl ) :: Fc
    DBL :: kx,ky,kz,stl,stl_min,stl_max,chi2,width,stl_mean

    stdin.read(num_sections)
    ENSURE(num_sections > 0, "number of sections to plot not positive")
    rcm = .reciprocal_cell_matrix

    ! Work out the limits of the sin(theta)/lambda.
    stl_min = 1000
    stl_max = ZERO
    do n=1, .n_refl
      kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
      ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
      kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
      stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)*BOHR_PER_ANGSTROM
      if (stl < stl_min) stl_min = stl
      if (stl > stl_max) stl_max = stl
    end
    width = (TOL(3) + stl_max - stl_min)/num_sections

    ! Determine which section each reflection belongs to.
    do n=1, .n_refl
      kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
      ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
      kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
      stl = HALF*sqrt(kx*kx+ky*ky+kz*kz)*BOHR_PER_ANGSTROM
      section_for(n) = ceiling((TOL(3) + stl - stl_min) / width)
    end

    stdout.flush
    stdout.text("Chi^2 vs angle plot")
    stdout.flush
    stdout.text("sin(theta)/lambda in Angstrom^(-1)")
    stdout.show("Smallest sin(theta)/lambda  = ",stl_min)
    stdout.show("Largest sin(theta)/lambda   = ",stl_max)
    stdout.flush
    stdout.put("stl")
    stdout.put("chi^2",flush=1)
    stdout.dash(dbl_fields=2)
    .update_gof_parameters
    Fc = .F_pred * .F_stats.scale_factor
    do n = 1, num_sections
      chi2 = ZERO
      num = 0
      stl_mean = stl_min + (n - HALF) * width
      do k = 1, .n_refl
        if (n==section_for(k)) then
          chi2 = chi2 + ((Fc(k) - .F_exp(k)) / .sigma(k))**2
          num = num + 1
        end
      end
      stdout.put(stl_mean)
      if (num==0) then
        stdout.flush
        cycle
      else
        chi2 = chi2 / max(num - .F_stats.n_param,1)
        stdout.put(chi2,flush=1)
      end
    end
    stdout.flush
  end

!  *******************
!  Tests for existence
!  *******************

   fragment_data_exists result(res)
   ! Return TRUE if a fragment information exists
      BIN :: res
      res = associated(.fragment_geometry)
   end

   no_fragment_data result(res)
   ! Return TRUE if a fragment information exists
      BIN :: res
      res = NOT associated(.fragment_geometry)
   end

   no_reflection_data result(res)
   ! Return TRUE if no reflection data exists
      BIN :: res
      res = NOT associated(.h) OR (.n_refl==0)
   end

   reflection_data_exists result(res)
   ! Return TRUE if reflection data exists
      BIN :: res
      res = associated(.h) AND (.n_refl>0)
   end

   no_F_exp result(res)
   ! Return TRUE if experimental structure factors does not exist
      BIN :: res
      res = NOT associated(.F_exp)
   end

   F_exp_exists result(res)
   ! Return TRUE if experimental structure factors exist
      BIN :: res
      res = associated(.F_exp)
   end

   no_F_calc result(res)
   ! Return TRUE if calculated structure factors does not exist
      BIN :: res
      res = NOT associated(.F_calc)
   end

   F_calc_exists result(res)
   ! Return TRUE if calculated structure factors exist
      BIN :: res
      res = associated(.F_calc)
   end

   no_F_pred result(res)
   ! Return TRUE if predicted structure factor magnitudes do not exist
      BIN :: res
      res = NOT associated(.F_pred)
   end

   F_pred_exists result(res)
   ! Return TRUE if predicted structure factor magnitudes exist
      BIN :: res
      res = associated(.F_pred)
   end

end
