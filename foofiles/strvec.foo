!---------------------------------------------------------------------------
!
!  STRVEC: String vectors
!
!  (c) dylan jayatilaka, 1998
!
! $Id$
!---------------------------------------------------------------------------
module STRVEC

   use TYPES
   use SYSTEM

   implicit none

#  include "macros"
#  include "strvec.int"

contains

   create(dim)
   ! Create space for a string vector
      PTR :: self
      INT :: dim
      nullify(self)
      allocate(self(dim))
      ADD_MEM(dim*len(self(1))*CHR_SIZE)
   end

   destroy
   ! Destroy space for a string vector
      PTR :: self
      if (.destroyed) return
      DELETE_MEM(size(self)*len(self(1))*CHR_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   this_item(this) result (res)
   ! Return the element "this" in "self". 
      INT, INOUT :: this
      STR :: res
      ENSURE(this<size(self),"there is no next item!")
      this = this + 1
      res = self(this)
   end

   next_item(this) result (res)
   ! Return the next element "this+1" in "self". "this" is incremented.
   ! The STRVEC is being used like a buffer, in this routine
      INT, INOUT :: this
      STR :: res
      ENSURE(this<size(self),"there is no next item!")
      ENSURE(this>0,"there is no next item!")
      this = this + 1
      res = self(this)
   end

   previous_item(this) result (res)
   ! Return the next element "this-1" in "self". "this" is decremented.
   ! The STRVEC is being used like a buffer, in this routine
      INT, INOUT :: this
      STR :: res
      ENSURE(this<size(self)+2,"there is no previous item!")
      ENSURE(this>2,"there is no previous item!")
      this = this - 1
      res = self(this)
   end

   sort [recursive]
   ! Sort the vector into dictionary order
      STRVEC, PTR :: smaller,larger
      INT :: n, ns, ne, nl
      STR :: chosen
      n = size(self)
      if (n>=2) then
         chosen = self(1)
         ns = count(self<chosen)
         nl = count(self>chosen)
         ne = n - ns - nl
         smaller.create(ns)
         larger.create(nl)
         smaller = pack(self,self<chosen)
         larger  = pack(self,self>chosen)
         smaller.sort
         larger.sort
         self(1:ns)       = smaller
         self(ns+1:ns+ne) = chosen
         self(ns+ne+1:)   = larger
         larger.destroy
         smaller.destroy
      end
   end

  expand(dim) [leaky]
  ! Expands self to dimension dim.  Contents are retained.
  ! Elements added are set to "".
    PTR :: self
    STRVEC, PTR :: old
    INT, IN :: dim
    INT :: old_size
    old => self
    old_size=size(old)
    nullify(self)
    self.create(dim)
    self(1:old_size)=old
    self(old_size+1:dim)=""
    old.destroy
  end

  prepend(pre) [leaky]
  ! Prepend the string vector "pre" to "self". "self" is expanded.
    PTR :: self
    STRVEC, IN :: pre
    STRVEC, PTR :: old
    INT :: dim,old_dim
    dim = size(pre)
    old => self
    old_dim = size(old)
    nullify(self)
    self.create(old_dim+dim)
    self(1    :dim)  = pre
    self(dim+1:   )  = old
    old.destroy
  end

  append(app) [leaky]
  ! Append the string vector "app" to "self". "self" is expanded.
    PTR :: self
    STRVEC, IN :: app
    STRVEC, PTR :: old
    INT :: dim,old_dim
    dim = size(app)
    old => self
    old_dim = size(old)
    nullify(self)
    self.create(old_dim+dim)
    self(1        :old_dim)  = old
    self(old_dim+1:       )  = app
    old.destroy
  end

end 
