!-------------------------------------------------------------------------------
!
! SHELL: used to describe contracted cartesian gaussian shells.
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module SHELL

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!  ******************
!  Allocation methods
!  ******************

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer part of a shell object
      nullify(.ex)
      nullify(.cc)
      nullify(.cc_s)
      nullify(.cc_p)
   end

   destroy_ptr_part ::: leaky
   ! Destroy pointer part of a shell object
      .ex.destroy
      .cc.destroy
      .cc_s.destroy
      .cc_p.destroy
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(shell) ::: leaky
   ! Copy a shell object. Make sure pointer parts are nullified or
   ! destroyed, as you like, before using this.
      shell :: SHELL, IN
      self = shell
      .nullify_ptr_part
      if (shell.ex.created) .ex.create_copy(shell.ex)
      if (shell.cc.created) .cc.create_copy(shell.cc)
      if (shell.cc_s.created) .cc_s.create_copy(shell.cc_s)
      if (shell.cc_p.created) .cc_p.create_copy(shell.cc_p)
   end

   set(object) ::: get_from(OBJECT)
   ! Set the object. Pointer parts are assigned not copied.
   end

   set_defaults
   ! Set defaults
      .l = 0
      .l_chr = " "
      .is_spherical = SHELL_IS_SPHERICAL
      .n_cc = 0
      .n_comp = 0
      .n_sph = 0
      .first_gaussian = 0
      .last_gaussian = 0
   end

   set_l(l) ::: template
   ! Set the l value
      l :: INT
      .l = l
      .l_chr = SHELL::l_chr(.l)
      .first_gaussian = SHELL::n_comp_up_to(l-1) + 1
      .last_gaussian  = SHELL::n_comp_up_to(l)
   end

   set_l(l) ::: get_from(SHELL)
   ! Set the l value
   end

   set_n_comp ::: template
   ! Set the number of components. "L" shells are a special case.
      if (.l_chr=="L") then; .n_comp = 4
      else;                  .n_comp = SHELL::n_comp(.l)
      end
      .n_sph = 2*.l + 1
   end

   set_n_comp ::: get_from(SHELL)
   ! Set the number of components. "L" shells are a special case.
   end

!   update ::: private
!   ! Update the shell data
!      DIE_IF(.ex.destroyed,"no expononents")
!      DIE_IF(.cc.destroyed,"no contractions")
!      ENSURE(stdin.default_units==" ","default units still set")
!   end

!   n_comp_sum result (res)
!   ! No. of cartesian components up to shell with momentum .l
!     res :: INT
!     res = (.l+1)*(.l+2)*(.l+3)/6
!   end

!  ************
!  I/O Routines
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("}           "); ! exit surrounding loop
       case ("cc=         "); .read_cc
       case ("ex=         "); .read_ex
       case ("ex,cc=      "); .read_ex_cc
       case ("junk,ex,cc= "); .read_junk_ex_cc
       case ("l=          "); .read_l
       case ("l_chr=      "); .read_l_chr
       case ("n_cc=       "); .read_n_cc
       case ("put         "); .put
       case ("spherical=  "); .read_spherical
       case ("units=      "); SHELL::read_units
       ! These are only for making custom tables for the list type
       case ("flush       "); stdout.flush
       case ("put_l       "); stdout.put(.l)
       case ("put_l_chr   "); stdout.put(.l_chr,int_width=TRUE)
       case ("put_l_int   "); stdout.put(.l)
       case ("put_n_cc    "); stdout.put(.n_cc)
       case ("put_n_prim  "); stdout.put(.n_prim)
       case ("put_norm    "); stdout.put(.norm)
       case default;         UNKNOWN(word)
     end
   end

   read_units ::: get_from(OBJECT), selfless, private
   ! Read a string which describes the units to be used
   end

   read_l
   ! Read in the l symbol
      word :: STR
      stdin.read(word)
      stdin.move_to_previous_item
      if (word.is_int) then; .read_l_int
      else;                  .read_l_chr
      end
   end

   read_l_int
   ! Read in the l integer. No way to get "L" shells in this input mode.
      word :: STR
      stdin.read(word)
      ENSURE(word.is_int,"expecting an integer for L")
      .set_l(word.to_int)
      .set_n_comp
   end

   read_l_chr
   ! Read in the l symbol
      word :: STR
      l_c :: STR(1) 
      l :: INT
      stdin.read(word)
      ENSURE(len_trim(word)==1,"unknown L symbol")
      .l_chr = word(1:1)
      if (.l_chr/="L") .l_chr.to_lower_case
      l_c = .l_chr
      select case (l_c)
         case ("s");   l = 0
         case ("p");   l = 1
         case ("L");   l = 1 ! This is the maximum l in the shell
         case ("d");   l = 2
         case ("f");   l = 3
         case ("g");   l = 4
         case ("h");   l = 5
         case ("i");   l = 6
         case default; l = 6 + iachar(l_c)-iachar("i")
      end
      .set_l(l)
      .set_n_comp
   end

   read_spherical
   ! Read in if this is a spherical shell
      stdin.read(.is_spherical)
   end

   read_n_cc
   ! Read in the number of contraction coefficients
      stdin.read(.n_cc)
      ENSURE(.n_cc>0,"n_cc must be positive")
   end

   read_ex ::: leaky
   ! Read in the exponents
   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.ex.destroyed,"ex already entered")
      .ex.create(.n_cc)
      stdin.read(.ex)
   end

   read_cc ::: leaky
   ! Read in the contraction coefficients
   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.cc.destroyed,"cc already entered")
      if (.l_chr/="L") then
         .cc.create(.n_cc)
         stdin.read(.cc)
      else 
         .cc_s.create(.n_cc)     ! Read l-shell as alternating 
         .cc_p.create(.n_cc)     ! columns
         stdin.read(.cc_s,.cc_p)
      end
   end

   read_ex_cc ::: leaky
   ! Read in the exponents and contractions
   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.ex.destroyed,"ex already entered")
   ENSURE(.cc.destroyed,"ex already entered")
      if (.l_chr/="L") then
         .ex.create(.n_cc)
         .cc.create(.n_cc)
         stdin.read(.ex,.cc)
      else
         .ex.create(.n_cc)
         .cc_s.create(.n_cc)
         .cc_p.create(.n_cc)
         stdin.read(.ex,.cc_s,.cc_p)
      end
   end

   read_junk_ex_cc ::: leaky
   ! Read in the exponents and contractions preceded by a junk string
   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.ex.destroyed,"ex already entered")
   ENSURE(.cc.destroyed,"ex already entered")
      i :: INT
      if (.l_chr/="L") then
         .ex.create(.n_cc)
         .cc.create(.n_cc)
         do i = 1,.n_cc
            stdin.skip_next_item
            stdin.read(.ex(i))
            stdin.read(.cc(i))
         end
      else
         .ex.create(.n_cc)
         .cc_s.create(.n_cc)
         .cc_p.create(.n_cc)
         do i = 1,.n_cc
            stdin.skip_next_item
            stdin.read(.ex(i))
            stdin.read(.cc_s(i))
            stdin.read(.cc_p(i))
         end
      end
   end

!  ********************
!  Key related routines
!  ********************

   read_keys ::: get_from(OBJECT)
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
      res :: BIN
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
     the_keys :: VEC{STR}
   end

   clear_keys ::: get_from(OBJECT)
   ! This is for destroying the "keys" externally.
   end

   put_table_footer ::: get_from(OBJECT)
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   end

   put_table_header
   ! Output a table header from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
     word :: STR
     width,k :: INT

     width = .table_width

     if (width > 0) then
       stdout.dash(width=width)
       do k = 1,size(keys)
         word = keys(k)
         word.to_lower_case
         select case (word)
           case ("flush       "); stdout.flush; exit
           case ("put_l       "); stdout.put("l",int_width=TRUE)
           case ("put_l_chr   "); stdout.put("l symbol",int_width=TRUE)
           case ("put_l_int   "); stdout.put("l",int_width=TRUE)
           case ("put_n_cc    "); stdout.put("n_cc",int_width=TRUE)
           case ("put_n_prim  "); stdout.put("n_prim",int_width=TRUE)
           case ("put_norm    "); stdout.put("norm")
           case default
         end
         if (k==size(keys)) then
           stdout.flush ! In case they didn't write one.
           WARN("no flush keyword - you may later overrun the output buffer")
         end
       end
       stdout.dash(width=width)
     end
   end

   table_width result (res)
   ! Return how wide a table is, based on "keys".  Note that not all keywords
   ! need to contribute to the banner - any unrecognised keyword is skipped.
     res :: INT
     int_dash,real_dash,k :: INT
     word :: STR
     int_dash = 0
     real_dash = 0
     ENSURE(keys.created,"no keywords")
     do k = 1,size(keys)
       word = keys(k)
       word.to_lower_case
       select case (word)
         case ("}           "); ! exit surrounding loop
         case ("put_l       "); int_dash = int_dash + 1
         case ("put_l_chr   "); int_dash = int_dash + 1
         case ("put_l_int   "); int_dash = int_dash + 1
         case ("put_n_cc    "); int_dash = int_dash + 1
         case ("put_n_prim  "); int_dash = int_dash + 1
         case ("put_norm    "); real_dash = real_dash + 1
         case ("flush       "); exit
         case default
       end
     end
     res = int_dash * stdout.int_width + real_dash * stdout.real_width
   end

!  *********************
!  Miscellaneous methods
!  *********************

   n_comp(l) result(res) ::: get_from(GAUSSIAN_DATA), selfless, private, always_pure
   ! No. of cartesian components in a gaussian shell of momentum "l".
   end

   n_comp_up_to(l) result(res) ::: get_from(GAUSSIAN_DATA), selfless, private, always_pure
   ! No. of gaussian cartesian component functions up to and including the shell
   ! with momentum "l".
   end

   l_chr(l) result(res) ::: selfless, private
   ! Return a character representation for angular mtm "l"
   ! Of course, "L" shells are never returned: they have mixed mtm.
      res :: STR(1)
      l :: INT
      select case (l)
         case (0); res="s"
         case (1); res="p"
         case (2); res="d"
         case (3); res="f"
         case (4); res="g"
         case default;
            DIE_IF(l>23,"angular momentum too large:"// trim(l.to_str))
            res = achar(l-4+iachar("g"))
      end select
   end

   same_as(sh) result(same)
   ! Return TRUE if the shell "self" is the same as "sh".
      sh :: SHELL
      same :: BIN
      same = .l_chr==sh.l_chr &
         AND (.is_spherical EQV sh.is_spherical) &
         AND (.ex.created   EQV sh.ex.created) &
         AND (.cc.created   EQV sh.cc.created) &
         AND (.cc_s.created EQV sh.cc_s.created) &
         AND (.cc_p.created EQV sh.cc_p.created) 
      if (NOT same) return
      if (.ex.created AND sh.ex.created) same = .ex.same_as(sh.ex) 
      if (NOT same) return
      if (.l_chr/="L") then
         if (.cc.created   AND sh.cc.created)   same = .cc.same_as(sh.cc) 
      else
         if (.cc_s.created AND sh.cc_s.created) same = .cc_s.same_as(sh.cc_s) 
         if (NOT same) return
         if (.cc_p.created AND sh.cc_p.created) same = .cc_p.same_as(sh.cc_p) 
      end
   end

   make_contraction_matrix(ccm,ccp)
   ! Return the contraction coefficient matrix "ccm". It is with respect to
   ! uniform normalisation i.e. all components are normalised to the first
   ! component, x^l. If this is an "L" shell, "ccp" may also be returned, the
   ! contraction matrix for the "p" shell. size "ccm" is normally (.n_prim,.n_comp).
      ccm :: MAT{REAL}, OUT
      ccp :: MAT{REAL}, OUT, optional
   ENSURE(.n_cc>0,"no contraction coefficients")
      b,p,i,f,l :: INT
      fb :: REAL
      fac :: VEC{REAL}*
      if (.l<2) then
         if (.l_chr/="L") then
            ENSURE(ccm.dim1==.n_prim,"wrong 1st dimension, ccm")
            ENSURE(ccm.dim2==.n_comp,"wrong 2nd dimension, ccm")
            ENSURE(.cc.created,"no contraction coefficients")
            do b = 1,.n_comp       ! do over basis components
               p = b               ! primitive p
               do i = 1,.n_cc      ! do over contractions
                  ccm(p,b) = .cc(i)
                  p = p + .n_comp
               end
            end
         else
            ENSURE(present(ccp),"no ccp matrix")
            ENSURE(ccm.dim1==.n_cc,"wrong 1st dimension, ccm")
            ENSURE(ccm.dim2==1,"wrong 2nd dimension, ccm")
            ENSURE(ccp.dim1==3*.n_cc,"wrong 1st dimension, ccp")
            ENSURE(ccp.dim2==3,"wrong 2nd dimension, ccp")
            ENSURE(.cc_s.created,"no s contraction coefficients")
            ENSURE(.cc_p.created,"no p contraction coefficients")
            do b = 1,1             ! do over basis components
               p = b               ! primitive p
               do i = 1,.n_cc      ! do over contractions
                  ccm(p,b) = .cc_s(i)
                  p = p + 1
               end
            end
            do b = 1,3             ! do over basis components
               p = b               ! primitive p
               do i = 1,.n_cc      ! do over contractions
                  ccp(p,b) = .cc_p(i)
                  p = p + 3
               end
            end
         end
      else
            ENSURE(ccm.dim1==.n_prim,"wrong 1st dimension, ccm")
            ENSURE(ccm.dim2==.n_comp,"wrong 2nd dimension, ccm")
            ENSURE(.cc.created,"no contraction coefficients")
            GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
            f = .first_gaussian; l = .last_gaussian
            fac => GAUSSIAN_DATA::normalising_factors(f:l)
            do b = 1,.n_comp       ! do over basis components
               p = b               ! primitive p
               fb = fac(b)
               do i = 1,.n_cc      ! do over contractions
                  ccm(p,b) = fb*.cc(i)
                  p = p + .n_comp
               end
            end
      end
   end

   norm result (res) ::: pure
   ! Return the norm of the shell, assuming that the existing contraction
   ! coefficients are with respect to NORMALISED primitive gaussians.
      self :: IN
      res :: REAL
      i,j :: INT
      sum,a,b,ab :: REAL
      sum = ZERO
      do i = 1,.n_cc
         a = .ex(i)
         do j = 1,i-1
            b = .ex(j)
            ab = TWO*sqrt(a*b)/(a+b);
            sum = sum + TWO*.cc(i)*.cc(j)*ab**(.l+ONE+HALF);
         end
         sum = sum + .cc(i)*.cc(i) ! this is the normalised diagonal term
      end
      res = sqrt(sum) * ((TWO*PI)**(THREE/FOUR))
   end

   unnormalise
   ! Assuming the existing contraction coefficients are initially with respect
   ! to NORMALISED primitive gaussians, take out this normalisation factor of
   ! each primitive and put it in the contraction coefficient. The normalisation
   ! factor removed is the one appropriate for the cartesian component x^l.
   ! NOTE: It is up to you to correct this factor with appropriate double
   ! factorial square roots for other components. The factor should be: 
   !   fac = 1/sqrt(df(nx)*df(ny)*df(nz))
   ! where nx,ny,nz are the cartesian powers of the basis component
       .cc(:) = .cc(:) * (FOUR*.ex(:))**(HALF*.l+HALF+QUARTER) &
                * (ONE/(.norm*sqrt(.l.double_factorial)))
   end

   renormalise
   ! Assuming the existing contraction coefficients are with respect to raw
   ! UNNORMALISED primitive gaussians, put back this normalisation factor for
   ! each primitive gaussian, by removing this factor from from the contraction
   ! coefficients. The result will be contraction coefficients relative to
   ! normalised primitive gausian. This will undo routine "unnormalise" routine
   ! above.  The ((TWO*PI)**(THREE/FOUR)) / .norm factor is supposed to make the
   ! contraction coefficient equal to 1 for a shell with one primitive i.e. the
   ! shell is not *really* normalised. This seems to be the usual convention.
      .cc(:) = .cc(:) / ((FOUR*.ex(:))**(HALF*.l+HALF+QUARTER)) 
      .cc(:) = .cc(:) * ((TWO*PI)**(THREE/FOUR)) / .norm
   end

   n_prim result(res) ::: pure
   ! Return the number of primitive gaussians in the shell
      self :: IN
      res :: INT
      res = .n_comp*.n_cc
   end

   put
   ! Put the shell information to "stdout"
      i :: INT
      stdout.flush
      stdout.show("Shell type     = ",.l_chr)
      stdout.show("l              = ",.l)
      stdout.show("is_spherical   = ",.is_spherical)
      stdout.show("n_comp         = ",.n_comp)
      stdout.show("n_sph          = ",.n_sph)
      stdout.show("first_gaussian = ",.first_gaussian)
      stdout.show("last_gaussian  = ",.last_gaussian)
      if (.n_cc<=0) return
      if (.l_chr/="L") then
         ENSURE(.ex.created,"no exponents")
         ENSURE(.cc.created,"no contractions")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=2)
         stdout.put("#", int_width=TRUE)
         stdout.put("Exponents")
         stdout.put("Contraction")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=2)
         do i = 1,.n_cc
            stdout.put(i)
            stdout.put(.ex(i))
            stdout.put(.cc(i))
            stdout.flush
         end
         stdout.dash(int_fields=1,real_fields=2)
      else
         ENSURE(.ex.created,"no exponents")
         ENSURE(.cc_s.created,"no s contractions")
         ENSURE(.cc_p.created,"no p contractions")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=3)
         stdout.put("#", int_width=TRUE)
         stdout.put("Exponents")
         stdout.put("Contraction")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=3)
         do i = 1,.n_cc
            stdout.put(i)
            stdout.put(.ex(i))
            stdout.put(.cc_s(i))
            stdout.put(.cc_p(i))
            stdout.flush
         end
         stdout.dash(int_fields=1,real_fields=3)
      end
   end

end
