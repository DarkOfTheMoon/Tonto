!-------------------------------------------------------------------------------
!
! SHELL: used to describe contracted cartesian gaussian shells. 
!
! (c) Dylan Jayatilaka, november 1997
!
! $Id$
!-------------------------------------------------------------------------------
module SHELL

   use TYPES
   use SYSTEM
   use STR
   use INT
   use IMAT
   use VEC
   use MAT
   use MAT3
   use TEXTFILE

   implicit none         

#  include "macros"
#  include "shell.int"

!   type shell_type
!
!   INT :: l
!   ! l quantum number for the gaussian shell
!
!   INT :: n_comp
!   ! No. of components for the gaussian shell
!
!   INT :: n_cc
!   ! No. of contractions for the gaussian shell
!
!   VEC* :: ex
!   ! Exponent vector
!
!   VEC* :: cc
!   ! Contraction coefficient vector
!   end

contains

!  ******************
!  Allocation methods
!  ******************

   create 
   ! Create a shell object
      PTR :: self
      allocate(self)
      ADD_MEM(SHELL_SIZE)
      .l = 0
      .n_cc = 0
      .n_comp = 0
      .nullify_ptr_part
   end

   destroy 
   ! Destroy a shell object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(SHELL_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer part of a shell object
      nullify(.ex)
      nullify(.cc)
   end

   destroy_ptr_part
   ! Destroy pointer part of a shell object
      .ex.destroy
      .cc.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   copy(shell) [leaky]
   ! Copy a shellell object
      SHELL :: shell
      .l = shell.l
      .n_comp = shell.n_comp
      .n_cc = shell.n_cc
      .ex.destroy
      .ex.create(.n_cc)
      .ex = shell.ex
      .cc.destroy
      .cc.create(.n_cc)
      .cc = shell.cc
   end

   set(shell) 
   ! Set a shell object
      SHELL :: shell
      .l = shell.l
      .n_comp = shell.n_comp
      .n_cc = shell.n_cc
      .ex => shell.ex
      .cc => shell.cc
   end

   set_default
   ! Set a default shell
      .l = 0
      .n_cc = 1
      .ex.create(1)
      .cc.create(1)
      .ex(1) = ONE
      .cc(1) = ONE
      .update
   end

   update     
   ! Update the shell data
      .n_comp = (.l+1)*(.l+2)/2
   end

   n_comp_sum result (res)
   ! No. of cartesian components up to shell with momentum .l
     INT :: res
     res = (.l+1)*(.l+2)*(.l+3)/6
   end

!  *************
!  Input methods
!  *************

   read [leaky]
   ! Read data from "stdin" using keyword style input.
      STR :: word
      ENSURE(stdin.next_str=="{","expecting an open bracket symbol, {")
      read_loop: do             ! Loop over keywords
         stdin.read(word)
         if (stdin.reverted)    exit read_loop
         if (word=="}")         exit read_loop
         .process(word)      
      end do read_loop
      .update
   end

   process(word) [leaky]
   ! Process a keyword "word". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case, 
   ! the sequence is processed as if it were a separate file.
      STR(*) :: word
      if (word.includes(" ")) then
         stdin.redirect([word])
         .read
      else
         select case (word)
            case("shell");      .read
            case("units");      .read_units
            case("l");          .read_l
            case("l_int");      .read_l_int
            case("l_chr");      .read_l_chr
            case("n_cc");       .read_n_cc
            case("ex");         .read_ex
            case("cc");         .read_cc
            case("ex,cc");      .read_ex_cc
            case("junk,ex,cc"); .read_junk_ex_cc
            case default;    DIE("unknown keyword, "//trim(word))
         end
      end
   end

   process(keyword) [leaky]
   ! Process each of the words in the "keyword" list.
      STRVEC :: keyword
      INT :: k,n_key
      n_key = size(keyword)
      do k = 1,n_key
         if (keyword(k)=="end") exit 
         .process(keyword(k)) 
      end
      ENSURE(k>=n_key,"unprocessed words remain in the keyword list")
      .update
   end

   read_units
   ! Read a string which describes the units to be used
      stdin.set_default_units(stdin.next_str)
   end

   read_l
   ! Read in the l symbol
      STR :: word
      CHR :: l_c
      INT :: l
      stdin.read(word)
      if (word.is_int) then
         ENSURE(word.is_int,"expecting an integer for L")
         .l = word.to_int 
      else;                  
         ENSURE(len_trim(word)==1,"unknown L symbol")
         l_c = word
         l_c.to_lower_case
         select case (l_c) 
            case ("s"); l = 0
            case ("p"); l = 1
            case ("d"); l = 2
            case ("f"); l = 3
            case ("g"); l = 4
            case default; 
               DIE_IF(l_c<"g","unknown angular momentum character:"//l_c)
               l = 4 + iachar(l_c)-iachar("g")
         end 
         .l = l
      end
   end

   read_l_int
   ! Read in the l integer
      STR :: word
      CHR :: l_c
      INT :: l
      stdin.read(word)
      ENSURE(word.is_int,"expecting an integer for L")
      .l = word.to_int 
   end

   read_l_chr
   ! Read in the l symbol
      STR :: word
      CHR :: l_c
      INT :: l
      stdin.read(word)
      ENSURE(len_trim(word)==1,"unknown L symbol")
      l_c = word
      l_c.to_lower_case
      select case (l_c) 
         case ("s"); l = 0
         case ("p"); l = 1
         case ("d"); l = 2
         case ("f"); l = 3
         case ("g"); l = 4
         case default; 
            DIE_IF(l_c<"g","unknown angular momentum character:"//l_c)
            l = 4 + iachar(l_c)-iachar("g")
      end 
      .l = l
   end

   read_n_cc
   ! Read in the number of vontraction coefficients
      stdin.read(.n_cc)
      ENSURE(.n_cc>0,"n_cc must be positive")
   end

   read_ex [leaky]
   ! Read in the exponents
      ENSURE(.n_cc>0,"n_cc must be entered first")
      ENSURE(.ex.destroyed,"ex already entered")
      .ex.create(.n_cc)
      stdin.read(.ex)
   end

   read_cc [leaky]
   ! Read in the contraction coefficients
      ENSURE(.n_cc>0,"n_cc must be entered first")
      ENSURE(.cc.destroyed,"cc already entered")
      .cc.create(.n_cc)
      stdin.read(.cc)
   end

   read_ex_cc [leaky]
   ! Read in the exponents and contractions
      ENSURE(.n_cc>0,"n_cc must be entered first")
      ENSURE(.ex.destroyed,"ex already entered")
      ENSURE(.cc.destroyed,"ex already entered")
      .ex.create(.n_cc)
      .cc.create(.n_cc)
      stdin.read(.ex,.cc)
   end

   read_junk_ex_cc [leaky]
   ! Read in the exponents and contractions preceded by a junk string
      INT :: i
      ENSURE(.n_cc>0,"n_cc must be entered first")
      ENSURE(.ex.destroyed,"ex already entered")
      ENSURE(.cc.destroyed,"ex already entered")
      .ex.create(.n_cc)
      .cc.create(.n_cc)
      do i = 1,.n_cc
         stdin.skip_next_item
         stdin.read(.ex(i))
         stdin.read(.cc(i))
      end
   end

   same_as(sh) result(same)
   ! Return TRUE if the shell "self" is the same as "sh".
      SHELL :: sh
      BIN :: same
      same = .l==sh.l AND .n_comp==sh.n_comp &
         AND .ex.same_as(sh.ex) AND .cc.same_as(sh.cc)
   end                                                                             

   l_chr result(res)
   ! Return a character representation for the angular mtm
      CHR :: res
      INT :: l
      l = .l
      select case (l) 
         case (0); res="s"
         case (1); res="p"
         case (2); res="d"
         case (3); res="f"
         case (4); res="g"
         case default; 
            DIE_IF(l>23,"angular momentum too large:"// trim(l.to_str))
            res = achar(l-4+iachar("g"))
      end select
   end
    
   make_contraction_matrix(ccm)
   ! Return the contraction coefficient matrix. Size of ccm is (.n_prim,.n_comp).
      MAT :: ccm
      INT :: b,p,i
      DBL :: f
      VEC* :: fac
      fac.create( .n_comp )
      fac.normalizing_factors( .l )
      do b = 1,.n_comp       ! do over basis components
         p = b               ! primitive p 
         f = fac(b)
         do i = 1,.n_cc      ! do over contractions
            ccm(p,b) = f*.cc(i) 
            p = p + .n_comp
         end
      end
      fac.destroy
   end

   norm result (res)
   ! Return the norm of the shell, assuming that the existing contraction 
   ! coefficients are with respect to NORMALISED gaussians 
      DBL :: res
      INT :: i,j
      DBL :: sum,a,b,ab
      sum = ZERO
      do i = 1,.n_cc
         a = .ex(i)
         do j = 1,i-1
            b = .ex(j)  
            ab = TWO*sqrt(a*b)/(a+b);
            sum = sum + TWO*.cc(i)*.cc(j)*ab**(.l+ONE+HALF);
         end
         sum = sum + .cc(i)*.cc(i)
      end
      res = sqrt(sum) * ((TWO*PI)**(THREE/FOUR)) 
   end

   unnormalise
   ! Unnormalise self as if all components in the shell were x^l, and also
   ! assuming the existing contraction coefficients are with respect to raw 
   ! UNNORMALISED gaussians. It is up to you to correct this factor with 
   ! appropriate double factorial square roots for other components.
      INT :: i
      DBL :: a,fac
      ! Now Take out the normalization of each primitive.
      ! The double factorial should be: fac = 1/sqrt(df(nx)*df(ny)*df(nz))
      ! where n are the cartesian powers of the basis component
      fac = ONE/(.norm*sqrt(.l.double_factorial))
      do i = 1,.n_cc
         a = FOUR*.ex(i)
         .cc(i) = .cc(i)*fac*a**(HALF*.l+HALF+QUARTER)
      end
   end

   renormalise
   ! Normalise self as if all components in the shell were x^l, and also
   ! assuming the existing contraction coefficients are with respect to raw 
   ! unnormalised gaussians. This will undo routine "unnormalise".
      INT :: i
      DBL :: a,fac
      fac = sqrt(.l.double_factorial)
      do i = 1,.n_cc
         a = FOUR*.ex(i)
         .cc(i) = .cc(i)*fac/(a**(HALF*.l+HALF+QUARTER))
      end
      .cc(:) = (.cc(:)/.norm) * ((TWO*PI)**(THREE/FOUR)) 
      ! The last factor is to make the cc=1 for a shell with one primitive
   end

   n_prim result(res)
   ! Return the number of primitive gaussians in the shell
      INT :: res
      res = .n_comp*.n_cc
   end

   put
   ! Put the shell information to "stdout"
      INT :: i
      stdout.flush
      stdout.show("L quantum number = ",.l)
      stdout.dash(int_fields=1,dbl_fields=2)
      stdout.put("N", int_width=TRUE)
      stdout.put("Exponents")
      stdout.put("Contraction")
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=2)
      do i = 1,.n_cc
         stdout.put(i)
         stdout.put( .ex(i))
         stdout.put( .cc(i))
         stdout.flush
      end
   end

end 
