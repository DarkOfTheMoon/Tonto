! $Id$
!---------------------------------------------------------------------------
!  CVEC: Complex vector operations ...
!  (c) dylan jayatilaka, 1997
!---------------------------------------------------------------------------
module CVEC

   use TYPES
   use SYSTEM

   implicit none         

#include "macros"
#include "cvec.int"
   
contains

   create(dim)
   ! Create a complex vector with dimension "dim"
      PTR :: self
      INT :: dim
      nullify(self)
      allocate(self(dim))
      ADD_MEM(dim*CDBL_SIZE)
   end

   destroy
   ! Destroy a complex vector
      PTR :: self
      if (.destroyed) return
      DELETE_MEM(size(self)*CDBL_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end
   
   sum_elements result (res)
   ! Return the sum of the elements of self
      CDBL :: res
      res = sum(self)
   end

   to_product(a,b,transpose_a)
   ! Set "self" to the product of matrix "a" and vector "b". If present,
   ! "transpose_a" can be set to TRUE if "a" needs to be transposed.
      MAT, IN :: a
      CVEC, IN :: b
      BIN, optional :: transpose_a
      INT :: a1,a2, i,j
      BIN :: ta
      a1 = size(a,1); a2 = size(a,2)
      ta = FALSE
      if (present(transpose_a)) ta = transpose_a
      if (ta) then
         self = ZERO
         do i = 1,a2
         do j = 1,a1
            self(i) = self(i) + a(j,i)*b(j)
         end
         end
      else
         self = ZERO
         do i = 1,a1
         do j = 1,a2
            self(i) = self(i) + a(i,j)*b(j)
         end
         end
      end
   end

   plus_product(a,b,transpose_a)
   ! Set "self" to the product of matrix "a" and vector "b". If present,
   ! "transpose_a" can be set to TRUE if "a" needs to be transposed.
      MAT, IN :: a
      CVEC, IN :: b
      BIN, optional :: transpose_a
      INT :: a1,a2, i,j
      BIN :: ta
      a1 = size(a,1); a2 = size(a,2)
      ta = FALSE
      if (present(transpose_a)) ta = transpose_a
      if (ta) then
         do i = 1,a2
         do j = 1,a1
            self(i) = self(i) + a(j,i)*b(j)
         end
         end
      else
         do i = 1,a1
         do j = 1,a2
            self(i) = self(i) + a(i,j)*b(j)
         end
         end
      end
   end

   dot(b) result (res)
   ! Return the dot product of "b" with self
      CVEC :: b
      CDBL :: res
      res = dot_product(self,b)
   end
   
   to_cross_product(x,y)
   ! Set self to the cross product of "x" and "y"
      CVEC :: x,y
      INT :: dims,dimx,dimy
      dims = size(self)
      dimx = size(x)
      dimy = size(y)
      DIE_IF(dims/=3 OR dimx/=3 OR dimy/=3,"vectors must have dimension 3")
      self(1) = x(2)*y(3) - y(2)*x(3)
      self(2) = x(3)*y(1) - y(3)*x(1)
      self(3) = x(1)*y(2) - y(1)*x(2)
   end

   norm result (val) [pure]
   ! Return the norm of self
      IN :: self
      CDBL :: val
      INT :: i
      val = ZERO
      do i=1,size(self)
        val = val + self(i)*self(i)
      end
      val = sqrt(val)
!      val = dznorm2(size(self),self,1) ! dxml library
   end
   
   to_scaled_vec(fac,b) [pure]
   ! Set self to the scaled product of "b"
      INOUT :: self
      CVEC, IN :: b
      CDBL, IN :: fac
      self = fac*b
   end
   
   plus_scaled_vec(fac,b) [pure]
   ! Add to self the scaled product of "b"
      INOUT :: self
      CVEC, IN :: b
      CDBL, IN :: fac
      self = self + fac*b
   end
   
   minus_vec(b) [pure]
   ! Subtract from self the vector "b"
      INOUT :: self
      CVEC, IN :: b
      self = self-b
   end
   
   plus_vec(b) [pure]
   ! Add to self the vector "b"
      INOUT :: self
      CVEC, IN :: b
      self = self+b
   end
   
   set_to(b) [pure]
   ! Set self to "b"
      INOUT :: self
      CVEC, IN :: b
      self = b
   end
   
   zero [pure]
   ! Set self to zero
      INOUT :: self
      self = ZERO
   end
   
   chop_large_values(maxval) [pure]
   ! chop the absolute values of self to be no larger than "maxval"
      INOUT :: self
      DBL, IN :: maxval
      INT :: dim,i
      DBL :: ba
      CDBL :: bb,phase
      dim = size(self)
      do i = 1,dim
         bb = self(i)
         ba = abs(bb)
         if (ba==ZERO) then
            self(i) = ZERO
         else
            phase = bb/ba
            self(i) = phase*min(maxval,ba)
         end
     end
   end
   
   largest_value result (maxval) [pure]
   ! Return the largest value in self
      IN :: self
      DBL :: maxval,bb
      INT :: i
      maxval = abs(self(1))
      do i = 2,size(self)
        bb = abs(self(i))
        if (bb > maxval) maxval = bb
      end
!      res = dzamax(size(self),self,1) ! blas library
   end
   
   smallest_value result (minval) [pure]
   ! Return the smallest value in self
      IN :: self
      DBL :: minval,bb
      INT :: i
      minval = abs(self(1))
      do i = 2,size(self)
        bb = abs(self(i))
        if (bb < minval) minval = bb
      end
!      res = dzamin(size(self),self,1) ! blas library
   end

   index_of_largest_value result (ind) [pure]
   ! Return the index of the largest value in self
      IN :: self
      INT :: ind,i
      DBL :: maxval,bb
      maxval = abs(self(1))
      ind = 1
      do i = 2,size(self)
        bb = abs(self(i))
        if (bb > maxval) then
          maxval = bb
          ind = i
        end
      end
!      ind = izamax(size(self),self,1) ! blas library
   end

   index_of_smallest_value result (ind) [pure]
   ! Return the index of the smallest value in self
      IN :: self
      INT :: ind,i
      DBL :: minval,bb
      minval = abs(self(1))
      ind = 1
      do i = 2,size(self)
        bb = abs(self(i))
        if (bb < minval) then
          minval = bb
          ind = i
        end
      end
!      ind = izamin(size(self),self,1) ! blas library
   end
   
end
