!-------------------------------------------------------------------------------
!
! UNIT_CELL: Data structure for a crystal unit cell
!
! $Id$
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module UNIT_CELL

   implicit none

contains

!  **************************
!  Create and destroy methods
!  **************************

   create ::: get_from(OBJECT), leaky
   ! Create an object. This version does not nullify point parts.
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object. This version does not destroy pointer parts.
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   set_defaults
   ! Set up a default crystal object
      .angle        = UNIT_CELL_ANGLES
      .angle.convert_from("degree")
      .length       = UNIT_CELL_LENGTHS
      .make_info
   end

   create_copy(unit_cell) ::: leaky
   ! Create a copy of "unit_cell"
     self :: PTR
     unit_cell :: UNIT_CELL, IN
     .create
     .copy(unit_cell)
   end

   copy(unit_cell)
   ! Set self to be "unit_cell"
     unit_cell :: UNIT_CELL, IN
     self = unit_cell
   end

!  ***************
!  Basic cell info
!  ***************

   alpha result(res)
   ! Return the alpha angle, in radians.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     res = .angle(1)
   end

   beta result(res)
   ! Return the beta angle, in radians.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     res = .angle(2)
   end

   gamma result(res)
   ! Return the gamma angle, in radians.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     res = .angle(3)
   end

   alpha_star result(res)
   ! Return the alpha reciprocal lattice angle, in radians.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     tmp,alpha,beta,gamma :: REAL
     alpha = .angle(1); beta  = .angle(2); gamma = .angle(3)
     tmp = (cos(beta)*cos(gamma)-cos(alpha))/(sin(beta)*sin(gamma))
     res = tmp.arccos
   end

   beta_star result(res)
   ! Return the beta reciprocal lattice angle, in radians.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     tmp,alpha,beta,gamma :: REAL
     alpha = .angle(1); beta  = .angle(2); gamma = .angle(3)
     tmp = (cos(gamma)*cos(alpha)-cos(beta))/(sin(gamma)*sin(alpha))
     res = tmp.arccos
   end

   gamma_star result(res)
   ! Return the gamma reciprocal lattice angle, in radians.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     tmp,alpha,beta,gamma :: REAL
     alpha = .angle(1); beta  = .angle(2); gamma = .angle(3)
     tmp = (cos(alpha)*cos(beta)-cos(gamma))/(sin(alpha)*sin(beta))
     res = tmp.arccos
   end

   a result(res)
   ! Return the a cell length, in bohr.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     res = .length(1) 
   end

   b result(res)
   ! Return the b cell length, in bohr.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     res = .length(2) 
   end

   c result(res)
   ! Return the c cell length, in bohr.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     res = .length(3) 
   end

   a_star result(res)
   ! Return the a reciprocal lattice length, in bohr.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     res = .length(2) * .length(3) * sin(.angle(1)) / .volume
   end

   b_star result(res)
   ! Return the b reciprocal lattice length, in bohr.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     res = .length(3) * .length(1) * sin(.angle(2)) / .volume
   end

   c_star result(res)
   ! Return the c reciprocal lattice length, in bohr.
     res :: REAL
   ENSURE(.info_made,"cell info not made")
     res = .length(1) * .length(2) * sin(.angle(3)) / .volume
   end

!  **************************
!  Make cell axis/volume info
!  **************************

   make_info 
   ! Calculate the various unit cell axis matrices.
      .info_made = FALSE
      .make_volume
      .make_direct_matrix
      .make_reciprocal_matrix
      .make_direct_U_matrix
      .make_reciprocal_U_matrix
      .info_made = TRUE
   end

   make_volume ::: private
   ! Calculate the cell volume
      a,b,c,ca,cb,cg,sb :: REAL
      a = .length(1)
      b = .length(2)
      c = .length(3)
      ca = cos(.angle(1))
      cb = cos(.angle(2))
      cg = cos(.angle(3))
      sb = sin(.angle(2))
      .volume = a*b*c*sqrt(ONE-ca**2-cb**2-cg**2+TWO*ca*cb*cg)
   end

   make_direct_matrix ::: private
   ! Calculate the direct cell matrices (i.e. cell axes) in units of BOHRS.
      v,a,b,c,ca,cb,cg,sb,sg :: REAL
      a = .length(1)
      b = .length(2)
      c = .length(3)
      ca = cos(.angle(1))
      cb = cos(.angle(2))
      cg = cos(.angle(3))
      sb = sin(.angle(2))
      sg = sin(.angle(3))
      v = .volume
      ! Direct cell matrix
      ! This version taken from Giacovazzo, C., Fundamentals of Crystallography
      ! p.68
      .direct_matrix(1,1) = a
      .direct_matrix(1,2) = b*cg
      .direct_matrix(1,3) = c*cb
      .direct_matrix(2,1) = ZERO
      .direct_matrix(2,2) = b*sg
      .direct_matrix(2,3) = c*(ca-cb*cg)/sg
      .direct_matrix(3,1) = ZERO
      .direct_matrix(3,2) = ZERO
      .direct_matrix(3,3) = v/(a*b*sg)
   end

   make_reciprocal_matrix ::: private
   ! Calculate the reciprocal cell matrices (i.e. reciprocal cell axes) in units
   ! of 1/BOHRS. Also calculate the inverse direct cell matrix.
      v,a,b,c,ca,cb,cg,sb,sg :: REAL
      a = .length(1)
      b = .length(2)
      c = .length(3)
      ca = cos(.angle(1))
      cb = cos(.angle(2))
      cg = cos(.angle(3))
      sb = sin(.angle(2))
      sg = sin(.angle(3))
      v = .volume
      ! Reciprocal cell matrix
      ! This version taken from Giacovazzo, C., Fundamentals of Crystallography
      ! p.68
      .reciprocal_matrix(1,1) = ONE/a
      .reciprocal_matrix(1,2) = ZERO
      .reciprocal_matrix(1,3) = ZERO
      .reciprocal_matrix(2,1) = -cg/(a*sg)
      .reciprocal_matrix(2,2) = 1/(b*sg)
      .reciprocal_matrix(2,3) = ZERO
      .reciprocal_matrix(3,1) = b*c*(ca*cg-cb)/v/sg
      .reciprocal_matrix(3,2) = a*c*(cb*cg-ca)/v/sg
      .reciprocal_matrix(3,3) = a*b*sg/v
      .inverse_matrix = transpose(.reciprocal_matrix)
   end

   make_direct_U_matrix ::: private
   ! Return the transformation matrix which changes the thermal tensor
   ! from the crystal axis system into the cartesian axis system.
   ! See comments for reciprocal_U_tensor_matrix below.
      len :: REAL
      i :: INT
      do i = 1,3
         len = .reciprocal_matrix(:,i).norm
         .direct_U_matrix(i,:) = len*.direct_matrix(:,i)
      end
   end

   make_reciprocal_U_matrix ::: private
   ! Return the transformation matrix which changes the thermal tensor
   ! from the cartesian axis system into the crystal axis system.
   ! The thermal tensor in the crystal axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where h are the Miller indices and a^* are the reciprocal lattice
   ! constants (in bohr^{-2}). This is as used by systems like Xtal.
   ! The thermal tensor in the cartesian axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -0.5 U_{ij} k_i k_j )
   ! where k = 2\pi B h, and B is the reciprocal cell matrix.
      len :: REAL
      i :: INT
      do i = 1,3
         len = ONE/.reciprocal_matrix(:,i).norm
         .reciprocal_U_matrix(:,i) = .reciprocal_matrix(:,i)*len
      end
   end

!  **************************
!  Geometry altering routines
!  **************************

   change_from_fractional(g)
   ! Change the columns of geometry array "g" *from* crystal fractional
   ! coordinates into standard cartesian coordiantes
      g :: MAT{REAL}
      if (g.dim1==3) then; g = matmul(.direct_matrix,g)
      else;                g = matmul(g,transpose(.direct_matrix))
      end
   end

   change_into_fractional(g)
   ! Change the columns of geometry array "g" from standard cartesian
   ! coordinates *into* crystal fractional coordinates
      g :: MAT{REAL}
      if (g.dim1==3) then; g = matmul(.inverse_matrix,g)
      else;                g = matmul(g,transpose(.inverse_matrix))
      end
   end

   change_from_fractional(p)
   ! Change the position "p" *from* crystal fractional coordinates into standard
   ! cartesian coordiantes
      p :: VEC{REAL}(3)
      p.rotate_by(.direct_matrix)
   end

   change_into_fractional(p)
   ! Change the position "p" from standard cartesian coordinates *into* crystal
   ! fractional coordinates
      p :: VEC{REAL}(3)
      p.rotate_by(.inverse_matrix)
   end

!  ************
!  Read methods
!  ************

   read_keywords ::: get_from(OBJECT), recursive
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword)
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
        case ("}                ")  ! exit read_loop
        case ("a=               "); .read_a
        case ("alpha=           "); .read_alpha
        case ("angles=          "); .read_angles
        case ("b=               "); .read_b
        case ("beta=            "); .read_beta
        case ("c=               "); .read_c
        case ("gamma=           "); .read_gamma
        case ("dimensions=      "); .read_lengths
        case ("junk=            "); .read_junk
        case ("lengths=         "); .read_lengths
        case ("put              "); .put
        case ("units=           "); .read_units
        case default;                       UNKNOWN(word)
      end
     .update
   end

   read_units ::: get_from(OBJECT)
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT)
   ! Read in a junk string, useful for ignoring a field
   end

   update
   ! Update the cell information
     .make_info
   end

   read_lengths ::: private
   ! Read the unit cell axis lengths
      stdin.read(.length)
   end

   read_a ::: private
   ! Read the a length
      stdin.read(.length(1))
   end

   read_b ::: private
   ! Read the b length
      stdin.read(.length(2))
   end

   read_c ::: private
   ! Read the c length
      stdin.read(.length(3))
   end

   read_angles ::: private
   ! Read the unit cell angles
      stdin.read(.angle)
   end

   read_alpha ::: private
   ! Read the alpha angle
      stdin.read(.angle(1))
   end

   read_beta ::: private
   ! Read the beta angle
      stdin.read(.angle(2))
   end

   read_gamma ::: private
   ! Read the gamma angle
      stdin.read(.angle(3))
   end

   read_CIF(cif) 
   ! Read cell information from a CIF file "cif"
      cif :: CIF
      err :: REAL
      found :: BIN
      .set_defaults
      .angle(1) = 90 ! Reset defaults (already set in read_CIF)
      .angle(2) = 90 ! in degrees !
      .angle(3) = 90
      cif.read_item("_cell_angle_alpha",.angle(1),err,found)
      cif.read_item("_cell_angle_beta" ,.angle(2),err,found)
      cif.read_item("_cell_angle_gamma",.angle(3),err,found)
      cif.read_item("_cell_length_a",.length(1),err)
      cif.read_item("_cell_length_b",.length(2),err)
      cif.read_item("_cell_length_c",.length(3),err)
      .length.convert_from("angstrom")
      .angle.convert_from("degree")    ! Now convert to rads
      .update
   end

! **************************
! Local field factor tensors
! **************************

   make_LFF_tensors(L2,pos)
   ! Make the local field factor tensor "L2" at a series of unit cell
   ! positions "pos" (in cartesian coordinates). These tell what the
   ! electric field is at a certain position k1 when there is a dipole
   ! at position k2 in the unit cell and all translationally
   ! equivalent cells, F = L2(:,:,k1k2) mu(:). The last index of "L2"
   ! is a triangle index.
      L2 :: MAT3{REAL}, OUT
      pos :: MAT{REAL}, IN
   ENSURE(L2.dim1==3 AND L2.dim2==3,"L2 must be 3x3")
   ENSURE(pos.dim1==3,"pos must have first dimension 3")

      L,L0,G,H :: MAT{REAL}(3,3)
      r,r0,q,hv :: VEC{REAL}(3)
      k,k1,k2,m,h1,h2,h3 :: INT
      v13,vr,vq,dot :: REAL

      v13 = .volume**(THIRD)
      vr  = SQRT_PI/v13
      vq  = SQRT_PI*v13

      k = 0
      do k1 = 1,pos.dim2
      do k2 = 1,k1

         k = k + 1
         r0 = vr*(pos(:,k2) - pos(:,k1))

         if (k1==k2) then
            L0.to_unit_matrix
            L0 = THIRD*L0
         else
            .make_LFF_h_tensor(r0,H)
            L0 = H
         end

!        m = 5
!           L = ZERO
!           do h1 = -m,m
!           do h2 = -m,m
!           do h3 = -m,m
!              if (h1==0 AND h2==0 AND h3==0) cycle
!              hv = [h1,h2,h3]
!              r = vr*matmul(.direct_matrix,hv) + r0
!              q = vq*matmul(.reciprocal_matrix,hv)
!              .make_LFF_h_tensor(r,H)
!              .make_LFF_g_tensor(q,G)
!              dot = q(1)*r0(1) + q(2)*r0(2) + q(3)*r0(3)
!              L = L + H - G*cos(TWO*dot)
!           end
!           end
!           end
!           L0 = L0 + L

         m = 0

         do ! until converged

            m = m + 1

            L = ZERO

            do h1 = -m,m,2*m
            do h2 = -m,m
            do h3 = -m,m
               hv = [h1,h2,h3]
               r = vr*matmul(.direct_matrix,hv) + r0
               q = vq*matmul(.reciprocal_matrix,hv)
               .make_LFF_h_tensor(r,H)
               .make_LFF_g_tensor(q,G)
               dot = q(1)*r0(1) + q(2)*r0(2) + q(3)*r0(3)
               L = L + H - G*cos(TWO*dot)
            end
            end
            end

            do h1 = -m+1,m-1
            do h2 = -m,m,2*m
            do h3 = -m,m
               hv = [h1,h2,h3]
               r = vr*matmul(.direct_matrix,hv) + r0
               q = vq*matmul(.reciprocal_matrix,hv)
               .make_LFF_h_tensor(r,H)
               .make_LFF_g_tensor(q,G)
               dot = q(1)*r0(1) + q(2)*r0(2) + q(3)*r0(3)
               L = L + H - G*cos(TWO*dot)
            end
            end
            end

            do h1 = -m+1,m-1
            do h2 = -m+1,m-1
            do h3 = -m,m,2*m
               hv = [h1,h2,h3]
               r = vr*matmul(.direct_matrix,hv) + r0
               q = vq*matmul(.reciprocal_matrix,hv)
               .make_LFF_h_tensor(r,H)
               .make_LFF_g_tensor(q,G)
               dot = q(1)*r0(1) + q(2)*r0(2) + q(3)*r0(3)
               L = L + H - G*cos(TWO*dot)
            end
            end
            end

            L0 = L0 + L
            if (maxval(abs(L))<TOL(10)) exit

         end

         L2(:,:,k) = L0

      end
      end

   end

   make_LFF_h_tensor(r,h2)
   ! Make the local field factor tensors. 
      r :: VEC{REAL}(3), IN
      h2 :: MAT{REAL}(3,3), OUT

      a,b :: INT
      r1,r2,rm1,rm2,rm5,faa,fab,f1,f2 :: REAL
      exmr2,erfcr,sqpi2,ra,rb,rab :: REAL

      ! Temporary variables related to R
      r2  = r(1)*r(1) + r(2)*r(2) + r(3)*r(3)
      r1  = sqrt(r2)
      rm1 = ONE/r1
      rm2 = rm1*rm1
      rm5 = rm2*rm2*rm1

      ! Inverse R sums, including exponential term
      f1 =  rm2
      f2 =  rm2*(3*f1 + 2)
      exmr2 = HALF*exp(-r2)
      f1 = f1*exmr2
      f2 = f2*exmr2

      ! Complementary erf term
      erfcr = erfc(r1)
      sqpi2 = SQRT_PI*QUARTER*erfcr*rm5

      ! These are for h2
      faa = -f1 - r2*sqpi2
      fab =  f2 +  3*sqpi2

      ! Now make the h tensors ...
      h2 = ZERO

      do a = 1,3
         ra = r(a)
         do b = 1,3
            rb = r(b)
            rab = ra*rb
            h2(a,b) = h2(a,b) + fab*rab
         end
         h2(a,a) = h2(a,a) + faa
      end
      
   end

   make_LFF_g_tensor(q,g2)
   ! Make the local field factor tensor.
      q :: VEC{REAL}(3), IN
      g2 :: MAT{REAL}(3,3), OUT

      a,b :: INT
      q2,qm2,exmq2,qa,qb,fab :: REAL

      q2  = q(1)*q(1) + q(2)*q(2) + q(3)*q(3)
      qm2 = ONE/q2

      exmq2 = exp(-q2)

      fab = qm2*exmq2

      do a = 1,3
         qa = q(a)
         do b = 1,3
            qb = q(b)
            g2(a,b) = qa*qb*fab
         end
      end
      
   end

   make_LFF_h_tensors(r,h2,h3,h4)
   ! Make the local field factor tensors. 
      r :: VEC{REAL}(3), IN
      h2 :: MAT{REAL}(3,3), OUT
      h3 :: MAT3{REAL}(3,3,3), OUT
      h4 :: MAT4{REAL}(3,3,3,3), OUT

      a,b,c,d :: INT
      r1,r2,rm1,rm2,rm5,v13,v23,r13,r23 :: REAL
      faa,fab,fabb,fabc,fabab,fabcc,fabcd :: REAL
      f1,f2,f3,f4,exmr2,erfcr,sqpi2,val,tmp :: REAL
      ra,rb,rc,rd,rab,rabc,rabcd :: REAL

      ! Temporary variables related to R
      r2  = r(1)*r(1) + r(2)*r(2) + r(3)*r(3)
      r1  = sqrt(r2)
      rm1 = ONE/r1
      rm2 = rm1*rm1
      rm5 = rm2*rm2*rm1

      ! Temporary variables relatd to V
      v13 = SQRT_PI*.volume**(-THIRD)
      v23 = v13*v13
      r13 = v13*rm2
      r23 = r13*r13

      ! Inverse R sums, including exponential term
      f1 =  rm2
      f2 =  rm2*(3*f1 + 2)
      f3 =  rm2*(5*f2 + 4)
      f4 =  rm2*(7*f3 + 8)
      exmr2 = HALF*exp(-r2)
      f1 = f1*exmr2
      f2 = f2*exmr2
      f3 = f3*exmr2
      f4 = f4*exmr2

      ! Complementary erf term
      erfcr = erfc(r1)
      sqpi2 = SQRT_PI*QUARTER*erfcr*rm5

      ! These are for h2
      faa = -f1
      fab =  f2
      val = sqpi2
      faa = faa - r2*val
      fab = fab +  3*val

      ! These are for h3
      fabb =  f2*v13
      fabc = -f3*v13
      val = r13*sqpi2
      fabb = fabb +  3*r2*val
      fabc = fabc - 15*val

      ! These are for h4
      fabab =  f2*v23
      fabcc = -f3*v23
      fabcd =  f4*v23
      val = r23*sqpi2
      fabab = fabab +   3*r2*r2*val
      fabcc = fabcc -  15*r2*val
      fabcd = fabcd + 105*val

      ! Now make the h tensors ...
      h2 = ZERO
      h3 = ZERO
      h4 = ZERO

      do a = 1,3
         ra = r(a)
         do b = 1,3
            rb = r(b)
            rab = ra*rb
            h2(a,b) = h2(a,b) + fab*rab
            do c = 1,3
               rc = r(c)
               rabc = rab*rc
               h3(a,b,c) = h3(a,b,c) + fabc*rabc
               do d = 1,3
                  rd = r(d)
                  rabcd = rabc*rd
                  h4(a,b,c,d) = h4(a,b,c,d) + fabcd*rabcd
               end
               tmp = fabcc*rab
               h4(a,b,c,c) = h4(a,b,c,c) + tmp
               h4(a,c,b,c) = h4(a,c,b,c) + tmp
               h4(a,c,c,b) = h4(a,c,c,b) + tmp
               h4(c,a,b,c) = h4(c,a,b,c) + tmp
               h4(c,a,c,b) = h4(c,a,c,b) + tmp
               h4(c,c,a,b) = h4(c,c,a,b) + tmp
            end
            tmp = fabb*ra
            h3(a,b,b) = h3(a,b,b) + tmp
            h3(b,b,a) = h3(b,b,a) + tmp
            h3(b,a,b) = h3(b,a,b) + tmp
            h4(a,b,a,b) = h4(a,b,a,b) + fabab
            h4(a,a,b,b) = h4(a,a,b,b) + fabab
            h4(a,b,b,a) = h4(a,b,b,a) + fabab
         end
         h2(a,a) = h2(a,a) + faa
      end
      
   end

   make_LFF_g_tensors(q,g2,g3,g4)
   ! Make the local field factor tensor.
      q :: VEC{REAL}(3), IN
      g2 :: MAT{REAL}(3,3), OUT
      g3 :: MAT3{REAL}(3,3,3), OUT
      g4 :: MAT4{REAL}(3,3,3,3), OUT

      a,b,c,d :: INT
      q2,qm2,exmq2,qa,qb,qc,qd,v13,fab,gab,gabc,gabcd :: REAL

      q2  = q(1)*q(1) + q(2)*q(2) + q(3)*q(3)
      qm2 = ONE/q2

      v13 = TWO*SQRT_PI*.volume**(-THIRD)

      exmq2 = exp(-q2)

      fab = qm2*exmq2

      do a = 1,3
         qa = q(a)
         do b = 1,3
            qb = q(b)
            gab = qa*qb*fab
            g2(a,b) = gab
            do c = 1,3
               qc = q(c)
               gabc = v13*qc*gab
               g3(a,b,c) = gabc
               do d = 1,3
                  qd = q(d)
                  gabcd = v13*qd*gabc
                  g4(a,b,c,d) = gabc
               end
            end
         end
      end
      
   end

!  ***********
!  Put methods
!  ***********

   put
   ! Put unit cell information 
     fd,fa,f1,f3 :: REAL
     fd = STR:conversion_factor("degree")
     fa = STR:conversion_factor("angstrom")
     f3 = STR:conversion_factor("angstrom^3")
     f1 = STR:conversion_factor("angstrom^-1")
     stdout.flush
     stdout.text("Unit cell information:")
     stdout.flush
     stdout.show("alpha angle (degree)     = ",.angle(1)*fd)
     stdout.show("beta  angle (degree)     = ",.angle(2)*fd)
     stdout.show("gamma angle (degree)     = ",.angle(3)*fd)
     stdout.show("a cell parameter (A)     = ",.length(1)*fa)
     stdout.show("b cell parameter (A)     = ",.length(2)*fa)
     stdout.show("c cell parameter (A)     = ",.length(3)*fa)
     stdout.show("Cell volume(A^3)         = ",.volume*f3)
     stdout.flush
     stdout.show("alpha angle (rad)        = ",.angle(1))
     stdout.show("beta  angle (rad)        = ",.angle(2))
     stdout.show("gamma angle (rad)        = ",.angle(3))
     stdout.show("a cell parameter (bohr)  = ",.length(1))
     stdout.show("b cell parameter (bohr)  = ",.length(2))
     stdout.show("c cell parameter (bohr)  = ",.length(3))
     stdout.show("Cell volume(bohr^3)      = ",.volume)
     stdout.flush
     stdout.show("alpha* angle (rad)       = ",.alpha_star)
     stdout.show("beta*  angle (rad)       = ",.beta_star)
     stdout.show("gamma* angle (rad)       = ",.gamma_star)
     stdout.show("a* cell parameter (bohr) = ",.a_star)
     stdout.show("b* cell parameter (bohr) = ",.b_star)
     stdout.show("c* cell parameter (bohr) = ",.c_star)

     stdout.flush
     stdout.text("Direct cell matrix/Angstrom:")
     stdout.put(.direct_matrix*fa)
     stdout.flush
     stdout.text("Inverse direct cell matrix/Angstrom^{-1}:")
     stdout.put(.inverse_matrix*f1)
     stdout.flush
     stdout.text("Reciprocal cell matrix/Angstrom^{-1}:")
     stdout.put(.reciprocal_matrix*f1)
     stdout.flush
     stdout.text("Direct U cell matrix/Angstrom:")
     stdout.put(.direct_U_matrix*fa)
     stdout.flush
     stdout.text("Reciprocal U cell matrix/Angstrom^{-1}:")
     stdout.put(.reciprocal_U_matrix*f1)

     stdout.flush
     stdout.text("Direct cell matrix/bohr:")
     stdout.put(.direct_matrix)
     stdout.flush
     stdout.text("Inverse direct cell matrix/bohr^{-1}:")
     stdout.put(.inverse_matrix)
     stdout.flush
     stdout.text("Reciprocal cell matrix/bohr^{-1}:")
     stdout.put(.reciprocal_matrix)
     stdout.flush
     stdout.text("Direct U cell matrix/bohr:")
     stdout.put(.direct_U_matrix)
     stdout.flush
     stdout.text("Reciprocal U cell matrix/bohr^{-1}:")
     stdout.put(.reciprocal_U_matrix)
     stdout.flush
   end

   put_CX(label,formula,spacegroup)
   ! Output some information for the Crystal Explorer program.
       label,formula,spacegroup :: STR
       stdout.flush
       stdout.text("begin crystalcell " // label.trim)
       stdout.text("   formula = "//'"'//trim(formula)//'"')
       stdout.show("   spacegroup =",spacegroup)
       stdout.show("   a =",.length(1).to_units("angstrom"))
       stdout.show("   b =",.length(2).to_units("angstrom"))
       stdout.show("   c =",.length(3).to_units("angstrom"))
       stdout.show("   alpha =",.angle(1).to_units("degree"))
       stdout.show("   beta  =",.angle(2).to_units("degree"))
       stdout.show("   gamma =",.angle(3).to_units("degree"))
       stdout.text("end crystalcell")
   end

end
