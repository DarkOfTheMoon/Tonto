Welcome to Tonto!

---------------
Compiling Tonto
---------------

To compile Tonto, type :

   perl -w Makefile.pl
   make

If you want a specific compiler, type:

   perl -w Makefile.pl -fc=<insert-your-compiler-here>
   make

where you should replace <insert-your-comipler-here> with
the command for your specific compiler.

----------------------
Running the test suite
----------------------

To run the test suite, type:

   make tests

---------------------------------
Where to find example input files
---------------------------------

Look in the directories in the tests/ directory for example
input files.  The example inputs are called "stdin" and the
example outputs are called "stdout"

----------------
How to run a job
----------------

Make an input file called "stdin", or copy one of those you
like from the directories within the tests/ directory, then
type:

   ./<your-compiler-on-your-OS>/run_molecule.exe

where <your-compiler-on-your-OS> is the directory appropriate
for your platform, which is created automatically when you
compile Tonto.

-----------------------------
How to make the documentation
-----------------------------

To make the documentation, type:

   make documentation

then point your browser at documentation/index.html.  The
hyperlinked code documentation is generated from the source
code, so it is up to date, but the text documentation is a
bit out of date.

-------------
Vim and ctags
-------------

Much better than html documentation, try using vim!

Copy the supplied .vimrc and .vim directories in tonto/ to
your home directory. Start up vim or gvim on one of the
files in foofiles/ . And enjoy.  To unfold routines type
"zo", to close type "zc". Click in the sidebar to go to the
routine you want (gvim only). F2 to get rid of the side bar.

If you get exuberant ctags (google it), copy the supplied
.ctags file into your home directory, then type:

   ctags --lang=foo macros *.foo

Then in vim type "g Ctrl-]" on top of the routine you want
to go to --- you'll see the documentation(s). Type "Ctrl-t"
to go back. Wonderful!

-----------------------------
Problems, bugs, contributions
-----------------------------

Let me know at 

   dylan@theochem.uwa.edu.au

If you can fix your own bugs, let me know too, and you can
easily check the fixes back into sourceforge. 

-----------------------------
Compiling compact executables
-----------------------------

Executables in tonto tend to be big. If you executable is
too big, you can remove all dead code from your application
by typing. 

   make compactify
   make

Consider also using the -DNO_GENERIC_NAMES compile option.
See below.

-------------------------
Compiling custom versions
-------------------------

By default, nearly production Tonto code is compiled.  

You can also compile debug versions of various kinds using
the switches described in the platforms/ directory, in the
file for <your-compiler-on-your-OS> . 

A summary of switches which control the versions:

-DMPI                        Parallel Tonto, using MPI.
                             Must specify your libraries
                             in the platforms file.

-DFLUSH                      Flush output to stdout.
                             Compiler must have flush().

-DNO_TONTO_SYSTEM_CALLS      No system checks, no parallel
                             calls

-DNO_TONTO_SYSTEM_CHECKS     No system checks, retain
                             parallel calls.  You must
                             still define MPI

-DNO_GENERIC_NAMES           Prepend module name to
                             routines.  May reduce compile
                             time by reducing namespace,
                             but will have nonstandard
                             routine names > 31 characters
                             long

-DUSE_ERROR_MANAGEMENT       Use die and warn, minimal
                             error checking (default)

-DUSE_PRECONDITIONS          Use routine preconditions.
                             More checking, but there will
                             be a perfomance hit. 
                             + USE_ERROR_MANAGEMENT     

-DUSE_CALL_STACK_MANAGEMENT  Tracks the call tree.
                             Good for tracking errors and
                             warnings. Big perfoamce hit. 
                             + USE_PRECONDITIONS

-DTRACK_MEMORY_LOCATIONS     Tracks all allocates and
                             deallocates, useful for
                             eliminating memory leaks.
                             Compiler must have loc()
                             pointer function.
                             + USE_CALL_STACK_MANAGEMENT

-DUSE_TIME_PROFILING         Time profile routines, not very
                             accurate
                             + BROKEN_PURE

-DBROKEN_PURE                Set if pure does not work; very
                             rare. Needed for time profiling
                             to allow IO

-DBROKEN_TYPE_INITIALIZATION Set if type initialisation fails

-DLANGUAGE_FORTRAN_90        + BROKEN_TYPE_INITIALIZATION      
                             + BROKEN_PURE

-DESSL                       Use ESSL math libraries
                             IBM only.

-DNO_CASE_OPTIONS            Removes informative error on
                             string-based case statements.
